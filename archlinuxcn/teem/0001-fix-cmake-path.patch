diff --color -ruN teem-1.11.0-src.orig/arch/win32/include/bzlib.h teem-1.11.0-src/arch/win32/include/bzlib.h
--- teem-1.11.0-src.orig/arch/win32/include/bzlib.h	2012-12-20 22:11:55.000000000 +0800
+++ teem-1.11.0-src/arch/win32/include/bzlib.h	2021-02-18 15:42:38.000000000 +0800
@@ -17,16 +17,16 @@
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
 
-  2. The origin of this software must not be misrepresented; you must 
-     not claim that you wrote the original software.  If you use this 
-     software in a product, an acknowledgment in the product 
+  2. The origin of this software must not be misrepresented; you must
+     not claim that you wrote the original software.  If you use this
+     software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.
 
   3. Altered source versions must be plainly marked as such, and must
      not be misrepresented as being the original software.
 
-  4. The name of the author may not be used to endorse or promote 
-     products derived from this software without specific prior written 
+  4. The name of the author may not be used to endorse or promote
+     products derived from this software without specific prior written
      permission.
 
   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
@@ -85,7 +85,7 @@
 #define BZ_OUTBUFF_FULL      (-8)
 #define BZ_CONFIG_ERROR      (-9)
 
-typedef 
+typedef
    struct {
       char *next_in;
       unsigned int avail_in;
@@ -102,7 +102,7 @@
       void *(*bzalloc)(void *,int,int);
       void (*bzfree)(void *,void *);
       void *opaque;
-   } 
+   }
    bz_stream;
 
 
@@ -135,34 +135,34 @@
 
 /*-- Core (low-level) library functions --*/
 
-BZ_EXTERN int BZ_API(BZ2_bzCompressInit) ( 
-      bz_stream* strm, 
-      int        blockSize100k, 
-      int        verbosity, 
-      int        workFactor 
+BZ_EXTERN int BZ_API(BZ2_bzCompressInit) (
+      bz_stream* strm,
+      int        blockSize100k,
+      int        verbosity,
+      int        workFactor
    );
 
-BZ_EXTERN int BZ_API(BZ2_bzCompress) ( 
-      bz_stream* strm, 
-      int action 
+BZ_EXTERN int BZ_API(BZ2_bzCompress) (
+      bz_stream* strm,
+      int action
    );
 
-BZ_EXTERN int BZ_API(BZ2_bzCompressEnd) ( 
-      bz_stream* strm 
+BZ_EXTERN int BZ_API(BZ2_bzCompressEnd) (
+      bz_stream* strm
    );
 
-BZ_EXTERN int BZ_API(BZ2_bzDecompressInit) ( 
-      bz_stream *strm, 
-      int       verbosity, 
+BZ_EXTERN int BZ_API(BZ2_bzDecompressInit) (
+      bz_stream *strm,
+      int       verbosity,
       int       small
    );
 
-BZ_EXTERN int BZ_API(BZ2_bzDecompress) ( 
-      bz_stream* strm 
+BZ_EXTERN int BZ_API(BZ2_bzDecompress) (
+      bz_stream* strm
    );
 
-BZ_EXTERN int BZ_API(BZ2_bzDecompressEnd) ( 
-      bz_stream *strm 
+BZ_EXTERN int BZ_API(BZ2_bzDecompressEnd) (
+      bz_stream *strm
    );
 
 
@@ -174,64 +174,64 @@
 
 typedef void BZFILE;
 
-BZ_EXTERN BZFILE* BZ_API(BZ2_bzReadOpen) ( 
-      int*  bzerror,   
-      FILE* f, 
-      int   verbosity, 
+BZ_EXTERN BZFILE* BZ_API(BZ2_bzReadOpen) (
+      int*  bzerror,
+      FILE* f,
+      int   verbosity,
       int   small,
-      void* unused,    
-      int   nUnused 
+      void* unused,
+      int   nUnused
    );
 
-BZ_EXTERN void BZ_API(BZ2_bzReadClose) ( 
-      int*    bzerror, 
-      BZFILE* b 
-   );
-
-BZ_EXTERN void BZ_API(BZ2_bzReadGetUnused) ( 
-      int*    bzerror, 
-      BZFILE* b, 
-      void**  unused,  
-      int*    nUnused 
-   );
-
-BZ_EXTERN int BZ_API(BZ2_bzRead) ( 
-      int*    bzerror, 
-      BZFILE* b, 
-      void*   buf, 
-      int     len 
-   );
-
-BZ_EXTERN BZFILE* BZ_API(BZ2_bzWriteOpen) ( 
-      int*  bzerror,      
-      FILE* f, 
-      int   blockSize100k, 
-      int   verbosity, 
-      int   workFactor 
-   );
-
-BZ_EXTERN void BZ_API(BZ2_bzWrite) ( 
-      int*    bzerror, 
-      BZFILE* b, 
-      void*   buf, 
-      int     len 
-   );
-
-BZ_EXTERN void BZ_API(BZ2_bzWriteClose) ( 
-      int*          bzerror, 
-      BZFILE*       b, 
-      int           abandon, 
-      unsigned int* nbytes_in, 
-      unsigned int* nbytes_out 
+BZ_EXTERN void BZ_API(BZ2_bzReadClose) (
+      int*    bzerror,
+      BZFILE* b
    );
 
-BZ_EXTERN void BZ_API(BZ2_bzWriteClose64) ( 
-      int*          bzerror, 
-      BZFILE*       b, 
-      int           abandon, 
-      unsigned int* nbytes_in_lo32, 
-      unsigned int* nbytes_in_hi32, 
-      unsigned int* nbytes_out_lo32, 
+BZ_EXTERN void BZ_API(BZ2_bzReadGetUnused) (
+      int*    bzerror,
+      BZFILE* b,
+      void**  unused,
+      int*    nUnused
+   );
+
+BZ_EXTERN int BZ_API(BZ2_bzRead) (
+      int*    bzerror,
+      BZFILE* b,
+      void*   buf,
+      int     len
+   );
+
+BZ_EXTERN BZFILE* BZ_API(BZ2_bzWriteOpen) (
+      int*  bzerror,
+      FILE* f,
+      int   blockSize100k,
+      int   verbosity,
+      int   workFactor
+   );
+
+BZ_EXTERN void BZ_API(BZ2_bzWrite) (
+      int*    bzerror,
+      BZFILE* b,
+      void*   buf,
+      int     len
+   );
+
+BZ_EXTERN void BZ_API(BZ2_bzWriteClose) (
+      int*          bzerror,
+      BZFILE*       b,
+      int           abandon,
+      unsigned int* nbytes_in,
+      unsigned int* nbytes_out
+   );
+
+BZ_EXTERN void BZ_API(BZ2_bzWriteClose64) (
+      int*          bzerror,
+      BZFILE*       b,
+      int           abandon,
+      unsigned int* nbytes_in_lo32,
+      unsigned int* nbytes_in_hi32,
+      unsigned int* nbytes_out_lo32,
       unsigned int* nbytes_out_hi32
    );
 #endif
@@ -239,23 +239,23 @@
 
 /*-- Utility functions --*/
 
-BZ_EXTERN int BZ_API(BZ2_bzBuffToBuffCompress) ( 
-      char*         dest, 
+BZ_EXTERN int BZ_API(BZ2_bzBuffToBuffCompress) (
+      char*         dest,
       unsigned int* destLen,
-      char*         source, 
+      char*         source,
       unsigned int  sourceLen,
-      int           blockSize100k, 
-      int           verbosity, 
-      int           workFactor 
+      int           blockSize100k,
+      int           verbosity,
+      int           workFactor
    );
 
-BZ_EXTERN int BZ_API(BZ2_bzBuffToBuffDecompress) ( 
-      char*         dest, 
+BZ_EXTERN int BZ_API(BZ2_bzBuffToBuffDecompress) (
+      char*         dest,
       unsigned int* destLen,
-      char*         source, 
+      char*         source,
       unsigned int  sourceLen,
-      int           small, 
-      int           verbosity 
+      int           small,
+      int           verbosity
    );
 
 
@@ -283,17 +283,17 @@
       int        fd,
       const char *mode
    );
-         
+
 BZ_EXTERN int BZ_API(BZ2_bzread) (
-      BZFILE* b, 
-      void* buf, 
-      int len 
+      BZFILE* b,
+      void* buf,
+      int len
    );
 
 BZ_EXTERN int BZ_API(BZ2_bzwrite) (
-      BZFILE* b, 
-      void*   buf, 
-      int     len 
+      BZFILE* b,
+      void*   buf,
+      int     len
    );
 
 BZ_EXTERN int BZ_API(BZ2_bzflush) (
@@ -305,7 +305,7 @@
    );
 
 BZ_EXTERN const char * BZ_API(BZ2_bzerror) (
-      BZFILE *b, 
+      BZFILE *b,
       int    *errnum
    );
 #endif
diff --color -ruN teem-1.11.0-src.orig/arch/win32/include/pngconf.h teem-1.11.0-src/arch/win32/include/pngconf.h
--- teem-1.11.0-src.orig/arch/win32/include/pngconf.h	2012-12-20 22:11:55.000000000 +0800
+++ teem-1.11.0-src/arch/win32/include/pngconf.h	2021-02-18 15:42:38.000000000 +0800
@@ -19,7 +19,7 @@
 
 #define PNG_1_2_X
 
-/* 
+/*
  * PNG_USER_CONFIG has to be defined on the compiler command line. This
  * includes the resource compiler for Windows DLL configurations.
  */
@@ -29,7 +29,7 @@
 
 /*
  * Added at libpng-1.2.8
- *  
+ *
  * If you create a private DLL you need to define in "pngusr.h" the followings:
  * #define PNG_USER_PRIVATEBUILD <Describes by whom and why this version of
  *        the DLL was built>
@@ -40,8 +40,8 @@
  *        number and must match your private DLL name>
  *  e.g. // private DLL "libpng13gx.dll"
  *       #define PNG_USER_DLLFNAME_POSTFIX "gx"
- * 
- * The following macros are also at your disposal if you want to complete the 
+ *
+ * The following macros are also at your disposal if you want to complete the
  * DLL VERSIONINFO structure.
  * - PNG_USER_VERSIONINFO_COMMENTS
  * - PNG_USER_VERSIONINFO_COMPANYNAME
@@ -129,9 +129,9 @@
  * 'Cygwin' defines/defaults:
  *   PNG_BUILD_DLL -- (ignored) building the dll
  *   (no define)   -- (ignored) building an application, linking to the dll
- *   PNG_STATIC    -- (ignored) building the static lib, or building an 
+ *   PNG_STATIC    -- (ignored) building the static lib, or building an
  *                    application that links to the static lib.
- *   ALL_STATIC    -- (ignored) building various static libs, or building an 
+ *   ALL_STATIC    -- (ignored) building various static libs, or building an
  *                    application that links to the static libs.
  * Thus,
  * a cygwin user should define either PNG_BUILD_DLL or PNG_STATIC, and
@@ -144,12 +144,12 @@
  *   PNG_BUILD_DLL
  *   PNG_STATIC
  *   (nothing) == PNG_USE_DLL
- * 
+ *
  * CYGWIN (2002-01-20): The preceding is now obsolete. With the advent
- *   of auto-import in binutils, we no longer need to worry about 
+ *   of auto-import in binutils, we no longer need to worry about
  *   __declspec(dllexport) / __declspec(dllimport) and friends.  Therefore,
  *   we don't need to worry about PNG_STATIC or ALL_STATIC when it comes
- *   to __declspec() stuff.  However, we DO need to worry about 
+ *   to __declspec() stuff.  However, we DO need to worry about
  *   PNG_BUILD_DLL and PNG_STATIC because those change some defaults
  *   such as CONSOLE_IO and whether GLOBAL_ARRAYS are allowed.
  */
@@ -193,8 +193,8 @@
 #        if !defined(PNG_DLL)
 #          define PNG_DLL
 #        endif
-#      endif  
-#    endif  
+#      endif
+#    endif
 #  endif
 #endif
 
@@ -690,7 +690,7 @@
 #  define PNG_EASY_ACCESS_SUPPORTED
 #endif
 
-/* PNG_ASSEMBLER_CODE was enabled by default in version 1.2.0 
+/* PNG_ASSEMBLER_CODE was enabled by default in version 1.2.0
    even when PNG_USE_PNGVCRD or PNG_USE_PNGGCCRD is not defined */
 #if defined(PNG_READ_SUPPORTED) && !defined(PNG_NO_ASSEMBLER_CODE)
 #  ifndef PNG_ASSEMBLER_CODE_SUPPORTED
@@ -1239,7 +1239,7 @@
 #  define PNGAPI __cdecl
 #  undef PNG_IMPEXP
 #  define PNG_IMPEXP
-#endif  
+#endif
 
 /* If you define PNGAPI, e.g., with compiler option "-DPNGAPI=__stdcall",
  * you may get warnings regarding the linkage of png_zalloc and png_zfree.
@@ -1404,7 +1404,7 @@
 #  define PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT  128  /*  >=  */
 #endif
 #ifndef PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT
-#  define PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT  9    /*  >=  */   
+#  define PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT  9    /*  >=  */
 #endif
 
 /* Set this in the makefile for VC++ on Pentium, not here. */
diff --color -ruN teem-1.11.0-src.orig/arch/win32/include/png.h teem-1.11.0-src/arch/win32/include/png.h
--- teem-1.11.0-src.orig/arch/win32/include/png.h	2012-12-20 22:11:55.000000000 +0800
+++ teem-1.11.0-src/arch/win32/include/png.h	2021-02-18 15:42:38.000000000 +0800
@@ -336,7 +336,7 @@
 #define PNG_LIBPNG_BUILD_RC       3
 #define PNG_LIBPNG_BUILD_STABLE   4
 #define PNG_LIBPNG_BUILD_RELEASE_STATUS_MASK 7
-  
+
 /* Release-Specific Flags */
 #define PNG_LIBPNG_BUILD_PATCH    8 /* Can be OR'ed with
                                        PNG_LIBPNG_BUILD_STABLE only */
@@ -367,12 +367,12 @@
 /* Ref MSDN: Private as priority over Special
  * VS_FF_PRIVATEBUILD File *was not* built using standard release
  * procedures. If this value is given, the StringFileInfo block must
- * contain a PrivateBuild string. 
+ * contain a PrivateBuild string.
  *
  * VS_FF_SPECIALBUILD File *was* built by the original company using
  * standard release procedures but is a variation of the standard
  * file of the same version number. If this value is given, the
- * StringFileInfo block must contain a SpecialBuild string. 
+ * StringFileInfo block must contain a SpecialBuild string.
  */
 
 #if defined(PNG_USER_PRIVATEBUILD)
diff --color -ruN teem-1.11.0-src.orig/CMake/airExistsConf.h teem-1.11.0-src/CMake/airExistsConf.h
--- teem-1.11.0-src.orig/CMake/airExistsConf.h	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/CMake/airExistsConf.h	2021-02-18 15:42:38.000000000 +0800
@@ -0,0 +1,5 @@
+#ifndef airExistsConf_h
+#define airExistsConf_h
+#cmakedefine AIR_EXISTS_MACRO_FAILS
+#endif // airExistsConf_h
+
diff --color -ruN teem-1.11.0-src.orig/CMake/FindBZ2.cmake teem-1.11.0-src/CMake/FindBZ2.cmake
--- teem-1.11.0-src.orig/CMake/FindBZ2.cmake	2012-12-20 22:07:08.000000000 +0800
+++ teem-1.11.0-src/CMake/FindBZ2.cmake	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
-# Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Teem: Tools to process and visualize scientific data and images
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -28,24 +28,24 @@
 # BZ2_LIBRARIES   - List of fully qualified libraries to link against when using bzlib.
 # BZ2_FOUND       - Do not attempt to use zlib if "no" or undefined.
 
-FIND_PATH(BZ2_INCLUDE_DIR bzlib.h
+find_path(BZ2_INCLUDE_DIR bzlib.h
   /usr/local/include
   /usr/include
 )
 
-FIND_LIBRARY(BZ2_LIBRARY bz2
+find_library(BZ2_LIBRARY bz2
   /usr/lib
   /usr/local/lib
 )
 
-IF(BZ2_INCLUDE_DIR)
-  IF(BZ2_LIBRARY)
-    SET( BZ2_LIBRARIES ${BZ2_LIBRARY} )
-    SET( BZ2_FOUND "YES" )
-  ENDIF(BZ2_LIBRARY)
-ENDIF(BZ2_INCLUDE_DIR)
+if(BZ2_INCLUDE_DIR)
+  if(BZ2_LIBRARY)
+    set( BZ2_LIBRARIES ${BZ2_LIBRARY} )
+    set( BZ2_FOUND "YES" )
+  endif()
+endif()
 
-MARK_AS_ADVANCED(
+mark_as_advanced(
   BZ2_LIBRARY
   BZ2_INCLUDE_DIR
   )
diff --color -ruN teem-1.11.0-src.orig/CMake/FindFFTW3.cmake teem-1.11.0-src/CMake/FindFFTW3.cmake
--- teem-1.11.0-src.orig/CMake/FindFFTW3.cmake	2012-12-20 22:07:08.000000000 +0800
+++ teem-1.11.0-src/CMake/FindFFTW3.cmake	2021-02-18 15:42:38.000000000 +0800
@@ -1,21 +1,21 @@
 
-FIND_PATH(FFTW3_INCLUDE_DIR fftw3.h
+find_path(FFTW3_INCLUDE_DIR fftw3.h
   /usr/local/include
   /usr/include
 )
 
-FIND_LIBRARY(FFTW3_LIBRARY fftw3
+find_library(FFTW3_LIBRARY fftw3
   /usr/lib
   /usr/local/lib
 )
 
-SET(FFTW3_FOUND FALSE)
-IF(FFTW3_INCLUDE_DIR AND FFTW3_LIBRARY)
-    SET(FFTW3_LIBRARIES ${FFTW3_LIBRARY} )
-    SET(FFTW3_FOUND TRUE)
-ENDIF(FFTW3_INCLUDE_DIR AND FFTW3_LIBRARY)
+set(FFTW3_FOUND FALSE)
+if(FFTW3_INCLUDE_DIR AND FFTW3_LIBRARY)
+    set(FFTW3_LIBRARIES ${FFTW3_LIBRARY} )
+    set(FFTW3_FOUND TRUE)
+endif()
 
-MARK_AS_ADVANCED(
+mark_as_advanced(
   FFTW3_INCLUDE_DIR
   FFTW3_LIBRARIES
   FFTW3_FOUND
diff --color -ruN teem-1.11.0-src.orig/CMake/FindLEVMAR.cmake teem-1.11.0-src/CMake/FindLEVMAR.cmake
--- teem-1.11.0-src.orig/CMake/FindLEVMAR.cmake	2012-12-20 22:07:08.000000000 +0800
+++ teem-1.11.0-src/CMake/FindLEVMAR.cmake	2021-02-18 15:42:38.000000000 +0800
@@ -1,22 +1,23 @@
 
-FIND_PATH(LEVMAR_INCLUDE_DIR lm.h
+find_path(LEVMAR_INCLUDE_DIR levmar.h
+  /usr/local/include/levmar
   /usr/local/include
   /usr/include
 )
 
-FIND_LIBRARY(LEVMAR_LIBRARY levmar
+find_library(LEVMAR_LIBRARY levmar
   /usr/lib
   /usr/local/lib
 )
 
-SET(LEVMAR_FOUND FALSE)
-IF(LEVMAR_INCLUDE_DIR AND LEVMAR_LIBRARY)
-    SET(LEVMAR_INCLUDE_DIRS ${LEVMAR_INCLUDE_DIR} )
-    SET(LEVMAR_LIBRARIES ${LEVMAR_LIBRARY} )
-    SET(LEVMAR_FOUND TRUE)
-ENDIF(LEVMAR_INCLUDE_DIR AND LEVMAR_LIBRARY)
+set(LEVMAR_FOUND FALSE)
+if(LEVMAR_INCLUDE_DIR AND LEVMAR_LIBRARY)
+    set(LEVMAR_INCLUDE_DIRS ${LEVMAR_INCLUDE_DIR} )
+    set(LEVMAR_LIBRARIES ${LEVMAR_LIBRARY} )
+    set(LEVMAR_FOUND TRUE)
+endif()
 
-MARK_AS_ADVANCED(
+mark_as_advanced(
   LEVMAR_INCLUDE_DIR
   LEVMAR_LIBRARIES
   LEVMAR_FOUND
diff --color -ruN teem-1.11.0-src.orig/CMake/TeemConfig.cmake.in teem-1.11.0-src/CMake/TeemConfig.cmake.in
--- teem-1.11.0-src.orig/CMake/TeemConfig.cmake.in	2012-12-20 22:07:08.000000000 +0800
+++ teem-1.11.0-src/CMake/TeemConfig.cmake.in	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -31,36 +31,36 @@
 # The directory of TeemConfig.cmake is, by definition, Teem_DIR.
 # (this_dir == Teem_DIR)
 #
-GET_FILENAME_COMPONENT(this_dir "${CMAKE_CURRENT_LIST_FILE}" PATH)
-GET_FILENAME_COMPONENT(Teem_ROOT_DIR "${this_dir}/@Teem_CV_CONFIG_TO_ROOT@" ABSOLUTE)
+get_filename_component(this_dir "${CMAKE_CURRENT_LIST_FILE}" PATH)
+get_filename_component(Teem_ROOT_DIR "${this_dir}/@Teem_CV_CONFIG_TO_ROOT@" ABSOLUTE)
 
 # CMake files required to build client applications that use Teem.
-SET(Teem_BUILD_SETTINGS_FILE "@Teem_CV_BUILD_SETTINGS_FILE@")
-SET(Teem_USE_FILE "@Teem_CV_USE_FILE@")
+set(Teem_BUILD_SETTINGS_FILE "@Teem_CV_BUILD_SETTINGS_FILE@")
+set(Teem_USE_FILE "@Teem_CV_USE_FILE@")
 
 # The Teem directories.
-SET(Teem_EXECUTABLE_DIRS "@Teem_CV_EXECUTABLE_DIRS@")
-SET(Teem_LIBRARY_DIRS "@Teem_CV_LIBRARY_DIRS@")
-SET(Teem_INCLUDE_DIRS "@Teem_CV_INCLUDE_DIRS@")
+set(Teem_EXECUTABLE_DIRS "@Teem_CV_EXECUTABLE_DIRS@")
+set(Teem_LIBRARY_DIRS "@Teem_CV_LIBRARY_DIRS@")
+set(Teem_INCLUDE_DIRS "@Teem_CV_INCLUDE_DIRS@")
 
 # The Teem libraries.
-SET(Teem_LIBRARIES "@Teem_CV_BUILT_LIBRARIES@")
+set(Teem_LIBRARIES "@Teem_CV_BUILT_LIBRARIES@")
 
 # The C flags added by Teem to the cmake-configured flags.
-SET(Teem_REQUIRED_C_FLAGS "@Teem_REQUIRED_C_FLAGS@")
+set(Teem_REQUIRED_C_FLAGS "@Teem_REQUIRED_C_FLAGS@")
 
 # The Teem version number
-SET(Teem_VERSION_MAJOR "@Teem_VERSION_MAJOR@")
-SET(Teem_VERSION_MINOR "@Teem_VERSION_MINOR@")
-SET(Teem_VERSION_PATCH "@Teem_VERSION_PATCH@")
+set(Teem_VERSION_MAJOR "@Teem_VERSION_MAJOR@")
+set(Teem_VERSION_MINOR "@Teem_VERSION_MINOR@")
+set(Teem_VERSION_PATCH "@Teem_VERSION_PATCH@")
 
 # Is Teem using shared libraries?
-SET(Teem_BUILD_SHARED_LIBS "@BUILD_SHARED_LIBS@")
+set(Teem_BUILD_SHARED_LIBS "@BUILD_SHARED_LIBS@")
 
 # The list of tools in teem
-SET(Teem_TOOLS "@Teem_TOOLS@")
+set(Teem_TOOLS "@Teem_TOOLS@")
 
 # The Teem library dependencies.
-IF(NOT Teem_NO_LIBRARY_DEPENDS)
-  INCLUDE("@Teem_CV_LIBRARY_DEPENDS_FILE@")
-ENDIF(NOT Teem_NO_LIBRARY_DEPENDS)
+if(NOT TARGET teem)
+  include("@Teem_CV_LIBRARY_DEPENDS_FILE@")
+endif()
diff --color -ruN teem-1.11.0-src.orig/CMake/TeemUse.cmake teem-1.11.0-src/CMake/TeemUse.cmake
--- teem-1.11.0-src.orig/CMake/TeemUse.cmake	2012-12-20 22:07:08.000000000 +0800
+++ teem-1.11.0-src/CMake/TeemUse.cmake	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
-# Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Teem: Tools to process and visualize scientific data and images
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -21,28 +21,28 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-IF(NOT Teem_FOUND)
-  MESSAGE(FATAL_ERROR "Something went wrong. You are including TeemUse.cmake but Teem was not found")
-ENDIF(NOT Teem_FOUND)
+if(NOT Teem_FOUND)
+  message(FATAL_ERROR "Something went wrong. You are including TeemUse.cmake but Teem was not found")
+endif()
 
 # Make Teem easier to use
-INCLUDE_DIRECTORIES(${Teem_INCLUDE_DIRS})
-LINK_DIRECTORIES(${Teem_LIBRARY_DIRS})
+include_directories(${Teem_INCLUDE_DIRS})
+link_directories(${Teem_LIBRARY_DIRS})
 
 # Load the compiler settings used for Teem.
-IF(Teem_BUILD_SETTINGS_FILE)
-  INCLUDE(CMakeImportBuildSettings)
+if(Teem_BUILD_SETTINGS_FILE)
+  include(CMakeImportBuildSettings)
   CMAKE_IMPORT_BUILD_SETTINGS(${Teem_BUILD_SETTINGS_FILE})
-ENDIF(Teem_BUILD_SETTINGS_FILE)
+endif()
 
 # Support static builds
-IF(NOT Teem_BUILD_SHARED_LIBS)
-  ADD_DEFINITIONS(-DTEEM_STATIC=1)
-ENDIF(NOT Teem_BUILD_SHARED_LIBS)
+if(NOT Teem_BUILD_SHARED_LIBS)
+  add_definitions(-DTEEM_STATIC=1)
+endif()
 
 # Add compiler flags needed to use Teem.
-SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${Teem_REQUIRED_C_FLAGS}")
-SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${Teem_REQUIRED_EXE_LINKER_FLAGS}")
-SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${Teem_REQUIRED_SHARED_LINKER_FLAGS}")
-SET(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} ${Teem_REQUIRED_MODULE_LINKER_FLAGS}")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${Teem_REQUIRED_C_FLAGS}")
+set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${Teem_REQUIRED_EXE_LINKER_FLAGS}")
+set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${Teem_REQUIRED_SHARED_LINKER_FLAGS}")
+set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} ${Teem_REQUIRED_MODULE_LINKER_FLAGS}")
 
diff --color -ruN teem-1.11.0-src.orig/CMake/testAirExists.cxx teem-1.11.0-src/CMake/testAirExists.cxx
--- teem-1.11.0-src.orig/CMake/testAirExists.cxx	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/CMake/testAirExists.cxx	2021-02-18 15:42:38.000000000 +0800
@@ -0,0 +1,24 @@
+
+typedef union {
+  unsigned int i;
+  float f;
+} airFloat;
+
+const airFloat airFloatQNaN = {0x7fffffff};
+#define AIR_NAN  (airFloatQNaN.f)
+
+#define AIR_CAST(t, v) ((t)(v))
+#define AIR_EXISTS(x) (AIR_CAST(int, !((x) - (x))))
+
+int main(int, char *[])
+{
+  double test = AIR_NAN;
+  if(AIR_EXISTS(test))
+    {
+    return 1;
+    }
+  else
+    {
+    return 0;
+    }
+}
diff --color -ruN teem-1.11.0-src.orig/CMake/TestNO_ICC_IDYNAMIC_NEEDED.cmake teem-1.11.0-src/CMake/TestNO_ICC_IDYNAMIC_NEEDED.cmake
--- teem-1.11.0-src.orig/CMake/TestNO_ICC_IDYNAMIC_NEEDED.cmake	2012-12-20 22:07:08.000000000 +0800
+++ teem-1.11.0-src/CMake/TestNO_ICC_IDYNAMIC_NEEDED.cmake	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
-# Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Teem: Tools to process and visualize scientific data and images
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -27,28 +27,28 @@
 # VARIABLE - variable to store the result to
 #
 
-MACRO(TESTNO_ICC_IDYNAMIC_NEEDED VARIABLE LOCAL_TEST_DIR)
-  IF("HAVE_${VARIABLE}" MATCHES "^HAVE_${VARIABLE}$")
-    TRY_RUN(${VARIABLE} HAVE_${VARIABLE}
+macro(TESTNO_ICC_IDYNAMIC_NEEDED VARIABLE LOCAL_TEST_DIR)
+  if("HAVE_${VARIABLE}" MATCHES "^HAVE_${VARIABLE}$")
+    try_run(${VARIABLE} HAVE_${VARIABLE}
       ${CMAKE_BINARY_DIR}
       ${LOCAL_TEST_DIR}/TestNO_ICC_IDYNAMIC_NEEDED.cxx
       OUTPUT_VARIABLE OUTPUT)
-    MESSAGE(STATUS "Check if using the Intel icc compiler, and if -i_dynamic is needed... COMPILE_RESULT...${HAVE_${VARIABLE}} RUN_RESULT...${VARIABLE}\n")
-    IF(HAVE_${VARIABLE}) #Test compiled, either working intel w/o -i_dynamic, or another compiler
-      IF(${VARIABLE})   #Intel icc compiler, -i_dynamic not needed
-        FILE(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log
+    message(STATUS "Check if using the Intel icc compiler, and if -i_dynamic is needed... COMPILE_RESULT...${HAVE_${VARIABLE}} RUN_RESULT...${VARIABLE}\n")
+    if(HAVE_${VARIABLE}) #Test compiled, either working intel w/o -i_dynamic, or another compiler
+      if(${VARIABLE})   #Intel icc compiler, -i_dynamic not needed
+        file(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log
                        "-i_dynamic not needed, (Not Intel icc, or this version of Intel icc does not conflict with OS glibc.")
-        MESSAGE(STATUS "-i_dynamic not needed, (Not Intel icc, or this version of Intel icc does not conflict with OS glibc.")
-      ELSE(${VARIABLE}) #The compiler is not Intel icc
-        FILE(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log 
+        message(STATUS "-i_dynamic not needed, (Not Intel icc, or this version of Intel icc does not conflict with OS glibc.")
+      else() #The compiler is not Intel icc
+        file(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log
                        "The compiler ERROR--This should never happen")
-        MESSAGE(STATUS "The compiler ERROR--This should never happen")
-      ENDIF(${VARIABLE})
-    ELSE(HAVE_${VARIABLE})  #Test did not compile, either badly broken compiler, or intel -i_dynamic needed
-      FILE(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log
+        message(STATUS "The compiler ERROR--This should never happen")
+      endif()
+    else()  #Test did not compile, either badly broken compiler, or intel -i_dynamic needed
+      file(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log
             "\tThe -i_dynamic compiler flag is needed for the Intel icc compiler on this platform.\n")
-      MESSAGE("The -i_dynamic compiler flag is needed for the Intel icc compiler on this platform.")
-    ENDIF(HAVE_${VARIABLE})
-    FILE(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log "TestNO_ICC_IDYNAMIC_NEEDED produced following output:\n${OUTPUT}\n\n")
-  ENDIF("HAVE_${VARIABLE}" MATCHES "^HAVE_${VARIABLE}$")
-ENDMACRO(TESTNO_ICC_IDYNAMIC_NEEDED)
+      message("The -i_dynamic compiler flag is needed for the Intel icc compiler on this platform.")
+    endif()
+    file(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log "TestNO_ICC_IDYNAMIC_NEEDED produced following output:\n${OUTPUT}\n\n")
+  endif()
+endmacro()
diff --color -ruN teem-1.11.0-src.orig/CMake/TestNO_ICC_IDYNAMIC_NEEDED.cxx teem-1.11.0-src/CMake/TestNO_ICC_IDYNAMIC_NEEDED.cxx
--- teem-1.11.0-src.orig/CMake/TestNO_ICC_IDYNAMIC_NEEDED.cxx	2012-12-20 22:07:08.000000000 +0800
+++ teem-1.11.0-src/CMake/TestNO_ICC_IDYNAMIC_NEEDED.cxx	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
-  Teem: Tools to process and visualize scientific data and images              
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Teem: Tools to process and visualize scientific data and images
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/CMake/TestQnanhibit.c teem-1.11.0-src/CMake/TestQnanhibit.c
--- teem-1.11.0-src.orig/CMake/TestQnanhibit.c	2012-12-20 22:07:08.000000000 +0800
+++ teem-1.11.0-src/CMake/TestQnanhibit.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
-  Teem: Tools to process and visualize scientific data and images              
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Teem: Tools to process and visualize scientific data and images
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/CMake/TestQnanhibit.cmake teem-1.11.0-src/CMake/TestQnanhibit.cmake
--- teem-1.11.0-src.orig/CMake/TestQnanhibit.cmake	2012-12-20 22:07:08.000000000 +0800
+++ teem-1.11.0-src/CMake/TestQnanhibit.cmake	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
-# Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Teem: Tools to process and visualize scientific data and images
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -22,38 +22,38 @@
 #
 
 #
-# Checks whether the 22nd bit of a 32-bit quiet-NaN is 1 (1) or 0 (0).  This 
-# distinction is needed in handling of IEEE floating point special values.  
+# Checks whether the 22nd bit of a 32-bit quiet-NaN is 1 (1) or 0 (0).  This
+# distinction is needed in handling of IEEE floating point special values.
 # This quantity is independent of endian-ness.
 #
 # VARIABLE - variable to store the result to
 #
 
-MACRO(TEST_QNANHIBIT VARIABLE LOCAL_TEST_DIR)
-  IF("HAVE_${VARIABLE}" MATCHES "^HAVE_${VARIABLE}$")
-    TRY_RUN(${VARIABLE} HAVE_${VARIABLE}
+macro(TEST_QNANHIBIT VARIABLE LOCAL_TEST_DIR)
+  if("HAVE_${VARIABLE}" MATCHES "^HAVE_${VARIABLE}$")
+    try_run(${VARIABLE} HAVE_${VARIABLE}
       ${CMAKE_BINARY_DIR}
       ${LOCAL_TEST_DIR}/TestQnanhibit.c
       OUTPUT_VARIABLE OUTPUT)
-    MESSAGE(STATUS "Check the value of the 22nd bit of a 32-bit quiet-NaN")
-    IF(HAVE_${VARIABLE})
-      IF(${VARIABLE} LESS 0)
-        MESSAGE(ERROR " A test (qnanhibit.c) necessary for NrrdIO configuration returned error code. NrrdIO may not properly handle NaN's.")
-      ENDIF(${VARIABLE} LESS 0)
-      IF(${VARIABLE})
-        FILE(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log
+    message(STATUS "Check the value of the 22nd bit of a 32-bit quiet-NaN")
+    if(HAVE_${VARIABLE})
+      if(${VARIABLE} LESS 0)
+        message(ERROR " A test (qnanhibit.c) necessary for NrrdIO configuration returned error code. NrrdIO may not properly handle NaN's.")
+      endif()
+      if(${VARIABLE})
+        file(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log
                     "Value of the 22nd bit of a 32-bit quiet-NaN is 1")
-        MESSAGE(STATUS "Check the value of the 22nd bit of a 32-bit quiet-NaN - 1")
-      ELSE(${VARIABLE})
-        FILE(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log
+        message(STATUS "Check the value of the 22nd bit of a 32-bit quiet-NaN - 1")
+      else()
+        file(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log
                     "Value of the 22nd bit of a 32-bit quiet-NaN is 0")
-        MESSAGE(STATUS "Check the value of the 22nd bit of a 32-bit quiet-NaN - 0")
-      ENDIF(${VARIABLE})
-    ELSE(HAVE_${VARIABLE})
-      FILE(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log
+        message(STATUS "Check the value of the 22nd bit of a 32-bit quiet-NaN - 0")
+      endif()
+    else()
+      file(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log
         "\tFailed to compile a test (TestQnanhibit.c) necessary to configure for proper handling of IEEE floating point NaN's.\n")
-      MESSAGE(STATUS "Failed to compile a test (TestQnanhibit.c) necessary to configure for proper handling of IEEE floating point NaN's")
-    ENDIF(HAVE_${VARIABLE})
-    FILE(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log "TestQnanhibit.c produced following output:\n${OUTPUT}\n\n")
-  ENDIF("HAVE_${VARIABLE}" MATCHES "^HAVE_${VARIABLE}$")
-ENDMACRO(TEST_QNANHIBIT)
+      message(STATUS "Failed to compile a test (TestQnanhibit.c) necessary to configure for proper handling of IEEE floating point NaN's")
+    endif()
+    file(APPEND ${CMAKE_BINARY_DIR}/CMakeError.log "TestQnanhibit.c produced following output:\n${OUTPUT}\n\n")
+  endif()
+endmacro()
diff --color -ruN teem-1.11.0-src.orig/CMakeLists.txt teem-1.11.0-src/CMakeLists.txt
--- teem-1.11.0-src.orig/CMakeLists.txt	2012-12-20 22:12:22.000000000 +0800
+++ teem-1.11.0-src/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -20,441 +20,387 @@
 # along with this library; if not, write to Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
-
 # This is the root Teem CMakeLists file
-CMAKE_MINIMUM_REQUIRED(VERSION 2.4)
-
-# Cmake shouldn't define WIN32 when compiling
-set(CMAKE_LEGACY_CYGWIN_WIN32 0) 
-
-# As of CMake 2.6 Policies were introduced in order to provide a mechanism for
-# adding backwards compatibility one feature at a time.
 
-# Run cmake --help-policy CMP<num> to see documentation.
-IF(COMMAND cmake_policy)
-  # Library paths (/path/to/libmy.so not translated to -L/path/to -lmy)
-  CMAKE_POLICY(SET CMP0003 NEW)
-ENDIF(COMMAND cmake_policy)
+# adapt to the available version of cmake
+cmake_minimum_required(VERSION 3.13...3.15)
 
-PROJECT(Teem)
+if(${CMAKE_VERSION} VERSION_LESS 3.15)
+    cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})
+else()
+    cmake_policy(VERSION 3.15)
+endif()
 
 #-----------------------------------------------------------------------------
 # Teem version number.  Must reflect the values in teem/src/air/air.h
-SET(Teem_VERSION_MAJOR "1")
-SET(Teem_VERSION_MINOR "11")
-SET(Teem_VERSION_PATCH "0")
-
-# Version string should not include patch level.  The major.minor is
-# enough to distinguish available features of the toolkit.
-SET(Teem_VERSION_STRING "${Teem_VERSION_MAJOR}.${Teem_VERSION_MINOR}.${Teem_VERSION_PATCH}")
-
-SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_CURRENT_SOURCE_DIR}/CMake")
+# means the version number is 1.12.0
+set(Teem_VERSION_MAJOR "1")
+set(Teem_VERSION_MINOR "12")
+set(Teem_VERSION_PATCH "0")
+
+# Version string (no space in version numbers, so doesn't have to be quoted)
+set(Teem_VERSION_STRING ${Teem_VERSION_MAJOR}.${Teem_VERSION_MINOR}.${Teem_VERSION_PATCH})
+
+# DESCRIPTION was added to set a project description in CMake 3.9
+project(Teem VERSION ${Teem_VERSION_STRING}
+        DESCRIPTION "Teem libraries developed by Gordon Kindlmann et. al."
+        LANGUAGES C CXX)
+
+# specifying a search path for CMake modules to be loaded by the include() or find_package()
+set(CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/CMake")
+
+# Include directory
+# path directory variable should always be quoted since path may contain spaces
+include_directories("${Teem_BINARY_DIR}/include/" "${Teem_SOURCE_DIR}/include/")
 
 # We need ansi c-flags, especially on HP
-SET(CMAKE_C_FLAGS "${CMAKE_ANSI_CFLAGS} ${CMAKE_C_FLAGS}")
-SET(CMAKE_REQUIRED_FLAGS ${CMAKE_ANSI_CFLAGS})
+set(CMAKE_C_FLAGS "${CMAKE_ANSI_CFLAGS} ${CMAKE_C_FLAGS}")
+set(CMAKE_REQUIRED_FLAGS ${CMAKE_ANSI_CFLAGS})
 
 #-----------------------------------------------------------------------------
 # Test for some required system information.
-INCLUDE (CMakeBackwardCompatibilityC)
-
-#-----------------------------------------------------------------------------
-# Output directories.
-SET (LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin CACHE INTERNAL "Single output directory for building all libraries.")
-SET (EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin CACHE INTERNAL "Single output directory for building all executables.")
-#output directory for installing all include files.")
-MARK_AS_ADVANCED(LIBRARY_OUTPUT_PATH EXECUTABLE_OUTPUT_PATH)
-SET(Teem_LIBRARY_PATH "${LIBRARY_OUTPUT_PATH}")
-SET(Teem_EXECUTABLE_PATH "${EXECUTABLE_OUTPUT_PATH}")
-SET(C_TEST_PATH ${EXECUTABLE_OUTPUT_PATH})
-
-
-FILE(MAKE_DIRECTORY ${Teem_BINARY_DIR}/include)
-FILE(MAKE_DIRECTORY ${Teem_BINARY_DIR}/include/teem)
+include (CMakeBackwardCompatibilityC)
 
 #-----------------------------------------------------------------------------
-# Find platform-specific differences in the handling of IEEE floating point 
-# special values.
-
-INCLUDE(${Teem_SOURCE_DIR}/CMake/TestQnanhibit.cmake)
+# set all output directories to be teem-build/bin unless defined
+foreach(type LIBRARY RUNTIME ARCHIVE)
+    if(DEFINED CMAKE_${type}_OUTPUT_DIRECTORY AND NOT EXISTS ${CMAKE_${type}_OUTPUT_DIRECTORY})
+        # message(FATAL_ERROR "CMAKE_${type}_OUTPUT_DIRECTORY is set to a non-existing directory [${CMAKE_${type}_OUTPUT_DIRECTORY}]")
+        message("CMAKE_${type}_OUTPUT_DIRECTORY is set to a non-existing directory [${CMAKE_${type}_OUTPUT_DIRECTORY}]")
+        file(MAKE_DIRECTORY ${CMAKE_${type}_OUTPUT_DIRECTORY})
+        message("${CMAKE_${type}_OUTPUT_DIRECTORY} has been created")
+    endif()
+
+    if(NOT DEFINED CMAKE_${type}_OUTPUT_DIRECTORY)
+        set(CMAKE_${type}_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
+    endif()
+endforeach()
+
+# build shared libraries option
+if(BUILD_SHARED_LIBS)
+    set(__LIBRARY_OUTPUT_PATH__ "${CMAKE_LIBRARY_OUTPUT_DIRECTORY}")
+else()
+    set(__LIBRARY_OUTPUT_PATH__ "${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}")
+endif()
+
+set(__RUNTIME_OUTPUT_PATH_ "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}")
+
+# output directory for installing all include files
+file(MAKE_DIRECTORY ${Teem_BINARY_DIR}/include)
+file(MAKE_DIRECTORY ${Teem_BINARY_DIR}/include/teem)
+
+#-----------------------------------------------------------------------------
+# Find platform-specific differences in the handling of IEEE floating point special values.
+# This is needed by Teem
+include(${Teem_SOURCE_DIR}/CMake/TestQnanhibit.cmake)
 TEST_QNANHIBIT(QNANHIBIT_VALUE ${Teem_SOURCE_DIR}/CMake)
-IF(QNANHIBIT_VALUE)
-  SET(QNANHIBIT 1 CACHE INTERNAL "The 22nd bit of 32-bit floating-point quiet NaN.")
-ELSE(QNANHIBIT_VALUE)
-  SET(QNANHIBIT 0 CACHE INTERNAL "The 22nd bit of 32-bit floating-point quiet NaN.")
-ENDIF(QNANHIBIT_VALUE)
-
-
-#-----------------------------------------------------------------------------
-# Teem build configuration options.
-OPTION(BUILD_SHARED_LIBS "Build Teem with shared libraries." OFF)
-SET(Teem_BUILD_SHARED_LIBS ${BUILD_SHARED_LIBS})
-IF(NOT Teem_BUILD_SHARED_LIBS)
-  ADD_DEFINITIONS(-DTEEM_STATIC)
-ENDIF(NOT Teem_BUILD_SHARED_LIBS)
-
-OPTION(Teem_ZLIB "Build Teem with support for gzip compression." ON)
-OPTION(Teem_PNG "Build Teem with support for PNG images." ON)
-OPTION(Teem_VTK_MANGLE "Build Teem using the mangled libraries from VTK for ZLIB and PNG." OFF)
-SET(Teem_VTK_ZLIB_MANGLE_IPATH "" CACHE PATH "Location of vtk_zlib_mangle.h")
-SET(Teem_VTK_TOOLKITS_IPATH "" CACHE PATH "Location of VTK Build directory for ZLIB and PNG includes.")
-
+if(QNANHIBIT_VALUE)
+    set(QNANHIBIT 1 CACHE INTERNAL "The 22nd bit of 32-bit floating-point quiet NaN.")
+else()
+    set(QNANHIBIT 0 CACHE INTERNAL "The 22nd bit of 32-bit floating-point quiet NaN.")
+endif()
+# Teem Defines
+if(QNANHIBIT)
+    add_definitions(-DTEEM_QNANHIBIT=1)
+else()
+    add_definitions(-DTEEM_QNANHIBIT=0)
+endif()
+
+#-----------------------------------------------------------------------------
+# test if AIR_EXISTS macro fails
+# try_run(<runResultVar> <compileResultVar>
+#         <bindir> <srcfile>)
+try_run(AIR_EXISTS_MACRO_FAILS AIR_EXISTS_MACRO_COMPILE
+        ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_LIST_DIR}/CMake/testAirExists.cxx)
+
+#-----------------------------------------------------------------------------
+# All the Teem build configuration options.
+# Option 1 - BUILD_SHARED_LIBS is a global flag that causes add_library to create shared libraries if on.
+option(BUILD_SHARED_LIBS "Build Teem with shared libraries." OFF)
+# If present and true, this will cause all libraries to be built shared unless the library was explicitly added as a static library
+set(Teem_BUILD_SHARED_LIBS ${BUILD_SHARED_LIBS})
+if(NOT Teem_BUILD_SHARED_LIBS)
+    add_definitions(-DTEEM_STATIC)
+endif()
+# Option 2 - if we are using ZLIB library
+option(Teem_ZLIB "Build Teem with support for gzip compression." ON)
+# Option 3 - if we are using PNG library
+option(Teem_PNG "Build Teem with support for PNG images." ON)
 # Can't build PNG without ZLIB, so force it on.
-IF(Teem_PNG AND NOT Teem_ZLIB)
-  SET(Teem_ZLIB ON)
-ENDIF(Teem_PNG AND NOT Teem_ZLIB)
-
-IF(Teem_VTK_MANGLE)
-  ADD_DEFINITIONS(-DTEEM_VTK_MANGLE=1)
-  INCLUDE_DIRECTORIES( ${Teem_VTK_TOOLKITS_IPATH} )
-  INCLUDE_DIRECTORIES( ${Teem_VTK_ZLIB_MANGLE_IPATH} )
-ENDIF(Teem_VTK_MANGLE)
-
-
-SET(Teem_ZLIB_LIB "")
-SET(Teem_PNG_LIB "")
-IF(Teem_ZLIB)
-  # Find ZLIB
-  FIND_PACKAGE(ZLIB)
-  IF(ZLIB_FOUND)
-    ADD_DEFINITIONS(-DTEEM_ZLIB)
-    SET(Teem_ZLIB_LIB ${ZLIB_LIBRARIES})
-    SET(Teem_ZLIB_IPATH ${ZLIB_INCLUDE_DIR})
-  ELSE(ZLIB_FOUND)
-    # We need to set this as a cache variable, so that it will show up as
-    # being turned off in the cache.
-    MESSAGE("warning: Turning off Teem_ZLIB, because it wasn't found.")
-    SET(Teem_ZLIB OFF CACHE BOOL "Build Teem with support for gzip compression." FORCE)
-  ENDIF(ZLIB_FOUND)
-
-  IF(Teem_PNG)
-    FIND_PACKAGE(PNG)
-    IF(PNG_FOUND)
-      ADD_DEFINITIONS(-DTEEM_PNG ${PNG_DEFINITIONS})
-      SET(Teem_PNG_LIB ${PNG_LIBRARIES})
-      SET(Teem_PNG_IPATH ${PNG_INCLUDE_DIR})
-    ELSE(PNG_FOUND)
-      # We need to set this as a cache variable, so that it will show up as
-      # being turned off in the cache.
-      MESSAGE("warning: Turning off Teem_PNG, because it wasn't found.")
-      SET(Teem_PNG OFF CACHE BOOL "Build Teem with support for PNG images." FORCE)
-    ENDIF(PNG_FOUND)
-  ENDIF(Teem_PNG)
-ENDIF(Teem_ZLIB)
-
-# Try and locate BZIP2 stuff
-OPTION(Teem_BZIP2 "Build Teem with support for bzip compression." ON)
-SET(Teem_BZIP2_LIB "")
-
-IF(Teem_BZIP2)
-  FIND_PACKAGE(BZ2)
-
-  IF(BZ2_FOUND)
-    ADD_DEFINITIONS(-DTEEM_BZIP2)
-    SET(Teem_BZIP2_LIB ${BZ2_LIBRARIES})
-    SET(Teem_BZIP2_IPATH ${BZ2_INCLUDE_DIR})
-  ELSE(BZ2_FOUND)
-    # We need to set this as a cache variable, so that it will show up as
-    # being turned off in the cache.
-    MESSAGE("warning: Turning off Teem_BZIP2, because it wasn't found.")
-    SET(Teem_BZIP2 OFF CACHE BOOL "Build Teem with support for bzip compression." FORCE)
-  ENDIF(BZ2_FOUND)
-ENDIF(Teem_BZIP2)
-
-# Look for threading libraries
-OPTION(Teem_PTHREAD "Build Teem with pthread library support." ON)
-IF(Teem_PTHREAD)
-  INCLUDE(FindThreads)
-  IF(CMAKE_USE_PTHREADS_INIT)
-    ADD_DEFINITIONS(-DTEEM_PTHREAD)
-  ELSE(CMAKE_USE_PTHREADS_INIT)
-    # We need to set this as a cache variable, so that it will show up as
-    # being turned off in the cache.
-    MESSAGE("warning: Turning off Teem_PTHREAD, because it wasn't found.")
-    SET(Teem_PTHREAD OFF CACHE BOOL "Build Teem with pthread library support." FORCE)
-    SET(Teem_PTHREAD OFF)
-  ENDIF(CMAKE_USE_PTHREADS_INIT)
-ENDIF(Teem_PTHREAD)
-
-# Look for "levmar" library <http://www.ics.forth.gr/~lourakis/levmar/>
-OPTION(Teem_LEVMAR "Build Teem with levmar library support." OFF)
-SET(Teem_LEVMAR_LIB "")
-IF(Teem_LEVMAR)
-  FIND_PACKAGE(LEVMAR)
-
-  IF(LEVMAR_FOUND)
-    ADD_DEFINITIONS(-DTEEM_LEVMAR)
-    SET(Teem_LEVMAR_LIB ${LEVMAR_LIBRARIES})
-    SET(Teem_LEVMAR_IPATH ${LEVMAR_INCLUDE_DIR})
-  ELSE(LEVMAR_FOUND)
-    # We need to set this as a cache variable, so that it will show up as
-    # being turned off in the cache.
-    MESSAGE("warning: Turning off Teem_LEVMAR, because it wasn't found.")
-    SET(Teem_LEVMAR OFF CACHE BOOL "Build Teem with levmar library support." FORCE)
-  ENDIF(LEVMAR_FOUND)
-ENDIF(Teem_LEVMAR)
-
-# Look for fftw <http://www.fftw.org/>
-OPTION(Teem_FFTW3 "Build Teem with fftw library support." OFF)
-SET(Teem_FFTW3_LIB "")
-
-IF(Teem_FFTW3)
-  FIND_PACKAGE(FFTW3)
-
-  IF(FFTW3_FOUND)
-    ADD_DEFINITIONS(-DTEEM_FFTW3)
-    SET(Teem_FFTW3_LIB ${FFTW3_LIBRARIES})
-    SET(Teem_FFTW3_IPATH ${FFTW3_INCLUDE_DIR})
-  ELSE(FFTW3_FOUND)
-    # We need to set this as a cache variable, so that it will show up as
-    # being turned off in the cache.
-    MESSAGE("warning: Turning off Teem_FFTW3, because it wasn't found.")
-    SET(Teem_FFTW3 OFF CACHE BOOL "Build Teem with fftw library support." FORCE)
-  ENDIF(FFTW3_FOUND)
-ENDIF(Teem_FFTW3)
-
-#-----------------------------------------------------------------------------
-
-IF(${CMAKE_GENERATOR} MATCHES "Visual Studio")
-  # For Visual Studio we don't care about warnings about deprecated sprintf and
-  # the like.
-  ADD_DEFINITIONS(-D_CRT_SECURE_NO_DEPRECATE -D_CRT_NONSTDC_NO_DEPRECATE)
-ENDIF(${CMAKE_GENERATOR} MATCHES "Visual Studio")
-
-#Teem Defines
-#The QNANHIBIT variable is configured by the root level CMakeLists.txt
-IF(QNANHIBIT)
-  ADD_DEFINITIONS(-DTEEM_QNANHIBIT=1)
-ELSE(QNANHIBIT)
-  ADD_DEFINITIONS(-DTEEM_QNANHIBIT=0)
-ENDIF(QNANHIBIT)
-
-#DirectIO is the fast way to do multi-gigabyte I/O and currently only available
-#for SGI platforms.  Use of DirectIO is enabled manually for now.
-#OPTION(USE_DIRECTIO "Use DirectIO for Nrrd file IO.  Only valid on SGI systems." 0)
-#MARK_AS_ADVANCED(USE_DIRECTIO)
-#IF(USE_DIRECTIO)
-#  ADD_DEFINITIONS(-DTEEM_DIO=1)
-#ELSE(USE_DIRECTIO)
-ADD_DEFINITIONS(-DTEEM_DIO=0)
-#ENDIF(USE_DIRECTIO)
-
-SET(BUILD_EXPERIMENTAL_LIBS OFF CACHE BOOL "Build Teem's experimental libraries")
-SET(BUILD_EXPERIMENTAL_APPS OFF CACHE BOOL "Build Teem's non-essential command-line tools")
-
-# If its a Dashboard build; turn ON both 
-# BUILD_EXPERIMENTAL_APPS and BUILD_EXPERIMENTAL_LIBS
-# (h/t David Cole)
-IF(NOT "$ENV{DASHBOARD_TEST_FROM_CTEST}" STREQUAL "")
-  # it is a dashboard build
-  SET(BUILD_EXPERIMENTAL_APPS ON)
-  SET(BUILD_EXPERIMENTAL_LIBS ON)
-ENDIF()
-
-# (TEEM_LIB_LIST)
-SET(Teem_LIBRARIES air hest biff nrrd ell unrrdu moss gage dye limn echo hoover seek ten pull mite meet)
-IF(BUILD_EXPERIMENTAL_LIBS)
-  # This list of the "experimental" libraries must be kept in sync with:
-  # * definition of Teem_HEADER_FILES (below)
-  # * teem/src/meet/meet.h
-  # * teem/src/meet/enumsall.c 
-  # re-setting list so libraries appear in expected order
-  SET(Teem_LIBRARIES air hest biff nrrd ell unrrdu alan moss tijk gage dye bane limn echo hoover seek ten elf pull coil push mite meet)
-  ADD_DEFINITIONS(-DTEEM_BUILD_EXPERIMENTAL_LIBS)
-ENDIF(BUILD_EXPERIMENTAL_LIBS)
-
-IF(BUILD_EXPERIMENTAL_APPS)
-  ADD_DEFINITIONS(-DTEEM_BUILD_EXPERIMENTAL_APPS)
-ENDIF(BUILD_EXPERIMENTAL_APPS)
-
-SET(Teem_HEADER_FILES
-  air/air.h
-  hest/hest.h
-  biff/biff.h
-  nrrd/nrrd.h   nrrd/nrrdDefines.h   nrrd/nrrdMacros.h  nrrd/nrrdEnums.h
-  ell/ell.h     ell/ellMacros.h
-  unrrdu/unrrdu.h
-  moss/moss.h
-  gage/gage.h
-  dye/dye.h
-  limn/limn.h
-  echo/echo.h
-  hoover/hoover.h
-  seek/seek.h
-  ten/ten.h     ten/tenMacros.h
-  pull/pull.h
-  mite/mite.h
-  meet/meet.h
-  )
-IF(BUILD_EXPERIMENTAL_LIBS)
-  SET(Teem_HEADER_FILES ${Teem_HEADER_FILES}
-    alan/alan.h
-    tijk/tijk.h
-    bane/bane.h
-    elf/elf.h
-    coil/coil.h
-    push/push.h
-    )
-ENDIF(BUILD_EXPERIMENTAL_LIBS)
-SET(Teem_INSTALLED_HEADER_FILES)
-FOREACH(header_file ${Teem_HEADER_FILES})
-  # When debugging, uncomment this line
-  #MESSAGE(STATUS "Copy header file: ${header_file}")
-  GET_FILENAME_COMPONENT(file_no_path "${header_file}" NAME)
-  CONFIGURE_FILE("${CMAKE_CURRENT_SOURCE_DIR}/src/${header_file}"
-    "${CMAKE_CURRENT_BINARY_DIR}/include/teem/${file_no_path}" COPYONLY IMMEDIATE)
-  SET(Teem_INSTALLED_HEADER_FILES
-    ${Teem_INSTALLED_HEADER_FILES}
-    "${CMAKE_CURRENT_BINARY_DIR}/include/teem/${file_no_path}")
-ENDFOREACH(header_file)
-
-#---
-# Include directory 
-INCLUDE_DIRECTORIES(
-  "${Teem_BINARY_DIR}/include/"
-  "${Teem_SOURCE_DIR}/include/"
-  )
-
-
-## Add external library path includes
-IF(Teem_ZLIB)
-  INCLUDE_DIRECTORIES(${Teem_ZLIB_IPATH})
-  INCLUDE_DIRECTORIES(${Teem_ZLIB_DLLCONF_IPATH})
-  IF(Teem_PNG)
-    INCLUDE_DIRECTORIES(${Teem_PNG_IPATH})
-    INCLUDE_DIRECTORIES(${Teem_PNG_DLLCONF_IPATH})
-  ENDIF(Teem_PNG)
-ENDIF(Teem_ZLIB)
-
-IF(Teem_BZIP2)
-  INCLUDE_DIRECTORIES(${Teem_BZIP2_IPATH})
-ENDIF(Teem_BZIP2)
-
-IF(Teem_LEVMAR)
-  INCLUDE_DIRECTORIES(${Teem_LEVMAR_IPATH})
-ENDIF(Teem_LEVMAR)
-
-IF(Teem_FFTW3)
-  INCLUDE_DIRECTORIES(${Teem_FFTW3_IPATH})
-ENDIF(Teem_FFTW3)
-
-# All the source files
-SET(Teem_SOURCES)
-
-#-----------------------------------------------------------------------------
-# Macro for adding the current set of source files to the master list
-MACRO(ADD_Teem_LIBRARY dir)
-  SET(srcs)
-  FOREACH(src ${ARGN})
-    SET(srcs ${srcs} "src/${dir}/${src}")
-  ENDFOREACH(src ${ARGN})
-  SET(Teem_SOURCES ${Teem_SOURCES} ${srcs})
-  # This will group all the source files in the VS project by directory
-  SOURCE_GROUP( ${dir} FILES ${srcs} )
-ENDMACRO(ADD_Teem_LIBRARY name)
-
-
-#-----------------------------------------------------------------------------
-# Dispatch the build into the proper subdirectories.
-FOREACH(dir ${Teem_LIBRARIES})
-  INCLUDE(src/${dir}/sources.cmake)
-ENDFOREACH(dir ${Teem_LIBRARIES})
+if(Teem_PNG AND NOT Teem_ZLIB)
+    message(WARNING "Can't build PNG without ZLIB, so Teem_ZLIB option has been turned on.")
+    set(Teem_ZLIB ON)
+endif()
+# Option 4 - if we are using bzip library
+option(Teem_BZIP2 "Build Teem with support for bzip compression." OFF)
+# Option 5 - if we are using threading libraries
+option(Teem_PTHREAD "Build Teem with pthread library support." ON)
+# Option 6 - Look for "levmar" library <http://www.ics.forth.gr/~lourakis/levmar/>
+option(Teem_LEVMAR "Build Teem with levmar library support." OFF)
+# Option 7 - Look for fftw <http://www.fftw.org/>
+option(Teem_FFTW3 "Build Teem with fftw library support." OFF)
+# Option 8
+option(USE_DIRECTIO "Use DirectIO for Nrrd file IO.  Only valid on SGI systems." OFF)
+# Option 9
+option(Teem_USE_LIB_INSTALL_SUBDIR "Add a Teem-X.Y.Z directory layer to the installation tree for libraries and archives." OFF)
+# Option 10 - Stand-alone programs to process hex encoding of data
+option(BUILD_HEX "Build dehex and enhex" OFF)
+# Option 11 - For testing
+option(BUILD_TESTING "Enable this to perform testing of Teem" ON)
+
+#-----------------------------------------------------------------------------
+# Obtain these libraries if requested
+# Option 2
+if (Teem_ZLIB)
+    # Find ZLIB
+    find_package(ZLIB)
+    if(ZLIB_FOUND)
+        add_definitions(-DTEEM_ZLIB)
+        set(Teem_ZLIB_LIB ${ZLIB_LIBRARIES})
+        set(Teem_ZLIB_IPATH ${ZLIB_INCLUDE_DIR})
+    else()
+        # We need to set this as a cache variable, so that it will show up as being turned off in the cache.
+        message("warning: Turning off Teem_ZLIB, because it wasn't found.")
+        set(Teem_ZLIB OFF CACHE BOOL "Build Teem with support for gzip compression." FORCE)
+    endif()
+endif()
+# Option 3
+if (Teem_PNG)
+    find_package(PNG)
+    if(PNG_FOUND)
+        add_definitions(-DTEEM_PNG ${PNG_DEFINITIONS})
+        set(Teem_PNG_LIB ${PNG_LIBRARIES})
+        set(Teem_PNG_IPATH ${PNG_INCLUDE_DIR})
+    else()
+        # We need to set this as a cache variable, so that it will show up as being turned off in the cache.
+        message("warning: Turning off Teem_PNG, because it wasn't found.")
+        set(Teem_PNG OFF CACHE BOOL "Build Teem with support for PNG images." FORCE)
+    endif()
+endif()
+# Option 4
+if(Teem_BZIP2)
+    find_package(BZ2)
+    if(BZ2_FOUND)
+        add_definitions(-DTEEM_BZIP2)
+        set(Teem_BZIP2_LIB ${BZ2_LIBRARIES})
+        set(Teem_BZIP2_IPATH ${BZ2_INCLUDE_DIR})
+    else()
+        # We need to set this as a cache variable, so that it will show up as being turned off in the cache.
+        message("warning: Turning off Teem_BZIP2, because it wasn't found.")
+        set(Teem_BZIP2 OFF CACHE BOOL "Build Teem with support for bzip compression." FORCE)
+    endif()
+endif()
+# Option 5
+if(Teem_PTHREAD)
+    include(FindThreads)
+    if(CMAKE_USE_PTHREADS_INIT)
+        add_definitions(-DTEEM_PTHREAD)
+    else()
+        # We need to set this as a cache variable, so that it will show up as being turned off in the cache.
+        message("warning: Turning off Teem_PTHREAD, because it wasn't found.")
+        set(Teem_PTHREAD OFF CACHE BOOL "Build Teem with pthread library support." FORCE)
+        set(Teem_PTHREAD OFF)
+    endif()
+endif()
+# Option 6
+if(Teem_LEVMAR)
+    find_package(LEVMAR)
+    if(LEVMAR_FOUND)
+        add_definitions(-DTEEM_LEVMAR)
+        set(Teem_LEVMAR_LIB ${LEVMAR_LIBRARIES})
+        set(Teem_LEVMAR_IPATH ${LEVMAR_INCLUDE_DIR})
+    else()
+        # We need to set this as a cache variable, so that it will show up as being turned off in the cache.
+        message("warning: Turning off Teem_LEVMAR, because it wasn't found.")
+        set(Teem_LEVMAR OFF CACHE BOOL "Build Teem with levmar library support." FORCE)
+    endif()
+endif()
+# Option 7
+if(Teem_FFTW3)
+    find_package(FFTW3)
+    if(FFTW3_FOUND)
+        add_definitions(-DTEEM_FFTW3)
+        set(Teem_FFTW3_LIB ${FFTW3_LIBRARIES})
+        set(Teem_FFTW3_IPATH ${FFTW3_INCLUDE_DIR})
+    else()
+        # We need to set this as a cache variable, so that it will show up as being turned off in the cache.
+        message("warning: Turning off Teem_FFTW3, because it wasn't found.")
+        set(Teem_FFTW3 OFF CACHE BOOL "Build Teem with fftw library support." FORCE)
+    endif()
+endif()
+# Option 8
+# DirectIO is the fast way to do multi-gigabyte I/O and currently only available for SGI platforms.
+if(USE_DIRECTIO)
+    add_definitions(-DTEEM_DIO=1)
+else()
+    add_definitions(-DTEEM_DIO=0)
+endif()
+# Option 9
+if(Teem_USE_LIB_INSTALL_SUBDIR)
+    set(EXTRA_INSTALL_PATH /Teem-${Teem_VERSION_STRING})
+else()
+    set(EXTRA_INSTALL_PATH "")
+endif()
+# Option 10 - Stand-alone programs to process hex encoding of data
+if(BUILD_HEX)
+    add_subdirectory(src/hex)
+endif()
+# Option 11 - For testing
+if(BUILD_TESTING)
+    include(CTest)
+    enable_testing()
+    set(BUILDNAME "${BUILDNAME}" CACHE STRING "Name of build on the dashboard")
+    mark_as_advanced(BUILDNAME)
+    mark_as_advanced(TCL_TCLSH)
+    add_subdirectory(Testing)
+endif()
+
+#-----------------------------------------------------------------------------
+# For Visual Studio we don't care about warnings about deprecated sprintf and the like.
+if(${CMAKE_GENERATOR} MATCHES "Visual Studio")
+    add_definitions(-D_CRT_SECURE_NO_DEPRECATE -D_CRT_NONSTDC_NO_DEPRECATE)
+endif()
+
+set(BUILD_EXPERIMENTAL_LIBS OFF CACHE BOOL "Build Teem's experimental libraries")
+set(BUILD_EXPERIMENTAL_APPS OFF CACHE BOOL "Build Teem's non-essential command-line tools")
+
+# If its a Dashboard build; turn ON both BUILD_EXPERIMENTAL_APPS and BUILD_EXPERIMENTAL_LIBS
+if(NOT "$ENV{DASHBOARD_TEST_FROM_CTEST}" STREQUAL "")
+    # it is a dashboard build
+    set(BUILD_EXPERIMENTAL_APPS ON)
+    set(BUILD_EXPERIMENTAL_LIBS ON)
+endif()
+
+# set the Teem library as a list
+set(Teem_LIBRARIES "air" "hest" "biff" "nrrd" "ell" "unrrdu" "moss" "gage" "dye" "limn" "echo" "hoover" "seek" "ten" "pull" "mite" "meet")
+if(BUILD_EXPERIMENTAL_LIBS)
+    # This list of the "experimental" libraries must be kept in sync with:
+    # * definition of Teem_HEADER_FILES (below)
+    # * teem/src/meet/meet.h
+    # * teem/src/meet/enumsall.c
+    # re-setting list so libraries appear in expected order
+    list(APPEND Teem_LIBRARIES "alan" "tijk" "bane" "elf" "coil" "push")
+    add_definitions(-DTEEM_BUILD_EXPERIMENTAL_LIBS)
+endif()
+
+if(BUILD_EXPERIMENTAL_APPS)
+    add_definitions(-DTEEM_BUILD_EXPERIMENTAL_APPS)
+endif()
+
+# set the Teem headers as a list
+set(Teem_HEADER_FILES
+    "air/air.h"
+    "hest/hest.h"
+    "biff/biff.h"
+    "nrrd/nrrd.h"   "nrrd/nrrdDefines.h"   "nrrd/nrrdMacros.h"  "nrrd/nrrdEnums.h"
+    "ell/ell.h"     "ell/ellMacros.h"
+    "unrrdu/unrrdu.h"
+    "moss/moss.h"
+    "gage/gage.h"
+    "dye/dye.h"
+    "limn/limn.h"
+    "echo/echo.h"
+    "hoover/hoover.h"
+    "seek/seek.h"
+    "ten/ten.h"     "ten/tenMacros.h"
+    "pull/pull.h"
+    "mite/mite.h"
+    "meet/meet.h")
+
+if(BUILD_EXPERIMENTAL_LIBS)
+    list(APPEND Teem_HEADER_FILES
+        "alan/alan.h"
+        "tijk/tijk.h"
+        "bane/bane.h"
+        "elf/elf.h"
+        "coil/coil.h"
+        "push/push.h")
+endif()
+
+set(Teem_INSTALLED_HEADER_FILES)
+foreach(header_file IN LISTS Teem_HEADER_FILES)
+    # When debugging, uncomment this line
+    # message(STATUS "Copy header file: ${header_file}")
+    get_filename_component(file_no_path "${header_file}" NAME)
+    configure_file("${CMAKE_CURRENT_SOURCE_DIR}/src/${header_file}"
+                    "${CMAKE_CURRENT_BINARY_DIR}/include/teem/${file_no_path}" COPYONLY IMMEDIATE)
+    list(APPEND Teem_INSTALLED_HEADER_FILES "${CMAKE_CURRENT_BINARY_DIR}/include/teem/${file_no_path}")
+endforeach()
+
+#-----------------------------------------------------------------------------
+# header that defines AIR_EXISTS_MACRO_FAILS
+configure_file(${CMAKE_CURRENT_SOURCE_DIR}/CMake/airExistsConf.h
+                ${CMAKE_CURRENT_BINARY_DIR}/include/teem/airExistsConf.h)
+list(APPEND Teem_INSTALLED_HEADER_FILES "${CMAKE_CURRENT_BINARY_DIR}/include/teem/airExistsConf.h")
 
 #-----------------------------------------------------------------------------
 # Build the Mega library
-#
-# This needs to occur after the parsing of the subdirectories.
-
-# Create the library target
-ADD_LIBRARY(teem ${Teem_SOURCES})
+add_library(teem "")
+foreach(dir IN LISTS Teem_LIBRARIES)
+    add_subdirectory(src/${dir})
+endforeach()
 
+#-----------------------------------------------------------------------------
 # Set up some library paths for installation.  Windows will ingore the
 # RPATH stuff, and mac will ingore the INSTALL_RPATH.  Make sure for
 # macs to set BUILD_WITH_INSTALL_RPATH OFF and set INSTALL_NAME_DIR.
 # I belive INSTALL_NAME_DIR will be ignored on linux.
-SET_TARGET_PROPERTIES(teem PROPERTIES
-  BUILD_WITH_INSTALL_RPATH OFF
-  INSTALL_RPATH ${CMAKE_INSTALL_PREFIX}/lib
-  INSTALL_NAME_DIR ${CMAKE_INSTALL_PREFIX}/lib
-  SOVERSION 1
-  VERSION ${Teem_VERSION_STRING}
-  )
-
-IF(Teem_BZIP2_LIB)
-  TARGET_LINK_LIBRARIES(teem ${Teem_BZIP2_LIB})
-ENDIF(Teem_BZIP2_LIB)
-IF(Teem_ZLIB_LIB)
-  TARGET_LINK_LIBRARIES(teem ${Teem_ZLIB_LIB})
-  IF(Teem_PNG_LIB)
-    TARGET_LINK_LIBRARIES(teem ${Teem_PNG_LIB})
-  ENDIF(Teem_PNG_LIB)
-ENDIF(Teem_ZLIB_LIB)
-
-IF(Teem_LEVMAR_LIB)
-  TARGET_LINK_LIBRARIES(teem ${Teem_LEVMAR_LIB})
-ENDIF(Teem_LEVMAR_LIB)
-
-IF(Teem_FFTW3_LIB)
-  TARGET_LINK_LIBRARIES(teem ${Teem_FFTW3_LIB})
-ENDIF(Teem_FFTW3_LIB)
-
-IF(Teem_PTHREAD)
-  TARGET_LINK_LIBRARIES(teem ${CMAKE_THREAD_LIBS_INIT})
-ENDIF(Teem_PTHREAD)
-
-IF(UNIX)
-  TARGET_LINK_LIBRARIES(teem -lm)
-ENDIF(UNIX)
-
-OPTION(Teem_USE_LIB_INSTALL_SUBDIR "Add a Teem-X.Y.Z directory layer to the installation tree for libraries and archives." OFF)
-IF(Teem_USE_LIB_INSTALL_SUBDIR)
-  SET(EXTRA_INSTALL_PATH /Teem-${Teem_VERSION_STRING})
-ELSE(Teem_USE_LIB_INSTALL_SUBDIR)
-  SET(EXTRA_INSTALL_PATH "")
-ENDIF(Teem_USE_LIB_INSTALL_SUBDIR)
-
-INSTALL(TARGETS teem
-  RUNTIME DESTINATION bin
-  LIBRARY DESTINATION lib${EXTRA_INSTALL_PATH}
-  ARCHIVE DESTINATION lib${EXTRA_INSTALL_PATH}
-  ) 
-
-# Stand-alone programs to process hex encoding of data
-OPTION(BUILD_HEX "Build dehex and enhex" OFF)
-IF(BUILD_HEX)
-  ADD_SUBDIRECTORY(src/hex)
-ENDIF(BUILD_HEX)
-
-#-----------------------------------------------------------------------------
-# For testing
-OPTION(BUILD_TESTING "Enable this to perform testing of Teem" ON)
-
-IF(BUILD_TESTING)
-  INCLUDE(CTest)
-  ENABLE_TESTING()
-  SET(BUILDNAME "${BUILDNAME}" CACHE STRING "Name of build on the dashboard")
-  MARK_AS_ADVANCED(BUILDNAME)
-  MARK_AS_ADVANCED(TCL_TCLSH)
-ENDIF(BUILD_TESTING)
+set_target_properties(teem PROPERTIES
+                      BUILD_WITH_INSTALL_RPATH OFF
+                      INSTALL_RPATH ${CMAKE_INSTALL_PREFIX}/lib
+                      INSTALL_NAME_DIR ${CMAKE_INSTALL_PREFIX}/lib
+                      SOVERSION 1
+                      VERSION ${Teem_VERSION_STRING})
+
+if(Teem_ZLIB_LIB)
+    target_include_directories(teem PUBLIC ${Teem_ZLIB_IPATH})
+    target_include_directories(teem PUBLIC ${Teem_ZLIB_DLLCONF_IPATH})
+    target_link_libraries(teem ${Teem_ZLIB_LIB})
+endif()
+if(Teem_PNG_LIB)
+    target_include_directories(teem PUBLIC ${Teem_PNG_IPATH})
+    target_include_directories(teem PUBLIC ${Teem_PNG_DLLCONF_IPATH})
+    target_link_libraries(teem ${Teem_PNG_LIB})
+endif()
+if(Teem_BZIP2_LIB)
+    target_include_directories(teem PUBLIC ${Teem_BZIP2_IPATH})
+    target_include_directories(teem PUBLIC ${Teem_BZIP2_DLLCONF_IPATH})
+    target_link_libraries(teem ${Teem_BZIP2_LIB})
+endif()
+if(Teem_LEVMAR_LIB)
+    target_include_directories(teem PUBLIC ${Teem_LEVMAR_IPATH})
+    target_include_directories(teem PUBLIC ${Teem_LEVMAR_DLLCONF_IPATH})
+    target_link_libraries(teem ${Teem_LEVMAR_LIB})
+endif()
+if(Teem_FFTW3_LIB)
+    target_include_directories(teem PUBLIC ${Teem_FFTW3_IPATH})
+    target_include_directories(teem PUBLIC ${Teem_FFTW3_DLLCONF_IPATH})
+    target_link_libraries(teem ${Teem_FFTW3_LIB})
+endif()
+if(Teem_PTHREAD)
+    target_link_libraries(teem ${CMAKE_THREAD_LIBS_INIT})
+endif()
+if(UNIX)
+    target_link_libraries(teem -lm)
+endif()
+
+# install targets
+install(TARGETS teem EXPORT teem
+        RUNTIME DESTINATION bin COMPONENT RuntimeLibraries
+        LIBRARY DESTINATION lib${EXTRA_INSTALL_PATH} COMPONENT RuntimeLibraries
+        ARCHIVE DESTINATION lib${EXTRA_INSTALL_PATH} COMPONENT Development)
+
+export(TARGETS teem FILE ${Teem_BINARY_DIR}/TeemLibraryDepends.cmake)
 
 #-----------------------------------------------------------------------------
 # Now compile the binaries
-ADD_SUBDIRECTORY(src/bin)
-
-IF(BUILD_TESTING)
-  ADD_SUBDIRECTORY(Testing)
-ENDIF(BUILD_TESTING)
+add_subdirectory(src/bin)
 
 #-----------------------------------------------------------------------------
-# Help outside projects build Teem projects.
-INCLUDE(CMakeExportBuildSettings)
-EXPORT_LIBRARY_DEPENDENCIES(${Teem_BINARY_DIR}/TeemLibraryDepends.cmake)
-CMAKE_EXPORT_BUILD_SETTINGS(${Teem_BINARY_DIR}/TeemBuildSettings.cmake)
-
-SET(CFLAGS "${CMAKE_C_FLAGS}")
-SET(CC "${CMAKE_C_COMPILER}")
+set(CFLAGS "${CMAKE_C_FLAGS}")
+set(CC "${CMAKE_C_COMPILER}")
 
-SET(Teem_EXECUTABLE_DIRS ${EXECUTABLE_OUTPUT_PATH} CACHE INTERNAL "Single output directory for building all executables.")
+set(Teem_EXECUTABLE_DIRS ${__RUNTIME_OUTPUT_PATH_} CACHE INTERNAL "Single output directory for building all executables.")
 
 
 # Teem_CV_ prefixed variables are only used inside TeemConfig.cmake.in for
@@ -466,52 +412,53 @@
 
 # In the build tree, TeemConfig.cmake is in Teem_BINARY_DIR. The root of the
 # tree for finding include files relative to TeemConfig.cmake is "."
-# 
-SET(Teem_CV_CONFIG_TO_ROOT ".")
-SET(Teem_CV_LIBRARY_DEPENDS_FILE ${Teem_BINARY_DIR}/TeemLibraryDepends.cmake)
-SET(Teem_CV_EXECUTABLE_DIRS ${Teem_EXECUTABLE_DIRS})
-SET(Teem_CV_LIBRARY_DIRS ${LIBRARY_OUTPUT_PATH})
-SET(Teem_CV_USE_FILE ${Teem_SOURCE_DIR}/CMake/TeemUse.cmake)
-SET(Teem_CV_INCLUDE_DIRS "${Teem_BINARY_DIR}/include")
-SET(Teem_CV_BUILD_SETTINGS_FILE ${Teem_BINARY_DIR}/TeemBuildSettings.cmake)
-SET(Teem_CV_BUILT_LIBRARIES teem) # The libraries built by teem.  Currently we only build the mega library.
+set(Teem_CV_CONFIG_TO_ROOT ".")
+set(Teem_CV_BUILD_SETTINGS_FILE ${Teem_BINARY_DIR}/TeemBuildSettings.cmake)
+set(Teem_CV_LIBRARY_DEPENDS_FILE ${Teem_BINARY_DIR}/TeemLibraryDepends.cmake)
+set(Teem_CV_EXECUTABLE_DIRS ${Teem_EXECUTABLE_DIRS})
+set(Teem_CV_LIBRARY_DIRS ${__LIBRARY_OUTPUT_PATH__})
+set(Teem_CV_USE_FILE ${Teem_SOURCE_DIR}/CMake/TeemUse.cmake)
+set(Teem_CV_INCLUDE_DIRS "${Teem_BINARY_DIR}/include")
+set(Teem_CV_BUILT_LIBRARIES teem) # The libraries built by teem.  Currently we only build the mega library.
 
-CONFIGURE_FILE("${Teem_SOURCE_DIR}/CMake/TeemConfig.cmake.in"
-  "${Teem_BINARY_DIR}/TeemConfig.cmake" @ONLY IMMEDIATE)
+configure_file("${Teem_SOURCE_DIR}/CMake/TeemConfig.cmake.in"
+                "${Teem_BINARY_DIR}/TeemConfig.cmake" @ONLY IMMEDIATE)
 
 
 # For install tree usage
 
-# In the install tree, TeemConfig.cmake is in lib or lib/Teem-X.Y based on the
+# In the install tree, TeemConfig.cmake is in lib/cmake/teem or lib/Teem-X.Y/cmake/teem based on the
 # value of Teem_USE_LIB_INSTALL_SUBDIR. The root of the tree for finding
-# include files relative to TeemConfig.cmake is therefore ".." or "../.."
-# 
-IF(Teem_USE_LIB_INSTALL_SUBDIR)
-  SET(Teem_CV_CONFIG_TO_ROOT "../..")
-ELSE(Teem_USE_LIB_INSTALL_SUBDIR)
-  SET(Teem_CV_CONFIG_TO_ROOT "..")
-ENDIF(Teem_USE_LIB_INSTALL_SUBDIR)
-
-SET(Teem_CV_LIBRARY_DEPENDS_FILE "\${Teem_ROOT_DIR}/lib${EXTRA_INSTALL_PATH}/TeemLibraryDepends.cmake")
-SET(Teem_CV_EXECUTABLE_DIRS "\${Teem_ROOT_DIR}/bin")
-SET(Teem_CV_LIBRARY_DIRS "\${Teem_ROOT_DIR}/lib${EXTRA_INSTALL_PATH}")
-SET(Teem_CV_USE_FILE "\${Teem_ROOT_DIR}/lib${EXTRA_INSTALL_PATH}/TeemUse.cmake")
-SET(Teem_CV_INCLUDE_DIRS "\${Teem_ROOT_DIR}/include")
-SET(Teem_CV_BUILD_SETTINGS_FILE "\${Teem_ROOT_DIR}/lib${EXTRA_INSTALL_PATH}/TeemBuildSettings.cmake")
-SET(Teem_CV_BUILT_LIBRARIES teem) # The libraries built by teem.  Currently we only build the mega library.
-
-CONFIGURE_FILE("${Teem_SOURCE_DIR}/CMake/TeemConfig.cmake.in"
-  "${Teem_BINARY_DIR}/CMake/TeemConfig.cmake" @ONLY IMMEDIATE)
-
-
-INSTALL(FILES ${Teem_INSTALLED_HEADER_FILES}
-  DESTINATION include/teem
-  )
-
-INSTALL(FILES
-  "${Teem_BINARY_DIR}/CMake/TeemConfig.cmake"
-  "${Teem_SOURCE_DIR}/CMake/TeemUse.cmake"
-  "${Teem_BINARY_DIR}/TeemBuildSettings.cmake"
-  "${Teem_BINARY_DIR}/TeemLibraryDepends.cmake"
-  DESTINATION lib${EXTRA_INSTALL_PATH}
-  )
+# include files relative to TeemConfig.cmake is therefore "../../../.." or "../../.."
+if(Teem_USE_LIB_INSTALL_SUBDIR)
+    set(Teem_CV_CONFIG_TO_ROOT "../../../..")
+else()
+    set(Teem_CV_CONFIG_TO_ROOT "../../..")
+endif()
+
+set(Teem_CV_LIBRARY_DEPENDS_FILE "\${Teem_ROOT_DIR}/lib${EXTRA_INSTALL_PATH}/cmake/teem/TeemLibraryDepends.cmake")
+set(Teem_CV_EXECUTABLE_DIRS "\${Teem_ROOT_DIR}/bin")
+set(Teem_CV_LIBRARY_DIRS "\${Teem_ROOT_DIR}/lib${EXTRA_INSTALL_PATH}")
+set(Teem_CV_USE_FILE "\${Teem_ROOT_DIR}/lib${EXTRA_INSTALL_PATH}/TeemUse.cmake")
+set(Teem_CV_INCLUDE_DIRS "\${Teem_ROOT_DIR}/include")
+set(Teem_CV_BUILT_LIBRARIES teem) # single library containing all teem "libraries"
+
+configure_file("${Teem_SOURCE_DIR}/CMake/TeemConfig.cmake.in"
+                "${Teem_BINARY_DIR}/CMake/TeemConfig.cmake" @ONLY IMMEDIATE)
+
+# install headers
+install(FILES ${Teem_INSTALLED_HEADER_FILES}
+        DESTINATION include/teem
+        COMPONENT Development)
+
+# make install and cpack
+# ${Teem_BINARY_DIR} is the build directory like /Teem-build
+set(Teem_CV_BUILD_SETTINGS_FILE "\${Teem_ROOT_DIR}/lib${EXTRA_INSTALL_PATH}/cmake/teem/TeemBuildSettings.cmake")
+file(WRITE ${Teem_BINARY_DIR}/TeemBuildSettings.cmake)
+install(EXPORT teem DESTINATION lib${EXTRA_INSTALL_PATH}/cmake/teem FILE TeemLibraryDepends.cmake)
+install(FILES
+        "${Teem_BINARY_DIR}/CMake/TeemConfig.cmake"
+        "${Teem_SOURCE_DIR}/CMake/TeemUse.cmake"
+        "${Teem_BINARY_DIR}/TeemBuildSettings.cmake"
+        DESTINATION lib${EXTRA_INSTALL_PATH}/cmake/teem
+        COMPONENT Development)
diff --color -ruN teem-1.11.0-src.orig/CTestConfig.cmake teem-1.11.0-src/CTestConfig.cmake
--- teem-1.11.0-src.orig/CTestConfig.cmake	2012-12-20 22:12:22.000000000 +0800
+++ teem-1.11.0-src/CTestConfig.cmake	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
-# Teem: Tools to process and visualize scientific data and images   
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Teem: Tools to process and visualize scientific data and images
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -25,8 +25,8 @@
 ## Then modify the CMakeLists.txt file in the root directory of your
 ## project to incorporate the testing dashboard.
 ## # The following are required to uses Dart and the Cdash dashboard
-##   ENABLE_TESTING()
-##   INCLUDE(Dart)
+##   enable_testing()
+##   include(Dart)
 set(CTEST_PROJECT_NAME "Teem")
 set(CTEST_NIGHTLY_START_TIME "05:00:00 UTC")
 
diff --color -ruN teem-1.11.0-src.orig/DartConfig.cmake teem-1.11.0-src/DartConfig.cmake
--- teem-1.11.0-src.orig/DartConfig.cmake	2012-12-20 22:12:22.000000000 +0800
+++ teem-1.11.0-src/DartConfig.cmake	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
-# Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Teem: Tools to process and visualize scientific data and images
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -21,10 +21,10 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-INCLUDE(${CMAKE_SOURCE_DIR}/CTestConfig.cmake)
-SET(NIGHTLY_START_TIME "${CTEST_NIGHTLY_START_TIME}")
-SET(DROP_METHOD "${CTEST_DROP_METHOD}")
-SET(DROP_SITE "${CTEST_DROP_SITE}")
-SET(DROP_LOCATION "${CTEST_DROP_LOCATION}")
-SET(TRIGGER_SITE "${CTEST_TRIGGER_SITE}")
+include(${CMAKE_SOURCE_DIR}/CTestConfig.cmake)
+set(NIGHTLY_START_TIME "${CTEST_NIGHTLY_START_TIME}")
+set(DROP_METHOD "${CTEST_DROP_METHOD}")
+set(DROP_SITE "${CTEST_DROP_SITE}")
+set(DROP_LOCATION "${CTEST_DROP_LOCATION}")
+set(TRIGGER_SITE "${CTEST_TRIGGER_SITE}")
 
Binary files teem-1.11.0-src.orig/data/test/trandhisto.nrrd and teem-1.11.0-src/data/test/trandhisto.nrrd differ
Binary files teem-1.11.0-src.orig/data/test/trandhisto.pgm and teem-1.11.0-src/data/test/trandhisto.pgm differ
Binary files teem-1.11.0-src.orig/data/test/trandvals.nrrd and teem-1.11.0-src/data/test/trandvals.nrrd differ
diff --color -ruN teem-1.11.0-src.orig/Examples/sanity/CMakeLists.txt teem-1.11.0-src/Examples/sanity/CMakeLists.txt
--- teem-1.11.0-src.orig/Examples/sanity/CMakeLists.txt	2012-12-20 22:12:22.000000000 +0800
+++ teem-1.11.0-src/Examples/sanity/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,10 +1,10 @@
 project (TeemSampleProject)
 
-cmake_minimum_required(VERSION 2.4)
+cmake_minimum_required(VERSION 2.8)
 
 if(COMMAND cmake_policy)
   cmake_policy(SET CMP0003 NEW)
-endif(COMMAND cmake_policy)
+endif()
 
 find_package(Teem REQUIRED)
 include(${Teem_USE_FILE})
diff --color -ruN teem-1.11.0-src.orig/Examples/sanity/sanity.c teem-1.11.0-src/Examples/sanity/sanity.c
--- teem-1.11.0-src.orig/Examples/sanity/sanity.c	2012-12-20 22:12:22.000000000 +0800
+++ teem-1.11.0-src/Examples/sanity/sanity.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,22 +1,22 @@
 /*
 ** Copyright (C) 2009, University of Chicago
 ** All rights reserved.
-** 
+**
 ** Redistribution and use in source and binary forms, with or without
 ** modification, are permitted provided that the following conditions are
 ** met:
-** 
+**
 ** Redistributions of source code must retain the above copyright
 ** notice, this list of conditions and the following disclaimer.
-** 
+**
 ** Redistributions in binary form must reproduce the above copyright
 ** notice, this list of conditions and the following disclaimer in the
 ** documentation and/or other materials provided with the distribution.
-** 
+**
 ** Neither the name of the University of Chicago nor the names of its
 ** contributors may be used to endorse or promote products derived from
 ** this software without specific prior written permission.
-** 
+**
 ** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 ** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 ** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
diff --color -ruN teem-1.11.0-src.orig/include/teemDio.h teem-1.11.0-src/include/teemDio.h
--- teem-1.11.0-src.orig/include/teemDio.h	2012-12-20 22:07:16.000000000 +0800
+++ teem-1.11.0-src/include/teemDio.h	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
-  Teem: Tools to process and visualize scientific data and images              
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Teem: Tools to process and visualize scientific data and images
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/include/teemPng.h teem-1.11.0-src/include/teemPng.h
--- teem-1.11.0-src.orig/include/teemPng.h	2012-12-20 22:07:16.000000000 +0800
+++ teem-1.11.0-src/include/teemPng.h	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
-  Teem: Tools to process and visualize scientific data and images              
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Teem: Tools to process and visualize scientific data and images
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -30,7 +30,7 @@
 
 #ifdef TEEM_PNG
 #  ifndef TEEM_ZLIB
-#    error TEEM_PNG set, but TEEM_ZLIB not set 
+#    error TEEM_PNG set, but TEEM_ZLIB not set
 #  endif
 #endif
 
diff --color -ruN teem-1.11.0-src.orig/include/teemQnanhibit.h teem-1.11.0-src/include/teemQnanhibit.h
--- teem-1.11.0-src.orig/include/teemQnanhibit.h	2012-12-20 22:07:16.000000000 +0800
+++ teem-1.11.0-src/include/teemQnanhibit.h	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
-  Teem: Tools to process and visualize scientific data and images              
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Teem: Tools to process and visualize scientific data and images
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/LICENSE.txt teem-1.11.0-src/LICENSE.txt
--- teem-1.11.0-src.orig/LICENSE.txt	2012-12-20 22:12:22.000000000 +0800
+++ teem-1.11.0-src/LICENSE.txt	2021-02-18 15:42:38.000000000 +0800
@@ -209,7 +209,7 @@
 on the Library (independent of the use of the Library in a tool for
 writing it).  Whether that is true depends on what the Library does
 and what the program that uses the Library does.
-  
+
   1. You may copy and distribute verbatim copies of the Library's
 complete source code as you receive it, in any medium, provided that
 you conspicuously and appropriately publish on each copy an
diff --color -ruN teem-1.11.0-src.orig/python/ctypes/gen-teem.py teem-1.11.0-src/python/ctypes/gen-teem.py
--- teem-1.11.0-src.orig/python/ctypes/gen-teem.py	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/python/ctypes/gen-teem.py	2021-02-18 15:42:39.000000000 +0800
@@ -0,0 +1,405 @@
+#! /usr/bin/env python
+
+##
+##  gen-teem.py: automatically-generated ctypes python wrappers for Teem
+##  Copyright (C) 2013, 2012, 2011 University of Chicago
+##  (originally created by Sam Quinan - samquinan@cs.uchicago.edu)
+##
+##  Permission is hereby granted, free of charge, to any person obtaining
+##  a copy of this software and associated documentation files (the
+##  "Software"), to deal in the Software without restriction, including
+##  without limitation the rights to use, copy, modify, merge, publish,
+##  distribute, sublicense, and/or sell copies of the Software, and to
+##  permit persons to whom the Software is furnished to do so, subject to
+##  the following conditions:
+##
+##  The above copyright notice and this permission notice shall be
+##  included in all copies or substantial portions of the Software.
+##
+##  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+##  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+##  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+##  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+##  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+##  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+##  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+##
+
+##
+## for posterity; this records the contents of the sourceme-ctypeslib.txt
+## file that this script automates ...
+oldtodo="""
+echo === These are commands that GLK used to create teem.py, in tcsh
+echo === Obviously, anyone is welcome to make this into a proper python script
+echo === or otherwise make it more robust and portable, especially the stuff
+echo === that removes the install path specifics from teem.py
+echo ===
+echo === You will need a recent gccxml to make this work.
+
+svn co http://svn.python.org/projects/ctypes/branches/ctypeslib-gccxml-0.9
+setenv CTYPES `pwd`/ctypeslib-gccxml-0.9
+setenv PYTHONPATH ${CTYPES}:`pwd`
+
+echo === A patch is still needed, hopefully this can be fixed
+patch -p0 -i ctypes-codegen.patch
+
+echo === TEEM has to be set to wherever CMake put its make install
+setenv TEEM /Users/gk/teem-install
+
+echo === all.h just includes all the other public top-level .h in Teem
+rm -rf teemincl
+mkdir teemincl
+cp -r ${TEEM}/include/teem teemincl
+cd teemincl
+ls -1 teem/*.h | awk '{print "#include <"$1">"}' > all.h
+cd ..
+
+echo === teem.xml represents the Teem API
+python ${CTYPES}/scripts/h2xml.py `pwd`/teemincl/all.h -I teemincl -o teem.xml
+
+echo === DYLD_LIBRARY_PATH is obviously Mac specific, please fix
+setenv DYLD_LIBRARY_PATH ${TEEM}/lib
+python ${CTYPES}/scripts/xml2py.py teem.xml -llibteem.dylib -o pre-teem.py -m stdio \
+        -r "(air|hest|biff|nrrd|ell|unrrdu|alan|moss|tijk|gage|dye|bane|limn|echo|hoover|seek|ten|elf|pull|coil|push|mite|meet).*"
+rm -rf teemincl
+
+
+echo === At this point GLK does emacs stuff to make pre-teem.py into what is
+echo === the currently svn committed teem.py
+echo === Obviously, this really needs to be automated...
+"""
+# and now it has been automated!
+
+import os, sys, shutil, platform, re, string
+
+if len(sys.argv) != 3:
+    sys.exit("usage: gen-teem.py <ctypeslib-gccxml source dir> <teem install dir>")
+
+## (TEEM_LIB_LIST)
+libs_list = ["air", "hest", "biff", "nrrd", "ell", "unrrdu", "alan", "moss", "tijk", "gage", "dye", "bane", "limn", "echo", "hoover", "seek", "ten", "elf", "pull", "coil", "push", "mite", "meet"]
+
+#
+# validate os
+#
+if os.name != "posix":
+    sys.exit("program only supports posix compilant systems at this time")
+
+#
+# validate gccxml install
+#
+tmp = os.path.join(os.getcwd(), "tmp")
+os.system("gccxml --version &> tmp")
+file = open(tmp, "r")
+file.seek(0)
+first_line = file.readline()
+file.close()
+if not first_line.startswith("GCC-XML version"):
+    os.remove(tmp)
+    sys.exit("error: gccxml of version >= 0.9.0 is required for this script")
+
+if not ((int(first_line[16]) > 0) or ((int(first_line[18]) == 9) and (int(first_line[20]) >= 0))):
+    os.remove(tmp)
+    sys.exit("error: gccxml of version >= 0.9.0 is required for this script")
+os.remove(tmp)
+
+#
+# validate ctypeslib-gccxml source dir path
+#
+if not os.path.isdir(sys.argv[1]):
+    sys.exit("%s does not point to a directory" % sys.argv[1])
+
+CTYPES = os.path.abspath(sys.argv[1])
+#
+# NOTE, however, that this really assumes a PATCHED ctypeslib-gccxml,
+# via a procedure like:
+# svn co http://svn.python.org/projects/ctypes/branches/ctypeslib-gccxml-0.9
+# patch -p0 -i ctypes-codegen.patch
+
+#
+# validate teem install dir path
+#
+if not os.path.isdir(sys.argv[2]):
+    sys.exit("%s does not point to a directory" % sys.argv[2])
+
+TEEM = os.path.abspath(sys.argv[2])
+
+
+#
+# copy files from install dir
+#
+
+TMP_DIR = "gen-teem-tmp"
+
+teem_include = os.path.join(TEEM, "include")
+
+if not os.path.isdir(teem_include):
+    sys.exit("%s is not the teem install directory; %s is not a valid path" % (teem, teem-install))
+
+if os.path.isdir(TMP_DIR):
+    shutil.rmtree(TMP_DIR)
+
+shutil.copytree(teem_include, TMP_DIR)
+
+
+#
+# generate all.h
+#
+
+all_h = os.path.join(TMP_DIR, "all.h")
+f_open = open (all_h, "w")
+
+defines = []
+
+Files = os.listdir(os.path.join(TMP_DIR, "teem"))
+for file in Files:
+    if file.endswith(".h"):
+        f_open.write("#include <teem/%s> %s" % (file, os.linesep))
+        #
+        # get #define statements from file
+        #
+        lines = open (os.path.join(TMP_DIR, "teem", file), "r").readlines()
+        expr1 = re.compile("^#define")
+        expr2 = re.compile("\\\\")
+        expr3 = re.compile("HAS_BEEN_INCLUDED")
+        expr4 = re.compile("##")
+        expr5 = re.compile("^#define [^ ]*\(")
+        expr6 = re.compile("NRRD_TYPE_BIGGEST")
+        # this strips out NRRD_LLONG_MAX, NRRD_LLONG_MIN, and NRRD_ULLONG_MAX,
+        # which depend on macros AIR_LLONG and AIR_LLONG.  For some reason
+        # this causes a problem now (Thu Jun 14 11:49:14 CDT 2012) even though
+        # they haven't before, though these constants and macros are not new
+        expr7 = re.compile("LLONG")
+        for line in lines:
+            if (expr1.search(line) and not expr2.search(line)
+                and not expr3.search(line) and not expr4.search(line)
+                and not expr5.search(line) and not expr6.search(line)
+                and not expr7.search(line)):
+                firstword, restwords = string.replace(string.replace(line[8:], "/*", "#" ), "*/", "").split(None,1)
+                defines.append("%s = %s" % (firstword, restwords))
+f_open.close()
+
+#
+# generate teem.xml
+#
+# note: these calls are unix only because windows support for command line
+#	append to python path (where the scopeis only that one call) is too
+#	difficult at this time -- better support may be added to later versions
+#	of python, so that something to watch for / modify in the future
+
+pypath_append = "PYTHONPATH=%s:%s" % (CTYPES, os.getcwd())
+teem_xml = os.path.join(os.getcwd(), "teem.xml")
+os.system("%s python %s %s -I %s -o %s" % (pypath_append, os.path.join(CTYPES, "scripts", "h2xml.py"), os.path.abspath(all_h), TMP_DIR, teem_xml))
+
+
+#
+# generate pre-teem.py
+#
+pre_teem_py = os.path.join(os.getcwd(), "pre-teem.py")
+
+teem_libs = '|'.join(libs_list)
+
+system_type = platform.system()
+dll_path = ""
+ext = ""
+substr = ""
+if system_type == "Darwin":
+    dll_path = "DYLD_LIBRARY_PATH=%s" % os.path.join(TEEM, "lib")
+    ext = "dylib"
+    substr = "_libraries['%s']" % os.path.join(TEEM, "lib", "libteem.dylib")
+else:
+    dll_path = "LD_LIBRARY_PATH=%s" % os.path.join(TEEM, "lib")
+    ext = "so"
+    substr = "_libraries['libteem.so']"
+
+os.system("%s %s python %s %s -l libteem.%s -o %s -m stdio -r \"(%s).*\"" % (dll_path, pypath_append, os.path.join(CTYPES, "scripts", "xml2py.py"), teem_xml, ext,  pre_teem_py, teem_libs))
+
+#
+# generate teem.py
+#
+
+libs_destuctable = list(libs_list)
+
+contents = open(pre_teem_py, "r").readlines()[8:]
+mod_contents = []
+for line in contents:
+    l = line.replace(substr, "libteem")
+    if not (("__darwin_size_t = c_ulong" in l) or ("size_t = __darwin_size_t" in l)):
+        l2 = l.replace("\'__darwin_size_t\',", "") #designed to remove defs from long list at end
+        l3 = l2.replace("\'size_t\',", "") #designed to remove defs from long list at end
+        l = l3
+        if not re.compile("_size_t").search(l3):
+            if not re.match("#", l3): # i.e. do not make changes in commented lines
+                l = l3.replace("size_t", "c_size_t")
+        mod_contents.append(l)
+        if "Present" in l:
+            for lib in libs_destuctable:
+                lib_str = lib+"Present"
+                if lib_str in l:
+                    libs_destuctable.remove(lib)
+                    break
+
+# in experimental libs not included, cleanup and fail
+if libs_destuctable: # empty sequence implicity false
+    shutil.rmtree(TMP_DIR)
+    os.remove(teem_xml)
+    #os.remove(pre_teem_py)
+    sys.exit("ERROR: experimental libs: %s not turned on - please rebuild teem with BUILD_EXPERIMENTAL_LIBS turned on, then re-run gen-teem.py" % ','.join(libs_destuctable))
+
+header = [
+"##",
+"##  teem.py: automatically-generated ctypes python wrappers for Teem",
+"##  Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago",
+"##",
+"##  Permission is hereby granted, free of charge, to any person obtaining",
+"##  a copy of this software and associated documentation files (the",
+"##  \"Software\"), to deal in the Software without restriction, including",
+"##  without limitation the rights to use, copy, modify, merge, publish,",
+"##  distribute, sublicense, and/or sell copies of the Software, and to",
+"##  permit persons to whom the Software is furnished to do so, subject to",
+"##  the following conditions:",
+"##",
+"##  The above copyright notice and this permission notice shall be",
+"##  included in all copies or substantial portions of the Software.",
+"##",
+"##  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,",
+"##  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF",
+"##  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND",
+"##  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE",
+"##  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION",
+"##  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION",
+"##  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
+"##",
+"##############################################################",
+"##############################################################",
+"#### NOTE: This teem.py file is automatically produced by",
+"#### teem/python/ctypes/gen-teem.py.  Necessary changes to ",
+"#### teem.py should be made in gen-teem.py, not here.",
+"##############################################################",
+"##############################################################",
+"",
+"from ctypes import *",
+"import ctypes.util",
+"import sys, os",
+"",
+"def load_library(libname, loader_path=\"\"):",
+"    ext = os.path.splitext(libname)[1]",
+"    if not ext:",
+"        # Try to load library with platform-specific name",
+"        if sys.platform == 'win32':",
+"            libname_ext = '%s.dll' % libname",
+"        elif sys.platform == 'darwin':",
+"            libname_ext = '%s.dylib' % libname",
+"        elif sys.platform == 'linux2':",
+"            libname_ext = '%s.so' % libname",
+"    else:"
+"        libname_ext = libname",
+"",
+"    if (loader_path != \"\"):",
+"        loader_path = os.path.abspath(loader_path)",
+"        if not os.path.isdir(loader_path):",
+"            libdir = os.path.dirname(loader_path)",
+"        else:",
+"            libdir = loader_path",
+"    else:",
+"        libdir = loader_path",
+"",
+"    try:",
+"        libpath = os.path.join(libdir, libname_ext)",
+"        return CDLL(libpath)",
+"    except OSError, e:",
+"        raise e"
+"",
+"try:",
+"    libteem = load_library('libteem')",
+"except OSError:",
+"    print \"**\"",
+"    print \"**  teem.py couldn't find and load the \\\"libteem\\\" shared library.\"",
+"    print \"**\"",
+"    print \"**  try setting optional loader_path argument in the load_library() call above to '<teem-install-dir>/lib/'\"",
+"    print \"**\"",
+"    raise ImportError",
+"",
+"# =============================================================",
+"# Utility types and classes to help teem.py be platform-independent.",
+"",
+"STRING = c_char_p",
+"",
+"class FILE(Structure):",
+"    pass",
+"",
+"# oddly, size_t is in ctypes, but not ptrdiff_t",
+"# which is probably a bug",
+"if sizeof(c_void_p) == 4:",
+"    ptrdiff_t = c_int32",
+"elif sizeof(c_void_p) == 8:",
+"    ptrdiff_t = c_int64",
+"",
+"# =============================================================",
+"# What follows are all the functions, struct definitions, globals, ",
+"# enum values, and typedefs in Teem. This is generated by ctypeslib:",
+"#   http://svn.python.org/projects/ctypes/branches/ctypeslib-gccxml-0.9",
+"# followed by further post-processing and filtering.",
+"# See end of this file for definitions of stderr, stdin, stdout",
+]
+
+footer = [
+"# =============================================================",
+"# Make sure this shared library will work on this machine.",
+"if not nrrdSanity():",
+"    errstr = biffGetDone(NRRD)",
+"    print \"**\"",
+"    print \"** Sorry, there is a problem (described below) with the \"",
+"    print \"** Teem shared library that prevents its use. This will \"",
+"    print \"** have to be fixed by recompiling the Teem library for \"",
+"    print \"** this platform. \"",
+"    print \"**\"",
+"    print \"** %s\" % errstr",
+"    raise ImportError",
+"",
+"# =============================================================",
+"# Its nice to have these FILE*s around for utility use, but they ",
+"# aren't available in a platform-independent way in ctypes. These ",
+"# air functions were created for this purpose.",
+"stderr = airStderr()",
+"stdout = airStdout()",
+"stdin = airStdin()",
+]
+
+teem_py = os.path.join(os.getcwd(), "teem.py")
+
+if os.path.exists(teem_py):
+    os.remove(teem_py)
+
+out = open(teem_py, "w")
+
+for line in header:
+    out.write(line)
+    out.write(os.linesep)
+
+out.writelines(mod_contents)
+out.write(os.linesep)
+
+out.write("# =============================================================\n")
+out.write("# What follows are the all #define's in Teem, excluding macros,\n")
+out.write("# and #defines that depend on compile-time tests done by the\n")
+out.write("# C pre-processor.\n")
+out.write("# This is created by something akin to grep'ing through the\n")
+out.write("# public header files, with some extra filters.\n")
+out.write(os.linesep)
+out.writelines(defines)
+out.write(os.linesep)
+
+for line in footer:
+    out.write(line)
+    out.write(os.linesep)
+
+out.close()
+
+
+#
+# cleanup
+#
+
+shutil.rmtree(TMP_DIR)
+os.remove(teem_xml)
+os.remove(pre_teem_py)
diff --color -ruN teem-1.11.0-src.orig/python/ctypes/go-gen-teem.sh teem-1.11.0-src/python/ctypes/go-gen-teem.sh
--- teem-1.11.0-src.orig/python/ctypes/go-gen-teem.sh	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/python/ctypes/go-gen-teem.sh	2021-02-18 15:42:39.000000000 +0800
@@ -0,0 +1,76 @@
+#!/usr/bin/env bash
+#
+# Teem: Tools to process and visualize scientific data and images             .
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+# Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public License
+# (LGPL) as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+# The terms of redistributing and/or modifying this software also
+# include exceptions to the LGPL that facilitate static linking.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public License
+# along with this library; if not, write to Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+#
+
+set -o nounset
+
+# The various directories used for this process
+# directory used for making source modifications
+TEEM_SRC=~/teem
+# clean check-out; no other modifications
+TEEM_SVN=~/teem-svn
+# CMake build directory for teem-svn
+TEEM_SVN_BUILD=~/teem-svn-build
+# target of "make install" from teem-svn-build
+TEEM_SVN_INSTALL=~/teem-svn-install
+
+if [[ ! (-d "$TEEM_SRC" &&
+         -d "$TEEM_SVN" &&
+         -d "$TEEM_SVN_BUILD" &&
+         -d "$TEEM_SVN_INSTALL") ]]; then
+  echo "Not all of following directories exist:"
+  echo "  TEEM_SRC=$TEEM_SRC"
+  echo "  TEEM_SVN=$TEEM_SVN"
+  echo "  TEEM_SVN_BUILD=$TEEM_SVN_BUILD"
+  echo "  TEEM_SVN_INSTALL=$TEEM_SVN_INSTALL"
+  echo "Sorry for the inconvenience.  This script is used mainly by GLK"
+  echo "to periodically refresh teem.py, especially prior to releases,"
+  echo "and it isn't more generally useful (yet)."
+  exit 1
+fi
+
+function doo {
+  echo "==== $1"
+  eval $1
+  ret=$?
+  if [ $ret != 0 ]; then
+    echo "==== ERROR (status $ret)"
+    exit $ret
+  fi
+}
+
+doo "cd $TEEM_SVN"
+doo "svn update"
+doo "cd $TEEM_SVN_BUILD"
+doo "make"
+doo "make install"
+doo "cd $TEEM_SRC/python/ctypes"
+doo "python gen-teem.py ctypeslib-gccxml-0.9 $TEEM_SVN_INSTALL"
+dfile=$(mktemp /tmp/svndiff.XXXXXXXXX)
+doo "svn diff teem.py | tee $dfile"
+if [[ -s $dfile ]]; then
+  echo "===="
+  echo "==== NOTE: There were new differences; consider \"svn commit teem.py\""
+  echo "===="
+fi
+rm -f $dfile
diff --color -ruN teem-1.11.0-src.orig/python/ctypes/interface_test.py teem-1.11.0-src/python/ctypes/interface_test.py
--- teem-1.11.0-src.orig/python/ctypes/interface_test.py	2012-12-20 22:07:16.000000000 +0800
+++ teem-1.11.0-src/python/ctypes/interface_test.py	2021-02-18 15:42:39.000000000 +0800
@@ -3,7 +3,7 @@
 # test.py: 16-bit grayscale PNG to nrrd file
 # Sam Quinan
 
-import Nrrd as nrd, numpy as np 
+import Nrrd as nrd, numpy as np
 
 # TESTING: fmob-ch4 crop test
 print "TEST: fmob-ch4.nrrd"
@@ -67,7 +67,7 @@
 #e = ExtendedArray(d)
 #e2 = e[:,[0,2]]
 #
-#print e 
+#print e
 #print type(e)
 #print e.flags
 #print e.data
diff --color -ruN teem-1.11.0-src.orig/python/ctypes/mobius.py teem-1.11.0-src/python/ctypes/mobius.py
--- teem-1.11.0-src.orig/python/ctypes/mobius.py	2012-12-20 22:07:16.000000000 +0800
+++ teem-1.11.0-src/python/ctypes/mobius.py	2021-02-18 15:42:39.000000000 +0800
@@ -22,7 +22,7 @@
              energy={'type':teem.pullInterTypeJustR, 'r':'cwell:0.6,-0.002'},
              iterMax=200,
              radSpace=0.05)
-           
+
 pullDemo.volFree(vol)
 
 if (teem.nrrdSave("npos.nrrd", npos, None)):
diff --color -ruN teem-1.11.0-src.orig/python/ctypes/Nrrd.py teem-1.11.0-src/python/ctypes/Nrrd.py
--- teem-1.11.0-src.orig/python/ctypes/Nrrd.py	2012-12-20 22:07:16.000000000 +0800
+++ teem-1.11.0-src/python/ctypes/Nrrd.py	2021-02-18 15:42:39.000000000 +0800
@@ -1,7 +1,7 @@
 #!/usr/bin/env python
 ##
 ##  Nrrd.py: bridge between Nrrd and Numpy arrays
-##  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+##  Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 ##  created by Sam Quinan - samquinan@cs.uchicago.edu
 ##
 ##  Permission is hereby granted, free of charge, to any person obtaining
@@ -41,7 +41,7 @@
         numpy.uint64    :   (ctypes.c_uint64, teem.nrrdTypeULLong),
         numpy.float     :   (ctypes.c_float, teem.nrrdTypeFloat),
         numpy.double    :   (ctypes.c_double, teem.nrrdTypeDouble)     }
-    
+
     dt = array.dtype.type
 
     if dt not in typeTable:
@@ -71,19 +71,19 @@
     }
     return numpy_type_map[teem_type]
 
-                        
-# design based on a combination of work done by Carlos Scheidegger 
+
+# design based on a combination of work done by Carlos Scheidegger
 #   [ http://code.google.com/p/python-teem/source/browse/trunk/teem/capi/numpy/__init__.py ,
 #     http://code.google.com/p/python-teem/source/browse/trunk/teem/nrrd.py ]
 #   and ideas presented by Travis Oliphant [ http://blog.enthought.com/?p=62 ]
-                    
+
 class Nrrd:
     def __init__(self):
         self._ctypesobj = teem.nrrdNew()
         # self._init = False
         self.base_ref = None
         self.teem = teem # world's ugliest hack -- but it appears to work
-    
+
     def __del__(self):
         if self.base_ref == None:
             self.teem.nrrdNuke(self._ctypesobj)
@@ -91,7 +91,7 @@
             self.teem.nrrdNix(self._ctypesobj)
         self.base_ref = None
         self.teem = None
-                        
+
     def __get_array_interface(self):
         nrrd = self._ctypesobj.contents
         s = []
@@ -102,22 +102,22 @@
             'data': (nrrd.data, False),
             'version': 3}
         return r
-    
+
     __array_interface__ = property(__get_array_interface)
-                        
+
     def fromNDArray(self, array):
-        
+
         if self.base_ref != None:
             self.base_ref = None
             teem.nrrdNix(self._ctypesobj)
             self._ctypesobj = teem.nrrdNew()
-        
+
         try:
             cTy, teemTy = ndarrayGetTypes(array)
         except Exception as err:
             print err
             return
-        
+
         c_type_p = ctypes.POINTER( cTy )
         if (array.flags.f_contiguous): # memory shared with array
             array_p = array.ctypes.data_as(c_type_p)
@@ -148,12 +148,12 @@
                 teem.nrrdAxisInfoCopy(self._ctypesobj, array.base_ref._ctypesobj, None, teem.NRRD_AXIS_INFO_SIZE_BIT)
 
     def load(self, file, args=None):
-        
+
         if self.base_ref != None:
             self.base_ref = None
             teem.nrrdNix(self._ctypesobj)
             self._ctypesobj = teem.nrrdNew()
-        
+
         teem.nrrdLoad(self._ctypesobj, file, args)
         self.base_ref = None
         self._init = True
@@ -177,8 +177,7 @@
             obj = numpy.asarray(input_array).view(cls)
             obj.base_ref = base_ref
         return obj
-    
+
     def __array_finalize__(self, obj):
         if obj is None: return
         self.base_ref = getattr(obj, 'base_ref', None)
-
diff --color -ruN teem-1.11.0-src.orig/python/ctypes/pullDemo.py teem-1.11.0-src/python/ctypes/pullDemo.py
--- teem-1.11.0-src.orig/python/ctypes/pullDemo.py	2012-12-20 22:07:16.000000000 +0800
+++ teem-1.11.0-src/python/ctypes/pullDemo.py	2021-02-18 15:42:39.000000000 +0800
@@ -25,7 +25,7 @@
 '''
 This is really hastily written, and doesn't conform in the least
 to good conventions of Python coding. The worst part is using exit()
-instead of raising exceptions when tings go wrong. 
+instead of raising exceptions when tings go wrong.
 
 The "API" here (this python interface to the pull library) is not well
 thought-out, and won't be helpful for integrating particles in other
@@ -56,7 +56,7 @@
         vol[i] = teem.meetPullVolNew()
         if (not E):
             E += teem.meetPullVolParse(vol[i], vlist[i])
-    if (not E): 
+    if (not E):
         E += teem.meetPullVolLoadMulti(vol, len(vol),
                                        cachePath, kSSblur,
                                        teem.nrrdBoundaryWrap, 0.0,
@@ -73,7 +73,7 @@
         vol[i] = teem.meetPullVolNix(vol[i])
 
 ##
-## especParse: returns a length-4 list of the arguments to pass 
+## especParse: returns a length-4 list of the arguments to pass
 ## to pullInterEnergySet. Arguments are:
 ## type: from pullIterType* enum
 ## r: string definition for energy function along space (especR)
@@ -111,10 +111,10 @@
     return
 
 ##
-## initSet: calls (and returns value from) the appropriate 
+## initSet: calls (and returns value from) the appropriate
 ## pullInitMethod* function. Possibilities are:
 ## [teem.pullInitMethodRandom, num]
-## [teem.pullInitMethodPointPerVoxel, 
+## [teem.pullInitMethodPointPerVoxel,
 ##     ppv, zslcmin, zslcmax, alongscalenum, jitter]
 ## [teem.pullInitMethodGivenPos, npos]
 ##
@@ -151,13 +151,13 @@
     if (not ('vol' in args and 'info' in args and 'efs' in args)):
         print "run: didn't get vol, info, and efs args"
         sys.exit(1)
-        
+
     # learn args, with defaults
     vol = a(args, 'vol')
     infoStr = a(args, 'info')
     efs = a(args, 'efs')
     init = a(args, 'init', [teem.pullInitMethodRandom, 100])
-    energyDict = a(args, 'energy', {'type':teem.pullInterTypeJustR, 
+    energyDict = a(args, 'energy', {'type':teem.pullInterTypeJustR,
                                     'r':'qwell:0.68'})
     verbose = a(args, 'verbose', 1)
     rngSeed = a(args, 'rngSeed', 42)
@@ -212,7 +212,7 @@
     if (teem.pullVerboseSet(pctx, verbose) or
         teem.pullRngSeedSet(pctx, rngSeed) or
         teem.pullFlagSet(pctx, teem.pullFlagNixAtVolumeEdgeSpace, nave) or
-        teem.pullFlagSet(pctx, teem.pullFlagConstraintBeforeSeedThresh, 
+        teem.pullFlagSet(pctx, teem.pullFlagConstraintBeforeSeedThresh,
                          cbst) or
         teem.pullFlagSet(pctx, teem.pullFlagEnergyFromStrength, efs) or
         teem.pullFlagSet(pctx, teem.pullFlagRestrictiveAddToBins, ratb) or
diff --color -ruN teem-1.11.0-src.orig/python/ctypes/sourceme-ctypeslib.txt teem-1.11.0-src/python/ctypes/sourceme-ctypeslib.txt
--- teem-1.11.0-src.orig/python/ctypes/sourceme-ctypeslib.txt	2012-12-20 22:07:16.000000000 +0800
+++ teem-1.11.0-src/python/ctypes/sourceme-ctypeslib.txt	1970-01-01 08:00:00.000000000 +0800
@@ -1,40 +0,0 @@
-
-echo === These are commands that GLK used to create teem.py, in tcsh
-echo === Obviously, anyone is welcome to make this into a proper python script
-echo === or otherwise make it more robust and portable, especially the stuff
-echo === that removes the install path specifics from teem.py
-echo ===
-echo === You will need a recent gccxml to make this work.
-
-svn co http://svn.python.org/projects/ctypes/branches/ctypeslib-gccxml-0.9
-setenv CTYPES `pwd`/ctypeslib-gccxml-0.9
-setenv PYTHONPATH ${CTYPES}:`pwd`
-
-echo === A patch is still needed, hopefully this can be fixed
-patch -p0 -i ctypes-codegen.patch
-
-echo === TEEM has to be set to wherever CMake put its make install
-setenv TEEM /Users/gk/teem-install
-
-echo === all.h just includes all the other public top-level .h in Teem
-rm -rf teemincl
-mkdir teemincl
-cp -r ${TEEM}/include/teem teemincl
-cd teemincl
-ls -1 teem/*.h | awk '{print "#include <"$1">"}' > all.h
-cd ..
-
-echo === teem.xml represents the Teem API
-python ${CTYPES}/scripts/h2xml.py `pwd`/teemincl/all.h -I teemincl -o teem.xml
-
-echo === DYLD_LIBRARY_PATH is obviously Mac specific, please fix
-setenv DYLD_LIBRARY_PATH ${TEEM}/lib
-python ${CTYPES}/scripts/xml2py.py teem.xml -llibteem.dylib -o pre-teem.py -m stdio \
-        -r "(air|hest|biff|nrrd|ell|unrrdu|alan|moss|tijk|gage|dye|bane|limn|echo|hoover|seek|ten|elf|pull|coil|push|mite|meet).*"
-rm -rf teemincl
-
-
-echo === At this point GLK does emacs stuff to make pre-teem.py into what is
-echo === the currently svn committed teem.py
-echo === Obviously, this really needs to be automated...
-
diff --color -ruN teem-1.11.0-src.orig/python/ctypes/teem-gen.py teem-1.11.0-src/python/ctypes/teem-gen.py
--- teem-1.11.0-src.orig/python/ctypes/teem-gen.py	2012-12-20 22:07:16.000000000 +0800
+++ teem-1.11.0-src/python/ctypes/teem-gen.py	1970-01-01 08:00:00.000000000 +0800
@@ -1,355 +0,0 @@
-#! /usr/bin/env python
-
-##
-##  teem-gen.py: automatically-generated ctypes python wrappers for Teem
-##  Copyright (C) 2012, 2011 University of Chicago
-##  created by Sam Quinan - samquinan@cs.uchicago.edu
-##
-##  Permission is hereby granted, free of charge, to any person obtaining
-##  a copy of this software and associated documentation files (the
-##  "Software"), to deal in the Software without restriction, including
-##  without limitation the rights to use, copy, modify, merge, publish,
-##  distribute, sublicense, and/or sell copies of the Software, and to
-##  permit persons to whom the Software is furnished to do so, subject to
-##  the following conditions:
-##
-##  The above copyright notice and this permission notice shall be
-##  included in all copies or substantial portions of the Software.
-##
-##  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-##  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-##  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-##  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-##  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-##  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-##  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-##
-
-import os, sys, shutil, platform, re, string
-
-if len(sys.argv) != 3:
-    sys.exit("program expexts arguments: 'ctypeslib-gccxml source dir' 'teem install dir' ")
-
-## (TEEM_LIB_LIST)
-libs_list = ["air", "hest", "biff", "nrrd", "ell", "unrrdu", "alan", "moss", "tijk", "gage", "dye", "bane", "limn", "echo", "hoover", "seek", "ten", "elf", "pull", "coil", "push", "mite", "meet"]
-
-#
-# validate os 
-#
-if os.name != "posix":
-    sys.exit("program only supports posix compilant systems at this time") 
-
-#
-# validate gccxml install
-#
-tmp = os.path.join(os.getcwd(), "tmp")
-os.system("gccxml --version &> tmp")
-file = open(tmp, "r")
-file.seek(0)
-first_line = file.readline()
-file.close()
-if not first_line.startswith("GCC-XML version"):
-    os.remove(tmp)
-    sys.exit("error: gccxml of version >= 0.9.0 is required for this script")
-
-if not ((int(first_line[16]) > 0) or ((int(first_line[18]) == 9) and (int(first_line[20]) >= 0))):
-    os.remove(tmp)
-    sys.exit("error: gccxml of version >= 0.9.0 is required for this script")
-os.remove(tmp)
-
-#
-# validate ctypeslib-gccxml source dir path 
-#
-if not os.path.isdir(sys.argv[1]):
-    sys.exit("%s does not point to a directory" % sys.argv[1])
-
-CTYPES = os.path.abspath(sys.argv[1])
-
-#
-# validate teem install dir path
-#
-if not os.path.isdir(sys.argv[2]):
-    sys.exit("%s does not point to a directory" % sys.argv[2])
-
-TEEM = os.path.abspath(sys.argv[2])
-
-
-#
-# copy files from install dir 
-#
-
-TMP_DIR = "teem-gen-tmp"
-
-teem_include = os.path.join(TEEM, "include") 
-
-if not os.path.isdir(teem_include): 
-    sys.exit("%s is not the teem install directory; %s is not a valid path" % (teem, teem-install))
-
-if os.path.isdir(TMP_DIR):
-    shutil.rmtree(TMP_DIR)
-
-shutil.copytree(teem_include, TMP_DIR)
-
-
-#
-# generate all.h
-#
-
-all_h = os.path.join(TMP_DIR, "all.h")
-f_open = open (all_h, "w")
-
-defines = []
-
-Files = os.listdir(os.path.join(TMP_DIR, "teem"))
-for file in Files:
-    if file.endswith(".h"):
-        f_open.write("#include <teem/%s> %s" % (file, os.linesep))
-        #
-        # get #define statements from file
-        #
-        lines = open (os.path.join(TMP_DIR, "teem", file), "r").readlines()
-        expr1 = re.compile("^#define")
-        expr2 = re.compile("\\\\")
-        expr3 = re.compile("HAS_BEEN_INCLUDED")
-        expr4 = re.compile("##")
-        expr5 = re.compile("^#define [^ ]*\(")
-        expr6 = re.compile("NRRD_TYPE_BIGGEST")
-        # this strips out NRRD_LLONG_MAX, NRRD_LLONG_MIN, and NRRD_ULLONG_MAX,
-        # which depend on macros AIR_LLONG and AIR_LLONG.  For some reason
-        # this cause a problem now (Thu Jun 14 11:49:14 CDT 2012) even though
-        # they haven't before, though these constants and macros are not new
-        expr7 = re.compile("LLONG")
-        for line in lines:
-            if (expr1.search(line) and not expr2.search(line) 
-                and not expr3.search(line) and not expr4.search(line)
-                and not expr5.search(line) and not expr6.search(line)
-                and not expr7.search(line)):
-                firstword, restwords = string.replace(string.replace(line[8:], "/*", "#" ), "*/", "").split(None,1)
-                defines.append("%s = %s" % (firstword, restwords))
-f_open.close()
-
-#
-# generate teem.xml 
-#
-# note: these calls are unix only because windows support for command line 
-#	append to python path (where the scopeis only that one call) is too
-#	difficult at this time -- better support may be added to later versions
-#	of python, so that something to watch for / modify in the future
-
-pypath_append = "PYTHONPATH=%s:%s" % (CTYPES, os.getcwd())
-teem_xml = os.path.join(os.getcwd(), "teem.xml")
-os.system("%s python %s %s -I %s -o %s" % (pypath_append, os.path.join(CTYPES, "scripts", "h2xml.py"), os.path.abspath(all_h), TMP_DIR, teem_xml))
-
-
-#
-# generate pre-teem.py 
-#
-pre_teem_py = os.path.join(os.getcwd(), "pre-teem.py")
-
-teem_libs = '|'.join(libs_list)
-
-system_type = platform.system()
-dll_path = ""
-ext = ""
-substr = ""
-if system_type == "Darwin":
-    dll_path = "DYLD_LIBRARY_PATH=%s" % os.path.join(TEEM, "lib")
-    ext = "dylib"
-    substr = "_libraries['%s']" % os.path.join(TEEM, "lib", "libteem.dylib")
-else:
-    dll_path = "LD_LIBRARY_PATH=%s" % os.path.join(TEEM, "lib")
-    ext = "so"
-    substr = "_libraries['libteem.so']"
-
-os.system("%s %s python %s %s -l libteem.%s -o %s -m stdio -r \"(%s).*\"" % (dll_path, pypath_append, os.path.join(CTYPES, "scripts", "xml2py.py"), teem_xml, ext,  pre_teem_py, teem_libs))
-
-#
-# generate teem.py 
-#
-
-libs_destuctable = list(libs_list)
-
-contents = open(pre_teem_py, "r").readlines()[8:]
-mod_contents = []
-for line in contents:
-    l = line.replace(substr, "libteem")
-    if not (("__darwin_size_t = c_ulong" in l) or ("size_t = __darwin_size_t" in l)):
-        l2 = l.replace("\'__darwin_size_t\',", "") #designed to remove defs from long list at end
-        l3 = l2.replace("\'size_t\',", "") #designed to remove defs from long list at end
-        l = l3
-        if not re.compile("_size_t").search(l3):
-            if not re.match("#", l3): # i.e. do not make changes in commented lines
-                l = l3.replace("size_t", "c_size_t")
-        mod_contents.append(l)
-        if "Present" in l:
-            for lib in libs_destuctable:
-                lib_str = lib+"Present"
-                if lib_str in l:
-                    libs_destuctable.remove(lib)
-                    break
-
-# in experimental libs not included, cleanup and fail
-if libs_destuctable: # empty sequence implicity false
-    shutil.rmtree(TMP_DIR)
-    os.remove(teem_xml)
-    #os.remove(pre_teem_py)
-    sys.exit("ERROR: experimental libs: %s not turned on - please rebuild teem with BUILD_EXPERIMENTAL_LIBS turned on, then re-run teem-gen.py" % ','.join(libs_destuctable))
-
-header = [
-"##",
-"##  teem.py: automatically-generated ctypes python wrappers for Teem",
-"##  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago",
-"##",
-"##  Permission is hereby granted, free of charge, to any person obtaining",
-"##  a copy of this software and associated documentation files (the",
-"##  \"Software\"), to deal in the Software without restriction, including",
-"##  without limitation the rights to use, copy, modify, merge, publish,",
-"##  distribute, sublicense, and/or sell copies of the Software, and to",
-"##  permit persons to whom the Software is furnished to do so, subject to",
-"##  the following conditions:",
-"##",
-"##  The above copyright notice and this permission notice shall be",
-"##  included in all copies or substantial portions of the Software.",
-"##",
-"##  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,",
-"##  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF",
-"##  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND",
-"##  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE",
-"##  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION",
-"##  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION",
-"##  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
-"##",
-"##############################################################",
-"##############################################################",
-"#### NOTE: This teem.py file is automatically produced by",
-"#### teem/python/ctypes/teem-gen.py.  Necessary changes to ",
-"#### teem.py should be made in teem-gen.py, not here.",
-"##############################################################",
-"##############################################################",
-"",
-"from ctypes import *",
-"import ctypes.util",
-"import sys, os",
-"",
-"def load_library(libname, loader_path=\"\"):",
-"    ext = os.path.splitext(libname)[1]",
-"    if not ext:",
-"        # Try to load library with platform-specific name",
-"        if sys.platform == 'win32':",
-"            libname_ext = '%s.dll' % libname",
-"        elif sys.platform == 'darwin':",
-"            libname_ext = '%s.dylib' % libname",
-"        elif sys.platform == 'linux2':",
-"            libname_ext = '%s.so' % libname",
-"    else:"
-"        libname_ext = libname",
-"",
-"    if (loader_path != \"\"):",
-"        loader_path = os.path.abspath(loader_path)",
-"        if not os.path.isdir(loader_path):",
-"            libdir = os.path.dirname(loader_path)",
-"        else:",
-"            libdir = loader_path",
-"    else:",
-"        libdir = loader_path",
-"",          
-"    try:",
-"        libpath = os.path.join(libdir, libname_ext)",
-"        return CDLL(libpath)",
-"    except OSError, e:",
-"        raise e"
-"",          
-"try:",
-"    libteem = load_library('libteem')",
-"except OSError:",
-"    print \"**\"",
-"    print \"**  teem.py couldn't find and load the \\\"libteem\\\" shared library.\"",
-"    print \"**\"",
-"    print \"**  try setting optional loader_path argument in the load_library() call above to '<teem-install-dir>/lib/'\"",
-"    print \"**\"",
-"    raise ImportError",
-"",          
-"# =============================================================",
-"# Utility types and classes to help teem.py be platform-independent.",
-"",
-"STRING = c_char_p",
-"",
-"class FILE(Structure):",
-"    pass",
-"",
-"# oddly, size_t is in ctypes, but not ptrdiff_t",
-"# which is probably a bug",
-"if sizeof(c_void_p) == 4:",
-"    ptrdiff_t = c_int32",
-"elif sizeof(c_void_p) == 8:",
-"    ptrdiff_t = c_int64",
-"",
-"# =============================================================",
-"# What follows are all the functions, struct definitions, globals, ",
-"# enum values, and typedefs in Teem. This is generated by ctypeslib:",
-"#   http://svn.python.org/projects/ctypes/branches/ctypeslib-gccxml-0.9",
-"# followed by further post-processing and filtering.",
-"# See end of this file for definitions of stderr, stdin, stdout",
-]
-
-footer = [
-"# =============================================================",
-"# Make sure this shared library will work on this machine.",
-"if not nrrdSanity():",
-"    errstr = biffGetDone(NRRD)",
-"    print \"**\"",
-"    print \"** Sorry, there is a problem (described below) with the \"",
-"    print \"** Teem shared library that prevents its use. This will \"",
-"    print \"** have to be fixed by recompiling the Teem library for \"",
-"    print \"** this platform. \"",
-"    print \"**\"",
-"    print \"** %s\" % errstr",
-"    raise ImportError",
-"",
-"# =============================================================",
-"# Its nice to have these FILE*s around for utility use, but they ",
-"# aren't available in a platform-independent way in ctypes. These ",
-"# air functions were created for this purpose.",
-"stderr = airStderr()",
-"stdout = airStdout()",
-"stdin = airStdin()",
-]
-
-teem_py = os.path.join(os.getcwd(), "teem.py")
-
-if os.path.exists(teem_py):
-    os.remove(teem_py)
-
-out = open(teem_py, "w")
-
-for line in header:
-    out.write(line)
-    out.write(os.linesep)
-
-out.writelines(mod_contents)
-out.write(os.linesep)
-
-out.write("# =============================================================\n")
-out.write("# What follows are the all #define's in Teem, excluding macros,\n")
-out.write("# and #defines that depend on compile-time tests done by the\n")
-out.write("# C pre-processor.\n")
-out.write("# This is created by something akin to grep'ing through the\n")
-out.write("# public header files, with some extra filters.\n")
-out.write(os.linesep)
-out.writelines(defines)
-out.write(os.linesep)
-
-for line in footer:
-    out.write(line)
-    out.write(os.linesep)
-
-out.close()
-
-
-#
-# cleanup
-#
-
-shutil.rmtree(TMP_DIR)
-os.remove(teem_xml)
-os.remove(pre_teem_py)
diff --color -ruN teem-1.11.0-src.orig/python/ctypes/teem.py teem-1.11.0-src/python/ctypes/teem.py
--- teem-1.11.0-src.orig/python/ctypes/teem.py	2012-12-20 22:07:16.000000000 +0800
+++ teem-1.11.0-src/python/ctypes/teem.py	2021-02-18 15:42:39.000000000 +0800
@@ -1,6 +1,6 @@
 ##
 ##  teem.py: automatically-generated ctypes python wrappers for Teem
-##  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+##  Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 ##
 ##  Permission is hereby granted, free of charge, to any person obtaining
 ##  a copy of this software and associated documentation files (the
@@ -24,8 +24,8 @@
 ##############################################################
 ##############################################################
 #### NOTE: This teem.py file is automatically produced by
-#### teem/python/ctypes/teem-gen.py.  Necessary changes to 
-#### teem.py should be made in teem-gen.py, not here.
+#### teem/python/ctypes/gen-teem.py.  Necessary changes to
+#### teem.py should be made in gen-teem.py, not here.
 ##############################################################
 ##############################################################
 
@@ -85,1337 +85,1355 @@
     ptrdiff_t = c_int64
 
 # =============================================================
-# What follows are all the functions, struct definitions, globals, 
+# What follows are all the functions, struct definitions, globals,
 # enum values, and typedefs in Teem. This is generated by ctypeslib:
 #   http://svn.python.org/projects/ctypes/branches/ctypeslib-gccxml-0.9
 # followed by further post-processing and filtering.
 # See end of this file for definitions of stderr, stdin, stdout
 
-gagePvlFlagVolume = 1
-tenDwiGageTensorLLS = 6
-pullPropStepConstr = 5
-tenGageClpmin2 = 80
-gagePvlFlagUnknown = 0
-tenGageDelNormK2 = 23
-tenGageOmegaHessianContrTenEvec2 = 147
-hooverErrLast = 11
-gageKernel00 = 1
-hooverErrThreadJoin = 9
-hooverErrSample = 6
-tenGageEvec1 = 21
-hooverErrThreadCreate = 3
-hooverErrRayBegin = 5
-echoTypeInstance = 11
-hooverErrNone = 0
-nrrdUnaryOpLog10 = 12
-echoMatterGlassFuzzy = 3
-tenGageTheta = 12
-echoMatterGlassKa = 1
-nrrdField_kinds = 16
-echoMatterPhongSp = 3
-echoMatterPhongKd = 1
-echoMatterPhongKa = 0
-tenGageEval2 = 18
-echoJitterRandom = 3
-echoJitterJitter = 2
-echoJitterNone = 0
-tenGageOmegaHessianContrTenEvec1 = 146
-echoJitterUnknown = -1
-pullIterParmCallback = 7
-pullIterParmPopCntlPeriod = 5
-pullIterParmConstraintMax = 4
-nrrdUnaryOpLog2 = 11
-pullIterParmMax = 2
-pullIterParmUnknown = 0
-tenGageMode = 11
-tenGageCp2 = 78
-dyeSpaceLUV = 6
-tenDwiGageLast = 36
-dyeSpaceLAB = 5
-tenDwiGage2TensorPeledAndError = 34
-nrrdTypeLast = 12
-nrrdTypeBlock = 11
-tenGageR = 10
-nrrdTypeDouble = 10
-nrrdTypeFloat = 9
-seekTypeValleySurface = 3
-nrrdTypeLLong = 7
-tenDwiGage2TensorPeledError = 33
-nrrdTypeUInt = 6
-gageParmRenormalize = 2
-nrrdTypeInt = 5
-nrrdTypeUShort = 4
-alanParmReact = 13
-nrrdTypeShort = 3
-nrrdTypeUChar = 2
-limnEdgeTypeLone = 7
-limnEdgeTypeBorder = 6
-hooverErrThreadEnd = 8
-tenGageOmega2ndDD = 144
-limnEdgeTypeBackCrease = 2
-gageCtxFlagShape = 6
-limnEdgeTypeUnknown = 0
-nrrdZlibStrategyLast = 4
-hooverErrRayEnd = 7
-nrrdZlibStrategyHuffman = 2
-nrrdZlibStrategyDefault = 1
-nrrdZlibStrategyUnknown = 0
-pullCountTestStep = 2
-echoTypeList = 10
-baneMeasrTotalCurv = 7
-pushEnergyTypeZero = 5
-baneIncAbsolute = 1
-pullSysParmFracNeighNixedMax = 19
+alanParmMinAverageChange = 16
+unrrduScaleAdd = 4
+nrrdTypeULLong = 8
+pullInfoIsovalueHessian = 21
+pullInfoNegativeTangent1 = 17
+tenAniso_Tr = 26
+pullInfoTangent1 = 15
+tenGageTraceHessianFrob = 91
+pullInfoLiveThresh3 = 14
+pullInfoLiveThresh2 = 13
+pullInfoSeedThresh = 11
+alanParmK = 14
+tenGageCp1Hessian = 187
+pullInfoHeightHessian = 8
+tenDwiGageTensorWLSLikelihood = 13
+pullInfoHeightGradient = 7
+nrrdIoStateUnknown = 0
+pullInfoNegativeTangent2 = 18
+alanParmDiffB = 12
+tenGageModeHessianEval1 = 127
+unrrduScaleDivide = 3
+pullFlagStartSkipsPoints = 14
+gageSclFlowlineCurv = 31
+pullFlagPopCntlEnoughTest = 9
+nrrdBlind8BitRangeState = 3
+pullFlagUseBetaForGammaLearn = 3
+pullInitMethodGivenPos = 4
+gageVecCurlNorm = 11
+gageSclCurvDir1 = 29
+tenGageDetNormal = 44
+gageSclMeanCurv = 27
+tenGageCp1HessianEvec0 = 193
+alanParmHomogAniso = 5
+tenGageTraceHessianEvec1 = 89
+pullConstraintFailLast = 7
+pullConstraintFailTravel = 6
+pullConstraintFailIterMaxed = 5
+limnSplineInfoLast = 7
+limnSplineInfoQuaternion = 6
+limnSplineInfo4Vector = 5
+pullConstraintFailHessZeroA = 1
+tenDwiGageTensorWLSError = 11
+gageSclShapeTrace = 25
+pullInfoHeightLaplacian = 9
+nrrdMeasureLast = 31
+limnSplineInfoScalar = 1
+alanParmNumThreads = 3
+nrrdField_units = 18
+tenGageFiberDispersion = 206
+nrrdBinaryOpNormalRandScaleAdd = 22
+nrrdFormatTypeText = 5
+nrrdFormatTypeVTK = 4
+tenGageDetGradMag = 43
+nrrdBinaryOpEqual = 18
+nrrdBinaryOpCompare = 17
+nrrdBinaryOpGTE = 16
+alanParmVerbose = 1
+nrrdBinaryOpLT = 13
+nrrdBinaryOpMax = 12
+nrrdBinaryOpFmod = 9
+tenGageCp1HessianEvec = 192
+alanParmUnknown = 0
+pushEnergyTypeLast = 6
 pushEnergyTypeCotan = 4
 pushEnergyTypeCoulomb = 3
-pushEnergyTypeGauss = 2
-tenDwiGageTensorNLS = 14
-echoTypeAABBox = 8
-tenGageOmegaLaplacian = 143
+tenGageCa1HessianEvec1 = 203
+pullTraceStopUnknown = 0
+nrrdBinaryOpAdd = 1
+tenDwiGageTensorWLS = 10
+nrrdBinaryOpUnknown = 0
+pullFlagZeroZ = 15
+tenAniso_Conf = 1
+nrrdMeasureHistoSD = 30
+nrrdField_min = 19
+pullCondConstraintFail = 5
+alanParmF = 15
+pullInfoTensorInverse = 2
+unrrduScaleUnknown = 0
+nrrdMeasureHistoVariance = 29
+tenGageCa1HessianEval1 = 199
+echoMatterGlassIndex = 0
+tenGageCp1HessianEval2 = 191
+nrrdField_labels = 17
+nrrdBlind8BitRangeUnknown = 0
+tenDwiGageTensorLLSLikelihood = 9
+nrrdMeasureHistoSum = 27
+tenGageCa1HessianEval = 197
+nrrdFormatTypePNG = 3
+gageSclHessEval1 = 13
+tenGageCp1HessianEvec2 = 195
+gageSigmaSamplingUniformTau = 2
+nrrdField_space_directions = 14
+gageSigmaSamplingUnknown = 0
+gageSclHessEval0 = 12
+hestSourceLast = 3
+tenGageCp1HessianEvec1 = 194
+tenGageCp1HessianEval1 = 190
+tenGageTraceHessianEvec0 = 88
+tijk_class_last = 4
+coilMethodTypeFinish = 8
+coilMethodTypeSelf = 7
+coilMethodTypeCurvatureFlow = 6
+tenGageTraceHessianEvec = 87
+coilMethodTypeModifiedCurvatureRings = 5
+nrrdField_kinds = 16
+coilMethodTypeModifiedCurvature = 4
+gageSclLaplacian = 9
+coilMethodTypePeronaMalik = 3
+coilMethodTypeHomogeneous = 2
+nrrdMeasureHistoL2 = 28
+tenGageBGradMag = 40
+nrrdBasicInfoKeyValuePairs = 15
+echoMatterMetalKd = 2
+tenGageTraceHessianEval1 = 85
+nrrdMeasureLineIntercept = 19
+hestSourceUser = 2
+nrrdBlind8BitRangeLast = 4
+nrrdBlind8BitRangeFalse = 2
+tenGageCp1HessianEval0 = 189
+nrrdField_space_dimension = 8
+nrrdBlind8BitRangeTrue = 1
+tijk_class_unknown = 0
+tenGageCp1HessianEval = 188
+tenGageTraceHessianEval = 83
+gageSclNProj = 5
+nrrdSpaceLast = 13
+tenGageTraceHessian = 82
+nrrdMeasureCoV = 16
+nrrdFormatTypeNRRD = 1
+tenGageHessian = 81
+pullSysParmLast = 20
+pullSysParmFracNeighNixedMax = 19
+nrrdBasicInfoComments = 14
+pullSysParmWall = 18
 pullSysParmConstraintStepMin = 17
-limnPolyDataInfoTex2 = 3
-limnPolyDataInfoNorm = 2
-limnPolyDataInfoUnknown = 0
-gageSclHessMode = 35
-echoTypeTriMesh = 6
-limnSpaceScreen = 3
-gageSclMedian = 32
-pullEnergyTypeQuartic = 7
-gageSclCurvDir2 = 30
-tenAniso_eval0 = 27
-pullStatusUnknown = 0
-gageSclGaussCurv = 28
+pullSysParmEnergyDecreaseMin = 16
 pullSysParmEnergyIncreasePermit = 15
-gageSclMeanCurv = 27
-gageSclShapeIndex = 26
-tenGageQ = 8
-gageSclK2 = 23
-echoTypeTriangle = 4
-gageSclGeomTensTen = 21
-baneMeasr2ndDD = 6
-tenGageCa1 = 75
-gageSclHessEvec2 = 18
-tenDwiGageTensorWLSLikelihood = 13
-tenGageOmegaHessianEvec2 = 142
-gageSclHessEval2 = 14
-airMopAlways = 3
+tenGageClpmin2 = 80
+pullSysParmEnergyDecreasePopCntlMin = 14
+nrrdKind4Color = 17
+pullSysParmBackStepScale = 13
+nrrdMeasureVariance = 14
 pullSysParmOpporStepScale = 12
-alanTextureTypeLast = 3
-alanTextureTypeGrayScott = 2
-airMopOnError = 1
-miteShadeMethodUnknown = 0
-limnPrimitiveLines = 7
 pullSysParmProbeProb = 11
-limnPrimitiveQuads = 5
-limnPrimitiveTriangleFan = 4
-limnPrimitiveTriangleStrip = 3
-pullCountUnknown = 0
-echoTypeSphere = 0
-tenGageS = 7
-miteValRi = 8
-baneIncUnknown = 0
-unrrduScaleSubtract = 5
-baneMeasrLaplacian = 5
-unrrduScaleDivide = 3
-tenGageCp1 = 74
-tenDwiGageTensorWLSErrorLog = 12
-echoMatterGlassIndex = 0
-gageParmVerbose = 1
-tenAniso_R = 19
-baneMeasrGradMag = 4
-baneMeasrValueZeroCentered = 2
-baneMeasrValuePositive = 1
-baneMeasrUnknown = 0
-nrrdUnaryOpExists = 25
+nrrdSpace3DLeftHanded = 10
+pullSysParmNeighborTrueProb = 10
+pullSysParmBinWidthSpace = 9
+tenGageCa2 = 79
+pullSysParmRadiusScale = 8
+pullSysParmRadiusSpace = 7
+nrrdMeasureLinf = 13
 pullSysParmStepInitial = 6
-nrrdResampleNonExistentRenormalize = 2
-miteRangeSP = 8
-echoMatterPhongKs = 2
-miteRangeEmissivity = 4
-miteValRw = 7
-tenAniso_VF = 16
-miteRangeAlpha = 0
-tenGageCl1 = 73
-nrrdUnaryOpRoundDown = 22
-pullSysParmGamma = 3
-tenGageOmegaHessianEvec0 = 140
-nrrdUnaryOpRoundUp = 21
+pullSysParmTheta = 5
+nrrdField_content = 2
 pullSysParmBeta = 2
-nrrdResampleNonExistentNoop = 1
-miteValNdotV = 13
+pullSysParmAlpha = 1
+pullEnergyTypeBspln = 3
 pullSysParmUnknown = 0
-echoJitterGrid = 1
-tenGageCp1HessianEvec = 192
-nrrdUnaryOpErf = 17
-pullPropNeighCovar = 11
-seekTypeRidgeSurfaceT = 9
-nrrdResampleNonExistentWeight = 3
-nrrdResampleNonExistentUnknown = 0
-nrrdFFTWPlanRigorExhaustive = 4
-nrrdFFTWPlanRigorPatient = 3
-tenGageFA = 9
-nrrdFFTWPlanRigorMeasure = 2
-nrrdFFTWPlanRigorUnknown = 0
-pullProcessModeUnknown = 0
-pullCondEnergyBad = 6
+nrrdUnaryOpRoundDown = 22
+pullFlagAllowCodimension3Constraints = 12
+nrrdFormatTypeUnknown = 0
+pullFlagBinSingle = 11
+tenGageClpmin1 = 76
+nrrdBasicInfoOldMax = 13
+pullEnergyTypeSpring = 1
+pullFlagConvergenceIgnoresPopCntl = 10
+limnCameraPathTrackFrom = 1
+nrrdMeasureL2 = 9
+tenGageCl1HessianEval = 179
+limnCameraPathTrackUnknown = 0
+pullFlagConstraintBeforeSeedThresh = 7
+tenAniso_Clpmin2 = 11
+pushEnergyTypeGauss = 2
+gageSclHessEvec = 15
+pullFlagNixAtVolumeEdgeSpace = 6
+tenGageNormGradMag = 37
+pullFlagEnergyFromStrength = 5
+tenGageRotTans = 70
+nrrdMeasureMode = 5
+pullFlagRestrictiveAddToBins = 4
+tenAniso_Q = 18
+tenGageInvarRGrads = 68
+pullFlagNoPopCntlWithZeroAlpha = 2
+tijk_class_efs = 3
+tenGageOmegaHessianEval1 = 137
+pullPropNeighTanCovar = 13
+tenGageInvarKGrads = 66
+pullFlagUnknown = 0
+tenGageOmegaNormal = 65
+airTypeString = 10
+tenAniso_B = 17
+echoMatterLightUnit = 1
+pullPropScale = 10
+tenGageOmegaGradVec = 63
+pullPropNeighDistMean = 9
 pullPropForce = 8
-pullCondConstraintFail = 5
+tenGageTensorRThetaPhiLinear = 166
+tenGageCp1GradVec = 170
+tenGageThetaGradMag = 61
+tenGageTensorQuatGeoLoxR = 165
+limnCameraPathTrackAt = 2
+seekTypeValleySurfaceOP = 10
+tenGageModeGradMag = 58
+tenGageCovarianceKGRT = 162
+nrrdTypeFloat = 9
+nrrdField_spacings = 10
+airEndianLast = 4322
+pullPropIdCC = 2
+pullCondLast = 8
+nrrdKindXYZColor = 16
 pullCondEnergyTry = 4
-echoMatterLightUnit = 1
-nrrdTernaryOpMaxSmooth = 6
-nrrdTernaryOpMax = 5
-gageKernelStack = 7
-tenAniso_Clpmin1 = 5
-gageCtxFlagUnknown = 0
-nrrdTernaryOpUnknown = 0
-nrrdBinaryOpLT = 13
-pullIterParmLast = 10
-nrrdBinaryOpMin = 11
-gageKernel22 = 6
-nrrdBinaryOpAtan2 = 10
-nrrdBinaryOpFmod = 9
-gageItemPackPartHessEval0 = 6
-tenAniso_Ca1 = 4
-nrrdBinaryOpMod = 8
-nrrdBinaryOpFlippedSgnPow = 7
-nrrdBinaryOpMultiply = 3
-nrrdUnaryOpLog = 10
-nrrdBinaryOpUnknown = 0
-pullInterTypeUnivariate = 2
-pullInterTypeJustR = 1
-nrrdUnaryOpExp = 9
-nrrdTypeDefault = 0
-echoMatterLightPower = 0
-nrrdUnaryOpAtan = 8
-pullIterParmAddDescent = 6
-hooverErrRenderBegin = 2
-airNoDio_ptr = 8
-nrrdUnaryOpAsin = 6
-pullStatusLast = 5
-pullPropUnknown = 0
-pullStatusEdge = 4
-pullStatusNixMe = 3
+pullIterParmUnknown = 0
+pullPropIdtag = 1
+pullCondConstraintSatB = 3
+pullCondConstraintSatA = 2
+pullCondOld = 1
+pullCondUnknown = 0
+nrrdKindLast = 32
+pullEnergyTypeLast = 14
+coilKindTypeScalar = 1
+tijk_class_esh = 2
+pullEnergyTypeQuarticWell = 10
+tenGageFANormal = 53
+pullEnergyTypeBetterCubicWell = 9
+pullEnergyTypeCubicWell = 8
 pullStatusNewbie = 2
-pullStatusStuck = 1
-nrrdUnaryOpTan = 5
-pullIterParmStuckMax = 3
-tenGageConfidence = 2
-miteValYw = 3
-nrrdUnaryOpCos = 4
-nrrdAxisInfoUnits = 10
-pullInfoLast = 24
-pullInfoQuality = 23
-tenGageInvarRGradMags = 69
-tenGageFADiffusionFraction = 153
-pullInfoIsovalueGradient = 20
-pullInfoIsovalue = 19
-pullInfoNegativeTangent1 = 17
-pullInfoTangent2 = 16
-pullInfoTangent1 = 15
-nrrdUnaryOpReciprocal = 2
-gageErrStackUnused = 6
-pullInfoLiveThresh3 = 14
-pullInfoLiveThresh = 12
-pullInfoSeedThresh = 11
-gageCtxFlagKernel = 4
-pullInfoSeedPreThresh = 10
-nrrdUnaryOpNegative = 1
-pullInfoHeightGradient = 7
-pullInfoHeight = 6
-gageCtxFlagNeedK = 3
-pullInfoHessian = 3
-nrrdUnaryOpUnknown = 0
-pullInfoTensorInverse = 2
-pullInfoTensor = 1
-pullInfoUnknown = 0
-miteValXi = 2
-airNoDio_okay = 0
-limnPolyDataInfoTang = 4
-tenGageCp1HessianEval = 188
-nrrdBinaryOpLast = 24
-nrrdUnaryOpLast = 31
-nrrdUnaryOpOne = 30
-nrrdUnaryOpZero = 29
-nrrdUnaryOpNormalRand = 27
-nrrdUnaryOpRand = 26
-nrrdUnaryOpSgn = 24
-nrrdUnaryOpAbs = 23
-gageErrLast = 7
-nrrdUnaryOpFloor = 20
-nrrdUnaryOpNerf = 18
-nrrdUnaryOpCbrt = 16
-nrrdUnaryOpSqrt = 15
-nrrdUnaryOpExpm1 = 14
-nrrdUnaryOpLog1p = 13
+pullEnergyTypeQuartic = 7
+pullEnergyTypeCubic = 6
+gageSigmaSamplingLast = 4
+tenGageConfGradVecDotEvec0 = 157
+pullEnergyTypeButterworth = 4
+pullEnergyTypeGauss = 2
+pullEnergyTypeUnknown = 0
+pullPropLast = 18
+pullPropStability = 17
+pullInterTypeLast = 5
+pullPropNeighCovar7Ten = 12
+pullPropNeighCovar = 11
+pullPropStuck = 6
+pullPropStepConstr = 5
+pullPropStepEnergy = 4
+limnEdgeTypeBorder = 6
+pullPropEnergy = 3
+tenGageOmegaGradVecDotEvec0 = 154
+airEndianBig = 4321
+airEndianLittle = 1234
+pullPropUnknown = 0
+coilKindTypeUnknown = 0
+nrrdKind2DMaskedSymMatrix = 25
+pullFlagScaleIsTau = 13
+echoMatterLast = 5
+echoMatterLight = 4
+nrrdSpaceLeftAnteriorSuperior = 2
+echoMatterMetal = 3
+echoMatterGlass = 2
+echoMatterPhong = 1
+echoMatterUnknown = 0
+pullInterTypeUnknown = 0
+airMopAlways = 3
+airTypeSize_t = 6
+airMopNever = 0
+tenAniso_Ct2 = 13
+tenGageTensorGradRotE = 176
+nrrdSpaceUnknown = 0
+miteStageOpLast = 5
+nrrdMeasureSD = 15
+miteStageOpAdd = 3
+miteStageOpMax = 2
+tenGageEvalGrads = 72
+miteStageOpMin = 1
+pullConstraintFailHessZeroB = 2
+mossFlagKernel = 1
+limnSplineInfoNormal = 4
 airNoDio_disable = 12
 airNoDio_test = 11
-airNoDio_setfl = 10
 airNoDio_fpos = 9
-nrrdUnaryOpAcos = 7
-airNoDio_size = 7
-airNoDio_small = 6
-tenGageTraceHessianEvec1 = 89
-tenGageInvarKGradMags = 67
-airNoDio_dioinfo = 5
-nrrdUnaryOpSin = 3
-airNoDio_std = 3
-airNoDio_format = 2
-tenTripleTypeWheelParm = 9
-miteShadeMethodLitTen = 3
-tenTripleTypeR = 8
-tenTripleTypeK = 7
-tenTripleTypeJ = 6
-tenTripleTypeEigenvalue = 1
-tenTripleTypeRThetaPhi = 5
-tenTripleTypeRThetaZ = 4
-tenTripleTypeXYZ = 3
-tenTripleTypeMoment = 2
-echoMatterLast = 5
-tenTripleTypeUnknown = 0
-echoMatterLight = 4
-airFP_Last = 11
+hooverErrSample = 6
+hooverErrRayBegin = 5
+nrrdKindRGBAColor = 18
+airNoDio_fd = 4
+hooverErrInit = 1
+limnSplineInfo2Vector = 2
+tenDwiGage2TensorPeledAndError = 34
+tenAniso_Cs2 = 12
+tenDwiGage2TensorPeled = 32
+tenDwiGage2TensorQSegAndError = 31
+tenDwiGage2TensorQSeg = 29
+tenDwiGageTensorAllDWIError = 28
+tenFiberTypeLast = 7
+tenDwiGageFA = 27
+tenDwiGageTensorError = 23
+tenGageOmegaLaplacian = 143
+tenDwiGageTensorMLELikelihood = 21
+nrrdKindHSVColor = 15
+tenDwiGageTensorMLEErrorLog = 20
+pullInfoInside = 4
+nrrdField_dimension = 6
+tenDwiGageTensorMLE = 18
 airFP_NEG_ZERO = 10
-pullFlagScaleIsTau = 12
-airFP_NEG_DENORM = 8
-airFP_POS_DENORM = 7
-pullFlagPopCntlEnoughTest = 9
-tenInterpTypeRThetaPhiLinear = 11
+airFP_POS_ZERO = 9
+tenDwiGageTensorNLS = 14
+airFP_NEG_NORM = 6
+airFP_POS_NORM = 5
 airFP_NEG_INF = 4
 airFP_POS_INF = 3
 airFP_QNAN = 2
-tenGageInvarKGrads = 66
-tenInterpTypeLoxK = 7
-tenDwiGageAll = 1
-tenInterpTypeGeoLoxR = 6
-tenInterpTypeGeoLoxK = 5
-pullFlagPermuteOnRebin = 1
-dyeSpaceLast = 7
-echoMatterPhong = 1
-tenInterpTypeLinear = 1
-tenInterpTypeUnknown = 0
-dyeSpaceXYZ = 4
-dyeSpaceRGB = 3
-dyeSpaceHSL = 2
-dyeSpaceUnknown = 0
-miteValTi = 10
-pushEnergyTypeSpring = 1
-pushEnergyTypeUnknown = 0
-limnPolyDataInfoRGBA = 1
-seekTypeValleySurfaceOP = 10
-tenGageOmegaNormal = 65
-pullFlagStartSkipsPoints = 13
-pullFlagAllowCodimension3Constraints = 11
-gageVecLast = 32
-gageVecMGEvec = 31
-gageVecMultiGrad = 28
-pullFlagBinSingle = 10
-gageVecGradient2 = 27
-gageVecGradient0 = 25
-gageVecProjHelGradient = 24
-gageVecDirHelDeriv = 23
-pullCondNew = 7
-gageVecNCurlNormGrad = 21
-gageVecCurlNormGrad = 20
-gageVecCurlGradient = 19
-gageVecDivGradient = 18
-gageSclFlowlineCurv = 31
-gageVecHessian = 17
-nrrdTernaryOpLast = 17
-gageVecImaginaryPart = 16
-gageVecLambda2 = 15
-gageVecSOmega = 14
-gageVecNormHelicity = 13
-gageVecHelicity = 12
-gageParmGradMagCurvMin = 5
-gageVecCurlNorm = 11
-gageVecCurl = 10
-gageVecDivergence = 9
-gageVecStrain = 8
-gageVecJacobian = 7
-gageVecNormalized = 6
-gageParmK3Pack = 4
-gageVecLength = 5
-tijk_class_last = 4
-gageVecVector1 = 3
-gageVecVector0 = 2
-gageVecVector = 1
-gageVecUnknown = 0
-gageItemPackPartNormal = 4
-pullFlagEnergyFromStrength = 5
-pullFlagRestrictiveAddToBins = 4
-nrrdAxisInfoLast = 11
-limnSpaceLast = 5
-miteRangeUnknown = -1
-seekTypeRidgeSurfaceOP = 8
-tenGageOmegaGradVec = 63
-tenEstimate2MethodLast = 3
-nrrdBinaryOpRicianRand = 23
-nrrdTernaryOpRician = 16
-tenEstimate2MethodPeled = 2
-nrrdBasicInfoContent = 5
-pullFlagUseBetaForGammaLearn = 3
-tenEstimate2MethodQSegLLS = 1
-nrrdHasNonExistUnknown = 3
-nrrdTypeULLong = 8
-gageItemPackPartGradMag = 3
-gageKernelUnknown = 0
-pullFlagUnknown = 0
-pullIterParmEnergyIncreasePermitHalfLife = 9
-tenInterpTypeLogLinear = 2
-limnSpaceDevice = 4
-nrrdTernaryOpGaussian = 15
-nrrdMeasureHistoMedian = 23
-tenDwiGageUnknown = 0
-baneClipTopN = 4
-airTypeChar = 9
-airEndianLast = 4322
+tenGageFA2ndDD = 112
+airFP_SNAN = 1
+limnPrimitiveTriangles = 2
+airFP_Unknown = 0
+tenDwiGageTensorLLS = 6
+tenDwiGageMeanDWIValue = 5
+tenDwiGageADC = 4
+seekTypeValleyLine = 5
+tenDwiGageJustDWI = 3
+nrrdKind2Vector = 12
+tenDwiGageB0 = 2
+airNoDio_ptr = 8
 airMopOnOkay = 2
-nrrdBinaryOpNormalRandScaleAdd = 22
-nrrdMeasureLast = 30
-nrrdTypeChar = 1
-gageSclLast = 36
-tenGageOmegaDiffusionAlign = 155
-dyeSpaceHSV = 1
-limnEdgeTypeLast = 8
-nrrdTypeUnknown = 0
+baneMeasrFlowlineCurv = 8
+tenGageCa1HessianEval2 = 200
+tenGageOmegaHessianEvec = 139
+baneMeasrTotalCurv = 7
+baneMeasr2ndDD = 6
+baneMeasrLaplacian = 5
+baneMeasrGradMag = 4
+baneMeasrValueAnywhere = 3
+baneMeasrValueZeroCentered = 2
+tenGageOmegaHessianEval2 = 138
+baneMeasrValuePositive = 1
+echoTypeAABBox = 8
+baneMeasrUnknown = 0
+nrrdField_block_size = 5
 nrrdBinaryOpIf = 21
-nrrdTernaryOpInOpen = 13
-limnEdgeTypeContour = 3
-nrrdBoundaryMirror = 5
-nrrdResampleNonExistentLast = 4
-nrrdBoundaryWeight = 4
-tenGageLast = 208
-alanParmLast = 22
-tenGageAniso = 207
-tenGageFiberDispersion = 206
-tenGageCa1HessianEvec2 = 204
-nrrdBoundaryWrap = 3
-tenGageCa1HessianEvec0 = 202
+alanParmTextureType = 2
+nrrdSpaceLeftPosteriorSuperior = 3
+gageErrLast = 7
 nrrdBinaryOpExists = 20
-tenGageCa1HessianEval1 = 199
-tenGageCa1HessianEval = 197
-tenGageCa1Hessian = 196
-tenGageCp1HessianEvec2 = 195
-nrrdKind3DMatrix = 30
-limnSpaceWorld = 1
-coilMethodTypeLast = 9
-seekTypeRidgeLine = 4
-tenGageCp1HessianEval2 = 191
-nrrdBoundaryPad = 1
-tenGageCp1HessianEval1 = 190
-gageSclHessValleyness = 33
-tenGageCp1HessianEval0 = 189
-nrrdZlibStrategyFiltered = 3
-airTypeSize_t = 6
-pullInitMethodLast = 5
-nrrdBasicInfoKeyValuePairs = 15
-pullTraceStopLast = 6
-gageParmOrientationFromSpacing = 13
-pullTraceStopConstrFail = 2
-pullTraceStopSpeeding = 1
-alanParmWrapAround = 21
-pullSourceLast = 3
-pullSourceProp = 2
-pullSourceGage = 1
-pullSourceUnknown = 0
+gageErrStackUnused = 6
+limnPrimitiveNoop = 1
 nrrdBinaryOpNotEqual = 19
-pullEnergyTypeButterworthParabola = 13
-pullEnergyTypeBetterCubicWell = 9
-pullEnergyTypeCotan = 5
-pullEnergyTypeBspln = 3
-pullEnergyTypeGauss = 2
-pullInitMethodGivenPos = 4
-gageParmStackNormalizeRecon = 12
-echoJitterLast = 4
-alanParmConstantFilename = 20
-gagePvlFlagNeedD = 3
-gagePvlFlagQuery = 2
-nrrdBinaryOpEqual = 18
-tenDwiGage2TensorPeledLevmarInfo = 35
-hooverErrThreadBegin = 4
-tenGageModeGradVec = 57
-hooverErrRenderEnd = 10
-tenDwiGage2TensorPeled = 32
-tenDwiGage2TensorQSegAndError = 31
-tenDwiGage2TensorQSegError = 30
-tenDwiGage2TensorQSeg = 29
-pullInitMethodPointPerVoxel = 3
-tenDwiGageTensorAllDWIError = 28
-nrrdBasicInfoOldMax = 13
-gageSclHessEvec0 = 16
-seekTypeMinimalSurface = 6
-gageSclHessEvec = 15
-gageSclHessEval1 = 13
-gageSclHessEval0 = 12
-gageSclHessEval = 11
-gageSclHessFrob = 10
-gageSclLaplacian = 9
-gageSclHessianTen = 8
-nrrdBinaryOpCompare = 17
-gageSclHessian = 7
-gageSclNPerp = 6
-gageSclNProj = 5
-gageSclNormal = 4
-echoJittableNormalA = 3
-coilKindTypeLast = 4
-gageSclGradMag = 3
-gageSclGradVec = 2
-gageSclUnknown = 0
-tenGageCa1HessianEvec = 201
-gageKernelLast = 8
-gageKernel21 = 5
-gageKernel20 = 4
-gageKernel11 = 3
-gageKernel10 = 2
-pushEnergyTypeLast = 6
-gageCtxFlagRadius = 5
-gageCtxFlagLast = 7
-alanParmAlpha = 18
-gageCtxFlagK3Pack = 2
-gageCtxFlagNeedD = 1
-nrrdBinaryOpGTE = 16
-gageErrStackSearch = 5
-tenAnisoLast = 30
-gageErrStackIntegral = 4
-gageErrBoundsStack = 3
-gageErrBoundsSpace = 2
-gageErrNone = 1
-gageErrUnknown = 0
-gageParmLast = 15
-gageParmGenerateErrStr = 14
-miteStageOpMax = 2
-nrrdTernaryOpGTSmooth = 8
-gageParmStackNormalizeDerivBias = 11
-gageParmStackNormalizeDeriv = 10
-gageParmStackUse = 9
-gageParmDefaultCenter = 8
-gageParmKernelIntegralNearZero = 7
-gageParmCurvNormalSide = 6
-gageParmCheckIntegrals = 3
-alanParmMaxPixelChange = 17
-tenGageCp1Hessian = 187
-airEndianBig = 4321
-nrrdBinaryOpGT = 15
-airEndianLittle = 1234
-airEndianUnknown = 0
-tenGageCl1HessianEvec2 = 186
-nrrdBoundaryLast = 6
-nrrdBoundaryBleed = 2
-tenFiberStopMinNumSteps = 10
-nrrdBoundaryUnknown = 0
-gageVecMGEval = 30
-echoJittableLast = 7
-echoJittableMotionB = 6
-gageVecMGFrob = 29
-echoJittableMotionA = 5
-echoJittableNormalB = 4
-echoJittableLens = 2
-echoJittableLight = 1
-tenGageModeNormal = 59
-echoJittablePixel = 0
+tenAniso_Ca2 = 10
+tenGageCl1Hessian = 178
+tenGageCp1 = 74
+nrrdFormatTypePNM = 2
+tenFiberTypePureLine = 5
+limnCameraPathTrackLast = 4
+gageSclHessRidgeness = 34
+tenGlyphTypeSuperquad = 4
+nrrdField_type = 4
+gageSclGeomTens = 20
+tenGlyphTypeBox = 1
+tenGlyphTypeUnknown = 0
+nrrdBasicInfoBlocksize = 3
+miteStageOpMultiply = 4
 nrrdBinaryOpLTE = 14
-echoJittableUnknown = -1
-limnSplineInfoNormal = 4
-pullProcessModeLast = 5
-limnPolyDataInfoLast = 5
-tenAniso_eval1 = 28
-pullProcessModeNixing = 4
-pullProcessModeAdding = 3
-pullProcessModeNeighLearn = 2
-pullProcessModeDescent = 1
-nrrdMeasureHistoSD = 29
-nrrdMeasureHistoVariance = 28
-nrrdMeasureHistoL2 = 27
-gageVecGradient1 = 26
-nrrdMeasureHistoSum = 26
-nrrdMeasureHistoProduct = 25
-nrrdMeasureHistoMode = 24
-nrrdMeasureHistoMean = 22
-nrrdMeasureHistoMax = 21
-nrrdMeasureHistoMin = 20
-nrrdMeasureLineError = 19
-nrrdMeasureLineIntercept = 18
-nrrdMeasureSkew = 16
+tenAniso_Cp2 = 9
 tenGageEvalHessian = 177
+airNoDio_size = 7
+alanTextureTypeLast = 3
+alanTextureTypeTuring = 1
+tenFiberParmUseIndexSpace = 2
+limnPrimitiveUnknown = 0
 airTypeLast = 13
-airTypeOther = 12
-nrrdMeasureRootMeanSquare = 11
-nrrdMeasureNormalizedL2 = 10
-nrrdMeasureL2 = 9
-limnSplineInfo3Vector = 3
+airTypeEnum = 11
+tenAnisoUnknown = 0
+airTypeChar = 9
 airTypeDouble = 8
-tenGageTensorGradRotE = 176
+gageSclHessValleyness = 33
+pushEnergyTypeSpring = 1
 airTypeFloat = 7
-nrrdMeasureProduct = 6
-coilKindTypeUnknown = 0
-nrrdMeasureMode = 5
-nrrdMeasureMedian = 4
-gageVecHelGradient = 22
-nrrdMeasureMean = 3
-airTypeInt = 2
-tenGageCa1Normal = 175
-nrrdMeasureMin = 1
-nrrdMeasureUnknown = 0
-nrrdOriginStatusLast = 5
+pushEnergyTypeUnknown = 0
+echoTypeIsosurface = 7
+airTypeULongInt = 5
+echoMatterMetalR0 = 0
+airTypeLongInt = 4
+airTypeBool = 1
+tenGageModeHessianEval0 = 126
+tenFiberParmVerbose = 4
+tenGageModeHessianEval = 125
+tenFiberParmWPunct = 3
+tenAniso_Cl2 = 8
+airNoDio_small = 6
+mossFlagLast = 2
+tenFiberParmUnknown = 0
+tenFiberParmStepSize = 1
+pushEnergyTypeZero = 5
 nrrdOriginStatusOkay = 4
-nrrdOriginStatusNoMaxOrSpacing = 3
-nrrdOriginStatusNoMin = 2
+mossFlagImage = 0
 nrrdOriginStatusDirection = 1
 nrrdOriginStatusUnknown = 0
-tenGageFAGaussCurv = 119
+nrrdSpacingStatusLast = 5
+nrrdFFTWPlanRigorLast = 5
+nrrdSpacingStatusDirection = 4
+tenGageDelNormR2 = 26
+nrrdSpacingStatusScalarWithSpace = 3
+nrrdSpacingStatusScalarNoSpace = 2
+nrrdBinaryOpPow = 5
+nrrdSpacingStatusNone = 1
+nrrdBasicInfoLast = 16
+nrrdBinaryOpDivide = 4
+tenAniso_Ct1 = 7
+tenDwiFiberType1Evec0 = 1
+pullCountLast = 15
+tenGageCa1Normal = 175
+airNoDio_dioinfo = 5
+nrrdBasicInfoOldMin = 12
+nrrdBasicInfoMeasurementFrame = 11
+nrrdBasicInfoSpaceOrigin = 10
+nrrdBinaryOpMultiply = 3
+nrrdBasicInfoSpaceDimension = 8
+nrrdBasicInfoSpace = 7
+hooverErrRenderEnd = 10
+nrrdBinaryOpSubtract = 2
+nrrdBasicInfoType = 2
+nrrdBasicInfoData = 1
+tenGageDelNormR1 = 25
+nrrdBasicInfoUnknown = 0
+pullInfoIsovalueGradient = 20
+hooverErrRayEnd = 7
+tenAniso_Cs1 = 6
+pullCountIteration = 14
+limnSplineTypeLast = 6
+nrrdKindQuaternion = 23
+limnSplineTypeCubicBezier = 4
+limnSpaceDevice = 4
+limnSplineTypeHermite = 3
+limnSpaceLast = 5
+limnSplineTypeLinear = 1
+limnSplineTypeUnknown = 0
+nrrdTypeUInt = 6
 limnSpaceView = 2
-miteRangeGreen = 2
-nrrdField_last = 33
-nrrdField_data_file = 32
-nrrdSpace3DLeftHanded = 10
-seekTypeValleyLine = 5
-alanParmF = 15
-airMopNever = 0
-nrrdField_sample_units = 28
-nrrdField_keyvalue = 27
-nrrdField_byte_skip = 26
-limnEdgeTypeFrontCrease = 4
-pullSysParmTheta = 5
-pullFlagLast = 14
-nrrdField_old_max = 22
-nrrdField_old_min = 21
-tenGageCp1GradMag = 171
-nrrdField_max = 20
-nrrdMeasureLineSlope = 17
-nrrdField_units = 18
-nrrdField_labels = 17
-tenGageTraceHessianEval1 = 85
-nrrdField_centers = 15
+alanStopConverged = 4
+hooverErrThreadBegin = 4
+pullInfoIsovalue = 19
+alanStopMaxIteration = 2
+tenGageFARidgeSurfaceAlignment = 111
+limnSpaceWorld = 1
 limnSpaceUnknown = 0
-nrrdField_space_directions = 14
-gageSclHessRidgeness = 34
-nrrdField_axis_mins = 12
-nrrdField_thicknesses = 11
-nrrdTernaryOpMinSmooth = 4
-nrrdField_sizes = 9
-gageSclCurvDir1 = 29
-nrrdField_space_dimension = 8
-nrrdField_space = 7
-nrrdMeasureCoV = 15
-nrrdField_dimension = 6
-nrrdField_type = 4
-echoMatterMetalR0 = 0
-tenFiberParmUnknown = 0
-nrrdField_content = 2
-nrrdField_comment = 1
-nrrdMeasureSD = 14
-nrrdField_unknown = 0
-alanParmK = 14
-nrrdKind3DSymMatrix = 28
-tenGageTensorRThetaPhiLinear = 166
-nrrdKind2DMaskedSymMatrix = 25
-nrrdMeasureVariance = 13
-nrrdKind4Vector = 22
-nrrdKind3Normal = 21
-nrrdKind3Gradient = 20
-gageSclShapeTrace = 25
-nrrdKind3Vector = 19
-nrrdKindRGBAColor = 18
-nrrdMeasureLinf = 12
-nrrdKind4Color = 17
-miteStageOpMin = 1
-nrrdKindXYZColor = 16
-nrrdKindHSVColor = 15
-nrrdKindRGBColor = 14
-gageSclTotalCurv = 24
-nrrdKind3Color = 13
-airTypeEnum = 11
-nrrdKindComplex = 11
-nrrdKindScalar = 10
-nrrdKindStub = 9
-tenGageTensorLogEuclidean = 163
-airInsane_QNaNHiBit = 6
-nrrdKindCovariantVector = 7
-nrrdKindVector = 6
-airTypeString = 10
-nrrdKindPoint = 5
-nrrdKindList = 4
-nrrdKindTime = 3
-nrrdKindSpace = 2
-nrrdKindDomain = 1
-alanStopNonExist = 3
-tenGageCovarianceRGRT = 161
-nrrdMeasureL1 = 8
-gageSclGeomTens = 20
-nrrdMeasureSum = 7
-nrrdTernaryOpMultiply = 2
-gageScl2ndDD = 19
-pullConstraintFailIterMaxed = 3
-airTypeULongInt = 5
-gageVecVector2 = 4
-airTypeLongInt = 4
-tenGageModeGradMag = 58
-airTypeUInt = 3
-tijk_class_esh = 2
-limnSplineInfoLast = 7
-limnSplineInfoQuaternion = 6
-limnPrimitiveTriangles = 2
-limnSplineInfo4Vector = 5
-nrrdMeasureMax = 2
-mossFlagImage = 0
-mossFlagUnknown = -1
-gageSclK1 = 22
-tijk_class_tensor = 1
-limnSplineInfo2Vector = 2
-limnSplineInfoScalar = 1
-limnSplineInfoUnknown = 0
-airTypeBool = 1
-tenDwiGageTensorWLSError = 11
-tijk_class_unknown = 0
+airNoDio_std = 3
+tenDwiGageLast = 36
+tenDwiGage2TensorPeledLevmarInfo = 35
+alanParmWrapAround = 21
+alanParmConstantFilename = 20
+alanParmAlpha = 18
+tenGageFALaplacian = 108
+pullCountPointsStuck = 11
+alanParmReact = 13
+airNoDio_okay = 0
+nrrdCenterLast = 3
+alanParmDiffA = 11
+alanParmDeltaX = 10
+tenGageCl1GradVec = 167
+airTypeInt = 2
+alanParmDeltaT = 9
+pullCountNixing = 10
+alanParmRandRange = 8
+alanParmSaveInterval = 6
+dyeSpaceLAB = 5
+alanParmFrameInterval = 4
+tenDwiGageTensorLLSErrorLog = 8
+limnEdgeTypeLast = 8
+airNoDio_format = 2
+dyeSpaceXYZ = 4
+pullCountConstraintSatisfy = 8
+tenDwiGage2TensorQSegError = 30
+nrrdMeasureL4 = 10
+pullConstraintFailProjGradZeroB = 4
+nrrdCenterCell = 2
+limnEdgeTypeFrontCrease = 4
+dyeSpaceLast = 7
+nrrdIoStateLast = 10
 nrrdIoStateBzip2BlockSize = 9
-airTypeUnknown = 0
 nrrdIoStateZlibStrategy = 8
+limnEdgeTypeContour = 3
 nrrdIoStateZlibLevel = 7
+airNoDio_arch = 1
+tenGageCa1GradMag = 174
 nrrdIoStateKeepNrrdDataFileOpen = 6
 nrrdIoStateSkipData = 5
 nrrdIoStateValsPerLine = 4
 nrrdIoStateCharsPerLine = 3
 nrrdIoStateBareText = 2
+pullCountEnergyFromImage = 3
 nrrdIoStateDetachedHeader = 1
-nrrdIoStateUnknown = 0
-pullIterParmMin = 1
-miteShadeMethodLast = 4
-tenFiberTypeEvec2 = 3
-nrrdBasicInfoBlocksize = 3
-limnSplineTypeLast = 6
-nrrdFormatTypeEPS = 6
-miteShadeMethodPhong = 2
-nrrdFormatTypeVTK = 4
+tenGageFAHessianEval0 = 98
+limnEdgeTypeBackFacet = 1
+pullCountDescent = 1
+nrrdBasicInfoDimension = 4
 nrrdCenterNode = 1
-nrrdFormatTypePNM = 2
-tenAniso_S = 20
-nrrdFormatTypeNRRD = 1
-nrrdFormatTypeUnknown = 0
-miteShadeMethodNone = 1
-nrrdBinaryOpSgnPow = 6
-nrrdSpacingStatusLast = 5
-limnSplineTypeHermite = 3
-tenGageSGradMag = 46
-tenGageTensorQuatGeoLoxK = 164
-seekTypeLast = 12
-seekTypeValleySurfaceT = 11
-nrrdTernaryOpExists = 12
-nrrdBasicInfoType = 2
-seekTypeMaximalSurface = 7
-limnPrimitiveLineStrip = 6
-seekTypeRidgeSurface = 2
-seekTypeIsocontour = 1
-seekTypeUnknown = 0
+pullInfoTangent2 = 16
+tenGageQHessian = 95
+tenAniso_Cl1 = 2
+tenGageCl1HessianEvec2 = 186
+tenGageCa1HessianEvec = 201
+tenDwiGageTensorMLEError = 19
+limnSplineInfo3Vector = 3
+nrrdCenterUnknown = 0
+nrrdEncodingTypeAscii = 2
+pullCountUnknown = 0
+tenGageCovariance = 160
+tenDwiGageTensorNLSLikelihood = 17
+tenTripleTypeMoment = 2
+gageSigmaSamplingUniformSigma = 1
+tenDwiGageTensorNLSError = 15
+tenInterpTypeLast = 12
+limnDeviceGL = 2
+airFP_POS_DENORM = 7
+tenInterpTypeRThetaPhiLinear = 11
+pullIterParmMax = 2
+echoTypeLast = 12
+echoTypeInstance = 11
+tenDwiGageTensorWLSErrorLog = 12
+echoTypeList = 10
 echoTypeSplit = 9
-pullSysParmWall = 18
-pullFlagNoAdd = 8
-pullEnergyTypeSpring = 1
-echoTypeIsosurface = 7
-pullPropIdCC = 2
+pullInfoInsideGradient = 5
+echoTypeTriMesh = 6
 echoTypeRectangle = 5
-pullSysParmEnergyDecreasePopCntlMin = 14
-tenGageRotTanMags = 71
+ell_cubic_root_last = 5
+echoTypeTriangle = 4
 echoTypeCube = 3
-echoTypeSuperquad = 2
+tenInterpTypeLoxR = 8
 echoTypeCylinder = 1
-pullSysParmNeighborTrueProb = 10
+echoTypeSphere = 0
 echoTypeUnknown = -1
-pullSysParmRadiusScale = 8
-pullSysParmRadiusSpace = 7
-miteStageOpUnknown = 0
-pullSysParmSeparableGammaLearnRescale = 4
-pullPropStability = 17
-miteRangeLast = 9
-pullPropNeighCovarDet = 16
-hooverErrInit = 1
-nrrdField_space_units = 29
-pullSysParmAlpha = 1
-tenGageFA2ndDD = 112
-airNoDio_fd = 4
-pullPropNeighInterNum = 14
-nrrdBasicInfoData = 1
-pullPropNeighTanCovar = 13
-pullPropNeighCovar7Ten = 12
-limnPrimitiveNoop = 1
-pullPropScale = 10
-pullPropNeighDistMean = 9
-alanParmRandRange = 8
-miteRangeRed = 1
-pullPropStuck = 6
-limnPrimitiveUnknown = 0
-pullPropEnergy = 3
-pullFlagConstraintBeforeSeedThresh = 7
-pullPropIdtag = 1
-pullCondConstraintSatB = 3
-unrrduScaleLast = 8
-nrrdField_line_skip = 25
-airInsane_NaNExists = 4
-nrrdField_encoding = 24
-tenGageFARidgeSurfaceAlignment = 111
-alanStopLast = 6
-unrrduScaleAspectRatio = 6
-tijk_class_efs = 3
-nrrdField_endian = 23
-alanParmMaxIteration = 7
-nrrdBinaryOpDivide = 4
-pullFlagNixAtVolumeEdgeSpace = 6
-airInsane_nInfExists = 3
-unrrduScaleMultiply = 2
-pullTraceStopStub = 5
-nrrdField_min = 19
-alanStopDiverged = 5
-unrrduScaleNothing = 1
+ell_cubic_root_three = 4
+pullFlagPermuteOnRebin = 1
+tenInterpTypeLoxK = 7
+echoTypeSuperquad = 2
+ell_cubic_root_single_double = 3
+pullConstraintFailUnknown = 0
+ell_cubic_root_triple = 2
+ell_cubic_root_single = 1
+tenDwiGageTensorLLSError = 7
+echoJitterRandom = 3
+pullCountProbe = 7
+echoJitterJitter = 2
+echoJitterGrid = 1
+ell_cubic_root_unknown = 0
+echoJitterNone = 0
+echoJitterUnknown = -1
+tenInterpTypeLogLinear = 2
+limnDeviceUnknown = 0
+limnSplineInfoUnknown = 0
+gageKernelLast = 8
+tenGageEval1 = 17
+pullInfoLiveThresh = 12
+tenInterpTypeUnknown = 0
+nrrdBinaryOpLast = 24
+coilMethodTypeLast = 9
+tenDwiGageUnknown = 0
+tenGageFAHessianFrob = 105
+gageSigmaSamplingOptimal3DL2L2 = 3
+tenFiberIntgLast = 4
+tenTripleTypeRThetaZ = 4
+tenGageTensorQuatGeoLoxK = 164
+echoMatterGlassFuzzy = 3
+echoMatterGlassKa = 1
+gageKernel11 = 3
+pullEnergyTypeButterworthParabola = 13
+gageKernel10 = 2
+tenFiberStopLast = 11
+miteValGTdotV = 16
+tenFiberStopMinNumSteps = 10
+tenFiberStopMinLength = 9
+gageKernel00 = 1
+tenFiberStopStub = 8
+tenFiberStopFraction = 7
+tenFiberStopRadius = 5
+miteValVrefN = 15
+tenFiberStopConfidence = 4
+tenFiberStopNumSteps = 3
+baneIncUnknown = 0
+nrrdAxisInfoLast = 11
+nrrdAxisInfoUnits = 10
+nrrdAxisInfoLabel = 9
+nrrdFormatTypeLast = 7
+nrrdAxisInfoKind = 8
+miteValNdotL = 14
+nrrdAxisInfoCenter = 7
+nrrdAxisInfoSpaceDirection = 6
+tenGageFAGradMag = 52
+nrrdAxisInfoMax = 5
+nrrdAxisInfoMin = 4
+nrrdAxisInfoThickness = 3
+pullInfoSeedPreThresh = 10
+nrrdAxisInfoSpacing = 2
+miteValNdotV = 13
+nrrdAxisInfoSize = 1
+nrrdAxisInfoUnknown = 0
+tenGageFAGradVec = 51
+tenGageTraceHessianEvec2 = 90
+gagePvlFlagQuery = 2
 limnDeviceLast = 3
-unrrduScaleUnknown = 0
-pullSysParmLast = 20
-echoTypeLast = 12
-tenInterpTypeQuatGeoLoxR = 10
-alanTextureTypeTuring = 1
-echoMatterGlassKd = 2
-tenGageFAHessianEvalMode = 109
-tenDwiGageFA = 27
-baneIncLast = 5
+limnDevicePS = 1
+miteRangeSP = 8
+gagePvlFlagUnknown = 0
+tenFiberIntgMidpoint = 2
+miteRangeKs = 7
+miteValTw = 9
+nrrdMeasureMean = 3
+gageCtxFlagLast = 7
+miteRangeKd = 6
+miteValRi = 8
+tenFiberStopAniso = 1
+tenGageFAHessian = 96
+tenFiberStopUnknown = 0
 tenGageCl1HessianEvec = 183
+tenFiberTypeZhukov = 6
+tenGageSGradVec = 45
+tenFiberTypeTensorLine = 4
+tenGageTensorLogEuclidean = 163
+tenFiberTypeEvec2 = 3
+tenFiberTypeEvec1 = 2
+tenFiberTypeEvec0 = 1
+tenFiberStopBounds = 6
+miteValZw = 5
+gageCtxFlagNeedK = 3
+miteValYi = 4
+gageCtxFlagK3Pack = 2
+nrrdZlibStrategyLast = 4
+tenGageBNormal = 41
+nrrdZlibStrategyHuffman = 2
+nrrdZlibStrategyDefault = 1
+nrrdZlibStrategyUnknown = 0
+limnPolyDataInfoLast = 5
+gageCtxFlagUnknown = 0
+limnPolyDataInfoTang = 4
+limnPolyDataInfoTex2 = 3
+limnPolyDataInfoNorm = 2
+miteValXw = 1
+limnPolyDataInfoUnknown = 0
+tenEstimate1MethodLast = 5
+tenEstimate1MethodNLS = 3
+tenEstimate1MethodWLS = 2
+tenEstimate1MethodLLS = 1
+tenEstimate1MethodUnknown = 0
+tenGageNormNormal = 38
+gageSclHessEvec2 = 18
+tenFiberIntgUnknown = 0
+gageItemPackPartHessEvec2 = 11
+tenAnisoLast = 30
+tenAniso_eval2 = 29
+tenAniso_eval0 = 27
+nrrdEncodingTypeHex = 3
+tenAniso_Omega = 24
+tenAniso_Th = 23
+tenGageNormGradVec = 36
+tenAniso_Mode = 22
+tenGageSHessian = 94
+tenAniso_Skew = 21
+seekTypeUnknown = 0
+tenAniso_S = 20
+nrrdBinaryOpRicianRand = 23
+tenGageTraceNormal = 35
+tenGageCovarianceRGRT = 161
+tenAniso_FA = 15
+tenAniso_RA = 14
+gageParmStackNormalizeRecon = 12
+gageErrStackSearch = 5
+tenGageAniso = 207
+gageParmStackNormalizeDerivBias = 11
+tenAniso_Clpmin1 = 5
+gageParmStackNormalizeDeriv = 10
+tenGageCa1HessianEval0 = 198
+pullInfoHeight = 6
+tenGageTensorGradMag = 31
+miteStageOpUnknown = 0
+pullEnergyTypeZero = 12
+gageParmDefaultCenter = 8
+gagePvlFlagVolume = 1
+nrrdSpace3DLeftHandedTime = 12
+tenGageRNormal = 56
+tenGageCl1HessianEvec0 = 184
+miteValZi = 6
 tenGageCl1HessianEval2 = 182
-nrrdField_axis_maxs = 13
 tenGageCl1HessianEval1 = 181
-alanParmHomogAniso = 5
-tenGageCl1HessianEval = 179
-tenGageCl1Hessian = 178
-tenDwiGageConfidence = 26
-tenGageCa1GradMag = 174
-nrrdBinaryOpSubtract = 2
+gageErrStackIntegral = 4
+limnQN11octa = 11
+gageParmCurvNormalSide = 6
 tenGageCa1GradVec = 173
-gageParmUnknown = 0
-tenGageCp1GradVec = 170
-tenInterpTypeQuatGeoLoxK = 9
+tenGageCp1Normal = 172
+gageParmGradMagCurvMin = 5
 tenGageCl1Normal = 169
-nrrdBinaryOpPow = 5
-tenGageCl1GradVec = 167
-baneMeasrValueAnywhere = 3
-tenGageTensorQuatGeoLoxR = 165
-nrrdField_spacings = 10
-tenGageCovarianceKGRT = 162
-nrrdSpaceLeftPosteriorSuperior = 3
-nrrdTernaryOpLerp = 11
-tenDwiGageTensor = 22
-baneIncStdv = 4
-nrrdCenterCell = 2
-tenFiberParmLast = 5
-nrrdCenterUnknown = 0
-gageSclHessEvec1 = 17
-limnSplineTypeBC = 5
-limnSplineTypeCubicBezier = 4
-nrrdBinaryOpAdd = 1
-limnSplineTypeLinear = 1
-limnSplineTypeUnknown = 0
-tenInterpTypeLast = 12
-tenInterpTypeLoxR = 8
-tenDwiGageTensorMLEError = 19
-nrrdField_block_size = 5
-nrrdSpaceLeftAnteriorSuperior = 2
-tenGageFALaplacian = 108
-alanStopMaxIteration = 2
-tenDwiGageTensorNLSLikelihood = 17
-nrrdField_number = 3
-tenDwiGageTensorLikelihood = 25
-tenDwiGageTensorError = 23
-tenDwiGageTensorMLEErrorLog = 20
-pullFlagNoPopCntlWithZeroAlpha = 2
-tenDwiGageTensorNLSErrorLog = 16
-tenDwiGageTensorNLSError = 15
+tenGageR = 10
+nrrdEncodingTypeRaw = 1
+limnPrimitiveLast = 8
+nrrdTypeBlock = 11
+limnPrimitiveLineStrip = 6
+gageParmK3Pack = 4
+limnPrimitiveQuads = 5
+limnPrimitiveTriangleFan = 4
+limnPrimitiveTriangleStrip = 3
+tenEstimate2MethodQSegLLS = 1
+nrrdKindNormal = 8
+gageParmCheckIntegrals = 3
 tenGageConfDiffusionFraction = 159
-tenGageConfDiffusionAlign = 158
-tenGageConfGradVecDotEvec0 = 157
-pullCondConstraintSatA = 2
-tenGageOmegaGradVecDotEvec0 = 154
-tenDwiGageTensorLLSErrorLog = 8
+tenGageRGradMag = 55
+tenGageOmegaDiffusionFraction = 156
+tenGageOmegaDiffusionAlign = 155
+tenGageFADiffusionFraction = 153
+gageParmRenormalize = 2
+tenGageFADiffusionAlign = 152
 tenGageFAGradVecDotEvec0 = 151
 tenGageTraceDiffusionFraction = 150
-tenDwiGageMeanDWIValue = 5
-nrrdSpaceRightAnteriorSuperior = 1
-tenDwiGageADC = 4
-miteRangeKs = 7
-tenDwiGageJustDWI = 3
-coilMethodTypePeronaMalik = 3
-tenGageFAValleySurfaceStrength = 107
-miteRangeKd = 6
-tenGageOmegaHessianEvec1 = 141
-nrrdKindLast = 32
-alanParmTextureType = 2
-tenGageOmegaHessianEval2 = 138
-tenGageOmegaHessianEval1 = 137
+tenGageTraceDiffusionAlign = 149
+tenGageTraceGradVecDotEvec0 = 148
+tenGageOmegaHessianContrTenEvec2 = 147
+gageParmVerbose = 1
+tenGageOmegaHessianContrTenEvec1 = 146
+tenGageEvec2 = 22
+tenAniso_R = 19
+nrrdEncodingTypeUnknown = 0
 tenGageOmegaHessianEval0 = 136
-tenGageOmegaHessianEval = 135
-tenGageOmegaHessian = 134
-nrrdKind3DMaskedMatrix = 31
+tenGageEvec1 = 21
 tenGageModeHessianFrob = 133
-pullSysParmEnergyDecreaseMin = 16
-tenGageModeHessianEvec1 = 131
+tenGageModeHessianEvec2 = 132
+nrrdTypeInt = 5
 tenGageModeHessianEvec0 = 130
-tenDwiGageTensorWLS = 10
 tenGageModeHessianEvec = 129
 tenGageModeHessianEval2 = 128
-tenGageModeHessianEval = 125
+tenGageConfDiffusionAlign = 158
+tenGageRGradVec = 54
 tenGageModeHessian = 124
-tenGageRHessian = 123
-nrrdKind3DMaskedSymMatrix = 29
+pullInitMethodPointPerVoxel = 3
+tenGageFAFlowlineCurv = 122
 tenGageFACurvDir2 = 121
+tenGageCl1HessianEvec1 = 185
 tenGageFACurvDir1 = 120
-airNoDio_arch = 1
-nrrdSpaceUnknown = 0
+gageErrBoundsStack = 3
+tenGageFAGaussCurv = 119
+nrrdTypeShort = 3
+tenGageFAMeanCurv = 118
 tenGageFAShapeIndex = 117
-pullTraceStopUnknown = 0
+tenGageEval2 = 18
+gageSclHessEval2 = 14
 tenGageFATotalCurv = 116
-tenGageFARidgeSurfaceStrength = 106
-tenDwiGageTensorLLSLikelihood = 9
+tenGageFAKappa2 = 115
+tenGlyphTypeCylinder = 3
+tenGageFAKappa1 = 114
 tenGageFAGeomTens = 113
-alanParmBeta = 19
+nrrdTypeUChar = 2
+tenGageModeGradVec = 57
+unrrduScaleSubtract = 5
 tenGageFARidgeLineAlignment = 110
-pullInfoStrength = 22
-nrrdSpaceRightAnteriorSuperiorTime = 4
-nrrdKind2DMaskedMatrix = 27
-limnQN9octa = 14
-alanParmDeltaX = 10
-tenGageFAHessianEvec = 101
-tenGageFAHessianEval1 = 99
-nrrdKind2DMatrix = 26
-alanParmSaveInterval = 6
-limnQN10octa = 13
-nrrdBasicInfoLast = 16
-alanParmNumThreads = 3
-pullInterTypeLast = 5
-nrrdBasicInfoComments = 14
-alanParmVerbose = 1
-alanParmUnknown = 0
-tenGageNormNormal = 38
-nrrdBasicInfoMeasurementFrame = 11
-nrrdBasicInfoSpaceOrigin = 10
-nrrdBasicInfoSpaceUnits = 9
-nrrdBasicInfoSpaceDimension = 8
-tenGageTraceHessianEvec = 87
-nrrdKind2DSymMatrix = 24
-nrrdBasicInfoSampleUnits = 6
-nrrdHasNonExistTrue = 1
-tenGageTraceHessianEval = 83
-tenDwiGageB0 = 2
-tenGageHessian = 81
-nrrdKindQuaternion = 23
-nrrdBasicInfoUnknown = 0
-tenGageCa2 = 79
-tenGageCl2 = 77
-tenGageOmegaHessianContrTenEvec0 = 145
-tenGageClpmin1 = 76
-limnEdgeTypeBackFacet = 1
-pullInitMethodHalton = 2
-tenGageEvalGrads = 72
-coilMethodTypeHomogeneous = 2
-tenAniso_Clpmin2 = 11
-tenInterpTypeWang = 4
-limnQN13octa = 8
-coilMethodTypeTesting = 1
-tenGageThetaNormal = 62
-tenGageThetaGradVec = 60
-coilMethodTypeUnknown = 0
+tenGageFAHessianEvalMode = 109
+tenGageQ = 8
+tenGageFAValleySurfaceStrength = 107
+tenGageFARidgeSurfaceStrength = 106
+mossFlagUnknown = -1
+pullInitMethodUnknown = 0
 tenGageFAHessianEvec2 = 104
-tenGageRGradMag = 55
-limnQN14checker = 6
-tenGageRGradVec = 54
-tenGageFAGradMag = 52
-tenGageFAGradVec = 51
-tenGageQNormal = 50
-tenGageQGradMag = 49
-limnQN15octa = 5
-tenGageQGradVec = 48
-tenGageSNormal = 47
-nrrdAxisInfoSpacing = 2
-tenGageDetNormal = 44
-pullSysParmBackStepScale = 13
-limnQN16octa = 4
-tenGageDetGradMag = 43
-tenGageOmegaHessianEvec = 139
-tenGageBGradMag = 40
-tenInterpTypeAffineInvariant = 3
-tenGageBGradVec = 39
-tenGageNormGradMag = 37
-tenGageNormGradVec = 36
-pullInterTypeSeparable = 3
-tenGageTraceNormal = 35
-nrrdAxisInfoLabel = 9
-tenGageTraceGradVec = 33
-tenGageTensorGradMag = 31
-nrrdAxisInfoMax = 5
-nrrdAxisInfoMin = 4
-nrrdAxisInfoThickness = 3
-tenGageFAHessianEvec1 = 103
-tenGageDelNormR2 = 26
-tenGageDelNormPhi3 = 29
-tenGageDelNormR1 = 25
-tenGageDelNormK3 = 24
-tenGageEvec2 = 22
-tenGageEvec0 = 20
-limnQNUnknown = 0
-tenGageEvec = 19
-tenGageEval1 = 17
-tenGageEval0 = 16
-nrrdKind2Vector = 12
-pullCondLast = 8
-tenGageOmega = 14
-tenGageDet = 6
-tenGageB = 5
-tenGageNorm = 4
-tenGageTrace = 3
-tenAniso_eval2 = 29
-tenGageTensor = 1
-tenGageUnknown = 0
-tenGageModeHessianEvec2 = 132
-tenAniso_Tr = 26
-tenAniso_Det = 25
-tenAniso_Omega = 24
 tenGageFAHessianEvec0 = 102
-tenAniso_Th = 23
-limnEdgeTypeFrontFacet = 5
-tenAniso_Mode = 22
-tenAniso_Skew = 21
-nrrdKindNormal = 8
-tenAniso_Q = 18
-tenAniso_FA = 15
-tenAniso_RA = 14
-tenAniso_Ct2 = 13
-tenAniso_Cs2 = 12
-tenAniso_Ca2 = 10
-tenAniso_Cp2 = 9
-tenAniso_Cl2 = 8
-tenAniso_Ct1 = 7
-tenAniso_Cs1 = 6
-alanTextureTypeUnknown = 0
-nrrdAxisInfoCenter = 7
-tenAniso_Cp1 = 3
-tenAniso_Cl1 = 2
-tenAniso_Conf = 1
-tenGageModeHessianEval1 = 127
-tenGageModeHessianEval0 = 126
-nrrdBlind8BitRangeLast = 4
-nrrdBlind8BitRangeState = 3
-nrrdBlind8BitRangeFalse = 2
-nrrdBlind8BitRangeTrue = 1
-nrrdBlind8BitRangeUnknown = 0
-tenGageFAFlowlineCurv = 122
-tenFiberParmVerbose = 4
-airInsane_pInfExists = 2
-coilKindType7Tensor = 3
-coilKindType3Color = 2
-coilKindTypeScalar = 1
-pullSysParmBinWidthSpace = 9
-miteValNdotL = 14
-limnDeviceGL = 2
-tenAniso_B = 17
-unrrduScaleExact = 7
-pullIterParmSnap = 8
-miteValLast = 20
-tenGageFAKappa2 = 115
-tenFiberStopLast = 11
-tenFiberStopMinLength = 9
-tenGageFAKappa1 = 114
-tenFiberStopStub = 8
-tenFiberStopFraction = 7
-tenFiberStopBounds = 6
-tenFiberStopRadius = 5
-baneClipPercentile = 3
-tenFiberStopConfidence = 4
-tenFiberStopNumSteps = 3
-tenFiberStopLength = 2
-tenFiberStopAniso = 1
-pullConstraintFailUnknown = 0
-tenFiberStopUnknown = 0
-tenFiberIntgLast = 4
-tenFiberIntgRK4 = 3
-tenFiberIntgMidpoint = 2
-tenFiberIntgEuler = 1
-tenFiberIntgUnknown = 0
-tenGageFAHessianEval0 = 98
-tenGageDelNormPhi2 = 28
-miteValGTdotV = 16
-nrrdBasicInfoOldMin = 12
-baneClipUnknown = 0
-tenGageCl1HessianEvec1 = 185
-nrrdCenterLast = 3
-tenDwiFiberTypeLast = 4
-pullCondUnknown = 0
-tenDwiFiberType12BlendEvec0 = 3
-nrrdSpacingStatusUnknown = 0
-tenDwiFiberType2Evec0 = 2
-tenDwiFiberType1Evec0 = 1
-tenDwiFiberTypeUnknown = 0
-ell_cubic_root_unknown = 0
-tenGageTensorGrad = 30
-miteValNormal = 12
-pullEnergyTypeZero = 12
+tenGageFAHessianEval2 = 100
+tenGageFAHessianEval1 = 99
+tenGageEval = 15
+tenTripleTypeJ = 6
 tenGageFAHessianEval = 97
-miteValView = 11
-pullInfoLiveThresh2 = 13
-pullConstraintFailTravel = 4
-tenGageCl1HessianEvec0 = 184
-baneRangeUnknown = 0
-tenGageFAHessianFrob = 105
 nrrdEncodingTypeLast = 6
-nrrdUnaryOpIf = 28
-nrrdKindUnknown = 0
-alanParmDiffB = 12
-pullConstraintFailProjGradZeroB = 2
-alanParmDiffA = 11
-pullConstraintFailProjGradZeroA = 1
-tenGageFAHessian = 96
-tenDwiGageTensorLLSError = 7
-miteValZi = 6
-limnQNLast = 17
+nrrdEncodingTypeBzip2 = 5
+nrrdEncodingTypeGzip = 4
+unrrduScaleMultiply = 2
+gageErrBoundsSpace = 2
+unrrduScaleNothing = 1
+tenInterpTypeQuatGeoLoxR = 10
+pullSourceLast = 3
+airInsane_AIR_NAN = 7
+tenInterpTypeGeoLoxK = 5
+tenGageTheta = 12
+tenInterpTypeAffineInvariant = 3
+tenGageCl1HessianEval0 = 180
+nrrdTernaryOpGTSmooth = 8
+tenGageMode = 11
+miteValWdotD = 19
+miteValVdefTdotV = 18
+airInsane_FltDblFPClass = 5
+nrrdKindPoint = 5
+gageCtxFlagRadius = 5
+miteValView = 11
+miteValTi = 10
+tenGageFA = 9
+miteValRw = 7
+gageErrNone = 1
+coilKindTypeLast = 4
+pullTraceStopConstrFail = 2
+miteValYw = 3
+miteValXi = 2
+nrrdField_comment = 1
+pullTraceStopSpeeding = 1
+airInsane_endian = 1
+hooverErrLast = 11
+tenEstimate2MethodPeled = 2
+nrrdTypeDouble = 10
+nrrdKindList = 4
+tenEstimate2MethodUnknown = 0
+pullEnergyTypeHepticWell = 11
+gageCtxFlagKernel = 4
+nrrdKind2DSymMatrix = 24
+nrrdTypeUShort = 4
+nrrdTypeChar = 1
+nrrdTypeDefault = 0
+gageErrUnknown = 0
+dyeSpaceHSL = 2
+airInsane_dio = 8
+coilKindType7Tensor = 3
+gageSclHessEval = 11
+airInsane_NaNExists = 4
+airInsane_nInfExists = 3
+tenEstimate2MethodLast = 3
+airInsane_pInfExists = 2
+tenGageConfidence = 2
+airInsane_not = 0
+pullInfoUnknown = 0
+nrrdBinaryOpMod = 8
 limnQN8octa = 16
 limnQN8checker = 15
-unrrduScaleAdd = 4
-miteValZw = 5
-echoMatterMetal = 3
-tenGageCl1GradMag = 168
-limnQN10checker = 12
-alanParmDeltaT = 9
-limnQN11octa = 11
+limnQN9octa = 14
+limnQN10octa = 13
+alanTextureTypeGrayScott = 2
 limnQN12octa = 10
-limnQN12checker = 9
-pullCondOld = 1
-tenGlyphTypePolarPlot = 6
-miteValYi = 4
-limnQN14octa = 7
-tenGageFAHessianEval2 = 100
-tenFiberParmWPunct = 3
+dyeSpaceLUV = 6
+limnQN15octa = 5
+limnSplineTypeBC = 5
 limnQN16checker = 3
 limnQN16border1 = 2
+hooverErrThreadJoin = 9
 limnQN16simple = 1
-pullEnergyTypeHepticWell = 11
-nrrdAxisInfoSize = 1
-tenGageQHessian = 95
-miteValXw = 1
-nrrdFFTWPlanRigorLast = 5
-miteValUnknown = 0
-alanParmFrameInterval = 4
-miteValWdotD = 19
-miteValVdefTdotV = 18
-miteValVdefT = 17
-nrrdSpacingStatusScalarWithSpace = 3
-miteRangeBlue = 3
-nrrdSpacingStatusScalarNoSpace = 2
-nrrdEncodingTypeGzip = 4
+limnQNUnknown = 0
+alanStopLast = 6
+pullEnergyTypeCotan = 5
+echoMatterGlassKd = 2
+baneClipLast = 5
+baneClipAbsolute = 1
+airTypeOther = 12
+seekTypeLast = 12
+nrrdBinaryOpGT = 15
+seekTypeValleySurfaceT = 11
+seekTypeRidgeSurfaceT = 9
+hooverErrThreadEnd = 8
+nrrdBoundaryWeight = 4
+nrrdBoundaryWrap = 3
+tenTripleTypeLast = 10
+seekTypeMinimalSurface = 6
+alanStopDiverged = 5
+nrrdBoundaryUnknown = 0
+seekTypeRidgeSurface = 2
+seekTypeIsocontour = 1
+airFP_NEG_DENORM = 8
 baneRangeLast = 5
 baneRangeAnywhere = 4
-gageItemPackPartHessEvec0 = 9
-nrrdTernaryOpInClosed = 14
-miteValTw = 9
-tenGageTraceGradVecDotEvec0 = 148
-tenGageDelNormPhi1 = 27
-gageItemPackPartHessEval2 = 8
-nrrdField_measurement_frame = 31
-nrrdFFTWPlanRigorEstimate = 1
+tenAniso_Ca1 = 4
+baneRangeZeroCentered = 3
+baneRangePositive = 1
+baneRangeUnknown = 0
 gageItemPackPartLast = 12
-tenGageSHessian = 94
-gageItemPackPartHessEvec2 = 11
+limnQNLast = 17
 gageItemPackPartHessEvec1 = 10
 gageItemPackPartHessEval1 = 7
+gageItemPackPartHessEval0 = 6
 gageItemPackPartHessian = 5
-nrrdAxisInfoUnknown = 0
-tenGageTraceHessianFrob = 91
-gageItemPackPartScalar = 1
-gageItemPackPartUnknown = 0
-nrrdTernaryOpIfElse = 10
-nrrdEncodingTypeHex = 3
-miteStageOpLast = 5
-nrrdTernaryOpClamp = 9
-nrrdField_space_origin = 30
-tenGageTraceHessianEvec0 = 88
-miteRangeKa = 5
-tenGageDetHessian = 93
+pullSysParmSeparableGammaLearnRescale = 4
+gageItemPackPartNormal = 4
+nrrdKindUnknown = 0
+miteShadeMethodLast = 4
 gageItemPackPartGradVec = 2
-nrrdBasicInfoSpace = 7
-tenGageCovariance = 160
-pullInfoHeightLaplacian = 9
-echoMatterUnknown = 0
-gageSclValue = 1
-tenFiberParmStepSize = 1
-nrrdEncodingTypeBzip2 = 5
-tenGageCl1HessianEval0 = 180
-nrrdHasNonExistOnly = 2
-pullCountLast = 15
-tenAnisoUnknown = 0
-nrrdEncodingTypeUnknown = 0
-pullPropLast = 18
-pullCountCC = 13
-pullCountPointsStuck = 11
-nrrdBasicInfoDimension = 4
-pullCountAdding = 9
-pullCountConstraintSatisfy = 8
-pullCountProbe = 7
-pullCountForceFromPoints = 6
-pullCountEnergyFromPoints = 5
-pullCountForceFromImage = 4
-nrrdTernaryOpMin = 3
-pullCountEnergyFromImage = 3
-alanParmMinAverageChange = 16
-mossFlagLast = 2
-pullCountDescent = 1
-airFP_POS_ZERO = 9
-mossFlagKernel = 1
-pullInfoHeightHessian = 8
-nrrdTernaryOpAdd = 1
-tenGageFANormal = 53
-coilMethodTypeModifiedCurvature = 4
-nrrdEncodingTypeRaw = 1
-miteStageOpMultiply = 4
-pullConstraintFailLast = 5
-alanStopNot = 1
-miteStageOpAdd = 3
-tenGageModeWarp = 13
-nrrdBinaryOpMax = 12
-echoMatterMetalFuzzy = 3
-echoMatterMetalKd = 2
-echoMatterMetalKa = 1
-baneMeasrLast = 9
-baneMeasrFlowlineCurv = 8
-limnDevicePS = 1
-limnDeviceUnknown = 0
-tenGageCa1HessianEval0 = 198
-pullPropStepEnergy = 4
-tenGageCa1HessianEval2 = 200
-tenFiberParmUseIndexSpace = 2
-baneClipLast = 5
-pullEnergyTypeQuarticWell = 10
-pullInitMethodRandom = 1
-tenGageCp1HessianEvec1 = 194
-pullInitMethodUnknown = 0
-baneRangeNegative = 2
-tenGageTraceHessianEvec2 = 90
-tenGageCp1HessianEvec0 = 193
-nrrdIoStateLast = 10
-tenGageBHessian = 92
-tenGageRotTans = 70
-pullPropNeighCovarTrace = 15
-nrrdSpacingStatusDirection = 4
-echoMatterGlass = 2
-nrrdHasNonExistLast = 4
-tenGageInvarRGrads = 68
-nrrdTernaryOpLTSmooth = 7
-airFP_NEG_NORM = 6
-pullInterTypeAdditive = 4
-tenGageOmegaDiffusionFraction = 156
-pullInfoInsideGradient = 5
+gageItemPackPartScalar = 1
+miteShadeMethodNone = 1
+miteShadeMethodUnknown = 0
+pullSysParmGamma = 3
+gageVecMGEvec = 31
+tijk_class_tensor = 1
+gageVecMGEval = 30
+gageVecMGFrob = 29
+gageVecMultiGrad = 28
+gageVecGradient0 = 25
+gageVecProjHelGradient = 24
+gageVecDirHelDeriv = 23
+gageVecHelGradient = 22
+gageVecNCurlNormGrad = 21
+gageVecDivGradient = 18
+airTypeUnknown = 0
+gageVecHessian = 17
 limnSplineTypeTimeWarp = 2
-pullCountIteration = 14
-tenGageOmegaGradMag = 64
-pullInterTypeUnknown = 0
-airFP_POS_NORM = 5
-miteValVrefN = 15
-pullInfoInside = 4
-tenGageThetaGradMag = 61
-pullTraceStopLength = 4
-tenTripleTypeLast = 10
+gageVecImaginaryPart = 16
+gageVecSOmega = 14
+gageVecNormHelicity = 13
+gageVecHelicity = 12
+pullProcessModeLast = 5
+gageVecCurl = 10
+gageVecDivergence = 9
+pullProcessModeNeighLearn = 2
+pullProcessModeDescent = 1
+pullProcessModeUnknown = 0
+nrrdBoundaryLast = 6
+gageVecVector2 = 4
+gageVecVector0 = 2
+gageVecUnknown = 0
+gageSclLast = 37
+gageSclHessMode = 36
+gageSclHessDotPeakness = 35
+gageSclNPerp = 6
+gageSclMedian = 32
+limnQN13octa = 8
+gageSclCurvDir2 = 30
+gageSclGaussCurv = 28
+gageSclShapeIndex = 26
+echoMatterMetalFuzzy = 3
+limnQN14octa = 7
+gageSclTotalCurv = 24
+gageSclK2 = 23
+gageSclK1 = 22
+gageSclGeomTensTen = 21
+gageScl2ndDD = 19
+limnQN14checker = 6
+nrrdTypeLast = 12
+gageSclHessEvec1 = 17
+gageSclHessEvec0 = 16
+tenFiberParmLast = 5
+nrrdMeasureHistoProduct = 26
+nrrdBoundaryMirror = 5
+nrrdMeasureHistoMode = 25
+nrrdMeasureHistoMedian = 24
+nrrdMeasureHistoMean = 23
+tenDwiFiberType2Evec0 = 2
+nrrdMeasureHistoMax = 22
+nrrdMeasureHistoMin = 21
+gageSclHessianTen = 8
+gageSclHessian = 7
+limnQN16octa = 4
+nrrdMeasureLineSlope = 18
+nrrdMeasureSkew = 17
+gageSclNormal = 4
+gageSclGradMag = 3
+nrrdKind3DMaskedSymMatrix = 29
+gageSclGradVec = 2
+gageSclValue = 1
+nrrdMeasureRootMeanSquare = 12
+nrrdMeasureNormalizedL2 = 11
+nrrdBinaryOpMin = 11
+nrrdMeasureL1 = 8
+tenGageCl1 = 73
+nrrdMeasureSum = 7
+nrrdMeasureProduct = 6
+nrrdMeasureMedian = 4
+nrrdMeasureMax = 2
+nrrdMeasureMin = 1
+nrrdMeasureUnknown = 0
+tenFiberStopLength = 2
+limnQN10checker = 12
+pullInterTypeJustR = 1
+pullStatusLast = 5
+pullStatusEdge = 4
+pullStatusNixMe = 3
+tenGageEvec0 = 20
+pullStatusStuck = 1
+pullStatusUnknown = 0
+echoJitterLast = 4
+nrrdSpaceRightAnteriorSuperior = 1
+nrrdBinaryOpAtan2 = 10
+tenGageCa1Hessian = 196
+miteValUnknown = 0
+pullCondNew = 7
+tenAniso_Cp1 = 3
+nrrdKind2DMaskedMatrix = 27
+tenDwiGage2TensorPeledError = 33
+alanTextureTypeUnknown = 0
+baneClipTopN = 4
+hooverErrThreadCreate = 3
+pullInfoStrength = 22
+baneClipPercentile = 3
+pullInfoTensor = 1
+nrrdBoundaryBleed = 2
 baneClipPeakRatio = 2
-pullTraceStopBounds = 3
-nrrdUnaryOpCeil = 19
-nrrdSpaceLast = 13
-nrrdSpace3DLeftHandedTime = 12
+pullInfoHessian = 3
+nrrdKind2DMatrix = 26
+pullIterParmLast = 10
+baneClipUnknown = 0
+pullIterParmEnergyIncreasePermitHalfLife = 9
+pullIterParmSnap = 8
+pullIterParmCallback = 7
+pullIterParmAddDescent = 6
+nrrdOriginStatusNoMaxOrSpacing = 3
+pullIterParmPopCntlPeriod = 5
+pullIterParmConstraintMax = 4
+pullIterParmStuckMax = 3
+hooverErrRenderBegin = 2
+pullIterParmMin = 1
+nrrdOriginStatusNoMin = 2
+tenTripleTypeWheelParm = 9
+tenTripleTypeR = 8
+tenTripleTypeK = 7
+tenTripleTypeRThetaPhi = 5
+tenTripleTypeXYZ = 3
+tenGlyphTypeLast = 7
+tenTripleTypeEigenvalue = 1
+tenTripleTypeUnknown = 0
+dyeSpaceRGB = 3
+miteRangeLast = 9
 nrrdSpace3DRightHandedTime = 11
+miteRangeKa = 5
+nrrdBinaryOpFlippedSgnPow = 7
+miteRangeEmissivity = 4
+miteRangeBlue = 3
+miteRangeGreen = 2
+miteRangeRed = 1
+miteRangeAlpha = 0
+miteRangeUnknown = -1
+baneIncLast = 5
+baneIncStdv = 4
+tenGageOmegaHessianContrTenEvec0 = 145
+airFP_Last = 11
+tenGlyphTypePolarPlot = 6
+nrrdKindCovariantVector = 7
+limnPrimitiveLines = 7
+gageSclUnknown = 0
+nrrdSpacingStatusUnknown = 0
+nrrdKindVector = 6
+tenAniso_VF = 16
+nrrdBinaryOpSgnPow = 6
+hooverErrNone = 0
+pullPropNeighCovarDet = 16
+tenGageOmega2ndDD = 144
+tenDwiFiberTypeLast = 4
+nrrdKindTime = 3
+tenDwiFiberType12BlendEvec0 = 3
+tenGlyphTypeBetterquad = 5
+nrrdKindSpace = 2
+tenGageEvec = 19
+dyeSpaceHSV = 1
+nrrdKindDomain = 1
+miteValLast = 20
+tenDwiFiberTypeUnknown = 0
+airEndianUnknown = 0
+seekTypeRidgeSurfaceOP = 8
+pullPropNeighCovarTrace = 15
+gageParmStackUse = 9
+tenGageFAHessianEvec = 101
+seekTypeMaximalSurface = 7
+pullCondEnergyBad = 6
+airInsane_DLSize = 11
+dyeSpaceUnknown = 0
+pullInfoLast = 24
+tenInterpTypeQuatGeoLoxK = 9
+nrrdBoundaryPad = 1
+nrrdBasicInfoSpaceUnits = 9
+seekTypeRidgeLine = 4
+pullSourceUnknown = 0
+tenGageFAHessianEvec1 = 103
+seekTypeValleySurface = 3
+pullPropNeighInterNum = 14
+tenGageOmegaHessianEvec2 = 142
+limnCameraPathTrackBoth = 3
+tenGageCl1GradMag = 168
+airInsane_FISize = 10
+nrrdBasicInfoSampleUnits = 6
+tenGageOmegaHessian = 134
+nrrdBasicInfoContent = 5
+pullInfoQuality = 23
+nrrdResampleNonExistentRenormalize = 2
+tenAniso_eval1 = 28
+pullFlagLast = 16
 nrrdSpace3DRightHanded = 9
-nrrdSpaceScannerXYZTime = 8
-tenGageRNormal = 56
+nrrdResampleNonExistentUnknown = 0
+tenGageOmegaHessianEvec1 = 141
+gageParmKernelIntegralNearZero = 7
+alanParmMaxIteration = 7
+tenEstimate1MethodMLE = 4
+airInsane_UCSize = 9
+tenGageLast = 208
+tenGlyphTypeSphere = 2
+coilMethodTypeTesting = 1
 nrrdSpaceScannerXYZ = 7
+nrrdKind3Gradient = 20
+nrrdFormatTypeEPS = 6
+tenDwiGageConfidence = 26
 nrrdSpaceLeftPosteriorSuperiorTime = 6
+miteValVdefT = 17
+echoMatterMetalKa = 1
+airTypeUInt = 3
+nrrdFFTWPlanRigorPatient = 3
+nrrdFFTWPlanRigorMeasure = 2
+tenGageOmegaHessianEvec0 = 140
+nrrdHasNonExistLast = 4
+nrrdHasNonExistOnly = 2
+nrrdFFTWPlanRigorEstimate = 1
+nrrdHasNonExistTrue = 1
+nrrdHasNonExistFalse = 0
+coilMethodTypeUnknown = 0
+tenDwiGageTensorLikelihood = 25
 nrrdSpaceLeftAnteriorSuperiorTime = 5
-baneClipAbsolute = 1
-tenFiberTypeLast = 7
-tenFiberTypeZhukov = 6
-tenFiberTypePureLine = 5
-baneIncPercentile = 3
-tenFiberTypeTensorLine = 4
-tenGageTraceHessianEval2 = 86
-nrrdEncodingTypeAscii = 2
-tenFiberTypeEvec1 = 2
-tenFiberTypeEvec0 = 1
+nrrdTypeLLong = 7
+pullConstraintFailProjGradZeroA = 3
+tenGageRHessian = 123
+nrrdField_last = 33
+limnEdgeTypeLone = 7
+nrrdField_data_file = 32
+nrrdField_measurement_frame = 31
+baneRangeNegative = 2
+nrrdField_space_origin = 30
+nrrdField_space_units = 29
+nrrdField_sample_units = 28
+nrrdField_keyvalue = 27
+nrrdField_byte_skip = 26
+nrrdField_line_skip = 25
+nrrdField_encoding = 24
+nrrdField_endian = 23
+nrrdField_old_max = 22
+nrrdField_old_min = 21
+nrrdField_max = 20
 tenFiberTypeUnknown = 0
+tenGageDetHessian = 93
+nrrdMeasureLineError = 20
+tenGageBHessian = 92
+nrrdField_centers = 15
+airNoDio_setfl = 10
 tenDwiGageTensorErrorLog = 24
-tenEstimate1MethodLast = 5
-tenEstimate1MethodMLE = 4
-tenEstimate1MethodNLS = 3
-tenEstimate1MethodWLS = 2
-tenEstimate1MethodLLS = 1
-tenEstimate1MethodUnknown = 0
-tenGlyphTypeLast = 7
-tenGlyphTypeBetterquad = 5
-tenGlyphTypeSuperquad = 4
-tenGlyphTypeCylinder = 3
-tenGlyphTypeSphere = 2
-pullEnergyTypeLast = 14
-tenGlyphTypeBox = 1
-tenGlyphTypeUnknown = 0
-pullCountPoints = 12
-nrrdHasNonExistFalse = 0
-tenEstimate2MethodUnknown = 0
+pullInitMethodHalton = 2
+nrrdSpaceRightAnteriorSuperiorTime = 4
+nrrdField_axis_maxs = 13
+nrrdField_axis_mins = 12
+nrrdField_thicknesses = 11
+tenGageTraceHessianEval2 = 86
+nrrdUnaryOpRoundUp = 21
+nrrdField_sizes = 9
+tenGageTraceHessianEval0 = 84
+nrrdField_space = 7
+nrrdTernaryOpExists = 12
+coilKindType3Color = 2
+nrrdField_number = 3
+nrrdOriginStatusLast = 5
+tenGageCp2 = 78
+tenGageCl2 = 77
+tenDwiGageAll = 1
+nrrdField_unknown = 0
+nrrdTernaryOpLerp = 11
+tenGageCa1 = 75
+baneMeasrLast = 9
+tenGageRotTanMags = 71
+tenGageInvarRGradMags = 69
 tenGageFiberCurving = 205
+tenGageInvarKGradMags = 67
+tenGageOmegaGradMag = 64
+nrrdTernaryOpClamp = 9
+echoMatterLightPower = 0
+tenGageThetaNormal = 62
+tenInterpTypeWang = 4
+tenGageThetaGradVec = 60
+tenGageModeNormal = 59
+echoMatterPhongSp = 3
+hestSourceUnknown = 0
+echoMatterPhongKs = 2
+echoMatterPhongKd = 1
+nrrdKind3DMaskedMatrix = 31
+nrrdKind3DMatrix = 30
+nrrdKind3DSymMatrix = 28
+limnEdgeTypeFrontFacet = 5
+pullInterTypeAdditive = 4
+pullInterTypeSeparable = 3
+gageItemPackPartHessEvec0 = 9
+pullInterTypeUnivariate = 2
+nrrdTernaryOpMaxSmooth = 6
+nrrdKind4Vector = 22
+nrrdKind3Normal = 21
+gageItemPackPartHessEval2 = 8
+nrrdKind3Vector = 19
+nrrdTernaryOpMax = 5
+airInsane_QNaNHiBit = 6
+tenGageCa1HessianEvec2 = 204
+tenGageCp1GradMag = 171
+nrrdKindRGBColor = 14
+nrrdKind3Color = 13
+nrrdKindScalar = 10
+nrrdKindStub = 9
+tenDwiGageTensor = 22
+nrrdTypeUnknown = 0
+nrrdTernaryOpMin = 3
+gageVecCurlNormGrad = 20
+nrrdUnaryOpCeil = 19
+tenFiberIntgRK4 = 3
+nrrdSpaceScannerXYZTime = 8
+tenFiberIntgEuler = 1
+gageItemPackPartGradMag = 3
+nrrdTernaryOpUnknown = 0
+limnSpaceScreen = 3
+miteShadeMethodLitTen = 3
+pullCountCC = 13
+pullCountPoints = 12
+miteShadeMethodPhong = 2
+pullCountAdding = 9
+pullCountForceFromPoints = 6
+pullCountEnergyFromPoints = 5
+pullCountForceFromImage = 4
+miteValNormal = 12
+gageItemPackPartUnknown = 0
+limnEdgeTypeBackCrease = 2
+pullCountTestStep = 2
+limnEdgeTypeUnknown = 0
+pullPropPosition = 7
+tenGageOmegaHessianEval = 135
+gageVecLast = 32
+tenGageCa1HessianEvec0 = 202
+airMopOnError = 1
+nrrdZlibStrategyFiltered = 3
+tenInterpTypeLinear = 1
+gageKernelStack = 7
+gageKernel22 = 6
+gageKernel21 = 5
+gageKernel20 = 4
+baneIncPercentile = 3
+baneIncRangeRatio = 2
+baneIncAbsolute = 1
+gageKernelUnknown = 0
+nrrdUnaryOpNormalRand = 27
 gagePvlFlagLast = 4
-tenGageFADiffusionAlign = 152
-pullCountNixing = 10
-limnCameraPathTrackLast = 4
-tenGageCp1Normal = 172
-tenGageSGradVec = 45
-limnPrimitiveLast = 8
-tenGageTraceHessianEval0 = 84
-airFP_SNAN = 1
-airInsane_DLSize = 11
-coilMethodTypeFinish = 8
-airInsane_FISize = 10
-pullEnergyTypeCubic = 6
-airInsane_UCSize = 9
-airInsane_dio = 8
+gagePvlFlagNeedD = 3
+tenGageQNormal = 50
+tenGageQGradMag = 49
+tenGageQGradVec = 48
+tenGageSNormal = 47
+gageCtxFlagShape = 6
+limnQN12checker = 9
+gageVecGradient2 = 27
 tenGageDetGradVec = 42
-airInsane_AIR_NAN = 7
-airInsane_FltDblFPClass = 5
-tenGageBNormal = 41
-airInsane_endian = 1
-airInsane_not = 0
-pullEnergyTypeButterworth = 4
-ell_cubic_root_last = 5
-ell_cubic_root_three = 4
-ell_cubic_root_single_double = 3
-ell_cubic_root_triple = 2
-ell_cubic_root_single = 1
-nrrdFormatTypeLast = 7
-tenGageCa1HessianEvec1 = 203
-airFP_Unknown = 0
-tenDwiGageTensorMLELikelihood = 21
-coilMethodTypeSelf = 7
-tenDwiGageTensorMLE = 18
-nrrdFormatTypeText = 5
-pullEnergyTypeUnknown = 0
-baneRangeZeroCentered = 3
-nrrdSpacingStatusNone = 1
-nrrdFormatTypePNG = 3
-tenGageEval = 15
+gageCtxFlagNeedD = 1
+nrrdUnaryOpExists = 25
+tenGageBGradVec = 39
+gageParmLast = 16
+gageParmTwoDimZeroZ = 15
+gageVecGradient1 = 26
+gageParmGenerateErrStr = 14
+gageParmOrientationFromSpacing = 13
 tenGageTraceGradMag = 34
-tenGageTraceHessian = 82
-nrrdAxisInfoKind = 8
-coilMethodTypeCurvatureFlow = 6
-tenGageTraceDiffusionAlign = 149
+tenGageTraceGradVec = 33
 tenGageTensorGradMagMag = 32
-nrrdAxisInfoSpaceDirection = 6
-pullPropPosition = 7
-alanStopConverged = 4
-baneIncRangeRatio = 2
-pullInfoIsovalueHessian = 21
-limnCameraPathTrackBoth = 3
-limnCameraPathTrackAt = 2
-limnCameraPathTrackFrom = 1
-coilMethodTypeModifiedCurvatureRings = 5
-limnCameraPathTrackUnknown = 0
-tenGageFAMeanCurv = 118
+tenGageTensorGrad = 30
+tenGageDelNormPhi3 = 29
+nrrdUnaryOpAbs = 23
+tenGageDelNormPhi2 = 28
+tenGageDelNormPhi1 = 27
+tenGageDelNormK3 = 24
+tenGageDelNormK2 = 23
+gageParmUnknown = 0
+pullInitMethodLast = 5
+alanStopNonExist = 3
+pullFlagNoAdd = 8
+unrrduScaleLast = 8
+unrrduScaleExact = 7
+unrrduScaleAspectRatio = 6
+pullInitMethodRandom = 1
+tenGageEval0 = 16
+tenGageOmega = 14
+tenGageModeWarp = 13
+pullTraceStopLast = 6
+pullTraceStopStub = 5
+pullTraceStopLength = 4
+pullTraceStopBounds = 3
+alanStopNot = 1
+tenGageS = 7
+tenGageDet = 6
+tenGageB = 5
+tenGageNorm = 4
+tenGageTrace = 3
 alanStopUnknown = 0
-baneRangePositive = 1
-pullEnergyTypeCubicWell = 8
-pullInfoNegativeTangent2 = 18
+tenGageTensor = 1
+tenGageUnknown = 0
+nrrdUnaryOpErf = 17
+gageVecCurlGradient = 19
+echoMatterPhongKa = 0
+nrrdKindComplex = 11
+gageVecLambda2 = 15
+nrrdHasNonExistUnknown = 3
+echoJittableLast = 7
+echoJittableMotionB = 6
+tenGageModeHessianEvec1 = 131
+echoJittableMotionA = 5
+echoJittableNormalB = 4
+echoJittableNormalA = 3
+echoJittableLens = 2
+echoJittableLight = 1
+echoJittablePixel = 0
+echoJittableUnknown = -1
+tenDwiGageTensorNLSErrorLog = 16
+limnPolyDataInfoRGBA = 1
+pullSourceProp = 2
+pullSourceGage = 1
+pullProcessModeNixing = 4
+nrrdResampleNonExistentLast = 4
+nrrdResampleNonExistentWeight = 3
+nrrdResampleNonExistentNoop = 1
+pullProcessModeAdding = 3
+nrrdFFTWPlanRigorExhaustive = 4
+nrrdFFTWPlanRigorUnknown = 0
+gageVecStrain = 8
+nrrdTernaryOpLast = 17
+nrrdTernaryOpRician = 16
+nrrdTernaryOpGaussian = 15
+nrrdTernaryOpInClosed = 14
+nrrdTernaryOpInOpen = 13
+gageVecJacobian = 7
+nrrdTernaryOpIfElse = 10
+hestSourceDefault = 1
+nrrdTernaryOpLTSmooth = 7
+gageVecNormalized = 6
+nrrdTernaryOpMinSmooth = 4
+nrrdTernaryOpMultiply = 2
+nrrdTernaryOpAdd = 1
+gageVecLength = 5
+tenAniso_Det = 25
+nrrdUnaryOpLast = 33
+nrrdUnaryOpSigmaOfTau = 32
+alanParmLast = 22
+nrrdUnaryOpTauOfSigma = 31
+nrrdUnaryOpOne = 30
+nrrdUnaryOpZero = 29
+nrrdUnaryOpIf = 28
+nrrdUnaryOpRand = 26
+nrrdUnaryOpSgn = 24
+gageVecVector1 = 3
+nrrdUnaryOpFloor = 20
+nrrdUnaryOpNerf = 18
+nrrdUnaryOpCbrt = 16
+nrrdUnaryOpSqrt = 15
+nrrdUnaryOpExpm1 = 14
+tenInterpTypeGeoLoxR = 6
+nrrdUnaryOpLog1p = 13
+nrrdUnaryOpLog10 = 12
+gageVecVector = 1
+nrrdUnaryOpLog2 = 11
+gageSclHessFrob = 10
+nrrdUnaryOpLog = 10
+nrrdUnaryOpExp = 9
+nrrdUnaryOpAtan = 8
+nrrdUnaryOpAcos = 7
+nrrdUnaryOpAsin = 6
+nrrdUnaryOpTan = 5
+nrrdUnaryOpCos = 4
+nrrdUnaryOpSin = 3
+nrrdUnaryOpReciprocal = 2
+alanParmMaxPixelChange = 17
+nrrdUnaryOpNegative = 1
+tenGageSGradMag = 46
+nrrdUnaryOpUnknown = 0
+alanParmBeta = 19
 airLLong = c_longlong
 airULLong = c_ulonglong
 class airPtrPtrUnion(Union):
@@ -1817,7 +1835,11 @@
 airSanity.restype = c_int
 airSanity.argtypes = []
 airTeemVersion = (STRING).in_dll(libteem, 'airTeemVersion')
+airTeemReleaseDone = (c_int).in_dll(libteem, 'airTeemReleaseDone')
 airTeemReleaseDate = (STRING).in_dll(libteem, 'airTeemReleaseDate')
+airTeemVersionSprint = libteem.airTeemVersionSprint
+airTeemVersionSprint.restype = None
+airTeemVersionSprint.argtypes = [STRING]
 airNull = libteem.airNull
 airNull.restype = c_void_p
 airNull.argtypes = []
@@ -1968,6 +1990,18 @@
 airBesselInExpScaled = libteem.airBesselInExpScaled
 airBesselInExpScaled.restype = c_double
 airBesselInExpScaled.argtypes = [c_int, c_double]
+airTauOfTime = libteem.airTauOfTime
+airTauOfTime.restype = c_double
+airTauOfTime.argtypes = [c_double]
+airTimeOfTau = libteem.airTimeOfTau
+airTimeOfTau.restype = c_double
+airTimeOfTau.argtypes = [c_double]
+airSigmaOfTau = libteem.airSigmaOfTau
+airSigmaOfTau.restype = c_double
+airSigmaOfTau.argtypes = [c_double]
+airTauOfSigma = libteem.airTauOfSigma
+airTauOfSigma.restype = c_double
+airTauOfSigma.argtypes = [c_double]
 airVanDerCorput = libteem.airVanDerCorput
 airVanDerCorput.restype = c_double
 airVanDerCorput.argtypes = [c_uint, c_uint]
@@ -2377,13 +2411,13 @@
     ('main', CFUNCTYPE(c_int, c_int, POINTER(STRING), STRING, POINTER(hestParm))),
     ('hidden', c_int),
 ]
+baneGkms_opacCmd = (unrrduCmd).in_dll(libteem, 'baneGkms_opacCmd')
 baneGkms_hvolCmd = (unrrduCmd).in_dll(libteem, 'baneGkms_hvolCmd')
+baneGkms_scatCmd = (unrrduCmd).in_dll(libteem, 'baneGkms_scatCmd')
 baneGkms_infoCmd = (unrrduCmd).in_dll(libteem, 'baneGkms_infoCmd')
-baneGkms_opacCmd = (unrrduCmd).in_dll(libteem, 'baneGkms_opacCmd')
+baneGkms_txfCmd = (unrrduCmd).in_dll(libteem, 'baneGkms_txfCmd')
 baneGkms_miteCmd = (unrrduCmd).in_dll(libteem, 'baneGkms_miteCmd')
 baneGkms_pvgCmd = (unrrduCmd).in_dll(libteem, 'baneGkms_pvgCmd')
-baneGkms_scatCmd = (unrrduCmd).in_dll(libteem, 'baneGkms_scatCmd')
-baneGkms_txfCmd = (unrrduCmd).in_dll(libteem, 'baneGkms_txfCmd')
 baneGkmsMeasr = (POINTER(airEnum)).in_dll(libteem, 'baneGkmsMeasr')
 baneGkmsCmdList = (POINTER(unrrduCmd) * 0).in_dll(libteem, 'baneGkmsCmdList')
 baneGkmsUsage = libteem.baneGkmsUsage
@@ -3047,6 +3081,9 @@
 elfGlyphPolar = libteem.elfGlyphPolar
 elfGlyphPolar.restype = c_float
 elfGlyphPolar.argtypes = [POINTER(limnPolyData), c_char, POINTER(c_float), POINTER(tijk_type), STRING, c_char, c_char, POINTER(c_ubyte), POINTER(c_ubyte)]
+elfGlyphKDE = libteem.elfGlyphKDE
+elfGlyphKDE.restype = c_float
+elfGlyphKDE.argtypes = [POINTER(limnPolyData), c_char, POINTER(c_float), c_size_t, c_float, c_char]
 elfColorGlyphMaxima = libteem.elfColorGlyphMaxima
 elfColorGlyphMaxima.restype = c_int
 elfColorGlyphMaxima.argtypes = [POINTER(limnPolyData), c_char, POINTER(c_int), c_uint, POINTER(c_float), POINTER(tijk_type), c_char, c_float]
@@ -3083,12 +3120,24 @@
 elfMaximaFind_f = libteem.elfMaximaFind_f
 elfMaximaFind_f.restype = c_int
 elfMaximaFind_f.argtypes = [POINTER(POINTER(c_float)), POINTER(POINTER(c_float)), POINTER(c_float), POINTER(elfMaximaContext)]
+elfCart2Thetaphi_d = libteem.elfCart2Thetaphi_d
+elfCart2Thetaphi_d.restype = None
+elfCart2Thetaphi_d.argtypes = [POINTER(c_double), POINTER(c_double), c_uint]
 elfCart2Thetaphi_f = libteem.elfCart2Thetaphi_f
 elfCart2Thetaphi_f.restype = None
 elfCart2Thetaphi_f.argtypes = [POINTER(c_float), POINTER(c_float), c_uint]
+elfESHEstimMatrix_d = libteem.elfESHEstimMatrix_d
+elfESHEstimMatrix_d.restype = c_int
+elfESHEstimMatrix_d.argtypes = [POINTER(c_double), POINTER(c_double), c_uint, POINTER(c_double), c_uint, c_double, POINTER(c_double)]
 elfESHEstimMatrix_f = libteem.elfESHEstimMatrix_f
 elfESHEstimMatrix_f.restype = c_int
 elfESHEstimMatrix_f.argtypes = [POINTER(c_float), POINTER(c_float), c_uint, POINTER(c_float), c_uint, c_float, POINTER(c_float)]
+elfTenEstimMatrix_d = libteem.elfTenEstimMatrix_d
+elfTenEstimMatrix_d.restype = c_int
+elfTenEstimMatrix_d.argtypes = [POINTER(c_double), POINTER(c_double), POINTER(tijk_type), POINTER(c_double), c_uint, POINTER(c_double)]
+elfTenEstimMatrix_f = libteem.elfTenEstimMatrix_f
+elfTenEstimMatrix_f.restype = c_int
+elfTenEstimMatrix_f.argtypes = [POINTER(c_float), POINTER(c_float), POINTER(tijk_type), POINTER(c_float), c_uint, POINTER(c_float)]
 class elfSingleShellDWI(Structure):
     pass
 elfSingleShellDWI._fields_ = [
@@ -3381,6 +3430,9 @@
 ell_cubic = libteem.ell_cubic
 ell_cubic.restype = c_int
 ell_cubic.argtypes = [POINTER(c_double), c_double, c_double, c_double, c_int]
+ell_2m_1d_nullspace_d = libteem.ell_2m_1d_nullspace_d
+ell_2m_1d_nullspace_d.restype = None
+ell_2m_1d_nullspace_d.argtypes = [POINTER(c_double), POINTER(c_double)]
 ell_3m_1d_nullspace_d = libteem.ell_3m_1d_nullspace_d
 ell_3m_1d_nullspace_d.restype = None
 ell_3m_1d_nullspace_d.argtypes = [POINTER(c_double), POINTER(c_double)]
@@ -3393,6 +3445,12 @@
 ell_3m_eigensolve_d = libteem.ell_3m_eigensolve_d
 ell_3m_eigensolve_d.restype = c_int
 ell_3m_eigensolve_d.argtypes = [POINTER(c_double), POINTER(c_double), POINTER(c_double), c_int]
+ell_3m2sub_eigenvalues_d = libteem.ell_3m2sub_eigenvalues_d
+ell_3m2sub_eigenvalues_d.restype = c_int
+ell_3m2sub_eigenvalues_d.argtypes = [POINTER(c_double), POINTER(c_double)]
+ell_3m2sub_eigensolve_d = libteem.ell_3m2sub_eigensolve_d
+ell_3m2sub_eigensolve_d.restype = c_int
+ell_3m2sub_eigensolve_d.argtypes = [POINTER(c_double), POINTER(c_double), POINTER(c_double)]
 ell_3m_svd_d = libteem.ell_3m_svd_d
 ell_3m_svd_d.restype = c_int
 ell_3m_svd_d.argtypes = [POINTER(c_double), POINTER(c_double), POINTER(c_double), POINTER(c_double), c_int]
@@ -3443,6 +3501,7 @@
     ('stackNormalizeDeriv', c_int),
     ('orientationFromSpacing', c_int),
     ('generateErrStr', c_int),
+    ('twoDimZeroZ', c_int),
 ]
 gageParm = gageParm_t
 class gagePoint_t(Structure):
@@ -3532,50 +3591,58 @@
 ]
 class gageStackBlurParm(Structure):
     pass
+class NrrdBoundarySpec(Structure):
+    pass
 gageStackBlurParm._pack_ = 4
 gageStackBlurParm._fields_ = [
     ('num', c_uint),
-    ('scale', POINTER(c_double)),
-    ('sigmaMax', c_double),
-    ('padValue', c_double),
+    ('sigmaRange', c_double * 2),
+    ('sigmaSampling', c_int),
+    ('sigma', POINTER(c_double)),
     ('kspec', POINTER(NrrdKernelSpec)),
-    ('dataCheck', c_int),
-    ('boundary', c_int),
     ('renormalize', c_int),
+    ('bspec', POINTER(NrrdBoundarySpec)),
+    ('oneDim', c_int),
+    ('needSpatialBlur', c_int),
     ('verbose', c_int),
+    ('dgGoodSigmaMax', c_double),
 ]
-class gageOptimSigParm(Structure):
+class gageOptimSigContext(Structure):
     pass
-gageOptimSigParm._pack_ = 4
-gageOptimSigParm._fields_ = [
+gageOptimSigContext._pack_ = 4
+gageOptimSigContext._fields_ = [
     ('dim', c_uint),
-    ('sigmaMax', c_double),
+    ('sampleNumMax', c_uint),
+    ('trueImgNum', c_uint),
+    ('sigmaRange', c_double * 2),
     ('cutoff', c_double),
-    ('measrSampleNum', c_uint),
+    ('kssSpec', POINTER(NrrdKernelSpec)),
     ('sampleNum', c_uint),
-    ('volMeasr', c_int),
-    ('lineMeasr', c_int),
-    ('plotting', c_int),
-    ('tentRecon', c_int),
     ('maxIter', c_uint),
+    ('imgMeasr', c_int),
+    ('allMeasr', c_int),
     ('convEps', c_double),
     ('sx', c_uint),
     ('sy', c_uint),
     ('sz', c_uint),
-    ('sigmatru', POINTER(c_double)),
-    ('truth', POINTER(c_double)),
-    ('ntruth', POINTER(Nrrd)),
     ('nerr', POINTER(Nrrd)),
-    ('ntruline', POINTER(Nrrd)),
     ('ninterp', POINTER(Nrrd)),
     ('ndiff', POINTER(Nrrd)),
-    ('sampleNumMax', c_uint),
-    ('scalePos', POINTER(c_double)),
-    ('step', POINTER(c_double)),
-    ('nsampvol', POINTER(POINTER(Nrrd))),
-    ('pvl', POINTER(gagePerVolume)),
-    ('pvlSS', POINTER(POINTER(gagePerVolume))),
+    ('rhoRange', c_double * 2),
+    ('kloc', POINTER(c_double)),
+    ('kern', POINTER(c_double)),
+    ('ktmp1', POINTER(c_double)),
+    ('ktmp2', POINTER(c_double)),
+    ('kone', c_double * 1),
     ('gctx', POINTER(gageContext)),
+    ('pvlBase', POINTER(gagePerVolume)),
+    ('pvlSS', POINTER(POINTER(gagePerVolume))),
+    ('nsampleImg', POINTER(POINTER(Nrrd))),
+    ('sampleSigma', POINTER(c_double)),
+    ('sampleRho', POINTER(c_double)),
+    ('sampleTmp', POINTER(c_double)),
+    ('sampleErrMax', POINTER(c_double)),
+    ('step', POINTER(c_double)),
     ('finalErr', c_double),
 ]
 gageBiffKey = (STRING).in_dll(libteem, 'gageBiffKey')
@@ -3591,9 +3658,9 @@
 gageDefStackNormalizeRecon = (c_int).in_dll(libteem, 'gageDefStackNormalizeRecon')
 gageDefStackNormalizeDeriv = (c_int).in_dll(libteem, 'gageDefStackNormalizeDeriv')
 gageDefStackNormalizeDerivBias = (c_double).in_dll(libteem, 'gageDefStackNormalizeDerivBias')
-gageDefStackBlurSigmaMax = (c_double).in_dll(libteem, 'gageDefStackBlurSigmaMax')
 gageDefOrientationFromSpacing = (c_int).in_dll(libteem, 'gageDefOrientationFromSpacing')
 gageDefGenerateErrStr = (c_int).in_dll(libteem, 'gageDefGenerateErrStr')
+gageDefTwoDimZeroZ = (c_int).in_dll(libteem, 'gageDefTwoDimZeroZ')
 gagePresent = (c_int).in_dll(libteem, 'gagePresent')
 gageZeroNormal = (c_double * 3).in_dll(libteem, 'gageZeroNormal')
 gageErr = (POINTER(airEnum)).in_dll(libteem, 'gageErr')
@@ -3710,33 +3777,26 @@
 gageOptimSigSet = libteem.gageOptimSigSet
 gageOptimSigSet.restype = c_int
 gageOptimSigSet.argtypes = [POINTER(c_double), c_uint, c_uint]
-gageOptimSigParmNew = libteem.gageOptimSigParmNew
-gageOptimSigParmNew.restype = POINTER(gageOptimSigParm)
-gageOptimSigParmNew.argtypes = [c_uint]
-gageOptimSigParmNix = libteem.gageOptimSigParmNix
-gageOptimSigParmNix.restype = POINTER(gageOptimSigParm)
-gageOptimSigParmNix.argtypes = [POINTER(gageOptimSigParm)]
-gageOptimSigTruthSet = libteem.gageOptimSigTruthSet
-gageOptimSigTruthSet.restype = c_int
-gageOptimSigTruthSet.argtypes = [POINTER(gageOptimSigParm), c_uint, c_double, c_double, c_uint]
+gageOptimSigContextNew = libteem.gageOptimSigContextNew
+gageOptimSigContextNew.restype = POINTER(gageOptimSigContext)
+gageOptimSigContextNew.argtypes = [c_uint, c_uint, c_uint, c_double, c_double, c_double]
+gageOptimSigContextNix = libteem.gageOptimSigContextNix
+gageOptimSigContextNix.restype = POINTER(gageOptimSigContext)
+gageOptimSigContextNix.argtypes = [POINTER(gageOptimSigContext)]
+NrrdKernelSpec._pack_ = 4
+NrrdKernelSpec._fields_ = [
+    ('kernel', POINTER(NrrdKernel)),
+    ('parm', c_double * 8),
+]
 gageOptimSigCalculate = libteem.gageOptimSigCalculate
 gageOptimSigCalculate.restype = c_int
-gageOptimSigCalculate.argtypes = [POINTER(gageOptimSigParm), POINTER(c_double), c_uint, c_int, c_int, c_double, c_uint]
-gageOptimSigPlot = libteem.gageOptimSigPlot
-gageOptimSigPlot.restype = c_int
-gageOptimSigPlot.argtypes = [POINTER(gageOptimSigParm), POINTER(Nrrd), POINTER(c_double), c_uint, c_int, c_int]
-gageTauOfTee = libteem.gageTauOfTee
-gageTauOfTee.restype = c_double
-gageTauOfTee.argtypes = [c_double]
-gageTeeOfTau = libteem.gageTeeOfTau
-gageTeeOfTau.restype = c_double
-gageTeeOfTau.argtypes = [c_double]
-gageSigOfTau = libteem.gageSigOfTau
-gageSigOfTau.restype = c_double
-gageSigOfTau.argtypes = [c_double]
-gageTauOfSig = libteem.gageTauOfSig
-gageTauOfSig.restype = c_double
-gageTauOfSig.argtypes = [c_double]
+gageOptimSigCalculate.argtypes = [POINTER(gageOptimSigContext), POINTER(c_double), c_uint, POINTER(NrrdKernelSpec), c_int, c_int, c_uint, c_double]
+gageOptimSigErrorPlot = libteem.gageOptimSigErrorPlot
+gageOptimSigErrorPlot.restype = c_int
+gageOptimSigErrorPlot.argtypes = [POINTER(gageOptimSigContext), POINTER(Nrrd), POINTER(c_double), c_uint, POINTER(NrrdKernelSpec), c_int]
+gageOptimSigErrorPlotSliding = libteem.gageOptimSigErrorPlotSliding
+gageOptimSigErrorPlotSliding.restype = c_int
+gageOptimSigErrorPlotSliding.argtypes = [POINTER(gageOptimSigContext), POINTER(Nrrd), c_double, c_uint, POINTER(NrrdKernelSpec), c_int]
 gageStackWtoI = libteem.gageStackWtoI
 gageStackWtoI.restype = c_double
 gageStackWtoI.argtypes = [POINTER(gageContext), c_double, POINTER(c_int)]
@@ -3755,32 +3815,67 @@
 gageStackProbeSpace = libteem.gageStackProbeSpace
 gageStackProbeSpace.restype = c_int
 gageStackProbeSpace.argtypes = [POINTER(gageContext), c_double, c_double, c_double, c_double, c_int, c_int]
+gageSigmaSampling = (POINTER(airEnum)).in_dll(libteem, 'gageSigmaSampling')
 gageStackBlurParmNew = libteem.gageStackBlurParmNew
 gageStackBlurParmNew.restype = POINTER(gageStackBlurParm)
 gageStackBlurParmNew.argtypes = []
+gageStackBlurParmCopy = libteem.gageStackBlurParmCopy
+gageStackBlurParmCopy.restype = c_int
+gageStackBlurParmCopy.argtypes = [POINTER(gageStackBlurParm), POINTER(gageStackBlurParm)]
+gageStackBlurParmInit = libteem.gageStackBlurParmInit
+gageStackBlurParmInit.restype = None
+gageStackBlurParmInit.argtypes = [POINTER(gageStackBlurParm)]
 gageStackBlurParmNix = libteem.gageStackBlurParmNix
 gageStackBlurParmNix.restype = POINTER(gageStackBlurParm)
 gageStackBlurParmNix.argtypes = [POINTER(gageStackBlurParm)]
+gageStackBlurParmCompare = libteem.gageStackBlurParmCompare
+gageStackBlurParmCompare.restype = c_int
+gageStackBlurParmCompare.argtypes = [POINTER(gageStackBlurParm), STRING, POINTER(gageStackBlurParm), STRING, POINTER(c_int), STRING]
 gageStackBlurParmScaleSet = libteem.gageStackBlurParmScaleSet
 gageStackBlurParmScaleSet.restype = c_int
 gageStackBlurParmScaleSet.argtypes = [POINTER(gageStackBlurParm), c_uint, c_double, c_double, c_int, c_int]
-NrrdKernelSpec._pack_ = 4
-NrrdKernelSpec._fields_ = [
-    ('kernel', POINTER(NrrdKernel)),
-    ('parm', c_double * 8),
-]
+gageStackBlurParmSigmaSet = libteem.gageStackBlurParmSigmaSet
+gageStackBlurParmSigmaSet.restype = c_int
+gageStackBlurParmSigmaSet.argtypes = [POINTER(gageStackBlurParm), c_uint, c_double, c_double, c_int]
 gageStackBlurParmKernelSet = libteem.gageStackBlurParmKernelSet
 gageStackBlurParmKernelSet.restype = c_int
-gageStackBlurParmKernelSet.argtypes = [POINTER(gageStackBlurParm), POINTER(NrrdKernelSpec), c_int]
+gageStackBlurParmKernelSet.argtypes = [POINTER(gageStackBlurParm), POINTER(NrrdKernelSpec)]
+gageStackBlurParmRenormalizeSet = libteem.gageStackBlurParmRenormalizeSet
+gageStackBlurParmRenormalizeSet.restype = c_int
+gageStackBlurParmRenormalizeSet.argtypes = [POINTER(gageStackBlurParm), c_int]
+gageStackBlurParmDgGoodSigmaMaxSet = libteem.gageStackBlurParmDgGoodSigmaMaxSet
+gageStackBlurParmDgGoodSigmaMaxSet.restype = c_int
+gageStackBlurParmDgGoodSigmaMaxSet.argtypes = [POINTER(gageStackBlurParm), c_double]
 gageStackBlurParmBoundarySet = libteem.gageStackBlurParmBoundarySet
 gageStackBlurParmBoundarySet.restype = c_int
 gageStackBlurParmBoundarySet.argtypes = [POINTER(gageStackBlurParm), c_int, c_double]
+NrrdBoundarySpec._pack_ = 4
+NrrdBoundarySpec._fields_ = [
+    ('boundary', c_int),
+    ('padValue', c_double),
+]
+gageStackBlurParmBoundarySpecSet = libteem.gageStackBlurParmBoundarySpecSet
+gageStackBlurParmBoundarySpecSet.restype = c_int
+gageStackBlurParmBoundarySpecSet.argtypes = [POINTER(gageStackBlurParm), POINTER(NrrdBoundarySpec)]
+gageStackBlurParmNeedSpatialBlurSet = libteem.gageStackBlurParmNeedSpatialBlurSet
+gageStackBlurParmNeedSpatialBlurSet.restype = c_int
+gageStackBlurParmNeedSpatialBlurSet.argtypes = [POINTER(gageStackBlurParm), c_int]
 gageStackBlurParmVerboseSet = libteem.gageStackBlurParmVerboseSet
 gageStackBlurParmVerboseSet.restype = c_int
 gageStackBlurParmVerboseSet.argtypes = [POINTER(gageStackBlurParm), c_int]
+gageStackBlurParmOneDimSet = libteem.gageStackBlurParmOneDimSet
+gageStackBlurParmOneDimSet.restype = c_int
+gageStackBlurParmOneDimSet.argtypes = [POINTER(gageStackBlurParm), c_int]
 gageStackBlurParmCheck = libteem.gageStackBlurParmCheck
 gageStackBlurParmCheck.restype = c_int
 gageStackBlurParmCheck.argtypes = [POINTER(gageStackBlurParm)]
+gageStackBlurParmParse = libteem.gageStackBlurParmParse
+gageStackBlurParmParse.restype = c_int
+gageStackBlurParmParse.argtypes = [POINTER(gageStackBlurParm), POINTER(c_int), POINTER(STRING), STRING]
+gageHestStackBlurParm = (POINTER(hestCB)).in_dll(libteem, 'gageHestStackBlurParm')
+gageStackBlurParmSprint = libteem.gageStackBlurParmSprint
+gageStackBlurParmSprint.restype = c_int
+gageStackBlurParmSprint.argtypes = [STRING, POINTER(gageStackBlurParm), POINTER(c_int), STRING]
 gageStackBlur = libteem.gageStackBlur
 gageStackBlur.restype = c_int
 gageStackBlur.argtypes = [POINTER(POINTER(Nrrd)), POINTER(gageStackBlurParm), POINTER(Nrrd), POINTER(gageKind)]
@@ -3866,6 +3961,7 @@
     ('CB', POINTER(hestCB)),
     ('kind', c_int),
     ('alloc', c_int),
+    ('source', c_int),
 ]
 hestParm._fields_ = [
     ('verbosity', c_int),
@@ -3911,7 +4007,7 @@
 hestParmFree.restype = POINTER(hestParm)
 hestParmFree.argtypes = [POINTER(hestParm)]
 hestOptAdd = libteem.hestOptAdd
-hestOptAdd.restype = None
+hestOptAdd.restype = c_uint
 hestOptAdd.argtypes = [POINTER(POINTER(hestOpt)), STRING, STRING, c_int, c_int, c_int, c_void_p, STRING, STRING]
 hestOptFree = libteem.hestOptFree
 hestOptFree.restype = POINTER(hestOpt)
@@ -4598,15 +4694,11 @@
     ('kind', POINTER(gageKind)),
     ('fileName', STRING),
     ('volName', STRING),
-    ('derivNormSS', c_int),
-    ('uniformSS', c_int),
-    ('optimSS', c_int),
+    ('sbp', POINTER(gageStackBlurParm)),
     ('leeching', c_int),
+    ('derivNormSS', c_int),
     ('recomputedSS', c_int),
-    ('numSS', c_uint),
-    ('rangeSS', c_double * 2),
     ('derivNormBiasSS', c_double),
-    ('posSS', POINTER(c_double)),
     ('nin', POINTER(Nrrd)),
     ('ninSS', POINTER(POINTER(Nrrd))),
 ]
@@ -4626,19 +4718,25 @@
 meetPullVolNew = libteem.meetPullVolNew
 meetPullVolNew.restype = POINTER(meetPullVol)
 meetPullVolNew.argtypes = []
+meetPullVolCopy = libteem.meetPullVolCopy
+meetPullVolCopy.restype = POINTER(meetPullVol)
+meetPullVolCopy.argtypes = [POINTER(meetPullVol)]
 meetPullVolParse = libteem.meetPullVolParse
 meetPullVolParse.restype = c_int
 meetPullVolParse.argtypes = [POINTER(meetPullVol), STRING]
 meetPullVolLeechable = libteem.meetPullVolLeechable
 meetPullVolLeechable.restype = c_int
-meetPullVolLeechable.argtypes = [POINTER(meetPullVol), POINTER(meetPullVol)]
+meetPullVolLeechable.argtypes = [POINTER(meetPullVol), POINTER(meetPullVol), POINTER(c_int), STRING]
 meetPullVolNix = libteem.meetPullVolNix
 meetPullVolNix.restype = POINTER(meetPullVol)
 meetPullVolNix.argtypes = [POINTER(meetPullVol)]
 meetHestPullVol = (POINTER(hestCB)).in_dll(libteem, 'meetHestPullVol')
+meetPullVolStackBlurParmFinishMulti = libteem.meetPullVolStackBlurParmFinishMulti
+meetPullVolStackBlurParmFinishMulti.restype = c_int
+meetPullVolStackBlurParmFinishMulti.argtypes = [POINTER(POINTER(meetPullVol)), c_uint, POINTER(c_uint), POINTER(c_uint), POINTER(NrrdKernelSpec), POINTER(NrrdBoundarySpec)]
 meetPullVolLoadMulti = libteem.meetPullVolLoadMulti
 meetPullVolLoadMulti.restype = c_int
-meetPullVolLoadMulti.argtypes = [POINTER(POINTER(meetPullVol)), c_uint, STRING, POINTER(NrrdKernelSpec), c_int, c_double, c_int]
+meetPullVolLoadMulti.argtypes = [POINTER(POINTER(meetPullVol)), c_uint, STRING, c_int]
 class pullContext_t(Structure):
     pass
 pullContext = pullContext_t
@@ -4996,6 +5094,9 @@
 nrrdGetenvDouble = libteem.nrrdGetenvDouble
 nrrdGetenvDouble.restype = c_int
 nrrdGetenvDouble.argtypes = [POINTER(c_double), POINTER(STRING), STRING]
+nrrdGetenvString = libteem.nrrdGetenvString
+nrrdGetenvString.restype = c_int
+nrrdGetenvString.argtypes = [POINTER(STRING), STRING]
 nrrdDefaultGetenv = libteem.nrrdDefaultGetenv
 nrrdDefaultGetenv.restype = None
 nrrdDefaultGetenv.argtypes = []
@@ -5024,6 +5125,27 @@
 nrrdTypeIsIntegral = (c_int * 12).in_dll(libteem, 'nrrdTypeIsIntegral')
 nrrdTypeIsUnsigned = (c_int * 12).in_dll(libteem, 'nrrdTypeIsUnsigned')
 nrrdPresent = (c_int).in_dll(libteem, 'nrrdPresent')
+nrrdBoundarySpecNew = libteem.nrrdBoundarySpecNew
+nrrdBoundarySpecNew.restype = POINTER(NrrdBoundarySpec)
+nrrdBoundarySpecNew.argtypes = []
+nrrdBoundarySpecNix = libteem.nrrdBoundarySpecNix
+nrrdBoundarySpecNix.restype = POINTER(NrrdBoundarySpec)
+nrrdBoundarySpecNix.argtypes = [POINTER(NrrdBoundarySpec)]
+nrrdBoundarySpecCopy = libteem.nrrdBoundarySpecCopy
+nrrdBoundarySpecCopy.restype = POINTER(NrrdBoundarySpec)
+nrrdBoundarySpecCopy.argtypes = [POINTER(NrrdBoundarySpec)]
+nrrdBoundarySpecCheck = libteem.nrrdBoundarySpecCheck
+nrrdBoundarySpecCheck.restype = c_int
+nrrdBoundarySpecCheck.argtypes = [POINTER(NrrdBoundarySpec)]
+nrrdBoundarySpecParse = libteem.nrrdBoundarySpecParse
+nrrdBoundarySpecParse.restype = c_int
+nrrdBoundarySpecParse.argtypes = [POINTER(NrrdBoundarySpec), STRING]
+nrrdBoundarySpecSprint = libteem.nrrdBoundarySpecSprint
+nrrdBoundarySpecSprint.restype = c_int
+nrrdBoundarySpecSprint.argtypes = [STRING, POINTER(NrrdBoundarySpec)]
+nrrdBoundarySpecCompare = libteem.nrrdBoundarySpecCompare
+nrrdBoundarySpecCompare.restype = c_int
+nrrdBoundarySpecCompare.argtypes = [POINTER(NrrdBoundarySpec), POINTER(NrrdBoundarySpec), POINTER(c_int), STRING]
 class NrrdIoState_t(Structure):
     pass
 NrrdIoState = NrrdIoState_t
@@ -5431,6 +5553,7 @@
 nrrdUntile2D.argtypes = [POINTER(Nrrd), POINTER(Nrrd), c_uint, c_uint, c_uint, c_size_t, c_size_t]
 nrrdHestNrrd = (POINTER(hestCB)).in_dll(libteem, 'nrrdHestNrrd')
 nrrdHestKernelSpec = (POINTER(hestCB)).in_dll(libteem, 'nrrdHestKernelSpec')
+nrrdHestBoundarySpec = (POINTER(hestCB)).in_dll(libteem, 'nrrdHestBoundarySpec')
 nrrdHestIter = (POINTER(hestCB)).in_dll(libteem, 'nrrdHestIter')
 class NrrdIter(Structure):
     pass
@@ -5501,6 +5624,9 @@
 nrrdClampConvert = libteem.nrrdClampConvert
 nrrdClampConvert.restype = c_int
 nrrdClampConvert.argtypes = [POINTER(Nrrd), POINTER(Nrrd), c_int]
+nrrdCastClampRound = libteem.nrrdCastClampRound
+nrrdCastClampRound.restype = c_int
+nrrdCastClampRound.argtypes = [POINTER(Nrrd), POINTER(Nrrd), c_int, c_int, c_int]
 nrrdQuantize = libteem.nrrdQuantize
 nrrdQuantize.restype = c_int
 nrrdQuantize.argtypes = [POINTER(Nrrd), POINTER(Nrrd), POINTER(NrrdRange), c_uint]
@@ -5579,7 +5705,7 @@
 nrrdInset = libteem.nrrdInset
 nrrdInset.restype = c_int
 nrrdInset.argtypes = [POINTER(Nrrd), POINTER(Nrrd), POINTER(Nrrd), POINTER(c_size_t)]
-nrrdMeasureLine = (CFUNCTYPE(None, c_void_p, c_int, c_void_p, c_int, c_size_t, c_double, c_double) * 30).in_dll(libteem, 'nrrdMeasureLine')
+nrrdMeasureLine = (CFUNCTYPE(None, c_void_p, c_int, c_void_p, c_int, c_size_t, c_double, c_double) * 31).in_dll(libteem, 'nrrdMeasureLine')
 nrrdProject = libteem.nrrdProject
 nrrdProject.restype = c_int
 nrrdProject.argtypes = [POINTER(Nrrd), POINTER(Nrrd), c_uint, c_int, c_int]
@@ -5732,6 +5858,9 @@
 nrrdResamplePadValueSet = libteem.nrrdResamplePadValueSet
 nrrdResamplePadValueSet.restype = c_int
 nrrdResamplePadValueSet.argtypes = [POINTER(NrrdResampleContext), c_double]
+nrrdResampleBoundarySpecSet = libteem.nrrdResampleBoundarySpecSet
+nrrdResampleBoundarySpecSet.restype = c_int
+nrrdResampleBoundarySpecSet.argtypes = [POINTER(NrrdResampleContext), POINTER(NrrdBoundarySpec)]
 nrrdResampleTypeOutSet = libteem.nrrdResampleTypeOutSet
 nrrdResampleTypeOutSet.restype = c_int
 nrrdResampleTypeOutSet.argtypes = [POINTER(NrrdResampleContext), c_int]
@@ -5884,6 +6013,7 @@
 nrrdKernelGaussianD = (POINTER(NrrdKernel)).in_dll(libteem, 'nrrdKernelGaussianD')
 nrrdKernelGaussianDD = (POINTER(NrrdKernel)).in_dll(libteem, 'nrrdKernelGaussianDD')
 nrrdKernelDiscreteGaussian = (POINTER(NrrdKernel)).in_dll(libteem, 'nrrdKernelDiscreteGaussian')
+nrrdKernelDiscreteGaussianGoodSigmaMax = (c_double).in_dll(libteem, 'nrrdKernelDiscreteGaussianGoodSigmaMax')
 nrrdKernelParse = libteem.nrrdKernelParse
 nrrdKernelParse.restype = c_int
 nrrdKernelParse.argtypes = [POINTER(POINTER(NrrdKernel)), POINTER(c_double), STRING]
@@ -5899,6 +6029,9 @@
 nrrdKernelCompare = libteem.nrrdKernelCompare
 nrrdKernelCompare.restype = c_int
 nrrdKernelCompare.argtypes = [POINTER(NrrdKernel), POINTER(c_double), POINTER(NrrdKernel), POINTER(c_double), POINTER(c_int), STRING]
+nrrdKernelSpecCompare = libteem.nrrdKernelSpecCompare
+nrrdKernelSpecCompare.restype = c_int
+nrrdKernelSpecCompare.argtypes = [POINTER(NrrdKernelSpec), POINTER(NrrdKernelSpec), POINTER(c_int), STRING]
 nrrdKernelCheck = libteem.nrrdKernelCheck
 nrrdKernelCheck.restype = c_int
 nrrdKernelCheck.argtypes = [POINTER(NrrdKernel), POINTER(c_double), c_size_t, c_double, c_uint, c_uint, POINTER(NrrdKernel), POINTER(c_double)]
@@ -6075,11 +6208,13 @@
     ('nixAtVolumeEdgeSpace', c_int),
     ('constraintBeforeSeedThresh', c_int),
     ('popCntlEnoughTest', c_int),
+    ('convergenceIgnoresPopCntl', c_int),
     ('noAdd', c_int),
     ('binSingle', c_int),
     ('allowCodimension3Constraints', c_int),
     ('scaleIsTau', c_int),
     ('startSkipsPoints', c_int),
+    ('zeroZ', c_int),
 ]
 pullContext_t._pack_ = 4
 pullContext_t._fields_ = [
@@ -6271,6 +6406,7 @@
 pullProp = (POINTER(airEnum)).in_dll(libteem, 'pullProp')
 pullProcessMode = (POINTER(airEnum)).in_dll(libteem, 'pullProcessMode')
 pullTraceStop = (POINTER(airEnum)).in_dll(libteem, 'pullTraceStop')
+pullInitMethod = (POINTER(airEnum)).in_dll(libteem, 'pullInitMethod')
 pullCount = (POINTER(airEnum)).in_dll(libteem, 'pullCount')
 pullConstraintFail = (POINTER(airEnum)).in_dll(libteem, 'pullConstraintFail')
 pullPropLen = libteem.pullPropLen
@@ -6356,7 +6492,7 @@
 pullTraceMultiSizeof.argtypes = [POINTER(pullTraceMulti)]
 pullTraceSet = libteem.pullTraceSet
 pullTraceSet.restype = c_int
-pullTraceSet.argtypes = [POINTER(pullContext), POINTER(pullTrace), c_int, c_double, c_double, c_double, c_uint, POINTER(c_double)]
+pullTraceSet.argtypes = [POINTER(pullContext), POINTER(pullTrace), c_int, c_int, c_double, c_double, c_double, c_uint, POINTER(c_double)]
 pullTraceMultiNew = libteem.pullTraceMultiNew
 pullTraceMultiNew.restype = POINTER(pullTraceMulti)
 pullTraceMultiNew.argtypes = []
@@ -6371,7 +6507,7 @@
 pullTraceMultiFilterConcaveDown.argtypes = [POINTER(Nrrd), POINTER(pullTraceMulti), c_double]
 pullTraceMultiPlotAdd = libteem.pullTraceMultiPlotAdd
 pullTraceMultiPlotAdd.restype = c_int
-pullTraceMultiPlotAdd.argtypes = [POINTER(Nrrd), POINTER(pullTraceMulti), POINTER(Nrrd), c_uint, c_uint]
+pullTraceMultiPlotAdd.argtypes = [POINTER(Nrrd), POINTER(pullTraceMulti), POINTER(Nrrd), c_int, c_uint, c_uint]
 pullTraceMultiWrite = libteem.pullTraceMultiWrite
 pullTraceMultiWrite.restype = c_int
 pullTraceMultiWrite.argtypes = [POINTER(FILE), POINTER(pullTraceMulti)]
@@ -6907,7 +7043,7 @@
     ('whyStop', c_int * 2),
     ('whyNowhere', c_int),
     ('nval', POINTER(Nrrd)),
-    ('measr', c_double * 30),
+    ('measr', c_double * 31),
 ]
 class tenFiberMulti(Structure):
     pass
@@ -7690,46 +7826,46 @@
 tenEMBimodal = libteem.tenEMBimodal
 tenEMBimodal.restype = c_int
 tenEMBimodal.argtypes = [POINTER(tenEMBimodalParm), POINTER(Nrrd)]
-tend_epiregCmd = (unrrduCmd).in_dll(libteem, 'tend_epiregCmd')
+tend_simCmd = (unrrduCmd).in_dll(libteem, 'tend_simCmd')
+tend_evqCmd = (unrrduCmd).in_dll(libteem, 'tend_evqCmd')
+tend_bmatCmd = (unrrduCmd).in_dll(libteem, 'tend_bmatCmd')
+tend_tconvCmd = (unrrduCmd).in_dll(libteem, 'tend_tconvCmd')
+tend_evecrgbCmd = (unrrduCmd).in_dll(libteem, 'tend_evecrgbCmd')
 tend_pointCmd = (unrrduCmd).in_dll(libteem, 'tend_pointCmd')
+tend_expandCmd = (unrrduCmd).in_dll(libteem, 'tend_expandCmd')
+tend_ellipseCmd = (unrrduCmd).in_dll(libteem, 'tend_ellipseCmd')
+tend_anplotCmd = (unrrduCmd).in_dll(libteem, 'tend_anplotCmd')
 tend_evalclampCmd = (unrrduCmd).in_dll(libteem, 'tend_evalclampCmd')
-tend_evaladdCmd = (unrrduCmd).in_dll(libteem, 'tend_evaladdCmd')
-tend_satinCmd = (unrrduCmd).in_dll(libteem, 'tend_satinCmd')
-tend_evalpowCmd = (unrrduCmd).in_dll(libteem, 'tend_evalpowCmd')
+tend_unmfCmd = (unrrduCmd).in_dll(libteem, 'tend_unmfCmd')
+tend_msimCmd = (unrrduCmd).in_dll(libteem, 'tend_msimCmd')
 tend_evalCmd = (unrrduCmd).in_dll(libteem, 'tend_evalCmd')
-tend_glyphCmd = (unrrduCmd).in_dll(libteem, 'tend_glyphCmd')
-tend_aboutCmd = (unrrduCmd).in_dll(libteem, 'tend_aboutCmd')
+tend_evalmultCmd = (unrrduCmd).in_dll(libteem, 'tend_evalmultCmd')
+tend_estimCmd = (unrrduCmd).in_dll(libteem, 'tend_estimCmd')
 tend_gradsCmd = (unrrduCmd).in_dll(libteem, 'tend_gradsCmd')
-tend_unmfCmd = (unrrduCmd).in_dll(libteem, 'tend_unmfCmd')
+tend_mconvCmd = (unrrduCmd).in_dll(libteem, 'tend_mconvCmd')
+tend_avgCmd = (unrrduCmd).in_dll(libteem, 'tend_avgCmd')
+tend_fiberCmd = (unrrduCmd).in_dll(libteem, 'tend_fiberCmd')
+tend_shrinkCmd = (unrrduCmd).in_dll(libteem, 'tend_shrinkCmd')
 tend_mfitCmd = (unrrduCmd).in_dll(libteem, 'tend_mfitCmd')
-tend_normCmd = (unrrduCmd).in_dll(libteem, 'tend_normCmd')
 tend_bfitCmd = (unrrduCmd).in_dll(libteem, 'tend_bfitCmd')
-tend_evqCmd = (unrrduCmd).in_dll(libteem, 'tend_evqCmd')
 tend_helixCmd = (unrrduCmd).in_dll(libteem, 'tend_helixCmd')
-tend_fiberCmd = (unrrduCmd).in_dll(libteem, 'tend_fiberCmd')
-tend_stenCmd = (unrrduCmd).in_dll(libteem, 'tend_stenCmd')
 tend_anhistCmd = (unrrduCmd).in_dll(libteem, 'tend_anhistCmd')
-tend_shrinkCmd = (unrrduCmd).in_dll(libteem, 'tend_shrinkCmd')
+tend_normCmd = (unrrduCmd).in_dll(libteem, 'tend_normCmd')
+tend_anscaleCmd = (unrrduCmd).in_dll(libteem, 'tend_anscaleCmd')
+tend_epiregCmd = (unrrduCmd).in_dll(libteem, 'tend_epiregCmd')
+tend_anvolCmd = (unrrduCmd).in_dll(libteem, 'tend_anvolCmd')
 tend_tripleCmd = (unrrduCmd).in_dll(libteem, 'tend_tripleCmd')
-tend_evecCmd = (unrrduCmd).in_dll(libteem, 'tend_evecCmd')
-tend_makeCmd = (unrrduCmd).in_dll(libteem, 'tend_makeCmd')
-tend_tconvCmd = (unrrduCmd).in_dll(libteem, 'tend_tconvCmd')
-tend_simCmd = (unrrduCmd).in_dll(libteem, 'tend_simCmd')
-tend_avgCmd = (unrrduCmd).in_dll(libteem, 'tend_avgCmd')
-tend_estimCmd = (unrrduCmd).in_dll(libteem, 'tend_estimCmd')
 tend_sliceCmd = (unrrduCmd).in_dll(libteem, 'tend_sliceCmd')
-tend_evecrgbCmd = (unrrduCmd).in_dll(libteem, 'tend_evecrgbCmd')
-tend_expandCmd = (unrrduCmd).in_dll(libteem, 'tend_expandCmd')
-tend_logCmd = (unrrduCmd).in_dll(libteem, 'tend_logCmd')
-tend_msimCmd = (unrrduCmd).in_dll(libteem, 'tend_msimCmd')
-tend_anplotCmd = (unrrduCmd).in_dll(libteem, 'tend_anplotCmd')
+tend_evaladdCmd = (unrrduCmd).in_dll(libteem, 'tend_evaladdCmd')
+tend_stenCmd = (unrrduCmd).in_dll(libteem, 'tend_stenCmd')
+tend_glyphCmd = (unrrduCmd).in_dll(libteem, 'tend_glyphCmd')
+tend_aboutCmd = (unrrduCmd).in_dll(libteem, 'tend_aboutCmd')
+tend_makeCmd = (unrrduCmd).in_dll(libteem, 'tend_makeCmd')
+tend_satinCmd = (unrrduCmd).in_dll(libteem, 'tend_satinCmd')
 tend_expCmd = (unrrduCmd).in_dll(libteem, 'tend_expCmd')
-tend_ellipseCmd = (unrrduCmd).in_dll(libteem, 'tend_ellipseCmd')
-tend_bmatCmd = (unrrduCmd).in_dll(libteem, 'tend_bmatCmd')
-tend_mconvCmd = (unrrduCmd).in_dll(libteem, 'tend_mconvCmd')
-tend_evalmultCmd = (unrrduCmd).in_dll(libteem, 'tend_evalmultCmd')
-tend_anvolCmd = (unrrduCmd).in_dll(libteem, 'tend_anvolCmd')
-tend_anscaleCmd = (unrrduCmd).in_dll(libteem, 'tend_anscaleCmd')
+tend_evecCmd = (unrrduCmd).in_dll(libteem, 'tend_evecCmd')
+tend_logCmd = (unrrduCmd).in_dll(libteem, 'tend_logCmd')
+tend_evalpowCmd = (unrrduCmd).in_dll(libteem, 'tend_evalpowCmd')
 tendCmdList = (POINTER(unrrduCmd) * 0).in_dll(libteem, 'tendCmdList')
 tendFiberStopCB = (POINTER(hestCB)).in_dll(libteem, 'tendFiberStopCB')
 tendTitle = (STRING).in_dll(libteem, 'tendTitle')
@@ -8002,6 +8138,18 @@
 tijk_esh_to_3d_sym_f = libteem.tijk_esh_to_3d_sym_f
 tijk_esh_to_3d_sym_f.restype = POINTER(tijk_type)
 tijk_esh_to_3d_sym_f.argtypes = [POINTER(c_float), POINTER(c_float), c_uint]
+tijk_3d_sym_to_esh_matrix_d = libteem.tijk_3d_sym_to_esh_matrix_d
+tijk_3d_sym_to_esh_matrix_d.restype = POINTER(c_double)
+tijk_3d_sym_to_esh_matrix_d.argtypes = [POINTER(tijk_type)]
+tijk_3d_sym_to_esh_matrix_f = libteem.tijk_3d_sym_to_esh_matrix_f
+tijk_3d_sym_to_esh_matrix_f.restype = POINTER(c_float)
+tijk_3d_sym_to_esh_matrix_f.argtypes = [POINTER(tijk_type)]
+tijk_esh_to_3d_sym_matrix_d = libteem.tijk_esh_to_3d_sym_matrix_d
+tijk_esh_to_3d_sym_matrix_d.restype = POINTER(c_double)
+tijk_esh_to_3d_sym_matrix_d.argtypes = [c_uint]
+tijk_esh_to_3d_sym_matrix_f = libteem.tijk_esh_to_3d_sym_matrix_f
+tijk_esh_to_3d_sym_matrix_f.restype = POINTER(c_float)
+tijk_esh_to_3d_sym_matrix_f.argtypes = [c_uint]
 tijk_esh_convolve_d = libteem.tijk_esh_convolve_d
 tijk_esh_convolve_d.restype = None
 tijk_esh_convolve_d.argtypes = [POINTER(c_double), POINTER(c_double), POINTER(c_double), c_uint]
@@ -8073,71 +8221,73 @@
 tijk_get_axis_type = libteem.tijk_get_axis_type
 tijk_get_axis_type.restype = c_int
 tijk_get_axis_type.argtypes = [POINTER(tijk_axis_info), POINTER(Nrrd), c_uint]
-unrrdu_makeCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_makeCmd')
-unrrdu_w2iCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_w2iCmd')
-unrrdu_envCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_envCmd')
-unrrdu_vidiconCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_vidiconCmd')
-unrrdu_joinCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_joinCmd')
-unrrdu_ccmergeCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_ccmergeCmd')
-unrrdu_axdeleteCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_axdeleteCmd')
-unrrdu_tileCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_tileCmd')
-unrrdu_unquantizeCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_unquantizeCmd')
-unrrdu_flipCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_flipCmd')
-unrrdu_dataCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_dataCmd')
+unrrdu_axinsertCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_axinsertCmd')
 unrrdu_2opCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_2opCmd')
-unrrdu_mrmapCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_mrmapCmd')
-unrrdu_shuffleCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_shuffleCmd')
+unrrdu_axmergeCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_axmergeCmd')
+unrrdu_projectCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_projectCmd')
+unrrdu_padCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_padCmd')
+unrrdu_reshapeCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_reshapeCmd')
+unrrdu_ccfindCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_ccfindCmd')
+unrrdu_undosCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_undosCmd')
+unrrdu_permuteCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_permuteCmd')
+unrrdu_cksumCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_cksumCmd')
+unrrdu_sliceCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_sliceCmd')
 unrrdu_i2wCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_i2wCmd')
+unrrdu_envCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_envCmd')
+unrrdu_jhistoCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_jhistoCmd')
+unrrdu_spliceCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_spliceCmd')
+unrrdu_swapCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_swapCmd')
+unrrdu_rmapCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_rmapCmd')
+unrrdu_insetCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_insetCmd')
+unrrdu_shuffleCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_shuffleCmd')
+unrrdu_substCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_substCmd')
+unrrdu_axdeleteCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_axdeleteCmd')
+unrrdu_w2iCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_w2iCmd')
+unrrdu_gammaCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_gammaCmd')
+unrrdu_ccadjCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_ccadjCmd')
+unrrdu_1opCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_1opCmd')
+unrrdu_histoCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_histoCmd')
+unrrdu_joinCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_joinCmd')
+unrrdu_histaxCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_histaxCmd')
+unrrdu_lut2Cmd = (unrrduCmd).in_dll(libteem, 'unrrdu_lut2Cmd')
 unrrdu_cropCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_cropCmd')
-unrrdu_convertCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_convertCmd')
-unrrdu_axinfoCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_axinfoCmd')
-unrrdu_distCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_distCmd')
-unrrdu_axmergeCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_axmergeCmd')
+unrrdu_dhistoCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_dhistoCmd')
 unrrdu_headCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_headCmd')
+unrrdu_axinfoCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_axinfoCmd')
 unrrdu_resampleCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_resampleCmd')
-unrrdu_sselectCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_sselectCmd')
-unrrdu_ccadjCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_ccadjCmd')
-unrrdu_deringCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_deringCmd')
-unrrdu_histaxCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_histaxCmd')
 unrrdu_imapCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_imapCmd')
-unrrdu_dnormCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_dnormCmd')
-unrrdu_insetCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_insetCmd')
-unrrdu_substCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_substCmd')
-unrrdu_permuteCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_permuteCmd')
-unrrdu_histoCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_histoCmd')
+unrrdu_ccmergeCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_ccmergeCmd')
+unrrdu_lutCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_lutCmd')
+unrrdu_aboutCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_aboutCmd')
+unrrdu_vidiconCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_vidiconCmd')
 unrrdu_cmedianCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_cmedianCmd')
-unrrdu_spliceCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_spliceCmd')
-unrrdu_acropCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_acropCmd')
-unrrdu_diffCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_diffCmd')
-unrrdu_lut2Cmd = (unrrduCmd).in_dll(libteem, 'unrrdu_lut2Cmd')
-unrrdu_affineCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_affineCmd')
-unrrdu_sliceCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_sliceCmd')
+unrrdu_mlutCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_mlutCmd')
 unrrdu_quantizeCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_quantizeCmd')
-unrrdu_unorientCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_unorientCmd')
-unrrdu_axsplitCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_axsplitCmd')
-unrrdu_jhistoCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_jhistoCmd')
-unrrdu_reshapeCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_reshapeCmd')
-unrrdu_dhistoCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_dhistoCmd')
 unrrdu_ccsettleCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_ccsettleCmd')
-unrrdu_fftCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_fftCmd')
-unrrdu_projectCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_projectCmd')
-unrrdu_axinsertCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_axinsertCmd')
-unrrdu_padCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_padCmd')
-unrrdu_swapCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_swapCmd')
-unrrdu_rmapCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_rmapCmd')
+unrrdu_deringCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_deringCmd')
+unrrdu_diffCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_diffCmd')
+unrrdu_untileCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_untileCmd')
+unrrdu_tileCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_tileCmd')
+unrrdu_basinfoCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_basinfoCmd')
+unrrdu_makeCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_makeCmd')
+unrrdu_flipCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_flipCmd')
+unrrdu_mrmapCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_mrmapCmd')
 unrrdu_heqCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_heqCmd')
-unrrdu_lutCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_lutCmd')
+unrrdu_fftCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_fftCmd')
+unrrdu_distCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_distCmd')
 unrrdu_3opCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_3opCmd')
-unrrdu_cksumCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_cksumCmd')
-unrrdu_ccfindCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_ccfindCmd')
-unrrdu_diceCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_diceCmd')
-unrrdu_mlutCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_mlutCmd')
+unrrdu_unorientCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_unorientCmd')
+unrrdu_acropCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_acropCmd')
+unrrdu_sselectCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_sselectCmd')
 unrrdu_saveCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_saveCmd')
+unrrdu_unquantizeCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_unquantizeCmd')
+unrrdu_dataCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_dataCmd')
+unrrdu_dnormCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_dnormCmd')
+unrrdu_convertCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_convertCmd')
+unrrdu_affineCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_affineCmd')
+unrrdu_axsplitCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_axsplitCmd')
 unrrdu_minmaxCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_minmaxCmd')
-unrrdu_untileCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_untileCmd')
-unrrdu_gammaCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_gammaCmd')
-unrrdu_aboutCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_aboutCmd')
-unrrdu_1opCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_1opCmd')
+unrrdu_diceCmd = (unrrduCmd).in_dll(libteem, 'unrrdu_diceCmd')
 unrrduPresent = (c_int).in_dll(libteem, 'unrrduPresent')
 unrrduBiffKey = (STRING).in_dll(libteem, 'unrrduBiffKey')
 unrrduDefNumColumns = (c_uint).in_dll(libteem, 'unrrduDefNumColumns')
@@ -8277,28 +8427,28 @@
     ('ringMagnitude', c_double),
 ]
 __all__ = ['tenFiberStopUIntSet', 'biffMsgAddf',
-           'limnCameraPathTrack', 'gageVecLambda2', 'miteUserNix',
-           'gageVecSOmega', 'tenInterpTypeRThetaPhiLinear',
-           'ell_4m_post_mul_f', 'nrrdArithGamma', 'ell_Nm_check',
-           'tijk_refine_max_2d_f', 'pushEnergyCoulomb', 'tijk_class',
-           'tenEstimate1MethodMLE', 'nrrdHasNonExistOnly',
-           'nrrdFormatPNG', 'pullInterTypeLast', 'miteBiffKey',
-           'limnEdgeTypeLast', 'tenGageFAShapeIndex',
-           'tijk_approx_rankk_3d_f', 'baneMeasrUnknown', 'alanParmF',
-           'seekTypeMinimalSurface', 'pullIterParmLast',
-           'airRandMTStateNix', 'nrrdKernelCatmullRomD',
-           'pullInfoTangent1', 'pullInfoTangent2', 'alanParmK',
-           'gageContextCopy', 'miteValVdefTdotV', 'nrrdKernelC4Hexic',
-           'unrrdu_dnormCmd', 'pullEnergyCotan',
-           'tenEstimateContextNix', 'tenGageFAGeomTens',
-           'airEndsWith', 'miteUser', 'ell_4m_to_q_d',
-           'nrrdField_block_size', 'mossSamplerNew',
-           'tenFiberIntgLast', 'tenDoubleContract_d',
-           'pullInfoQuality', 'limnSpaceView', 'limnSplineMinT',
+           'limnCameraPathTrack', 'gageVecLambda2',
+           'nrrdBoundarySpecParse', 'miteUserNix', 'tenFiberIntgLast',
+           'tenInterpTypeRThetaPhiLinear', 'ell_4m_post_mul_f',
+           'nrrdArithGamma', 'ell_Nm_check', 'tijk_refine_max_2d_f',
+           'pushEnergyCoulomb', 'tijk_class', 'tenEstimate1MethodMLE',
+           'nrrdHasNonExistOnly', 'nrrdFormatPNG',
+           'pullInterTypeLast', 'miteBiffKey', 'limnEdgeTypeLast',
+           'tenGageFAShapeIndex', 'tijk_approx_rankk_3d_f',
+           'baneMeasrUnknown', 'alanParmF', 'seekTypeMinimalSurface',
+           'pullIterParmLast', 'airRandMTStateNix',
+           'nrrdKernelCatmullRomD', 'pullInfoTangent1',
+           'pullInfoTangent2', 'alanParmK', 'gageContextCopy',
+           'miteValVdefTdotV', 'nrrdKernelC4Hexic', 'unrrdu_dnormCmd',
+           'pullEnergyCotan', 'tenEstimateContextNix',
+           'tenGageFAGeomTens', 'airEndsWith', 'miteUser',
+           'ell_4m_to_q_d', 'nrrdField_block_size', 'mossSamplerNew',
+           'gageVecSOmega', 'tenDoubleContract_d', 'pullInfoQuality',
+           'limnSpaceView', 'limnSplineMinT',
            'nrrdResampleNonExistentRenormalize', 'nrrdFieldInfoParse',
            'nrrdField_space', 'baneStateHistEqSmart',
            'tenGageConfDiffusionAlign', 'gageSclK2',
-           'hestRespFileComment', 'nrrdApply2DLut', 'gageSclK1',
+           'hestRespFileComment', 'nrrdApply2DLut', 'pullCountLast',
            'tenGageNormGradMag', 'ell_q_exp_f',
            'tijk_refine_max_3d_f', 'bane1DOpacInfoFrom2D',
            'tijk_refine_max_3d_d', 'tijk_refine_max_2d_d',
@@ -8311,31 +8461,32 @@
            'limnSplineInfoSize', 'nrrdSimpleResample',
            'tenInterpTypeLoxK', 'nrrdTernaryOpIfElse',
            'tenGlyphTypePolarPlot', 'limnPolyDataCylinder',
-           'tendFiberStopCB', 'seekTypeMaximalSurface',
+           'tendFiberStopCB', 'tenGageTraceDiffusionAlign',
            'unrrdu_flipCmd', 'nrrdKeyValueSize', 'gageErrUnknown',
            'limnPolyDataNeighborArray', 'nrrdBinaryOpSgnPow',
            'nrrdKeyValueGet', 'nrrdKernelCatmullRomSupportDebugDD',
            'limnQN16octa', 'nrrdKernelC3QuinticD', 'airTypeFloat',
-           'pullFlagBinSingle', 'nrrdField_line_skip', 'miteValYi',
+           'pullFlagBinSingle', 'alanParmDeltaX', 'tenGlyphTypeBox',
            'limnLightReset', 'ellPresent', 'nrrdField_space_units',
            'gageSclShapeTrace', 'seekStrengthSet',
            'pullCondEnergyTry', 'tenDwiGage2TensorPeled',
            'nrrdKernelBSpline4DDD', 'tenGageTraceHessianEvec0',
-           'tenGageTraceHessianEvec1', 'nrrdMeasureMax',
-           'miteShadeMethodLast', 'echoMatterLightUnit',
-           'unrrdu_substCmd', 'limnHestPolyDataLMPD',
-           'baneGkms_hvolCmd', 'nrrdUnaryOpExists',
-           'nrrdSpace3DRightHandedTime', 'airArrayNix',
-           'nrrdArithIterBinaryOp', 'airFPClass_d', 'airNoDio_format',
-           'gageCtxFlagLast', 'dyeConvert', 'ell_q_3v_rotate_d',
-           'limnQNLast', 'gageParmOrientationFromSpacing',
+           'tenGageTraceHessianEvec1', 'tenGageTraceHessianEvec2',
+           'miteShadeMethodLast', 'airHeap', 'unrrdu_substCmd',
+           'limnHestPolyDataLMPD', 'baneGkms_hvolCmd',
+           'nrrdUnaryOpExists', 'nrrdSpace3DRightHandedTime',
+           'airArrayNix', 'nrrdArithIterBinaryOp', 'airFPClass_d',
+           'airNoDio_format', 'gageCtxFlagLast', 'dyeConvert',
+           'ell_q_3v_rotate_d', 'limnQNLast',
+           'gageParmOrientationFromSpacing',
            'nrrdBasicInfoMeasurementFrame', 'limnQN8octa',
            'limnPolyDataNix', 'tenInterpTypeWang',
            'limnPolyDataOctahedron', 'unrrdu_envCmd',
            'nrrdSpace3DLeftHanded', 'nrrdUnaryOpCbrt',
            'nrrdAxisInfoLast', 'coilMethodTesting',
            'tenFiberDirectionNumber', 'tijk_eval_efs_f',
-           'coilKind7Tensor', 'baneIncAnswer', 'hooverThreadBegin_t',
+           'coilKind7Tensor', 'baneIncAnswer',
+           'gageSigmaSamplingUniformTau', 'hooverThreadBegin_t',
            'airFastExp', 'tenExperSpecNix', 'pullStatusNixMe',
            'tenGageQGradVec', 'tenGageOmegaLaplacian',
            'pullTraceMultiNix', 'nrrdOriginStatusNoMin',
@@ -8350,29 +8501,30 @@
            'airInsane_UCSize', 'limnSplineTypeSpecParse',
            'limnSplineInfo4Vector', 'tenInterpParmBufferAlloc',
            'nrrdResampleRangeSet', 'unrrdu_dhistoCmd',
-           'tenFiberIntgRK4', 'pushEnergySpring', 'tenGageModeWarp',
-           'nrrdFormatUnknown', 'gageStackBlurParmScaleSet',
-           'elfMaximaParmSet', 'tenInterpTwoDiscrete_d',
-           'tenFiberStopMinNumSteps', 'nrrdKernelSprint',
-           'gageKindVolumeCheck', 'tenGageNormGradVec',
-           'tenGageQHessian', 'airHeapNix', 'limnPolyDataCone',
-           'unrrdu_distCmd', 'hestParmNew', 'tenEstimate2Method',
-           'nrrdUnaryOpAcos', 'tenModel1Stick', 'tendCmdList',
-           'airMopAlways', 'gageKindAnswerLength', 'nrrdMeasureSD',
-           'tenBMatrixCalc', 'nrrdLoad', 'miteVariableParse',
-           'pullCCSort', 'echoThreadStateNew', 'coilKindTypeLast',
-           'mossMatTranslateSet', 'nrrdBinaryOpGT',
-           'tenDefFiberMaxHalfLen', 'tenGlyphBqdEvalUv',
-           'banePosCalc', 'tijk_3o2d_sym', 'airFloatQNaN',
-           'limnPolyDataIcoSphere', 'tenEigensolve_f',
+           'meetAirEnumAllCheck', 'tenFiberIntgRK4',
+           'pushEnergySpring', 'tenGageModeWarp', 'nrrdFormatUnknown',
+           'gageStackBlurParmScaleSet', 'elfMaximaParmSet',
+           'tenInterpTwoDiscrete_d', 'tenFiberStopMinNumSteps',
+           'nrrdKernelSprint', 'gageKindVolumeCheck',
+           'tenGageNormGradVec', 'pullFlagZeroZ', 'tenGageQHessian',
+           'airHeapNix', 'tenEstimate2MethodUnknown',
+           'limnPolyDataCone', 'unrrdu_distCmd', 'hestParmNew',
+           'tenEstimate2Method', 'nrrdUnaryOpAcos', 'tenModel1Stick',
+           'tendCmdList', 'airMopAlways', 'gageKindAnswerLength',
+           'nrrdMeasureSD', 'tenBMatrixCalc', 'nrrdLoad',
+           'miteVariableParse', 'pullCCSort', 'echoThreadStateNew',
+           'coilKindTypeLast', 'mossMatTranslateSet',
+           'nrrdBinaryOpGT', 'tenDefFiberMaxHalfLen',
+           'tenGlyphBqdEvalUv', 'banePosCalc', 'tijk_3o2d_sym',
+           'airFloatQNaN', 'limnPolyDataIcoSphere', 'tenEigensolve_f',
            'pullEnergyTypeZero', 'tenEigensolve_d',
            'meetNrrdKernelAllCheck', 'tenGageQGradMag',
            'gageDefStackNormalizeDeriv', 'nrrdArithUnaryOp',
            'tenGageCp1HessianEvec2', 'tenGageCp1HessianEvec1',
            'tenGageCp1HessianEvec0', 'pullTask_t', 'echoColorSet',
-           'pullConstraintFailTravel',
-           'nrrdEnvVarStateMeasureModeBins', 'tenFiberMultiProbeVals',
-           'miteRayBegin', 'alanParmNumThreads', 'pullFlagSet',
+           'pullConstraintFailTravel', 'limnPolyDataInfo',
+           'tenFiberMultiProbeVals', 'miteRayBegin',
+           'alanParmNumThreads', 'pullFlagSet',
            'gageParmDefaultCenter', 'unrrdu_ccmergeCmd',
            'miteThreadNew', 'miteStage', 'airDrandMT53_r',
            'airMopNever', 'tenFiberTypeEvec1', 'tenFiberTypeEvec0',
@@ -8383,15 +8535,15 @@
            'tenGageFADiffusionFraction', 'gageStackBlurParm',
            'limnPolyDataSpiralSuperquadric', 'seekTypeRidgeSurfaceT',
            'nrrdBasicInfoSpaceOrigin', 'airUnescape', 'airEnumPrint',
-           'tenGageCa1HessianEval', 'alanRun',
-           'pullProcessModeNixing', 'airFPGen_f', 'airFPGen_d',
-           'airInsane_FltDblFPClass', 'pullInfoSpecNew',
-           'nrrdBinaryOpIf', 'nrrdAxisInfoSpacing', 'airExists',
-           'pullInfoLiveThresh', 'gageStackBlurParmNix',
+           'nrrdField_endian', 'alanRun', 'pullProcessModeNixing',
+           'airFPGen_f', 'airFPGen_d', 'airInsane_FltDblFPClass',
+           'pullInfoSpecNew', 'nrrdBinaryOpIf', 'nrrdAxisInfoSpacing',
+           'airExists', 'pullInfoLiveThresh', 'gageStackBlurParmNix',
            'tenDWMRINexKeyFmt', 'pullInfoInside',
            'tijk_approx_heur_3d_f', 'nrrdBinaryOpLTE',
            'gageErrStackUnused', 'nrrdZeroSet',
-           'nrrdSpaceLeftAnteriorSuperiorTime', 'unrrduScaleUnknown',
+           'nrrdSpaceLeftAnteriorSuperiorTime',
+           'pullEnergyTypeQuartic', 'airHeapMerge',
            'nrrdRangePercentileFromStringSet', 'limnPolyDataCopy',
            'coilMethodArray', 'gageDeconvolveSeparableKnown',
            'coilMethodTypeLast', 'tijk_zero_f', 'nrrdAxisInfoUnknown',
@@ -8399,27 +8551,27 @@
            'nrrdKernelBSpline2DD', 'nrrdTernaryOpMinSmooth',
            'gageShapeItoW', 'miteThreadNix', 'limnPrimitiveLines',
            'pullSysParmBeta', 'unrrduCmdList', 'nrrdUnaryOpNerf',
-           'pushTask', 'gageShapeCopy', 'tenFiberVerboseSet',
-           'nrrdSanity', 'nrrdCCFind', 'nrrdUnaryOpTan',
+           'pushTask', 'gageShapeCopy', 'ell_2m_1d_nullspace_d',
+           'nrrdSanity', 'nrrdSameSize', 'nrrdUnaryOpTan',
            'tijk_copy_f', 'tenAniso_RA', 'tenTripleTypeRThetaZ',
            'tenGageRHessian', 'gageKindCheck', 'airNoDio_size',
            'seekTypeRidgeSurface', 'pullEnergyZero',
            'gagePerVolumeNew', 'alanParmDiffB',
            'pullFlagPopCntlEnoughTest', 'alanParmDiffA',
            'pushBinDone', 'pullInfoLiveThresh2',
-           'pullInfoLiveThresh3', 'nrrdAxesSwap',
-           'gageOptimSigTruthSet', 'gageItemSpec', 'baneMakeHVol',
-           'gageSclHessRidgeness', 'mossFlagLast',
-           'nrrdDefaultWriteBareText', 'airShuffle_r',
+           'pullInfoLiveThresh3', 'nrrdAxesSwap', 'gageItemSpec',
+           'baneMakeHVol', 'nrrdResampleNonExistentLast',
+           'mossFlagLast', 'nrrdDefaultWriteBareText', 'airShuffle_r',
            'limnObjectRender', 'miteValXw',
            'nrrdSpacingStatusScalarWithSpace', 'tenDWMRIModalityKey',
-           'pullFlag', 'nrrdKind3DMaskedMatrix', 'miteValXi',
+           'pullFlag', 'gageSclK1', 'miteValXi',
            'gageParmStackNormalizeDerivBias', 'alanContext_t',
            'nrrdOriginStatusDirection', 'baneMeasrValuePositive',
-           'baneSigmaCalc', 'nrrdWrite', 'pullInfoIsovalue',
-           'nrrdAlloc_va', 'gageItemPackPartHessEval1',
-           'gageItemPackPartHessEval0', 'gageItemPackPartHessEval2',
-           'seekDescendToRidge', 'tenFiberParmStepSize',
+           'baneSigmaCalc', 'seekTypeSet', 'nrrdWrite',
+           'pullInfoIsovalue', 'nrrdAlloc_va',
+           'gageItemPackPartHessEval1', 'gageItemPackPartHessEval0',
+           'gageItemPackPartHessEval2', 'seekDescendToRidge',
+           'tenFiberParmStepSize',
            'pullPointInitializeRandomOrHalton',
            'limnObjectSpaceTransform', 'nrrdKeyValueErase',
            'limnPolyDataPrimitiveArea', 'nrrdResampleTypeOutSet',
@@ -8437,9 +8589,9 @@
            'nrrdTypeUChar', 'nrrdAxisInfoThickness',
            'pullPropStepConstr', 'tijk_esh_to_3d_sym_d',
            'airHeapFrontPeek', 'pushBin_t', 'airTypeLast',
-           'nrrdBasicInfoSpace', 'miteStageOpLast',
-           'tenDwiGageConfidence', 'ell_cubic_root_last', 'biffGet',
-           'gageProbe', 'nrrdMeasureL2', 'nrrdMeasureL1',
+           'gageVecMGFrob', 'miteStageOpLast', 'tenDwiGageConfidence',
+           'ell_cubic_root_last', 'biffGet', 'nrrdMeasureL4',
+           'nrrdMeasureL2', 'nrrdMeasureL1',
            'alanParmConstantFilename', 'miteShadeMethodLitTen',
            'nrrdCenterUnknown', 'limnHestCameraOptAdd',
            'echoTypeInstance', 'airBesselI1', 'seekSamplesSet',
@@ -8460,8 +8612,7 @@
            'limnObjectReadOFF', 'pullInfoIsovalueGradient',
            'tenGradientParm', 'hooverContextNew', 'elfGlyphPolar',
            'limnPolyDataVertexWindingFlip', 'nrrdBoundaryBleed',
-           'ell_cubic_root_unknown', 'pullPointNew',
-           'nrrdArithAffine', 'meetHestPullInfo',
+           'pullPointNew', 'nrrdArithAffine', 'meetHestPullInfo',
            'nrrdKernelCos4SupportDebugDDD', 'elfMaximaContext',
            'echoJitterUnknown', 'nrrdResampleRenormalizeSet',
            'ell_aa_to_q_f', 'ell_aa_to_q_d', 'baneRawScatterplots',
@@ -8477,19 +8628,19 @@
            'limnSplineInfoLast', 'nrrdMeasureLineSlope',
            'pullLogAddSet', 'tenFiberKernelSet', 'nrrdTypeIsUnsigned',
            'nrrdHistoCheck', 'gageStackBlurParmCheck',
-           'pullIterParmSet', 'airNoDio_setfl', 'tend_anhistCmd',
-           'ell_3m_print_f', 'nrrdKernelBSpline7DDD',
-           'ell_3m_print_d', 'tenGageTraceDiffusionAlign',
-           'gagePvlFlagNeedD', 'nrrdAxisInfoCompare',
-           'nrrdBasicInfoComments', 'echoSuperquad',
-           'nrrdKind3DMaskedSymMatrix', 'limnPolyDataTransform_f',
-           'tenGlyphTypeCylinder',
+           'nrrdHestBoundarySpec', 'pullIterParmSet',
+           'airNoDio_setfl', 'tend_anhistCmd', 'ell_3m_print_f',
+           'nrrdKernelBSpline7DDD', 'ell_3m_print_d',
+           'seekTypeMaximalSurface', 'gagePvlFlagNeedD',
+           'nrrdAxisInfoCompare', 'nrrdBasicInfoComments',
+           'airRandInt', 'echoSuperquad', 'nrrdKind3DMaskedSymMatrix',
+           'limnPolyDataTransform_f', 'tenGlyphTypeCylinder',
            'tenEstimate1TensorSimulateSingle_f',
            'tenEstimate1TensorSimulateSingle_d', 'nrrdHistoAxis',
            'tenDWMRINAVal', 'tenDwiGageTensorWLS',
-           'tenInterpTypeQuatGeoLoxR', 'limnPrimitiveNoop',
+           'nrrdAxisInfoCenter', 'limnPrimitiveNoop',
            'tenGageTensorGradMag', 'pullIterParmMax',
-           'nrrdIoStateSkipData', 'nrrdSpaceVecExists',
+           'tenGageCp1GradMag', 'nrrdSpaceVecExists',
            'echoJittableLast', 'nrrdCenterNode', 'nrrdJoin',
            'echoCylinder', 'airUIrandMT_r', 'nrrdDStore',
            'mossHestOrigin', 'tenGageFAKappa2', 'nrrdUnaryOpLast',
@@ -8504,39 +8655,40 @@
            'unrrduCmd', 'limnVertex', 'nrrdCheck', 'pullCCFind',
            'limnObjectVertexNumPreSet', 'gageVecMultiGrad',
            'coilMethodTypeSelf', 'airBesselI0', 'nrrdKindUnknown',
-           'ell_cubic_root', 'tenEstimateMethodSet', 'nrrdUnaryOpErf',
+           'ell_cubic_root', 'tenEstimateMethodSet', 'nrrdMeasureSum',
            'nrrdResampleNonExistentNoop', 'nrrdSliceSelect',
-           'airNoDio_arch', 'tijk_4o3d_sym', 'tenInterpPathLength',
-           'echoMatterGlassFuzzy', 'pullTraceStop', 'meetPullVolNew',
-           'nrrdRangeSafeSet', 'pullCount', 'tenInterpParmNew',
-           'airCbrt', 'airTypeEnum', 'nrrdApply1DRegMap',
-           'tend_mconvCmd', 'tenGageCl2', 'tenGageCl1',
-           'pullFlagScaleIsTau', 'tenFiberStopMinLength',
-           'nrrdKernelBlackman', 'echoInstance',
-           'nrrdMeasureHistoMax', 'limnPolyDataPlane',
-           'nrrdIoStateValsPerLine', 'pullPropIdCC', 'nrrdFormatText',
+           'nrrdUnaryOpCos', 'airNoDio_arch', 'tijk_4o3d_sym',
+           'tenInterpPathLength', 'echoMatterGlassFuzzy',
+           'pullTraceStop', 'meetPullVolNew', 'nrrdRangeSafeSet',
+           'pullCount', 'tenInterpParmNew', 'airCbrt', 'airTypeEnum',
+           'nrrdApply1DRegMap', 'tend_mconvCmd', 'tenGageCl2',
+           'tenGageCl1', 'pullFlagScaleIsTau',
+           'tenFiberStopMinLength', 'nrrdKernelBlackman',
+           'echoInstance', 'nrrdMeasureHistoMax', 'limnPolyDataPlane',
+           'limnSplineSample', 'pullPropIdCC', 'nrrdFormatText',
            'tend_evalmultCmd', 'nrrdResampleNrrdSet',
            'nrrdEnvVarDefaultWriteValsPerLine',
            'pullCondConstraintSatB', 'miteStageOpMax',
            'pullCondConstraintSatA', 'airArrayNew', 'nrrdKernelHann',
-           'ell_q_pow_d', 'nrrdBinaryOpGTE', 'ell_q_pow_f',
-           'pullCountCC', 'tenFiberAnisoSpeedSet', 'pushFinish',
-           'tenGageFAGradVecDotEvec0', 'tenDwiGageKindNix',
-           'nrrdKindPoint', 'pullFlagUnknown',
+           'meetPullVolCopy', 'ell_q_pow_d', 'nrrdBinaryOpGTE',
+           'ell_q_pow_f', 'pullCountCC', 'tenFiberAnisoSpeedSet',
+           'pushFinish', 'tenGageFAGradVecDotEvec0',
+           'tenDwiGageKindNix', 'nrrdKindPoint', 'pullFlagUnknown',
            'limnPolyDataPolygonNumber', 'mossMatRightMultiply',
            'tenBiffKey', 'pullTraceStopSpeeding', 'nrrdFormatType',
-           'nrrdDistanceL2Biased', 'nrrdUnaryOpLog',
-           'limnPolyDataWriteLMPD', 'tenGageTraceHessianEvec2',
-           'nrrdUnaryOpNegative', 'pullCondNew', 'nrrdFInsert',
+           'gageSigmaSamplingOptimal3DL2L2', 'nrrdDistanceL2Biased',
+           'nrrdUnaryOpLog', 'limnPolyDataWriteLMPD',
+           'nrrdMeasureMax', 'nrrdTernaryOpLerp',
+           'gageItemPackPartUnknown', 'nrrdFInsert',
            'limnCameraPathTrackFrom', 'meetGageKindParse',
            'hestRespFileFlag', 'baneDefMakeMeasrVol',
            'nrrdMeasureMode', 'nrrdDefaultWriteValsPerLine',
-           'gageSclLaplacian', 'tenGlyphParm', 'nrrdConvert',
-           'biffMaybeAddf', 'tenGlyphTypeSuperquad',
+           'gageOptimSigContext', 'gageSclLaplacian', 'tenGlyphParm',
+           'nrrdConvert', 'biffMaybeAddf', 'tenGlyphTypeSuperquad',
            'nrrdFormatTypeText', 'miteValYw', 'airDioRead',
            'unrrdu_minmaxCmd', 'pullEnergyTypeButterworth',
            'hooverContext', 'echoMatterLast', 'airHeapFrontUpdate',
-           'tenEstimateSkipReset', 'tenGlyphTypeBox',
+           'tenEstimateSkipReset', 'miteValYi',
            'tenGageOmegaDiffusionAlign', 'nrrdMeasureHistoSD',
            'tenEstimateContextNew', 'tenAnisoPlot', 'nrrdIoStateInit',
            'nrrdKernelCatmullRom', 'dyeHSVtoRGB',
@@ -8564,26 +8716,26 @@
            'nrrdKindIsDomain', 'ell_3mv_mul_d', 'dyeXYZtoLUV',
            'ell_3mv_mul_f', 'nrrdType', 'echoThreadStateInit',
            'baneHVolParmGKMSInit', 'airExp', 'NrrdResampleAxis',
-           'nrrdAxisInfoCenter', 'hestElideSingleOtherType',
+           'tenInterpTypeQuatGeoLoxR', 'hestElideSingleOtherType',
            'tenEMBimodalParm', 'tenInterpTypeQuatGeoLoxK',
            'echoAABBox', 'NrrdIter', 'gageParmVerbose',
            'airThreadMutexNew', 'tenGageTensorGrad',
            'limnHestSplineTypeSpec', 'pullPropGet',
            'limnSplineTypeUnknown', 'nrrdUnaryOpExpm1',
            'tend_unmfCmd', 'tenMeasurementFrameReduce',
-           'nrrdTernaryOpLerp', 'NrrdIoState', 'airErfc',
+           'nrrdUnaryOpNegative', 'NrrdIoState', 'airErfc',
            'tenGlyphBqdZoneUv', 'airNoDio_dioinfo',
            'gageItemPackPartScalar', 'pullTraceMultiRead',
            'pushBiffKey', 'biffSetStr', 'nrrdBinaryOpDivide',
            'nrrdDeringCenterSet', 'nrrdFprint', 'biffMsg',
            'elfBallStickODF_f', 'nrrdMeasureVariance',
-           'nrrdHistoThresholdOtsu', 'airEnumVal', 'tenExperSpecNew',
-           'nrrdSpaceLeftPosteriorSuperiorTime', 'airHeapFrontPop',
-           'airTypeStr', 'tenFiberStopOn', 'hooverErrSample',
-           'nrrdZlibStrategyHuffman', 'gageStackBlurCheck',
-           'pullInfoNegativeTangent1', 'pullInfoNegativeTangent2',
-           'nrrdSprint', 'hooverBiffKey', 'pullEnergyTypeQuarticWell',
-           'gageOptimSigPlot', 'nrrdTypeMax',
+           'limnObjectEmpty', 'nrrdHistoThresholdOtsu', 'airEnumVal',
+           'tenExperSpecNew', 'nrrdSpaceLeftPosteriorSuperiorTime',
+           'airHeapFrontPop', 'airTypeStr', 'tenFiberStopOn',
+           'hooverErrSample', 'nrrdZlibStrategyHuffman',
+           'gageStackBlurCheck', 'pullInfoNegativeTangent1',
+           'pullInfoNegativeTangent2', 'nrrdSprint', 'hooverBiffKey',
+           'nrrdKernelCompare', 'nrrdTypeMax',
            'pullInterTypeUnivariate', 'gageParmLast',
            'pullPropUnknown', 'airParseStrF', 'airParseStrD',
            'airParseStrE', 'airParseStrB', 'airParseStrC',
@@ -8591,19 +8743,21 @@
            'gageSclMeanCurv', 'tend_evalclampCmd',
            'tenModel1Cylinder', 'airParseStrI', 'nrrdKeyValueAdd',
            'airParseStrS', 'nrrdTernaryOpMin', 'unrrdu_convertCmd',
-           'limnEdge', 'tenGageEval1', 'tenGageEval0', 'tenAniso_Cs1',
-           'dyePresent', 'tenGageAniso', 'tenDwiGageTensor',
-           'echoRTRender', 'gageItemPackPartNormal', 'dyeXYZtoRGB',
-           'alanStopUnknown', 'gageKindTotalAnswerLength',
-           'miteStageOpAdd', 'dyeSpaceLUV', 'nrrdKernelGaussianD',
-           'pullInfoTensor', 'airAtod', 'nrrdField_number',
-           'tenGageModeGradMag', 'tijk_esh_make_kernel_delta_d',
-           'tenAniso_Conf', 'airHeapNew', 'tijk_incr_f',
-           'nrrdDeringInputSet', 'nrrdByteSkip', 'nrrdBasicInfoData',
-           'baneBcptsCheck', 'gageKernelReset', 'airThreadCapable',
-           'seekContext', 'nrrdFormatTypeLast', 'dyeColorCopy',
+           'limnEdge', 'tenGageEval1', 'tenGageEval0',
+           'tenGageTraceGradVec', 'dyePresent', 'tenGageAniso',
+           'tenDwiGageTensor', 'echoRTRender',
+           'gageItemPackPartNormal', 'ell_3m2sub_eigensolve_d',
+           'dyeXYZtoRGB', 'alanStopUnknown',
+           'gageKindTotalAnswerLength', 'miteStageOpAdd',
+           'dyeSpaceLUV', 'nrrdKernelGaussianD', 'pullInfoTensor',
+           'airAtod', 'nrrdField_number', 'tenGageModeGradMag',
+           'tijk_esh_make_kernel_delta_d', 'tenAniso_Conf',
+           'airHeapNew', 'tijk_incr_f', 'nrrdDeringInputSet',
+           'nrrdByteSkip', 'nrrdBasicInfoData', 'baneBcptsCheck',
+           'gageKernelReset', 'nrrdBinaryOpMultiply', 'seekContext',
+           'nrrdFormatTypeLast', 'dyeColorCopy',
            'nrrdEnvVarStateVerboseIO', 'gageDefVerbose',
-           'gageSclNProj', 'tenGageDelNormR2', 'miteNtxfCheck',
+           'tenGageDelNormR1', 'tenGageDelNormR2', 'miteNtxfCheck',
            'pullTraceMultiWrite', 'tenAniso_Omega',
            'gageStackBlurParmNew', 'pushEnergySpecSet',
            'hooverStubThreadBegin', 'unrrdu_1opCmd',
@@ -8614,7 +8768,7 @@
            'tenGageCl1HessianEvec0', 'pullEnergyUnknown',
            'limnQN12checker', 'nrrdDLookup', 'ell_q_3v_rotate_f',
            'nrrdDInsert', 'pullSourceProp', 'tenModelFromAxisLearn',
-           'nrrdIoStateCharsPerLine', 'ell_3m_eigenvalues_d',
+           'tenGageCa1', 'ell_3m_eigenvalues_d',
            'hooverDefVolCentering', 'gageVecHessian',
            'gageParmStackNormalizeDeriv', 'limnObject',
            'pullIterParm', 'tenFiberStopFraction', 'airToLower',
@@ -8640,46 +8794,49 @@
            'baneIncNix', 'nrrdWrap_va',
            'nrrdStateKeyValueReturnInternalPointers',
            'unrrduHestBitsCB', 'limnSplineNew', 'miteValGTdotV',
-           'pushPtrPtrUnion', 'gageItemPackPart', 'nrrdKindTime',
+           'pushPtrPtrUnion', 'gageItemPackPart',
+           'gageStackBlurParmBoundarySpecSet', 'nrrdKindTime',
            'meetPresent', 'airArrayLenPreSet', 'nrrdMeasure',
            'tenModelSqeFit', 'airParseStrZ', 'airMopAdd',
-           'alanPresent', 'limnObjectEmpty', 'coilMethodType',
-           'airEqvAdd', 'ell_3m_inv_d', 'tenGageEval2',
-           'pullProgressBinModSet', 'nrrdKernelCos4SupportDebugD',
-           'miteValNormal', 'tijk_eval_efs_basis_f',
-           'tijk_eval_efs_basis_d', 'tenEstimate2MethodUnknown',
-           'tend_evalpowCmd', 'unrrdu_lutCmd', 'tenDwiGageUnknown',
-           'miteValTw', 'tenFiberIntg', 'miteValTi',
-           'nrrdFormatTypeEPS', 'tijk_negate_f', 'tend_tripleCmd',
-           'dyeColorParse', 'airIndexClamp', 'nrrdEncodingTypeLast',
-           'nrrdTypeDefault', 'baneHVolParm', 'pullBin_t',
-           'tijk_init_max_3d_f', 'nrrdEncodingTypeAscii', 'coil_t',
-           'tenAniso_FA', 'tenGageFAHessian', 'gageStackBlurGet',
-           'limnPolyDataReadOFF', 'gageSclValue', 'airEqvSettle',
-           'echoIsosurface', 'echoMatterPhongSp', 'nrrdField_max',
-           'seekTypeRidgeSurfaceOP', 'nrrdFLookup', 'mossPresent',
-           'ell_q_to_3m_f', 'unrrdu_diceCmd', 'pushBinInit',
-           'hestNoArgsIsNoProblem', 'limnPolyDataInfoLast',
-           'airHeapFromArray', 'nrrdResampleSamplesSet',
-           'gageVecHelGradient', 'miteShadeMethodNone',
-           'unrrdu_ccfindCmd', 'gagePvlFlagUnknown',
-           'nrrdIterContent', 'tenEstimateLinear3D', 'gageContextNix',
-           'nrrdRangeCopy', 'pullPositionHistoryGet', 'alan3DSizeSet',
+           'alanPresent', 'gageSigmaSampling', 'coilMethodType',
+           'gageStackBlurParmCopy', 'airEqvAdd', 'ell_3m_inv_d',
+           'tenGageEval2', 'pullProgressBinModSet',
+           'nrrdKernelCos4SupportDebugD', 'miteValNormal',
+           'tijk_eval_efs_basis_f', 'tijk_eval_efs_basis_d',
+           'limnQN12octa', 'tend_evalpowCmd', 'unrrdu_lutCmd',
+           'tenDwiGageUnknown', 'nrrdKind3DMatrix', 'tenFiberIntg',
+           'miteValTi', 'nrrdFormatTypeEPS', 'tijk_negate_f',
+           'tend_tripleCmd', 'dyeColorParse', 'airIndexClamp',
+           'nrrdEncodingTypeLast', 'nrrdTypeDefault', 'baneHVolParm',
+           'pullBin_t', 'tijk_init_max_3d_f', 'nrrdEncodingTypeAscii',
+           'coil_t', 'tenAniso_FA', 'tenGageFAHessian',
+           'gageStackBlurGet', 'limnPolyDataReadOFF', 'gageSclValue',
+           'airEqvSettle', 'echoIsosurface', 'echoMatterPhongSp',
+           'nrrdField_max', 'seekTypeRidgeSurfaceOP', 'nrrdFLookup',
+           'mossPresent', 'ell_q_to_3m_f', 'unrrdu_diceCmd',
+           'pushBinInit', 'hestNoArgsIsNoProblem',
+           'limnPolyDataInfoLast', 'airHeapFromArray',
+           'nrrdResampleSamplesSet', 'gageVecHelGradient',
+           'miteShadeMethodNone', 'unrrdu_ccfindCmd',
+           'gagePvlFlagUnknown', 'nrrdIterContent',
+           'tenEstimateLinear3D', 'gageContextNix', 'nrrdRangeCopy',
+           'pullPositionHistoryGet', 'alan3DSizeSet',
            'tenFiberStopLast', 'tenModelConvert', 'tenModelZero',
            'nrrdKernelBSpline5D', 'hooverStubSample', 'biffMsgErrNum',
            'gagePerVolumeDetach', 'gageScl',
            'nrrdResampleNonExistentUnknown', 'airBool',
-           'tend_makeCmd', 'alanParmLast', 'limnSplineNix',
+           'tend_makeCmd', 'nrrdBinaryOpSubtract', 'limnSplineNix',
            'tenEvecRGB', 'hestGlossary', 'nrrdUILoad',
-           'pullHestEnergySpec', 'airNull', 'nrrdField_keyvalue',
+           'pullHestEnergySpec', 'airNull',
+           'gageStackBlurParmRenormalizeSet', 'nrrdField_keyvalue',
            'unrrdu_2opCmd', 'gageAnswerLength', 'airTypeOther',
            'nrrdKernelBSpline3DD', 'nrrdIoStateFormatSet',
            'pullPropIdtag', 'ell_3v_angle_d', 'unrrdu_i2wCmd',
            'ell_3v_angle_f', 'airEnumUnknown', 'nrrdFormatVTK',
-           'echoRayIntx', 'pullPointScalar',
+           'echoRayIntx', 'pullPointScalar', 'nrrdUnaryOpSigmaOfTau',
            'nrrdField_space_dimension', 'limnObjectPartAdd',
            'tenEvecRGBParmCheck', 'limnSplineNrrdEvaluate',
-           'tijk_incr_d', 'limnQN12octa', 'seekBiffKey',
+           'tijk_incr_d', 'limnPolyData', 'seekBiffKey',
            'nrrdDefaultResampleCheap', 'airOneLine',
            'nrrdKernelForwDiff', 'tijk_get_axis_type',
            'miteShadeSpecNew', 'hestCB', 'tenEstimate2MethodLast',
@@ -8690,10 +8847,10 @@
            'nrrdDefaultSpacing', 'unrrdu_unorientCmd', 'hestColumns',
            'alanStopConverged', 'tenFiberTraceSet',
            'nrrdApplyMulti1DLut', 'nrrdCCMerge',
-           'nrrdMeasureHistoMode', 'nrrdBinaryOpNotEqual',
-           'pullVolumeSingleAdd', 'nrrdBinaryOpMultiply',
+           'nrrdMeasureHistoMode', 'pullCondLast',
+           'pullVolumeSingleAdd', 'airThreadCapable',
            'gageParmGenerateErrStr', 'pullConstraintFailLast',
-           'tenInterpTypeUnknown', 'tenGageOmegaHessianContrTenEvec1',
+           'pullPropStuck', 'tenGageOmegaHessianContrTenEvec1',
            'biffMaybeAdd', 'tijk_esh_len', 'hooverContextNix',
            'nrrdSpatialResample', 'pullPointNix', 'echoSplit',
            'dyeColorGetAs', 'tenDefFiberStepSize', 'echoObjectNix',
@@ -8702,56 +8859,58 @@
            'limnPrimitiveQuads', 'limnPolyDataVertexNormals',
            'limnLightNix', 'unrrdu_untileCmd', 'gageVecCurl',
            'nrrdInset', 'pullInitParm', 'dyeLABtoXYZ',
-           'nrrdBinaryOpMod', 'tenFiberTypeUnknown',
-           'limnSplineNumPoints', 'hestOptAdd', 'tenGageDelNormR1',
-           'nrrdTypeMin', 'airStrdup', 'echoRoughSphereNew',
-           'airThreadMutexLock', 'nrrdInit', 'gageKernelStack',
-           'tenGradientIdealEdge', 'nrrdGetenvBool',
-           'nrrdIoStateEncodingGet', 'alanDimensionSet',
-           'baneOpacCalc', 'dyeSpaceRGB', 'tijk_refine_rankk_3d_d',
+           'gageSigmaSamplingUnknown', 'nrrdBinaryOpMod',
+           'tenFiberTypeUnknown', 'limnSplineNumPoints', 'hestOptAdd',
+           'gageSclNProj', 'nrrdTypeMin', 'airStrdup',
+           'echoRoughSphereNew', 'airThreadMutexLock', 'nrrdInit',
+           'gageKernelStack', 'tenGradientIdealEdge',
+           'nrrdGetenvBool', 'nrrdIoStateEncodingGet',
+           'alanDimensionSet', 'baneOpacCalc',
+           'limnCameraPathTrackLast', 'tijk_refine_rankk_3d_d',
            'baneClip', 'tijk_refine_rankk_3d_f',
            'tenTripleCalcSingle_f', 'miteThread_t', 'limnBiffKey',
-           'tijk_2o3d_unsym', 'alanContextNix', 'tenAniso_Mode',
-           'pullEnergyQuarticWell', 'echoJitterJitter',
-           'baneMeasrLaplacian', 'limnObjectVertexAdd',
-           'nrrdBinaryOpLT', 'unrrdu_acropCmd', 'coilKindType',
-           'pullSysParmProbeProb', 'airStrtokQuoting',
+           'tijk_2o3d_unsym', 'alanContextNix',
+           'pullEnergyTypeCubicWell', 'pullEnergyQuarticWell',
+           'echoJitterJitter', 'baneMeasrLaplacian',
+           'limnObjectVertexAdd', 'nrrdBinaryOpLT', 'unrrdu_acropCmd',
+           'coilKindType', 'pullSysParmProbeProb', 'airStrtokQuoting',
            'pullInfoHeightGradient', 'pullPropStability',
            'coilMethod', 'gageSclMedian', 'miteQueryAdd',
-           'limnPolyDataClipMulti', 'airTypeSize', 'pullSysParmGamma',
-           'airStrcmp', 'airStrlen', 'tenGageCp1HessianEval',
-           'echoMatterUnknown', 'unrrdu_saveCmd', 'gageSclGradVec',
-           'tenDwiFiberType', 'tijk_init_rank1_2d_d',
-           'tijk_init_rank1_2d_f', 'tenLog', 'tenGageCp1HessianEval2',
-           'tenGageCp1HessianEval0', 'tenGageCp1HessianEval1',
-           'nrrdSpaceDimension', 'miteDefNormalSide',
-           'nrrdTernaryOpGTSmooth', 'unrrdu_axmergeCmd',
-           'pullSourceLast', 'tijk_type_t', 'pullInfoSpec',
-           'nrrdFStore', 'biffAdd', 'tijk_scale_f',
+           'gageParmK3Pack', 'limnPolyDataClipMulti', 'airTypeSize',
+           'pullSysParmGamma', 'airStrcmp', 'airStrlen',
+           'tenGageCp1HessianEval', 'echoMatterUnknown',
+           'unrrdu_saveCmd', 'gageSclGradVec', 'tenDwiFiberType',
+           'tijk_init_rank1_2d_d', 'tijk_init_rank1_2d_f', 'tenLog',
+           'tenGageCp1HessianEval2', 'tenGageCp1HessianEval0',
+           'tenGageCp1HessianEval1', 'nrrdSpaceDimension',
+           'miteDefNormalSide', 'nrrdTernaryOpGTSmooth',
+           'unrrdu_axmergeCmd', 'nrrdField_labels', 'tijk_type_t',
+           'pullInfoSpec', 'nrrdFStore', 'biffAdd', 'tijk_scale_f',
            'tenGradientDistribute', 'tijk_scale_d', 'nrrdKind',
-           'nrrdValCompare', 'gagePvlFlagQuery',
+           'nrrdValCompare', 'hestSourceLast', 'gagePvlFlagQuery',
            'pullTraceMultiPlotAdd', 'nrrdIterSetValue',
            'limnCameraPathMake', 'unrrdu_affineCmd', 'unrrduScaleAdd',
            'nrrdHasNonExistUnknown', 'elfBallStickPredict_f',
-           'miteRenderEnd', 'miteRender', 'nrrdBinaryOpFlippedSgnPow',
-           'pullPropNeighCovarDet', 'limnObjectWorldHomog',
-           'tijk_6o3d_sym', 'tenGradientParmNix',
-           'tenGageEvalHessian', 'nrrdKernelC4HexicApproxInverse',
-           'nrrdBinaryOpEqual', 'limnQN10checker', 'mitePresent',
-           'tenFiberStopAnisoSet', 'pullTraceMultiFilterConcaveDown',
-           'meetHestGageKind', 'tenAnisoTen_d', 'tenPowSingle_d',
-           'tenAnisoTen_f', 'echoMatterPhongSet', 'echoMatterMetal',
+           'miteRenderEnd', 'tijk_esh_convolve_d', 'miteRender',
+           'nrrdBinaryOpFlippedSgnPow', 'pullPropNeighCovarDet',
+           'limnObjectWorldHomog', 'tijk_6o3d_sym',
+           'tenGradientParmNix', 'tenGageEvalHessian',
+           'nrrdKernelC4HexicApproxInverse', 'nrrdBinaryOpEqual',
+           'limnQN10checker', 'mitePresent', 'tenFiberStopAnisoSet',
+           'pullTraceMultiFilterConcaveDown', 'meetHestGageKind',
+           'tenAnisoTen_d', 'tenPowSingle_d', 'tenAnisoTen_f',
+           'echoMatterPhongSet', 'echoMatterMetal',
            'nrrdTernaryOpMultiply', 'mossImageCheck',
-           'tenFiberMultiNix', 'nrrdBinaryOpAdd', 
+           'tenFiberMultiNix', 'nrrdBinaryOpAdd',
            'nrrdTernaryOpExists', 'limnObjectCubeAdd',
            'nrrdKindVector', 'echoRTParm', 'tijkPresent',
            'limnLightAmbientSet', 'gageShapeSet',
            'tenDefFiberUseIndexSpace', 'tijk_esh_sp_f',
            'nrrdBlind8BitRangeFalse', 'tenGageDetGradVec',
-           'airFP_NEG_INF', 'hestOptFree', 'tenGageModeHessianEval',
-           'echoJitterGrid', 'nrrdIoStateBzip2BlockSize',
-           'hooverErrRenderBegin', 'hooverErrRayBegin',
-           'airFPPartsToVal_f', 'hestVerbosity',
+           'nrrdMeasureCoV', 'hestOptFree', 'tenGageModeHessianEval',
+           'gageSclHessDotPeakness', 'echoJitterGrid',
+           'nrrdIoStateBzip2BlockSize', 'hooverErrRenderBegin',
+           'hooverErrRayBegin', 'airFPPartsToVal_f', 'hestVerbosity',
            'alanParmMaxIteration', 'nrrdDefaultWriteEncodingType',
            'limnLight', 'tenAnisoVolume', 'echoMatterGlassKa',
            'airHalton', 'echoMatterGlassKd', 'nrrdAxisInfoCopy',
@@ -8770,22 +8929,23 @@
            'nrrdKernelCos4SupportDebug', 'ell_q_avgN_d', 'airStdout',
            'airThreadCondNix', 'baneMeasrValueAnywhere',
            'alanParmDeltaT', 'airInsane_not', 'tenExp',
-           'miteValVdefT', 'tenModel_t', 'alanParmDeltaX',
+           'miteValVdefT', 'tenModel_t', 'nrrdField_line_skip',
            'tenFiberParmSet', 'pullEnergyBetterCubicWell',
            'airTypeChar', 'airRandInt_r', 'nrrdResampleKernelSet',
            'tenGageRNormal', 'limnPolyDataReadLMPD',
            'tijk_refine_rank1_parm', 'nrrdDefaultWriteCharsPerLine',
-           'nrrdMaybeAlloc_va', 'nrrdStateDisableContent',
+           'nrrdBoundarySpecCopy', 'nrrdStateDisableContent',
            'nrrdKindQuaternion', 'nrrdNonSpatialAxesGet',
            'tenExperSpecGradSingleBValSet',
-           'tenDwiGageTensorErrorLog', 'limnPolyDataInfo',
-           'airFP_QNAN', 'tijk_axis_info_t', 'nrrdProject',
-           'baneRangePositive', 'nrrdField_endian',
-           'nrrdKindCovariantVector', 'baneClipAnswer',
-           'ell_4v_print_d', 'ell_4v_print_f', 'nrrdEncodingTypeGzip',
-           'gageParm', 'tenGageOmegaHessian', 'unrrdu_lut2Cmd',
-           'alanBiffKey', 'limnWindowNix', 'nrrdEnvVarDefaultCenter',
-           'unrrdu_3opCmd', 'tijk_esh_convolve_f', 'tenEvqVolume',
+           'tenDwiGageTensorErrorLog', 'pullConstraintFailHessZeroA',
+           'pullConstraintFailHessZeroB', 'airFP_QNAN',
+           'tijk_axis_info_t', 'nrrdProject', 'baneRangePositive',
+           'tenGageCa1HessianEval', 'nrrdKindCovariantVector',
+           'baneClipAnswer', 'ell_4v_print_d', 'ell_4v_print_f',
+           'nrrdEncodingTypeGzip', 'gageParm', 'tenGageOmegaHessian',
+           'unrrdu_lut2Cmd', 'alanBiffKey', 'limnWindowNix',
+           'nrrdEnvVarDefaultCenter', 'unrrdu_3opCmd',
+           'tijk_esh_convolve_f', 'tenEvqVolume',
            'nrrdEncodingTypeRaw', 'ell_aa_to_4m_f',
            'nrrdKernelBSpline4D', 'nrrdSpaceDimensionSet',
            'tijk_type', 'nrrdFormatEPS', 'unrrduScaleLast',
@@ -8794,11 +8954,12 @@
            'pullInfoLen', 'nrrdKindSize', 'pullSourceUnknown',
            'limnPrimitiveTriangleStrip', 'airThreadMutexNix',
            'tenGradientCheck', 'tenSimulateSingle_f',
-           'tenGageFATotalCurv', 'tijk_4o2d_sym', 'airRandInt',
-           'pushHestEnergySpec', 'nrrdAlloc_nva', 'miteRayEnd',
-           'airFloatNegInf', 'nrrdKernelSpecSprint', 'limnVtoQN_f',
-           'limnVtoQN_d', 'tijk_approx_heur_2d_d', 'miteRangeSP',
-           'pullStatusLast', 'airThreadCondSignal', 'airEndianBig',
+           'tenGageFATotalCurv', 'tijk_4o2d_sym',
+           'gageSigmaSamplingUniformSigma', 'pushHestEnergySpec',
+           'nrrdAlloc_nva', 'miteRayEnd', 'airFloatNegInf',
+           'nrrdKernelSpecSprint', 'limnVtoQN_f', 'limnVtoQN_d',
+           'tijk_approx_heur_2d_d', 'miteRangeSP', 'pullStatusLast',
+           'airThreadCondSignal', 'airEndianBig',
            'nrrdUnaryOpReciprocal', 'biffMsgStrSet', 'hestOptCheck',
            'hooverErr', 'hooverRayEnd_t', 'echoTriMeshSet',
            'nrrdIterSetOwnNrrd', 'limnEnvMapFill', 'unrrdu_aboutCmd',
@@ -8813,13 +8974,13 @@
            'nrrdSpaceLeftPosteriorSuperior', 'baneIncLast',
            'alanTensorSet', 'nrrdHasNonExistTrue', 'gageProbeSpace',
            'baneAxis', 'limnSplineInfo', 'pullEnergyTypeLast',
-           'tenGageCa1', 'NrrdEncoding_t', 'tenGageCa2',
+           'nrrdIoStateCharsPerLine', 'NrrdEncoding_t', 'tenGageCa2',
            'pullEnergyBspln', 'pullCountForceFromImage',
            'ell_4m_pre_mul_f', 'elfMaximaRefineSet',
            'tenMakeSingle_d', 'dyeBiffKey', 'miteVal',
            'nrrdAxisInfoSpacingSet', 'tenGageDet',
            'baneMeasrValueZeroCentered', 'tenAniso_Ct1',
-           'tenGageModeGradVec', 'tenAniso_Ct2',
+           'gageVecNormalized', 'tenAniso_Ct2',
            'limnEdgeTypeBackCrease', 'limnPolyDataJoin',
            'hooverDefImgCentering', 'hooverErrThreadJoin',
            'airPrettySprintSize_t', 'airFree', 'tijk_class_tensor',
@@ -8829,45 +8990,47 @@
            'tijk_refine_rank1_3d_d', 'biffSetStrDone',
            'pullInfoStrength', 'gageKernel10', 'gageKernel11',
            'tenFiberTypeTensorLine', 'airFPFprintf_f',
-           'airFPFprintf_d', 'limnSpaceUnknown',
-           'pullEnergyTypeCubicWell', 'gageQueryItemOn', 'nrrdILoad',
-           'tenTensorCheck', 'pullPropPosition', 'gageVecVector',
-           'tenExpSingle_d', 'airMopPrint', 'tenExpSingle_f', 'Nrrd',
+           'airFPFprintf_d', 'limnSpaceUnknown', 'tenAniso_Mode',
+           'gageQueryItemOn', 'nrrdILoad', 'gageDefTwoDimZeroZ',
+           'pullPropPosition', 'gageVecVector', 'tenExpSingle_d',
+           'airMopPrint', 'tenExpSingle_f', 'Nrrd',
            'tenInterpDistanceTwo_d', 'ell_4m_to_aa_f',
-           'gageOptimSigParm', 'ell_4m_to_aa_d', 'tenPowSingle_f',
-           'alanParmBeta', 'airFP_Last', 'limnPolyDataColorSet',
+           'ell_4m_to_aa_d', 'tenPowSingle_f', 'alanParmBeta',
+           'airFP_Last', 'unrrdu_basinfoCmd', 'limnPolyDataColorSet',
            'tenGageFAFlowlineCurv', 'echoRTRenderCheck',
            'nrrdKernelCatmullRomSupportDebug', 'nrrdAxisInfoMin',
            'hestParseOrDie', 'echoJittableMotionA',
            'pullInitMethodGivenPos', 'echoJittableMotionB',
            'echoInstanceSet', 'gageStructureTensor',
+           'gageStackBlurParmNeedSpatialBlurSet',
            'nrrdOrientationReduce', 'tenGageRGradMag',
-           'alanTextureTypeUnknown', 'pullCountAdding',
+           'alanTextureTypeUnknown', 'tenGageBGradVec',
            'tenDwiGage2TensorQSegAndError', 'ell_aa_to_4m_d',
-           'tenGageB', 'nrrdPad_nva', 'nrrdKeyValueCopy',
-           'pullStatusStuck', 'baneRangeNew', 'tenGageS', 'tenGageR',
-           'tenGageQ', 'tenGageTheta', 'miteShadeSpec', 'nrrdSave',
-           'gageSclGaussCurv', 'tenEMBimodal', 'limnObjectFaceAdd',
-           'nrrdUnaryOpFloor', 'gageErrLast', 'tenAniso',
-           'pushTask_t', 'baneClipPeakRatio', 'nrrdBasicInfoUnknown',
-           'tenEigenvaluePower', 'tenSizeNormalize',
-           'nrrdKernelBSpline3D', 'baneRangeNegative', 'baneIncStdv',
-           'tijk_sym_fun', 'gageParmStackNormalizeRecon',
-           'tenFiberStopDoubleSet', 'gageItemPackPartHessian',
-           'nrrdKernelBoxSupportDebug', 'nrrdIInsert',
-           'airInsane_pInfExists', 'baneOpacInfo',
+           'tenGageB', 'nrrdMeasureNormalizedL2', 'nrrdPad_nva',
+           'nrrdKeyValueCopy', 'pullStatusStuck', 'baneRangeNew',
+           'tenGageS', 'tenGageR', 'tenGageQ', 'tenGageTheta',
+           'miteShadeSpec', 'nrrdSave', 'gageSclGaussCurv',
+           'tenEMBimodal', 'limnObjectFaceAdd', 'nrrdUnaryOpFloor',
+           'gageErrLast', 'tenAniso', 'pushTask_t',
+           'baneClipPeakRatio', 'nrrdBasicInfoUnknown',
+           'tenEigenvaluePower', 'gageStackBlurParmInit',
+           'tenSizeNormalize', 'nrrdKernelBSpline3D',
+           'baneRangeNegative', 'baneIncStdv', 'tijk_sym_fun',
+           'gageParmStackNormalizeRecon', 'tenFiberStopDoubleSet',
+           'gageItemPackPartHessian', 'nrrdKernelBoxSupportDebug',
+           'nrrdIInsert', 'airInsane_pInfExists', 'baneOpacInfo',
            'limnObjectWriteOFF', 'alanParmRandRange',
            'tenDwiFiberType1Evec0', 'airLogBesselI0',
            'gageDefGradMagCurvMin', 'pushEnergySpecParse',
            'nrrdKernelBSpline6D', 'airMop',
            'limnPolyDataSuperquadric', 'nrrdTernaryOpUnknown',
            'nrrdHistoJoint', 'tend_anvolCmd', 'airInsane_QNaNHiBit',
-           'nrrdEnvVarStateMeasureType', 'baneDefRenormalize',
-           'airArrayStructCB', 'limnSpaceWorld', 'pullInfoHeight',
-           'unrrdu_gammaCmd', 'nrrdBoundaryLast',
+           'nrrdEnvVarStateMeasureType', 'nrrdKind4Color',
+           'tijk_3d_sym_to_esh_matrix_d', 'nrrdField_dimension',
+           'pullInfoHeight', 'unrrdu_gammaCmd', 'nrrdBoundaryLast',
            'miteStageOpMultiply', 'limnPolyDataNeighborArrayComp',
-           'airVanDerCorput', 'tenGageKind', 'tijk_add_d', 'gageVec',
-           'nrrdEnvVarDefaultWriteBareTextOld',
+           'airVanDerCorput', 'gageStackBlurParmParse', 'tijk_add_d',
+           'gageVec', 'nrrdEnvVarDefaultWriteBareTextOld',
            'gageStackBlurParmBoundarySet', 'nrrdTypeLast',
            'pullTraceStopLength', 'baneHack', 'gageQuerySet',
            'tenDwiFiberType12BlendEvec0', 'echoMatterGlassIndex',
@@ -8890,23 +9053,23 @@
            'tenEstimateSigmaSet', 'tijk_efs_to_2d_sym_f',
            'pullBinProcess', 'pullProcessModeAdding', 'tend_simCmd',
            'limnEdgeTypeLone', 'unrrdu_heqCmd', 'airStrntok',
-           'nrrdTernaryOpInOpen', 'nrrdPGM', 'airMopOnOkay',
+           'nrrdTernaryOpInOpen', 'nrrdPGM', 'nrrdTernaryOpRician',
            'baneFindInclusion', 'gageDefK3Pack', 'echoTypeAABBox',
            'nrrdZlibStrategyUnknown', 'tenGageFADiffusionAlign',
-           'unrrdu_diffCmd', 'airRician', 'coilKindType7Tensor',
-           'echoMatterLightSet', 'echoPresent',
+           '_airThread', 'unrrdu_diffCmd', 'airRician',
+           'coilKindType7Tensor', 'echoMatterLightSet', 'echoPresent',
            'limnPrimitiveTriangles', 'nrrdTernaryOpClamp',
            'echoObjectHasMatter', 'ell_3m_to_aa_f', 'ell_3m_to_aa_d',
-           'airIsNaN', 'alanParmTextureType', 'tend_epiregCmd',
-           'gageVecCurlGradient', 'airMopMem', 'biffMsgStrGet',
-           'gageDefRenormalize', 'coilKind', 'tenGageCp2',
-           'pullInfoSpecSprint', 'tenGageCp1', 'limnObjectNew',
-           'nrrdBasicInfoLast', 'pushPresent', 'tenAniso_Clpmin1',
-           'tenAniso_Clpmin2', 'echoCube', 'pullTrace',
-           'echoMatterMetalR0', 'limnEdge_t', 'alanStopLast',
-           'limnEdgeTypeFrontFacet', 'tenFiberIntgUnknown',
-           'limnObjectDepthSortFaces', 'tenGageOmegaNormal',
-           'airStdin', 'gageTeeOfTau',
+           'airIsNaN', 'alanParmTextureType', 'tenFiberVerboseSet',
+           'tend_epiregCmd', 'gageVecCurlGradient', 'airMopMem',
+           'biffMsgStrGet', 'gageDefRenormalize', 'coilKind',
+           'tenGageCp2', 'pullInfoSpecSprint', 'tenGageCp1',
+           'limnObjectNew', 'nrrdBasicInfoLast', 'pushPresent',
+           'tenAniso_Clpmin1', 'tenAniso_Clpmin2', 'echoCube',
+           'pullTrace', 'echoMatterMetalR0', 'limnEdge_t',
+           'alanStopLast', 'limnEdgeTypeFrontFacet',
+           'tenFiberIntgUnknown', 'limnObjectDepthSortFaces',
+           'tenGageOmegaNormal', 'airStdin',
            'tenGageTraceDiffusionFraction', 'airThreadCondBroadcast',
            'nrrdBinaryOp', 'tenDwiGage2TensorPeledAndError',
            'mossMatShearSet', 'pullInfo', 'nrrdMeasureMin',
@@ -8916,19 +9079,20 @@
            'pushContextNix', 'limnSpaceScreen', 'pushRebin',
            'airThreadBarrierWait', 'gageItemSpecNew',
            'nrrdClampConvert', 'nrrdKernelCos4SupportDebugDD',
-           'alanStop', 'tenExpand', 'gageItemPackSclValue',
-           'tijk_refine_rankk_parm', 'ell_3m_mul_f',
-           'tenTripleTypeWheelParm', 'seekVertexStrength',
-           'hooverRayBegin_t', 'tenSlice', 'airIndexULL',
-           'airNormalRand_r', 'baneBiffKey', 'miteValView',
-           'nrrdReshape_va', 'tijk_sym_fun_t', 'nrrdKindComplex',
-           'echoChannelAverage', 'limnQN13octa', 'baneMeasrTotalCurv',
-           'ell_3m_inv_f', 'limnQN14octa', 'tenGageCp1GradVec',
-           'alanContextNew', 'echoTriangleSet', 'gageKernel00',
-           'pullCountTestStep', 'nrrdEmpty', 'limnSplineTypeTimeWarp',
-           'hestMinNumArgs', 'limnObjectVertexNormals',
-           'tenTripleTypeEigenvalue', 'nrrdKind4Vector', 'airPresent',
-           'nrrdArithIterAffine', 'tenGageFARidgeSurfaceAlignment',
+           'alanStop', 'tenExpand', 'nrrdCCFind',
+           'gageItemPackSclValue', 'tijk_refine_rankk_parm',
+           'ell_3m_mul_f', 'tenTripleTypeWheelParm',
+           'seekVertexStrength', 'hooverRayBegin_t', 'tenSlice',
+           'airIndexULL', 'airNormalRand_r', 'baneBiffKey',
+           'miteValView', 'nrrdReshape_va', 'tijk_sym_fun_t',
+           'nrrdKindComplex', 'echoChannelAverage', 'limnQN13octa',
+           'baneMeasrTotalCurv', 'ell_3m_inv_f', 'limnQN14octa',
+           'tenGageCp1GradVec', 'alanContextNew', 'echoTriangleSet',
+           'gageKernel00', 'pullCountTestStep', 'nrrdEmpty',
+           'limnSplineTypeTimeWarp', 'hestMinNumArgs',
+           'gageOptimSigErrorPlot', 'tenTripleTypeEigenvalue',
+           'nrrdKind4Vector', 'airPresent', 'nrrdArithIterAffine',
+           'tenGageFARidgeSurfaceAlignment',
            'nrrdKernelBSpline5ApproxInverse', 'pushPointNix',
            'tenAnisoEval_f', 'tijk_2o2d_sym', 'tenAnisoEval_d',
            'tenDWMRIBValueKey', 'tenGageCa1HessianEvec0',
@@ -8937,7 +9101,7 @@
            'nrrdUnquantize', 'baneMeasrCopy', 'pullEnergyType',
            'tenGageOmegaHessianEval', 'nrrdStateUnknownContent',
            'baneIncCopy', 'alanParmMinAverageChange',
-           'echoTypeTriangle', 'airFclose', 'pullPropEnergy',
+           'echoTypeTriangle', 'gageKernel22', 'pullPropEnergy',
            'tijk_eval_esh_f', 'nrrdEnvVarDefaultWriteBareText',
            'limnPolyDataSpiralSphere', 'tenGageModeHessianEvec2',
            'tenGageModeHessianEvec1', 'tenGageModeHessianEvec0',
@@ -8945,25 +9109,24 @@
            'limnObjectPolarSuperquadFancyAdd', 'pullBinsPointAdd',
            'baneClipCopy', 'pullSysParmAlpha', 'gageShapeNew',
            'pullInterTypeJustR', 'pullIterParmConstraintMax',
-           'nrrdKind3DMatrix', 'mossSamplerUpdate',
-           'hestGreedySingleString', 'meetAirEnumAll',
-           'tenFiberStopAniso', 'gageShapeWtoI',
+           'miteValTw', 'mossSamplerUpdate', 'hestGreedySingleString',
+           'meetAirEnumAll', 'tenFiberStopAniso', 'gageShapeWtoI',
            'pullBinsPointMaybeAdd', 'nrrdHestKernelSpec',
            'unrrduScaleNothing', 'nrrdMeasureLinf', 'limnPart',
-           'gagePerVolume', 'tenGageCl1GradVec', 'seekUpdate',
-           'tenGradientJitter', 'banePresent', 'baneRangeCopy',
-           'tenFiberStop', 'alanParmAlpha', 'gageParmGradMagCurvMin',
-           'miteDefOpacNear1', 'nrrdEncodingTypeUnknown',
-           'tenTripleCalc', 'biffGetDone', 'alanTextureTypeGrayScott',
-           'ell_debug', 'tenGageSHessian',
+           'tijk_eval_esh_d', 'gagePerVolume', 'tenGageCl1GradVec',
+           'seekUpdate', 'tenGradientJitter', 'banePresent',
+           'baneRangeCopy', 'tenFiberStop', 'alanParmAlpha',
+           'gageParmGradMagCurvMin', 'hestSourceUser',
+           'nrrdEncodingTypeUnknown', 'tenTripleCalc', 'biffGetDone',
+           'alanTextureTypeGrayScott', 'ell_debug', 'tenGageSHessian',
            'limnSplineTypeCubicBezier', 'nrrdUnaryOpRand',
            'airArrayLenIncr', 'tenEstimate1TensorSingle_d',
            'tenEstimate1TensorSingle_f', 'alanStopNonExist',
-           'pullTraceMultiNew', 'pullProcessModeNeighLearn',
-           'pullCountLast', 'ell_4mv_mul_d',
-           'tenDefFiberAnisoStopType', 'nrrdSlice',
+           'pullTraceMultiNew', 'tenDwiGageAll', 'ell_4mv_mul_f',
+           'ell_4mv_mul_d', 'tenDefFiberAnisoStopType', 'nrrdSlice',
            'tenFiberMultiNew', 'nrrdKernelBlackmanDD',
-           'airNoDio_test', 'tenGageOmegaGradVecDotEvec0',
+           'airNoDio_test', 'nrrdKernelSpecCopy',
+           'tenGageOmegaGradVecDotEvec0',
            'gageStackBlurParmKernelSet', 'limnDefCameraRightHanded',
            'nrrdKernelAQuarticD', 'nrrdDefaultResampleNonExistent',
            'nrrdBoundaryWeight', 'tenGlyphParmCheck',
@@ -8973,48 +9136,50 @@
            'coilMethodTypeFinish', 'nrrdBlind8BitRangeLast',
            'nrrdField_centers', 'pullPropLen', 'airLog2',
            'airThreadBarrier', 'ell_q_inv_d', 'pullSysParmUnknown',
-           'tenGageSGradVec', 'airFP_NEG_DENORM',
-           'nrrdAxisInfoGet_va', 'pullInterTypeUnknown',
-           'limnEnvMapCB', 'tenGageOmegaGradVec', 'airFP_NEG_NORM',
-           'airToUpper', 'tenEigenvalueClamp', 'nrrdApply1DIrregMap',
+           'miteRangeGreen', 'airFP_NEG_DENORM', 'nrrdAxisInfoGet_va',
+           'pullInterTypeUnknown', 'limnEnvMapCB',
+           'tenGageOmegaGradVec', 'airFP_NEG_NORM', 'airToUpper',
+           'tenEigenvalueClamp', 'nrrdApply1DIrregMap',
            'airFloatSNaN', 'nrrdKernelC3QuinticDD', 'echoTypeTriMesh',
            'nrrdStateGrayscaleImage3D', 'hooverRenderEnd_t',
            'tenFiberMulti', 'ell_Nm_tran', 'tijk_esh_sp_d',
            'nrrdUnaryOpLog10', 'airStrcpy', 'tenFiberMultiPolyData',
-           'airHeapUpdate', 'nrrdFormatTypePNG',
+           'airHeapUpdate', 'miteValNdotL',
            'gageParmKernelIntegralNearZero', 'meetPullVolLeechable',
            'nrrdFormatTypePNM', 'airErf', 'baneGkms_pvgCmd',
-           'pullPresent', 'miteValNdotV', 'mossHestTransform',
-           'ell_3m_det_f', 'ell_3m_det_d', 'ell_q_4v_rotate_d',
-           'alanParmUnknown', 'gagePerVolumeIsAttached',
-           'pullEnergySpecParse', 'nrrdField_measurement_frame',
-           'limnCamera', 'nrrdPPM', 'echoTypeList', 'pullInfoGet',
-           'nrrdMeasureLast', 'nrrdUnaryOpLog1p', 'airInsane_endian',
+           'pullPresent', 'gageOptimSigContextNew', 'miteValNdotV',
+           'mossHestTransform', 'ell_3m_det_f', 'ell_3m_det_d',
+           'ell_q_4v_rotate_d', 'ell_q_4v_rotate_f',
+           'gagePerVolumeIsAttached', 'pullEnergySpecParse',
+           'nrrdField_measurement_frame', 'limnCamera', 'nrrdPPM',
+           'echoTypeList', 'pullInfoGet', 'nrrdMeasureLast',
+           'nrrdUnaryOpLog1p', 'airInsane_endian',
            'tenEMBimodalParmNew', 'pullInfoInsideGradient',
-           'pullStatusUnknown', 'tenFiberParmLast',
-           'nrrdBasicInfoInit', 'nrrdIterSetNrrd', 'pullStart',
-           'tenModelSimulate', 'tenGageFAHessianEvec2',
+           'airTeemReleaseDone', 'pullStatusUnknown',
+           'tenFiberParmLast', 'nrrdBasicInfoInit', 'nrrdIterSetNrrd',
+           'pullStart', 'tenModelSimulate', 'tenGageFAHessianEvec2',
            'tenGageFAHessianEvec1', 'tenGageFAHessianEvec0',
            'ell_4m_post_mul_d', 'echoIntxMaterialColor',
            'pullEnergySpring', 'gageSclHessEval',
            'airThreadNoopWarning', 'airMopSingleDone', 'limnDevicePS',
            'nrrdBasicInfoSpaceUnits', 'nrrdKernelCatmullRomDD',
-           'tend_mfitCmd', 'gageStackProbe', 'nrrdBinaryOpAtan2',
-           'unrrdu_cmedianCmd', 'tenAniso_Tr', 'biffMove',
-           'hooverRenderBegin_t', 'nrrdHestNrrd', 'echoSceneNew',
-           'pullCallbackSet', 'nrrdEnvVarStateAlwaysSetContent',
+           'tend_mfitCmd', 'elfTenEstimMatrix_f',
+           'elfTenEstimMatrix_d', 'gageStackProbe',
+           'nrrdBinaryOpAtan2', 'unrrdu_cmedianCmd', 'tenAniso_Tr',
+           'biffMove', 'hooverRenderBegin_t', 'nrrdHestNrrd',
+           'echoSceneNew', 'pullCallbackSet',
+           'nrrdEnvVarStateAlwaysSetContent',
            'tijk_approx_heur_parm_t', 'pushEnergyCotan',
            'tijk_eval_efs_d', 'limnWindowNew',
            'pullConstraintFailProjGradZeroB',
            'pullConstraintFailProjGradZeroA', 'tenAniso_Th',
-           'nrrdTypeDouble', 'ell_3m_rotate_between_d',
-           'gageTauOfTee', 'nrrdTypeBlock',
+           'ell_3m_rotate_between_d', 'nrrdTypeBlock',
            'pullEnergyTypeHepticWell', 'pullCountNixing',
            'nrrdSpatialAxesGet', 'seekItemGradientSet',
            'tenGageTensor', 'pushContext', 'nrrdSpaceScannerXYZ',
            'airBesselInExpScaled', 'coilMethodTypeTesting',
            'nrrdEncodingGzip', 'airTeemVersion', 'meetPullInfo',
-           'airHeapMerge', 'airThreadMutex', 'unrrduUsage',
+           'unrrduScaleUnknown', 'airThreadMutex', 'unrrduUsage',
            'nrrdDistanceL2Signed', 'tenGageTensorQuatGeoLoxR',
            'tenGageInvarKGrads', 'tenSizeScale',
            'tenGageTensorQuatGeoLoxK', 'biffAddf',
@@ -9022,19 +9187,18 @@
            'gageDefCheckIntegrals', 'coilBiffKey',
            'nrrdBinaryOpCompare', 'tend_normCmd', 'airNoDio_okay',
            'airTypeUnknown', 'tenAnisoHistogram', 'tenGageFA',
-           'nrrdSpaceVecNorm', 'alanStopNot', 'tenDwiGageJustDWI',
+           'airTeemVersionSprint', 'alanStopNot', 'tenDwiGageJustDWI',
            'tenDwiGageTensorLLSError', 'tenDwiGageTensorAllDWIError',
-           'tenDwiGage', 'tijk_2d_sym_to_efs_f', 'nrrdBinaryOpFmod',
-           'nrrdKind3Vector', 'airStrtrans', 'meetPullVolParse',
-           'nrrdTypeChar', 'nrrdCCRevalue',
+           'tenDwiGage', 'nrrdCastClampRound', 'tijk_2d_sym_to_efs_f',
+           'nrrdBinaryOpFmod', 'nrrdKind3Vector', 'airStrtrans',
+           'meetPullVolParse', 'nrrdTypeChar', 'nrrdCCRevalue',
            'ell_3v_barycentric_spherical_d', 'echoObject',
            'nrrdFFTWWisdomWrite', 'pullInitHaltonSet',
            'pullIterParmSnap', 'nrrdSpace3DLeftHandedTime',
            'ell_biff_key', 'gageSclNormal', 'nrrdDefaultResampleType',
            'nrrdDeringContextNew', 'unrrdu_axdeleteCmd',
-           'nrrdBasicInfoCopy', 'baneInc_t',
-           'tenDwiGageTensorNLSError', 'dyeConverter', 'nrrdCrop',
-           'tenGageFiberDispersion', 'nrrdUnaryOpAbs',
+           'nrrdBasicInfoCopy', 'baneInc_t', 'dyeConverter',
+           'nrrdCrop', 'tenGageFiberDispersion', 'nrrdUnaryOpAbs',
            'limnSplineUpdate', 'tenGageCovariance', 'nrrdCompare',
            'echoCylinderSet', 'alan2DSizeSet', 'unrrduScaleSubtract',
            'hestMultiFlagSep', 'limnObjectPSDraw', 'baneMeasr',
@@ -9042,18 +9206,19 @@
            'nrrdKeyValueIndex', 'limnPolyDataCompress', 'seekType',
            'nrrdSpacingStatusUnknown', 'limnSplineTypeSpec',
            'airEnumStr', 'pushEnergyTypeGauss', 'airDioTest',
-           'pullEnergyTypeQuartic', 'miteValVrefN',
+           'pullEnergyTypeQuarticWell', 'miteValVrefN',
            'pushEnergyTypeZero', 'unrrduPresent', 'tenFiberTrace',
            'limnEdgeTypeFrontCrease', 'miteSample',
-           'nrrdBinaryOpNormalRandScaleAdd', 'tenFiberIntgMidpoint',
-           'meetPullInfoAddMulti', 'limnWindow', 'tend_bfitCmd',
-           'nrrdField_old_min', 'unrrduScaleExact',
-           'pullConstraintFailIterMaxed', 'airThreadBarrierNix',
-           'ell_q_avg4_d', 'coilKindTypeUnknown', 'nrrdTypeFloat',
-           'airParseStrUI', 'coilContextNew', 'nrrdKernelBSpline1D',
-           'airEqvMap', 'seekTypeLast', 'gageKind_t',
+           'nrrdGetenvString', 'nrrdBinaryOpNormalRandScaleAdd',
+           'tenFiberIntgMidpoint', 'meetPullInfoAddMulti',
+           'limnWindow', 'tend_bfitCmd', 'nrrdField_old_min',
+           'unrrduScaleExact', 'pullConstraintFailIterMaxed',
+           'airThreadBarrierNix', 'ell_q_avg4_d',
+           'coilKindTypeUnknown', 'nrrdTypeFloat', 'airParseStrUI',
+           'coilContextNew', 'nrrdKernelBSpline1D', 'airEqvMap',
+           'seekTypeLast', 'gageKind_t',
            'gageDefKernelIntegralNearZero', 'nrrdEncodingTypeHex',
-           'tenGageEvec0', 'tenGageEvec1', 'tenGageEvec2',
+           'tenGageEvec0', 'tenGageEvec1', 'nrrdIoStateValsPerLine',
            'unrrdu_tileCmd', 'pullInterTypeSeparable',
            'nrrdKind2DMaskedSymMatrix',
            'pullSysParmFracNeighNixedMax', 'baneDefPercHistBins',
@@ -9070,18 +9235,17 @@
            'nrrdKindRGBColor', 'gageDefStackNormalizeRecon',
            'airSingleSscanf', 'airThreadCondWait',
            'pullFlagRestrictiveAddToBins', 'pullProcessModeDescent',
-           'limnSplineTypeSpecNix', 'gageOptimSigParmNew',
-           'gageVecMGEval', 'tenFiberIntgSet', 'tenModel1Unit2D',
-           'pullBin', 'nrrdField_unknown', 'nrrdCCNum',
+           'limnSplineTypeSpecNix', 'gageVecMGEval',
+           'tenFiberIntgSet', 'tenModel1Unit2D', 'pullBin',
+           'nrrdField_unknown', 'nrrdCCNum',
            'pullInitUnequalShapesAllowSet', 'pullPropStepEnergy',
-           'nrrdBinaryOpMax',
            'pullIterParmEnergyIncreasePermitHalfLife', 'tenGageOmega',
            'tijk_set_axis_efs', 'pullIterParmAddDescent',
            'tijk_set_axis_tensor', 'pullSysParmEnergyDecreaseMin',
            'tend_logCmd', 'pullSysParmLast', 'mossSamplerFill',
-           'nrrdBinaryOpSubtract', 'limnObjectNix',
-           'tenGageDetHessian', 'tenGageBGradVec', 'limnQN15octa',
-           'nrrdTernaryOpRician', 'pullEnergyCubic', 'limnSplineMaxT',
+           'nrrdKernelDiscreteGaussianGoodSigmaMax', 'alanParmLast',
+           'limnObjectNix', 'tenGageDetHessian', 'pullCountAdding',
+           'limnQN15octa', 'pullEnergyCubic', 'limnSplineMaxT',
            'pullPropNeighCovar7Ten', 'gageErrStackIntegral',
            'nrrdRangeNewSet', 'miteShadeSpecQueryAdd',
            'nrrdEnvVarStateKindNoop', 'tenGageInvarRGradMags',
@@ -9094,14 +9258,14 @@
            'baneGkmsHestGthresh', 'tijk_8o3d_sym', 'baneClipLast',
            'gagePointReset', 'nrrdKernelC5SepticDD', 'hestOpt',
            'nrrdMeasureLineError', 'alanParmWrapAround',
-           'nrrdField_labels', 'elfBallStickOptimize_f',
-           'nrrdKernelBCCubicDD', 'limnOptsPS',
-           'nrrdSpacingStatusLast', 'tenFiberStopBounds',
-           'airSrandMT_r', 'pullProp', 'limnSplineInfo2Vector',
-           'nrrdKernelBSpline7ApproxInverse', 'tenDwiGageAll',
-           'nrrdFFTWWisdomRead', 'nrrdKernelSpecNew',
-           'baneGkms_txfCmd', 'pullFlagEnergyFromStrength',
-           'nrrdRangeSet', 'limnEdgeTypeContour', 'ell_4m_inv_f',
+           'elfBallStickOptimize_f', 'nrrdKernelBCCubicDD',
+           'limnOptsPS', 'nrrdSpacingStatusLast',
+           'tenFiberStopBounds', 'airSrandMT_r', 'pullProp',
+           'limnSplineInfo2Vector', 'nrrdKernelBSpline7ApproxInverse',
+           'pullProcessModeNeighLearn', 'nrrdFFTWWisdomRead',
+           'nrrdKernelSpecNew', 'baneGkms_txfCmd',
+           'pullFlagEnergyFromStrength', 'nrrdRangeSet',
+           'limnEdgeTypeContour', 'ell_4m_inv_f',
            'nrrdField_space_origin', 'dyeXYZtoLAB',
            'nrrdFormatTypeNRRD', 'echoLightPosition', 'tenAnisoScale',
            'echoScene_t', 'nrrdResampleClampSet', 'mossMatPrint',
@@ -9119,18 +9283,20 @@
            'tenGageCovarianceRGRT', 'mossFlagImage', 'pullVolumeNew',
            'coilMethodTypeModifiedCurvatureRings',
            'meetNrrdKernelAll', 'gageKernel21', 'gageKernel20',
-           'gageKernel22', 'miteDefRefStep', 'airArrayNuke',
+           'airMopOnOkay', 'miteDefRefStep', 'airArrayNuke',
            'echoMatterPhong', 'tenGageFARidgeLineAlignment',
            'nrrdCropAuto', 'tenGageSGradMag', 'tenGageEvalGrads',
-           'limnLightNew', 'miteRangeEmissivity',
+           'airSigmaOfTau', 'limnLightNew', 'miteRangeEmissivity',
            'pullIterParmUnknown', 'nrrdAxisInfoPosRange',
-           'gageItemEntry', 'pullSource', 'echoJitter',
-           'seekItemStrengthSet', 'nrrdFormatPNM', 'nrrdReshape_nva',
-           'pullBiffKey', 'tenGlyphTypeUnknown', 'pushEnergyUnknown',
-           'pushEnergyTypeSpring', 'gageVecMGFrob',
-           'tenGageModeHessianEvec', 'nrrdMeasureHistoMin',
-           'nrrdUnaryOpRoundUp', 'tenFiberTypeLast', 'nrrdILookup',
-           'gageParmCheckIntegrals', 'tend_evqCmd', 'nrrdUnaryOpCos',
+           'gageItemEntry', 'pullSource', 'airTimeOfTau',
+           'echoJitter', 'seekItemStrengthSet', 'nrrdFormatPNM',
+           'nrrdReshape_nva', 'pullBiffKey', 'tenGlyphTypeUnknown',
+           'pushEnergyUnknown', 'pushEnergyTypeSpring',
+           'ell_cubic_root_unknown', 'tenGageModeHessianEvec',
+           'nrrdMeasureHistoMin', 'nrrdUnaryOpRoundUp',
+           'tenFiberTypeLast', 'nrrdILookup',
+           'gageParmCheckIntegrals', 'tend_evqCmd',
+           'tenDwiGageTensorNLSError',
            'tenDWMRIKeyValueFromExperSpecSet', 'pullEnergyTypeGauss',
            'tijk_class_unknown', 'ell_6m_mul_d', 'dyeRGBtoHSL',
            'limnPolyDataPrimitiveVertexNumber', 'nrrdField_content',
@@ -9144,25 +9310,28 @@
            'tenGageMode', 'nrrdKernelBSpline6DDD',
            'tenGageCp1HessianEvec', 'gageUpdate',
            'nrrdSpacingCalculate', 'miteDefRenorm', 'nrrdKernelHannD',
-           'limnObjectPolarSuperquadAdd', 'seekTypeSet',
-           'limnPolyData', 'airThreadCondNew', 'nrrdStateGetenv',
-           'tenInterpType', 'tenGageCp1Normal', 'airEndianUnknown',
-           'pullVolume', 'echoIntxColor', 'nrrdMeasureMean',
-           'miteValWdotD', 'pullInitPointPerVoxelSet', 'tenGlyphGen',
+           'limnObjectPolarSuperquadAdd', 'nrrdKind3DMaskedMatrix',
+           'airThreadCondNew', 'tijk_esh_to_3d_sym_matrix_f',
+           'nrrdStateGetenv', 'tenInterpType', 'gageProbe',
+           'tenGageCp1Normal', 'airEndianUnknown', 'pullVolume',
+           'echoIntxColor', 'nrrdMeasureMean', 'miteValWdotD',
+           'pullInitPointPerVoxelSet', 'tenGlyphGen',
            'miteShadeSpecParse', 'airTypeBool', 'unrrdu_deringCmd',
            'tenDwiGage2TensorQSeg', 'nrrdStateKeyValuePairsPropagate',
-           'nrrdKernelCompare', 'gageShapeEqual', 'pullFlagLast',
-           'echoJittableLens', 'tijk_sub_f', 'pullGammaLearn',
-           'tenInterpParmNix', 'limnObjectPolarSphereAdd',
-           'tenGageFiberCurving', 'nrrdKernelC5SepticD',
-           'pullSourceGage', 'nrrdDeringVerticalSeamSet', 'pushPoint',
-           'nrrdStateMeasureHistoType', 'echoJitterNone',
-           'limnSplineInfoQuaternion', 'tenGageTraceGradMag',
-           'NrrdKernel', 'nrrdField_encoding', 'nrrdKernelGaussian',
-           'biffMovef', 'echoScene', 'limnSplineTypeBC',
-           'nrrdIoStateZlibStrategy', 'nrrdField_thicknesses',
-           'baneMeasrGradMag', 'echoTypeLast',
-           'gageStackPerVolumeNew', 'nrrdArithIterBinaryOpSelect',
+           'gageShapeEqual', 'pullFlagLast', 'echoJittableLens',
+           'tijk_sub_f', 'pullGammaLearn', 'tenInterpParmNix',
+           'limnObjectPolarSphereAdd', 'tenGageFiberCurving',
+           'nrrdKernelC5SepticD', 'pullSourceGage',
+           'nrrdDeringVerticalSeamSet', 'pushPoint',
+           'nrrdArithTernaryOp', 'nrrdStateMeasureHistoType',
+           'echoJitterNone', 'nrrdBoundarySpecNew',
+           'gageHestStackBlurParm', 'limnSplineInfoQuaternion',
+           'tenGageTraceGradMag', 'NrrdKernel', 'nrrdField_encoding',
+           'nrrdKernelGaussian', 'biffMovef', 'echoScene',
+           'limnSplineTypeBC', 'nrrdIoStateZlibStrategy',
+           'nrrdField_thicknesses', 'baneMeasrGradMag',
+           'echoTypeLast', 'gageStackPerVolumeNew',
+           'nrrdArithIterBinaryOpSelect', 'ell_3m2sub_eigenvalues_d',
            'nrrdEncodingArray', 'gageKernelSet', 'nrrdKindList',
            'limnCamera_t', 'echoSphereSet', 'echoGlobalState',
            'pullEnergyGauss', 'tenModel', 'baneIncProcess',
@@ -9190,19 +9359,22 @@
            'nrrdMeasureMedian', 'nrrdMinMaxExactFind',
            'pullEnergyTypeCotan', 'ell_q_div_f', 'ell_q_div_d',
            'nrrdPad_va', 'nrrdAxisInfoSize', 'miteRangeKs',
-           'baneMeasr_t', 'pullCondLast', 'nrrdStateAlwaysSetContent',
-           'tenGageFAGaussCurv', 'NrrdFormat', 'nrrdKernelCheap',
-           'pullFlagUseBetaForGammaLearn', 'limnSplineTypeLast',
-           'nrrdArithTernaryOp', 'pushEnergy', 'airInsane_dio',
-           'baneInc', 'nrrdTernaryOpMax', 'tenGageLast',
-           'gageScl3PFilter4', 'tenGlyphParmNew', 'baneMeasrAnswer',
-           'dyeColorNix', 'tenFiberTypeZhukov', 'pullInitGivenPosSet',
+           'baneMeasr_t', 'nrrdBinaryOpNotEqual',
+           'nrrdStateAlwaysSetContent', 'tenGageFAGaussCurv',
+           'NrrdFormat', 'nrrdKernelCheap',
+           'pullFlagUseBetaForGammaLearn',
+           'tenDwiGage2TensorPeledError', 'nrrdBoundarySpecSprint',
+           'pushEnergy', 'airInsane_nInfExists', 'baneInc',
+           'nrrdTernaryOpMax', 'tenGageLast', 'gageScl3PFilter4',
+           'tenGlyphParmNew', 'baneMeasrAnswer', 'dyeColorNix',
+           'tenFiberTypeZhukov', 'pullInitGivenPosSet',
            'echoListSplit3', 'tenDwiGageKindNew', 'gageQueryPrint',
-           'tenEstimateVerboseSet', 'airSgn', 'meetAirEnumAllPrint',
-           'gageCtxFlagUnknown', 'echoJittableUnknown', 'pullPoint',
-           'pullPropStuck', 'nrrdKernelBCCubicD',
+           'tenEstimateVerboseSet', 'airSgn', 'nrrdMaybeAlloc_va',
+           'meetAirEnumAllPrint', 'gageCtxFlagUnknown',
+           'echoJittableUnknown', 'gageOptimSigContextNix',
+           'pullPoint', 'tenInterpTypeUnknown', 'nrrdKernelBCCubicD',
            'tenGageCl1HessianEvec', 'nrrdBasicInfoDimension',
-           'coilKindArray', 'alanParmHomogAniso',
+           'unrrdu_undosCmd', 'coilKindArray', 'alanParmHomogAniso',
            'limnPolyDataCCFind', 'airTeemReleaseDate',
            'limnObjectFaceNormals', 'gageStackBlurParmVerboseSet',
            'nrrdKernelTMF_maxC', 'nrrdIoStateDetachedHeader',
@@ -9218,13 +9390,14 @@
            'tenFiberAnisoSpeedReset', 'coilMethodTypePeronaMalik',
            'miteRangeBlue', 'limnPolyDataInfoRGBA', 'miteValRw',
            'tenGradientGenerate', 'coilPresent', 'tend_stenCmd',
-           'limnEdgeTypeUnknown', 'airSprintSize_t',
-           'seekDescendToDeg', 'nrrdBasicInfoOldMax',
-           'unrrdu_shuffleCmd', 'echoJittableLight',
-           'tenInterpMulti3D', 'seekIsovalueSet', 'airMopDebug',
-           'nrrdEncodingType', 'nrrdCRC32', 'baneGkmsCmdList',
-           'pullCondUnknown', 'limnQN11octa', 'pullEnergyTypeBspln',
-           'tenDwiGageTensorMLE', 'pullEnergyTypeBetterCubicWell',
+           'tijk_esh_to_3d_sym_matrix_d', 'limnEdgeTypeUnknown',
+           'airSprintSize_t', 'gageStackBlurParmSigmaSet',
+           'nrrdBasicInfoOldMax', 'unrrdu_shuffleCmd',
+           'echoJittableLight', 'tenInterpMulti3D', 'seekIsovalueSet',
+           'airMopDebug', 'nrrdEncodingType', 'nrrdCRC32',
+           'baneGkmsCmdList', 'pullCondUnknown', 'limnQN11octa',
+           'pullEnergyTypeBspln', 'tenDwiGageTensorMLE',
+           'pullEnergyTypeBetterCubicWell', 'tenFiberType',
            'ell_q_to_aa_d', 'gagePoint_t', 'ell_q_to_aa_f',
            'unrrdu_padCmd', 'pushEnergyTypeCoulomb', 'airMopOnError',
            'nrrdDefaultKernelParm0', 'tend_pointCmd',
@@ -9233,21 +9406,23 @@
            'tijk_set_axis_esh', 'nrrdGetenvEnum', 'baneRangeLast',
            'nrrdUnaryOpSqrt', 'airFP_POS_ZERO', 'nrrdIoStateGet',
            'tenModelFromAxisLearnPossible', 'tenGageHessian',
-           'nrrdUnaryOpOne', 'gageCtxFlagRadius',
+           'pullCondEnergyBad', 'nrrdUnaryOpOne', 'gageCtxFlagRadius',
            'tenInterpTypeLogLinear', 'ell_3m_mul_d',
-           'mossFlagUnknown', 'coilContext_t', 'gageKindAnswerOffset',
-           'nrrdNew', 'nrrdEncodingTypeBzip2', 'airMopSingleError',
-           'nrrdField_sample_units', 'hooverErrRayEnd',
-           'tend_anplotCmd', 'pullInfoTensorInverse',
-           'pullPropNeighTanCovar', 'nrrdAxesSplit', 'nrrdSameSize',
-           'nrrdTernaryOpMaxSmooth', 'tenEstimateContext',
+           'mossFlagUnknown', 'coilContext_t', 'tenTensorCheck',
+           'gageKindAnswerOffset', 'nrrdNew', 'nrrdEncodingTypeBzip2',
+           'airMopSingleError', 'nrrdField_sample_units',
+           'hooverErrRayEnd', 'tend_anplotCmd',
+           'pullInfoTensorInverse', 'pullPropNeighTanCovar',
+           'nrrdAxesSplit', 'echoRTParmNew', 'nrrdTernaryOpMaxSmooth',
+           'tenEstimateContext', 'hestSourceUnknown',
            'unrrdu_swapCmd', 'seekItemEigensystemSet', 'airDioMalloc',
            'limnPrimitiveLineStrip', 'airThreadJoin',
            'pullEnergyTypeCubic', 'pullSysParmConstraintStepMin',
            'tenDefFiberWPunct', 'nrrdTypeUShort',
            'hooverContextCheck', 'tenFiberStopSet',
            'echoMatterPhongKs', 'limnSpaceDevice', 'nrrdUnaryOpAsin',
-           'biffMsgAdd', 'tenGageInvarRGrads', 'echoMatterPhongKd',
+           'biffMsgAdd', 'tenGageInvarRGrads',
+           'pullFlagConvergenceIgnoresPopCntl', 'echoMatterPhongKd',
            'nrrdUnblock', 'pushEnergySpec', 'echoMatterPhongKa',
            'tenFiberStopRadius', 'limnPrimitiveUnknown',
            'airSinglePrintf', 'airNormalRand', 'nrrdIterNew',
@@ -9256,7 +9431,7 @@
            'tenFiberStopConfidence', 'nrrdKind3Normal',
            'tenGageModeHessianEval2', 'tenGageModeHessianEval0',
            'tenGageModeHessianEval1', 'airThreadNix',
-           'gageSclTotalCurv', 'gageCtxFlagK3Pack', 'nrrdMeasureSum',
+           'gageSclTotalCurv', 'gageCtxFlagK3Pack', 'nrrdUnaryOpErf',
            'airGaussian', 'elfMaximaContextNix',
            'nrrdResampleBoundarySet', 'tenEMatrixCalc',
            'tenRotationTangents_d', 'nrrdBasicInfoType',
@@ -9279,46 +9454,47 @@
            'airMyEndian', 'pullPropNeighCovar', 'miteRangeRed',
            'gageVecVector2', 'gageVecVector1', 'nrrdBinaryOpMin',
            'tenGageThetaNormal', 'nrrdKernelC4HexicDDD',
-           'nrrdSimplePad_nva', 'pullEnergySpecNix',
+           'nrrdSimplePad_nva', 'nrrdSpaceVecNorm',
            'pullInitRandomSet', 'airPrimeList', 'tijk_negate_d',
-           'gageSclHessEvec', 'echoThreadStateNix', 'airThreadStart',
-           'tenFiberSingle', 'ell_3m_to_q_d', 'ell_3m_to_q_f',
-           'airFP_POS_DENORM', 'nrrdAxesInsert',
-           'airThreadBarrierNew', 'gageSclHessian', 'baneIncNew',
-           'limnSpline', 'meetPullInfoNix', 'limnDeviceLast',
-           'tijk_eval_esh_d', 'nrrdSample_va', 'limnPolyDataSmoothHC',
-           'tenGageOmegaHessianContrTenEvec2',
+           'tenDwiGageTensorWLSErrorLog', 'meetBiffKey',
+           'echoThreadStateNix', 'airThreadStart', 'tenFiberSingle',
+           'ell_3m_to_q_d', 'ell_3m_to_q_f', 'airFP_POS_DENORM',
+           'nrrdAxesInsert', 'airThreadBarrierNew', 'gageSclHessian',
+           'baneIncNew', 'limnSpline', 'meetPullInfoNix',
+           'limnDeviceLast', 'airTypeULongInt', 'nrrdSample_va',
+           'limnPolyDataSmoothHC', 'tenGageOmegaHessianContrTenEvec2',
            'nrrdAxisInfoSpaceDirection',
            'tenGageOmegaHessianContrTenEvec0', 'tenAniso_Det',
            'tijk_class_esh', 'nrrdResampleNonExistent',
            'tenGageFA2ndDD', 'elfSingleShellDWI', 'tenGageCl1GradMag',
-           'tenFiberContextNew',  'gageParmK3Pack',
+           'tenFiberContextNew',  'tenGageFANormal',
            'tenGageBNormal', 'tenEpiRegister3D', 'baneGkmsUsage',
-           'echoSphere', 'nrrdApply1DSubstitution',
-           'gageOptimSigParmNix', 'airEnumFmtDesc', 'seekPresent',
-           'tenExperSpecFromKeyValueSet', 'echoJittablePixel',
-           'tenGageTraceHessianEval2', 'ell_3m_eigensolve_d',
-           'echoIntxLightColor', 'dyeSimpleConvert',
+           'echoSphere', 'nrrdApply1DSubstitution', 'airEnumFmtDesc',
+           'seekPresent', 'tenExperSpecFromKeyValueSet',
+           'echoJittablePixel', 'tenGageTraceHessianEval2',
+           'ell_3m_eigensolve_d', 'echoIntxLightColor',
+           'dyeSimpleConvert', 'limnObjectVertexNormals',
            'nrrdSpaceVecCopy', 'seekExtract', 'pullRngSeedSet',
-           'nrrdField_last', 'nrrdHestIter', 'alanParmVerbose',
-           'gageVecImaginaryPart', 'nrrdBasicInfoContent',
-           'tenEstimateValueMinSet', 'tijk_3d_sym_to_esh_f',
-           'limnPolyDataInfoTang', 'limnCameraPathTrackLast',
-           'mossImageAlloc', 'tenGlyphTypeLast', 'airRandMTStateNew',
-           'nrrdEnvVarDefaultCenterOld', 'tenExperSpecMaxBGet',
-           'pullPointNumberFilter', 'tenEstimateUpdate',
-           'pullInfoIsovalueHessian', 'baneRangeZeroCentered',
-           'nrrdLineSkip', 'coilStart', 'coilMethodTypeHomogeneous',
-           'nrrdField_kinds', 'tijk_refine_rankk_parm_t',
-           'tenExpand2D', 'gageVecJacobian',
-           'nrrdBlind8BitRangeState', 'tenEstimate1Method',
-           'tijk_4o2d_unsym', 'pullTraceMultiSizeof',
-           'tijk_axis_info', 'airFP_NEG_ZERO', 'pushEnergyAll',
-           'echoMatter', 'pullFlagStartSkipsPoints',
-           'tenFiberParmUnknown', 'airStderr', 'pushEnergyType',
-           'unrrdu_histoCmd', 'pullSysParmSeparableGammaLearnRescale',
+           'nrrdField_last', 'NrrdBoundarySpec', 'nrrdHestIter',
+           'alanParmVerbose', 'gageVecImaginaryPart',
+           'nrrdBasicInfoContent', 'tenEstimateValueMinSet',
+           'tijk_3d_sym_to_esh_f', 'limnPolyDataInfoTang',
+           'dyeSpaceRGB', 'mossImageAlloc', 'tenGlyphTypeLast',
+           'airRandMTStateNew', 'nrrdEnvVarDefaultCenterOld',
+           'tenExperSpecMaxBGet', 'pullPointNumberFilter',
+           'tenEstimateUpdate', 'pullInfoIsovalueHessian',
+           'baneRangeZeroCentered', 'nrrdLineSkip', 'coilStart',
+           'coilMethodTypeHomogeneous', 'nrrdField_kinds',
+           'tijk_refine_rankk_parm_t', 'tenExpand2D',
+           'gageVecJacobian', 'nrrdBlind8BitRangeState',
+           'tenEstimate1Method', 'tijk_4o2d_unsym',
+           'pullTraceMultiSizeof', 'tijk_axis_info', 'airFP_NEG_ZERO',
+           'pushEnergyAll', 'echoMatter', 'pullFlagStartSkipsPoints',
+           'gageSigmaSamplingLast', 'tenFiberParmUnknown',
+           'airStderr', 'pushEnergyType', 'unrrdu_histoCmd',
+           'pullSysParmSeparableGammaLearnRescale',
            'unrrduDefNumColumns', 'tenModel1Tensor2',
-           'airEndianLittle', 'nrrdKind4Color', 'nrrdField_dimension',
+           'airEndianLittle', 'airArrayStructCB', 'limnSpaceWorld',
            'seekTypeUnknown', 'seekContour3DTopoHackTriangle',
            'nrrdCommentClear', 'limnPolyDataSpiralTubeWrap',
            'tenGageRGradVec', 'nrrdStateBlind8BitRange',
@@ -9329,7 +9505,7 @@
            'nrrdKernelHermiteScaleSpaceFlag', 'ell_cubic_root_triple',
            'nrrdKernelSpecNix', 'nrrdDefaultResampleBoundary',
            'nrrdAxesDelete', 'airFloatPosInf', 'nrrdKernelSpecSet',
-           'limnPolyDataInfoUnknown', 'echoJitterRandom',
+           'limnPolyDataInfoUnknown', 'tenGageThetaGradVec',
            'gageItemSpecInit', 'tend_aboutCmd', 'gageErr',
            'gagePoint', 'pullTraceNew', 'tenGageFAHessianFrob',
            'alanParmMaxPixelChange', 'seekVerboseSet', 'airMopper',
@@ -9338,27 +9514,28 @@
            'nrrdBlock', 'mossFlagKernel', 'airTypeString',
            'nrrdKernelC4HexicD', 'miteStageOpMin',
            'nrrdFormatTypeUnknown', 'dyeColorSprintf',
-           'pullEnergySpecCopy', 'airFlippedSgnPow', 'baneMeasr2ndDD',
-           'pullCountPoints', 'meetConstGageKindParse',
-           'nrrdSpacingStatusNone', 'airTypeULongInt', 'gageShape_t',
-           'alanParmSet', 'limnPolyDataCube',
-           'limnDefCameraAtRelative', 'ell_cubic_root_three',
-           'biffMsgNix', 'tenGageCa1GradMag', 'limnPolyDataNew',
-           'nrrdDefaultResampleRound',
-           'coilMethodTypeModifiedCurvature', 'echoRTParmNew',
+           'pullEnergySpecCopy', 'tend_gradsCmd', 'airFlippedSgnPow',
+           'baneMeasr2ndDD', 'pullCountPoints',
+           'meetConstGageKindParse', 'nrrdSpacingStatusNone',
+           'gageVecDivergence', 'gageShape_t', 'alanParmSet',
+           'limnPolyDataCube', 'limnDefCameraAtRelative',
+           'ell_cubic_root_three', 'biffMsgNix', 'tenGageCa1GradMag',
+           'limnPolyDataNew', 'nrrdDefaultResampleRound',
+           'coilMethodTypeModifiedCurvature', 'airFclose',
            'gageSclHessEvec0', 'gageSclHessEvec1', 'gageSclHessEvec2',
            'tenGlyphBqdUvEval', 'hestElideSingleNonExistFloatDefault',
            'tenFiberStopLength', 'ell_4m_print_f',
-           'limnPrimitiveTriangleFan', 'ell_4m_print_d',
+           'limnSplineInfo3Vector', 'ell_4m_print_d',
            'tenDefFiberMaxNumSteps', 'limnLightDiffuseCB',
            'nrrdMeasureHistoSum', 'tenGageFARidgeSurfaceStrength',
            'nrrdField_axis_mins', 'pullEnergyCubicWell',
            'tenFiberUpdate', 'biffMsgStrAlloc', 'tenDwiGageADC',
-           'pullProbe', 'nrrdOriginCalculate', 'tenInterpN_d',
-           'mossMatInvert', 'seekTypeRidgeLine',
-           'pullCountEnergyFromPoints', 'gageSclLast',
+           'pullProbe', 'hestSourceDefault', 'nrrdOriginCalculate',
+           'tenInterpN_d', 'mossMatInvert', 'seekTypeRidgeLine',
+           'pullCountEnergyFromPoints', 'coilMethodTypeUnknown',
            'gageVecLength', 'pullSysParmRadiusSpace', 'pushContext_t',
            'limnSpace', 'nrrdIoStateFormatGet', 'gageStackWtoI',
+           'gageStackBlurParmDgGoodSigmaMaxSet',
            'nrrdKernelBSpline5DD', 'pushPointNew',
            'pushEnergySpecNew', 'pullContext_t', 'tenDwiGageKindData',
            'nrrdDeringRadiusScaleSet', 'nrrdTypePrintfStr',
@@ -9377,15 +9554,17 @@
            'pullEnergyButterworthParabola',
            'hestElideSingleEmptyStringDefault', 'tenExperSpec',
            'nrrdDeringVerboseSet', 'tenDwiGage2TensorQSegError',
-           'hestElideMultipleNonExistFloatDefault', 'gageScl2ndDD',
+           'hestElideMultipleNonExistFloatDefault',
+           'nrrdBasicInfoSpace', 'gageScl2ndDD',
            'limnPolyDataTransform_d', 'airTypeDouble',
            'pullEnergyHepticWell', 'tijk_esh_make_kernel_rank1_d',
            'tijk_esh_make_kernel_rank1_f', 'baneIncUnknown',
            'pullInfoUnknown', 'pullEnergyAll', 'unrrdu_permuteCmd',
-           'limnDeviceUnknown', '_airThread', 'tenGageDelNormPhi3',
-           'tenGageDelNormPhi2', 'tenGageDelNormPhi1',
-           'airRandMTState', 'NrrdKernelSpec', 'pullCondEnergyBad',
-           'tenGageTensorGradRotE', 'nrrdInvertPerm', 'nrrdTernaryOp',
+           'limnDeviceUnknown', 'nrrdTypeDouble',
+           'tenGageDelNormPhi3', 'tenGageDelNormPhi2',
+           'tenGageDelNormPhi1', 'airRandMTState', 'NrrdKernelSpec',
+           'nrrdBinaryOpMax', 'tenGageTensorGradRotE',
+           'nrrdInvertPerm', 'nrrdTernaryOp', 'nrrdBoundarySpecNix',
            'tenGlyphBqdAbcUv', 'nrrdUnaryOpSgn',
            'ell_3v_area_spherical_d', 'pullSysParmBackStepScale',
            'dyeColorSet', 'baneIncAbsolute', 'nrrdKernelBSpline5',
@@ -9393,59 +9572,62 @@
            'nrrdKernelBSpline1', 'nrrdKernelBSpline2',
            'gageSclGeomTensTen', 'nrrdMeasureHistoL2',
            'limnPolyDataAlloc', 'tenGradientBalance',
-           'tijk_esh_make_kernel_delta_f',
-           'tenDwiGageTensorWLSErrorLog', 'meetBiffKey',
-           'nrrdHistoDraw', 'nrrdGetenvDouble', 'nrrdLoadMulti',
-           'echoMatterTextureSet', 'limnQNtoV_f', 'limnQNtoV_d',
-           'tenGageTraceHessianEval1', 'tenGageTraceHessianEval0',
-           'echoSceneNix', 'nrrdZlibStrategyFiltered',
-           'nrrdTernaryOpLTSmooth', 'elfColorGlyphMaxima',
+           'tijk_esh_make_kernel_delta_f', 'gageSclHessEvec',
+           'elfGlyphKDE', 'nrrdHistoDraw', 'nrrdGetenvDouble',
+           'nrrdLoadMulti', 'echoMatterTextureSet', 'limnQNtoV_f',
+           'limnQNtoV_d', 'tenGageTraceHessianEval1',
+           'tenGageTraceHessianEval0', 'echoSceneNix',
+           'nrrdZlibStrategyFiltered', 'nrrdTernaryOpLTSmooth',
+           'elfColorGlyphMaxima', 'pullEnergySpecNix',
            'nrrdKindHSVColor', 'elfBallStickParms',
            'nrrdFormatTypeVTK', 'pullCondOld',
            'alanTextureTypeTuring', 'pullCountForceFromPoints',
            'tend_evecrgbCmd', 'pushEnergyTypeCotan',
-           'tenGageThetaGradVec', 'pullPtrPtrUnion',
+           'echoJitterRandom', 'pullPtrPtrUnion',
            'tenGageOmegaHessianEvec2', 'echoIntx', 'gageCtxFlagShape',
-           'gageVecDivergence', 'limnCameraPathTrackAt',
+           'alanParmUnknown', 'limnCameraPathTrackAt',
            'limnPolyDataCopyN', 'tijk_3d_sym_to_esh_d',
            'tenDWMRIModalityVal', 'pullTraceSet',
-           'nrrdKernelAQuartic', 'nrrdSpace3DRightHanded',
-           'nrrdUnaryOpSin', 'nrrdFFTWPlanRigorMeasure',
-           'airHeapFind', 'ell_Nm_mul', 'nrrdKindXYZColor',
-           'echoTypeCylinder', 'nrrdAxisInfoMinMaxSet',
-           'gageVolumeCheck', 'gageVecDirHelDeriv', 'tijk_2o2d_unsym',
-           'nrrdStringWrite', 'tenAniso_B', 'limnLightUpdate',
-           'nrrdOriginStatusOkay', 'tenAniso_Q', 'tenAniso_R',
-           'tenAniso_S', 'limnQN16simple', 'tijk_max_efs_order',
-           'dyeColorGet', 'nrrdMeasureLine', 'tenGageFAMeanCurv',
-           'ell_4m_mul_f', 'gagePresent', 'ell_4m_mul_d',
-           'limnPresent', 'tenDwiGageTensorWLSError',
-           'tenGageCp1Hessian', 'tenTripleTypeLast', 'nrrdSwapEndian',
+           'nrrdKernelAQuartic', 'airTauOfTime',
+           'nrrdSpace3DRightHanded', 'nrrdUnaryOpSin',
+           'nrrdFFTWPlanRigorMeasure', 'airHeapFind', 'ell_Nm_mul',
+           'nrrdKindXYZColor', 'echoTypeCylinder',
+           'nrrdAxisInfoMinMaxSet', 'gageVolumeCheck',
+           'gageVecDirHelDeriv', 'tijk_2o2d_unsym', 'nrrdStringWrite',
+           'tenAniso_B', 'limnLightUpdate', 'nrrdOriginStatusOkay',
+           'tenAniso_Q', 'tenAniso_R', 'tenAniso_S', 'limnQN16simple',
+           'tijk_max_efs_order', 'dyeColorGet', 'nrrdMeasureLine',
+           'tenGageFAMeanCurv', 'ell_4m_mul_f', 'gagePresent',
+           'ell_4m_mul_d', 'limnPresent', 'nrrdUnaryOpTauOfSigma',
+           'tenDwiGageTensorWLSError', 'miteRangeLast',
+           'tenTripleTypeLast', 'nrrdSwapEndian',
            'gageErrBoundsStack', 'tijk_approx_heur_parm',
            'tenEstimate1TensorSimulateVolume', 'unrrdu_resampleCmd',
            'limnPolyDataInfoBitFlag', 'hooverStubRayBegin',
-           'nrrdRangeAxesGet', 'tenGageConfDiffusionFraction',
-           'nrrdKernelBCCubic', 'pullVolumeStackAdd',
-           'tenGageCa1Normal', 'airDoneStr', 'pullSysParmSet',
-           'nrrdResamplePadValueSet', 'nrrdDeringContextNix',
-           'nrrdMeasureNormalizedL2', 'echoMatterMetalFuzzy',
-           'mossMatScaleSet', 'miteRangeLast', 'unrrdu_sliceCmd',
-           'gageKindVec', 'echoMatterMetalKd', 'tenGageCp1GradMag',
+           'tenGageKind', 'nrrdRangeAxesGet',
+           'tenGageConfDiffusionFraction', 'nrrdKernelBCCubic',
+           'pullVolumeStackAdd', 'tenGageCa1Normal', 'airDoneStr',
+           'pullSysParmSet', 'nrrdResamplePadValueSet',
+           'nrrdDeringContextNix', 'pullSourceLast',
+           'echoMatterMetalFuzzy', 'mossMatScaleSet',
+           'tenGageCp1Hessian', 'unrrdu_sliceCmd', 'gageKindVec',
+           'echoMatterMetalKd', 'nrrdIoStateSkipData',
            'echoMatterMetalKa', 'unrrduScaleMultiply',
            'unrrdu_vidiconCmd', 'gageKindScl',
            'hestCleverPluralizeOtherY', 'nrrdCheapMedian',
            'nrrdKernelDiscreteGaussian', 'limnSplineInfoUnknown',
            'tenEstimateLinearSingle_d', 'tenEstimateLinearSingle_f',
            'tenModel1Vector2D', 'nrrdSaveMulti', 'baneDefIncLimit',
-           'tenLogSingle_d', 'tend_satinCmd', 'nrrdIoStateZlibLevel',
+           'tenLogSingle_d', 'tend_satinCmd',
+           'tijk_3d_sym_to_esh_matrix_f', 'nrrdIoStateZlibLevel',
            'gageQueryAdd', 'gageItemPackPartLast',
            'nrrdKernelBSpline3ApproxInverse', 'baneMeasrLast',
            'tenFiberSingleNix', 'gageVecLast', 'limnQNUnknown',
            'nrrdKernelAQuarticDD', 'airIsInf_f', 'tend_anscaleCmd',
            'airIsInf_d', 'tenGageTensorGradMagMag',
            'tenDWMRIGradKeyFmt', 'alan_t', 'tenGageCl1Hessian',
-           'seekTypeIsocontour', 'airFP_Unknown',
-           'nrrdBasicInfoKeyValuePairs', 'limnQN8checker',
+           'limnQN10octa', 'airFP_Unknown',
+           'nrrdBasicInfoKeyValuePairs', 'tenTripleTypeRThetaPhi',
            'gageParmUnknown', 'pushBin', 'miteShadeMethodUnknown',
            'nrrdBinaryOpPow', 'elfMaximaFind_d', 'biffMsgNoop',
            'baneIncPercentile', 'elfMaximaFind_f',
@@ -9456,7 +9638,7 @@
            'tenGageFAGradVec', 'tenInterpTypeGeoLoxK',
            'nrrdDefaultCenter', 'limnPolyDataWriteVTK',
            'ell_3m_post_mul_f', 'ell_3m_post_mul_d', 'limnPart_t',
-           'pullIterParmCallback', 'tenDWMRIKeyValueParse',
+           'baneDefRenormalize', 'tenDWMRIKeyValueParse',
            'airIndexClampULL', 'baneIncRangeRatio',
            'baneStateHistEqBins', 'nrrdFLoad', 'echoGlobalStateNew',
            'tenEstimateThresholdSet', 'pullFlagPermuteOnRebin',
@@ -9468,36 +9650,36 @@
            'biffMsgClear', 'ell_3m_2d_nullspace_d',
            'nrrdBinaryOpLast', 'tend_evalCmd', 'coilDefaultRadius',
            'nrrdRangeNix', 'dyeSpaceUnknown',
-           'airRandMTStateGlobalInit', 'nrrdDomainAxesGet', 'airHeap',
-           'pullInterTypeAdditive', 'tenGageDetNormal',
-           'nrrdDeringClampHistoBinsSet', 'airDrandMT',
-           'nrrdUnaryOpLog2', 'pullEnergyTypeSpring', 'airMode3',
-           'tijk_refine_rank1_parm_nix', 'limnObjectConeAdd',
-           'NrrdAxisInfo', 'tijk_esh_convolve_d', 'airMopDone',
-           'tenSqrtSingle_f', 'tenDwiGageTensorNLSLikelihood',
-           'baneGkms_infoCmd', 'meetAirEnumAllCheck', 'baneGkmsMeasr',
-           'nrrdField_min', 'dyeStrToSpace', 'gageVecStrain',
-           'nrrdShuffle', 'baneGkms_miteCmd', 'mite_t',
-           'gageDeconvolveSeparable', 'airSetNull',
-           'pullThreadNumSet', 'airDioInfo', 'airArray',
+           'airRandMTStateGlobalInit', 'nrrdDomainAxesGet',
+           'echoMatterLightUnit', 'pullInterTypeAdditive',
+           'tenGageDetNormal', 'nrrdDeringClampHistoBinsSet',
+           'airDrandMT', 'nrrdUnaryOpLog2', 'pullEnergyTypeSpring',
+           'airMode3', 'tijk_refine_rank1_parm_nix',
+           'limnObjectConeAdd', 'NrrdAxisInfo', 'seekDescendToDeg',
+           'airMopDone', 'tenSqrtSingle_f',
+           'tenDwiGageTensorNLSLikelihood', 'baneGkms_infoCmd',
+           'elfESHEstimMatrix_d', 'baneGkmsMeasr', 'nrrdField_min',
+           'dyeStrToSpace', 'gageVecStrain', 'nrrdShuffle',
+           'baneGkms_miteCmd', 'mite_t', 'gageDeconvolveSeparable',
+           'airSetNull', 'pullThreadNumSet', 'airDioInfo', 'airArray',
            'nrrdResampleContextNew', 'limnSplineTypeSpec_t',
            'echoListAdd', 'tenDefFiberAnisoThresh',
            'pullTraceStopBounds', 'tenGageFAHessianEval',
-           'nrrdResampleExecute', 'nrrdField_spacings',
-           'nrrdKernelSpecCopy', 'gageParmStackUse', 'airNoDio_fpos',
-           'nrrdOriginStatusNoMaxOrSpacing',
-           'nrrdResampleNonExistentLast', 'nrrdDClamp',
-           'unrrdu_reshapeCmd', 'pullInfoHessian',
-           'limnPolyDataPrimitiveTypes', 'gageOptimSigSet',
-           'gageStackItoW', 'tenTripleTypeMoment',
+           'nrrdResampleExecute', 'nrrdField_spacings', 'dyeColorNew',
+           'gageParmStackUse', 'nrrdBoundarySpecCompare',
+           'airNoDio_fpos', 'nrrdOriginStatusNoMaxOrSpacing',
+           'gageSclHessRidgeness', 'nrrdDClamp', 'unrrdu_reshapeCmd',
+           'pullInfoHessian', 'limnPolyDataPrimitiveTypes',
+           'gageOptimSigSet', 'gageStackItoW',
+           'nrrdEnvVarStateMeasureModeBins', 'tenTripleTypeMoment',
            'nrrdKernelBSpline2D', 'nrrdIStore', 'mossSamplerNix',
            'tenModelParse', 'miteRangeUnknown',
            'tenGageInvarKGradMags', 'biffPresent', 'nrrdTypeInt',
            'seekTypeValleySurfaceT', 'limnPolyDataWriteIV',
            'nrrdFormatArray', 'nrrdCCMax', 'airBesselI0ExpScaled',
-           'tenTripleTypeK', 'tenTripleTypeJ', 'ell_4mv_mul_f',
-           'coilTask', 'tenTripleTypeR', 'mossDefCenter',
-           'tenVerbose', 'nrrdIoStateUnknown',
+           'tenTripleTypeK', 'tenTripleTypeJ', 'coilTask',
+           'tenTripleTypeR', 'mossDefCenter', 'tenVerbose',
+           'miteDefOpacNear1', 'nrrdIoStateUnknown',
            'pullSysParmRadiusScale', 'nrrdKernelSpecParse',
            'gageDefCurvNormalSide', 'tijk_approx_heur_parm_nix',
            'tenGageCa1GradVec', 'tijk_approx_rankk_2d_d',
@@ -9506,19 +9688,19 @@
            'gageItemPackPartHessEvec2', 'limnHestSpline',
            'nrrdEnvVarStateBlind8BitRange', 'echoLightColor',
            'tenFiberSingleNew', 'dyeRGBtoXYZ', 'tijk_2o2d_asym',
-           'baneInfoCheck', 'unrrdu_mrmapCmd', 'hestParmFree',
+           'baneInfoCheck', 'unrrdu_mlutCmd', 'hestParmFree',
            'tenFiberIntgEuler', 'baneGkmsHestIncStrategy',
            'echoTextureLookup', 'pullOutputGet', 'nrrdGetenvUInt',
            'pullVolumeNix', 'nrrdBoundaryMirror', 'nrrdFFTWPlanRigor',
            'pullCountPointsStuck', 'pullInfoSpec_t',
            'nrrdTernaryOpInClosed', 'tenGageFAHessianEvalMode',
            'echoTypeSphere', 'gagePerVolumeAttach', 'pushIterate',
-           'nrrdField_units', 'unrrduUsageUnu', 'unrrdu_mlutCmd',
-           'ell_aa_to_3m_f', 'ell_aa_to_3m_d', 'baneMeasrNix',
-           'pullCondConstraintFail', 'tenGageTraceGradVec',
-           'tenAniso_Cs2', 'alanStopMaxIteration', 'miteUserNew',
-           'nrrdSimpleCrop', 'tenEstimate1MethodNLS', 'gageKind',
-           'nrrdSanityOrDie', 'seekStrengthUseSet', 'pullContextNew',
+           'nrrdField_units', 'unrrduUsageUnu', 'ell_aa_to_3m_f',
+           'ell_aa_to_3m_d', 'baneMeasrNix', 'pullCondConstraintFail',
+           'tenAniso_Cs1', 'tenAniso_Cs2', 'airTauOfSigma',
+           'alanStopMaxIteration', 'miteUserNew', 'nrrdSimpleCrop',
+           'tenEstimate1MethodNLS', 'gageKind', 'nrrdSanityOrDie',
+           'seekStrengthUseSet', 'pullContextNew',
            'tenDwiGageTensorNLSErrorLog', 'echoList', 'airMopNew',
            'nrrdOriginStatusLast', 'tijk_3o3d_sym', 'gageQueryReset',
            'gageDefStackNormalizeDerivBias', 'pullInfoSeedPreThresh',
@@ -9527,16 +9709,15 @@
            'tenFiberSingleInit', 'tenModelBall1Cylinder',
            'unrrdu_projectCmd', 'biffCheck', 'pullInitMethodRandom',
            'pullInfoSeedThresh', 'tenDwiGageTensorMLEErrorLog',
-           'hooverRender', 'biffMsgMove',
-           'tenDwiGage2TensorPeledError', 'tenEstimate1MethodLLS',
+           'hooverRender', 'biffMsgMove', 'limnSplineTypeLast',
+           'tenEstimate1MethodLLS',
            'nrrdEnvVarDefaultWriteCharsPerLine', 'tenInterpTwo_d',
            'hestParseFree', 'hooverStubRenderEnd', 'pullPoint_t',
            'tenGageTrace', 'mossSamplerKernelSet', 'echoRayColor',
            'gageSclGradMag', 'nrrdCopy', 'nrrdUnaryOp',
            'nrrdKernelTMF', 'pullEnergyButterworth',
-           'gagePerVolumeNix', 'tenEstimateSkipSet',
-           'airInsane_nInfExists', 'tenDwiFiberTypeLast',
-           'gageScl3PFilter_t', 'echoTriMesh',
+           'gagePerVolumeNix', 'tenEstimateSkipSet', 'airInsane_dio',
+           'tenDwiFiberTypeLast', 'gageScl3PFilter_t', 'echoTriMesh',
            'tenDwiGageTensorError', 'coilIterate', 'airTypeLongInt',
            'nrrdKernelParmSet',
            'pullFlagAllowCodimension3Constraints',
@@ -9545,12 +9726,12 @@
            'tenDwiGage2TensorPeledLevmarInfo', 'baneMeasrNew',
            'airLogRician', 'tenGageTraceGradVecDotEvec0',
            'tenDwiGageTensorWLSLikelihood', 'nrrdSplice',
-           'nrrdKernelGaussianDD', 'gageSigOfTau', 'nrrdFFTWEnabled',
+           'nrrdKernelGaussianDD', 'nrrdFFTWEnabled',
            'nrrdRangeReset', 'nrrdKind3Color', 'airSrandMT',
            'tenGageModeHessianFrob', 'tenGageConfGradVecDotEvec0',
            'echoThreadState', 'tenDwiGageTensorNLS', 'baneInputCheck',
            'airNoDio_fd', 'pushEnergyGauss', 'tend_tconvCmd',
-           'nrrdAxisInfoSet_va', 'gageVecNormalized',
+           'nrrdAxisInfoSet_va', 'tenGageModeGradVec',
            'nrrdValCompareInv', 'nrrdStringRead', 'unrrdu_rmapCmd',
            'nrrdDeringLinearInterpSet', 'limnPolyDataPrimitiveSelect',
            'pullPointInitializePerVoxel', 'ell_q_inv_f',
@@ -9565,15 +9746,16 @@
            'gageCtxFlagNeedK', 'mossSamplerEmpty', 'limnQN16checker',
            'tenExperSpecGradBValSet', 'gageZeroNormal',
            'nrrdFFTWPlanRigorEstimate', 'gageSclHessValleyness',
-           'nrrdSpacingStatus', 'miteRangeGreen', 'meetPullVol',
-           'nrrdMeasureCoV', 'airBesselI1By0',
+           'nrrdSpacingStatus', 'tenGageSGradVec', 'meetPullVol',
+           'airFP_NEG_INF', 'airBesselI1By0',
            'nrrdBasicInfoSampleUnits', 'nrrdIoStateEncodingSet',
            'nrrdMeasureUnknown', 'ell_3m_pre_mul_d',
            'ell_3m_pre_mul_f', 'tijk_esh_deconvolve_d', 'tenPresent',
            'unrrduBiffKey', 'coilFinish', 'nrrdResampleRoundSet',
-           'miteShadeMethodPhong', 'airSprintPtrdiff_t', 'biffMsgNew',
-           'airEndianLast', 'nrrdSpaceVecScale', 'ell_q_to_3m_d',
-           'nrrdDLoad', 'hestInfo', 'miteStageOpUnknown', 'nrrdField',
+           'miteShadeMethodPhong', 'nrrdResampleBoundarySpecSet',
+           'airSprintPtrdiff_t', 'biffMsgNew', 'airEndianLast',
+           'nrrdSpaceVecScale', 'ell_q_to_3m_d', 'nrrdDLoad',
+           'hestInfo', 'miteStageOpUnknown', 'nrrdField',
            'echoPtrPtrUnion', 'nrrdEncodingHex',
            'nrrdStateMeasureModeBins', 'tijk_init_max_3d_d',
            'gagePerVolume_t', 'limnPolyDataPolarSphere',
@@ -9582,11 +9764,11 @@
            'limnPolyDataCubeTriangles', 'nrrdKindNormal',
            'miteValLast', 'gageErrStackSearch', 'tenGageTraceNormal',
            'nrrdKernelBSpline7DD', 'baneRangeAnswer',
-           'airFPPartsToVal_d', 'nrrdAxesMerge', 'echoJitterLast',
-           'airIntPow', 'tenModelBall', 'hooverThreadEnd_t',
-           'tenTripleTypeRThetaPhi', 'nrrdAxisInfoSet_nva',
-           'nrrdEnvVarStateGrayscaleImage3D',
-           'tenEstimateBMatricesSet', 'airHeapLength', 'dyeColorNew',
+           'gageStackBlurParmOneDimSet', 'airFPPartsToVal_d',
+           'nrrdAxesMerge', 'echoJitterLast', 'airIntPow',
+           'tenModelBall', 'hooverThreadEnd_t', 'limnQN8checker',
+           'nrrdAxisInfoSet_nva', 'nrrdEnvVarStateGrayscaleImage3D',
+           'tenEstimateBMatricesSet', 'airHeapLength', 'tenGageEvec2',
            'gageParmSet', 'nrrdRead',
            'pullFlagNoPopCntlWithZeroAlpha', 'nrrdElementNumber',
            'tijk_eval_esh_basis_f', 'nrrdDeringExecute',
@@ -9596,46 +9778,47 @@
            'nrrdUnaryOpNormalRand', 'tend_msimCmd',
            'seekTypeValleySurface', 'airShuffle', 'dyeSpaceXYZ',
            'tenGageCl1HessianEval', 'mossBiffKey', 'tenAniso_Cl1',
-           'tenAniso_Cl2', 'miteValNdotL', 'airULLong', 'gageKernel',
-           'gageSclGeomTens', 'nrrdKernelBSpline3DDD',
+           'tenAniso_Cl2', 'nrrdFormatTypePNG', 'airULLong',
+           'gageKernel', 'gageSclGeomTens', 'nrrdKernelBSpline3DDD',
            'ell_cubic_root_single_double', 'airEnum',
            'nrrdCenterCell', 'hooverErrThreadBegin',
            'nrrdUnaryOpUnknown', 'elfCart2Thetaphi_f',
-           'baneGkms_opacCmd', 'airNaN',
-           'limnPolyDataVertexWindingFix', 'miteStageOp',
-           'gageDefStackBlurSigmaMax', 'dyeSpaceHSV',
-           'tenEstimate1MethodLast', 'gageShapeBoundingBox',
-           'limnObjectPartTransform', 'gageTauOfSig',
-           'nrrdField_byte_skip', 'pullPropNeighInterNum',
+           'elfCart2Thetaphi_d', 'baneGkms_opacCmd', 'airNaN',
+           'limnPolyDataVertexWindingFix', 'gageStackBlurParmSprint',
+           'miteStageOp', 'dyeSpaceHSV', 'tenEstimate1MethodLast',
+           'gageShapeBoundingBox', 'limnObjectPartTransform',
+           'tenGageCl1HessianEval2', 'pullPropNeighInterNum',
            'airDisableDio', 'airArrayLenSet', 'gageQuery',
            'pullEnergyPlot', 'gageScl3PFilter8',
-           'nrrdSpaceRightAnteriorSuperiorTime', 'tenFiberContext',
+           'tenGageCl1HessianEval0', 'tenFiberContext',
            'gageScl3PFilter2', 'nrrdBlind8BitRangeTrue',
            'gageScl3PFilter6', 'dyeSpaceHSL',
            'nrrdSpaceScannerXYZTime', 'echoTypeCube',
            'nrrdCommentCopy', 'airSanity', 'tenFiberContextDwiNew',
            'nrrdKernelTMF_maxA', 'dyeSpaceToStr', 'nrrdKindDomain',
            'nrrdKernelTMF_maxD', 'unrrduHestPosCB', 'nrrdKernelTent',
-           'unrrduHestFileCB', 'gageParmReset', 'limnSplineSample',
-           'airDouble', 'mossSamplerImageSet', 'tenFiberType',
-           'airInsane_DLSize', 'baneRangeUnknown', 'nrrdElementSize',
-           'limnCameraNew', 'gageVecUnknown', 'nrrdMeasureSkew',
+           'unrrduHestFileCB', 'gageParmReset', 'airDouble',
+           'mossSamplerImageSet', 'pullInitMethod',
+           'airInsane_DLSize', 'baneRangeUnknown',
+           'gageParmTwoDimZeroZ', 'nrrdElementSize', 'limnCameraNew',
+           'gageVecUnknown', 'nrrdMeasureSkew',
            'tenGlyphTypeBetterquad', 'echoCol_t', 'echoListSplit',
            'pullPropScale', 'gageKernelLast', 'airStrtok',
            'tenGageTraceHessianFrob', 'seekContour3DTopoHackEdge',
            'nrrdBlind8BitRangeUnknown', 'limnQNDemo',
            'gageScl3PFilterN', 'unrrdu_spliceCmd', 'nrrdAxisInfoMax',
            'tijk_1o3d', 'nrrdTypeLLong', 'nrrdKernelBSpline6DD',
-           'echoMatterGlass', 'unrrdu_sselectCmd', 'tenGageFANormal',
-           'pullStatusEdge', 'nrrdIoStateKeepNrrdDataFileOpen',
-           'nrrdMaybeAlloc_nva', 'nrrdSpaceUnknown',
-           'tenModelPrefixStr', 'meetPullVolNix', '_airThreadMutex',
-           'nrrdWrap_nva', 'nrrdPresent', 'nrrdNix',
-           'nrrdResampleInfoNix', 'pushBinProcess',
+           'echoMatterGlass', 'unrrdu_sselectCmd',
+           'pullIterParmCallback', 'pullStatusEdge',
+           'nrrdIoStateKeepNrrdDataFileOpen', 'nrrdMaybeAlloc_nva',
+           'nrrdSpaceUnknown', 'tenModelPrefixStr', 'meetPullVolNix',
+           '_airThreadMutex', 'nrrdWrap_nva', 'nrrdPresent',
+           'nrrdNix', 'nrrdResampleInfoNix', 'pushBinProcess',
            'tenGageFALaplacian', 'nrrdCCSettle', 'gagePvlFlagLast',
-           'mossSamplerSample', 'ell_q_4v_rotate_f', 'airFP_POS_NORM',
-           'limnSplineInfo3Vector', 'nrrdField_type', 'miteThreadEnd',
-           'pullInfoHeightHessian', 'coilMethodTypeUnknown',
+           'mossSamplerSample', 'airFP_POS_NORM',
+           'limnPrimitiveTriangleFan', 'nrrdField_type',
+           'unrrdu_mrmapCmd', 'miteThreadEnd',
+           'pullInfoHeightHessian', 'gageSclLast',
            'tenInterpTypeAffineInvariant', 'airMopSub', 'dyeHSLtoRGB',
            'unrrdu_axinfoCmd', 'tenGageCl1Normal',
            'tenGageCa1Hessian', 'limnDefCameraOrthographic',
@@ -9654,7 +9837,7 @@
            'tenLogSingle_f', 'limnObjectCylinderAdd',
            'gageErrBoundsSpace', 'gageSclShapeIndex',
            'pullSysParmOpporStepScale', 'nrrdKernelHannDD',
-           'limnQN10octa', 'pullConstraintScaleRange',
+           'seekTypeIsocontour', 'pullConstraintScaleRange',
            'echoIntxFuzzify', 'nrrdTypeUnknown',
            'nrrdResampleContextNix', 'hooverStubRayEnd',
            'limnSplineBCSet', 'limnPolyDataSpiralBetterquadric',
@@ -9675,25 +9858,29 @@
            'nrrdResampleRangeFullSet', 'pullSysParm',
            'nrrdDeringThetaKernelSet', 'limnPolyDataSize',
            'airMyQNaNHiBit', 'coilMethodTypeCurvatureFlow',
-           'pullInitMethodUnknown', 'pushStart', 'tend_gradsCmd',
-           'tenFiberParmVerbose', 'limnObjectLookAdd',
-           'tijk_refine_rankk_2d_f', 'tenModelNllFit',
-           'tenFiberMultiTrace', 'limnEdgeTypeBorder',
-           'nrrdSpaceOriginGet', 'nrrdBoundaryUnknown', 'tenInv_f',
-           'tenInv_d', 'baneHVolCheck', 'pullInitLiveThreshUseSet',
-           'tenGageCl1HessianEval2', 'tenTripleTypeUnknown',
-           'tenGageCl1HessianEval0', 'tenGageCl1HessianEval1',
-           'pullTraceStopStub', 'tenFiberStopUnknown',
-           'tenDwiGageLast', 'meetPullInfoNew', 'limnLightSwitch',
-           'echoObjectNew', 'tijk_init_max_2d_d', 'pullTraceMultiAdd',
-           'nrrdMeasureLineIntercept', 'airNoDioErr',
-           'nrrdResample_t', 'nrrdUnaryOpRoundDown', 'coilVerbose',
-           'pullProcessMode', 'airArrayPointerCB', 'airEnumCheck',
-           'nrrdOriginStatusUnknown', 'nrrdKind2Vector',
-           'nrrdEnvVarDefaultKernelParm0', 'nrrdAxisInfoIdxRange',
-           'echoMatterLight', 'gageItemPackPartUnknown',
-           'tijk_2o3d_sym', 'gageDeconvolve', 'gageSclHessEval1',
-           'gageSclHessEval0', 'gageSclHessEval2',
+           'pullInitMethodUnknown', 'pushStart',
+           'nrrdBoundarySpecCheck',
+           'meetPullVolStackBlurParmFinishMulti',
+           'tenFiberParmVerbose', 'gageStackBlurParmCompare',
+           'limnObjectLookAdd', 'tijk_refine_rankk_2d_f',
+           'tenModelNllFit', 'tenFiberMultiTrace',
+           'limnEdgeTypeBorder', 'nrrdSpaceOriginGet',
+           'nrrdBoundaryUnknown', 'tenInv_f', 'tenInv_d',
+           'baneHVolCheck', 'pullInitLiveThreshUseSet',
+           'nrrdField_byte_skip', 'tenTripleTypeUnknown',
+           'nrrdSpaceRightAnteriorSuperiorTime',
+           'tenGageCl1HessianEval1', 'pullTraceStopStub',
+           'tenFiberStopUnknown', 'tenDwiGageLast', 'meetPullInfoNew',
+           'limnLightSwitch', 'echoObjectNew', 'tijk_init_max_2d_d',
+           'pullTraceMultiAdd', 'nrrdMeasureLineIntercept',
+           'airNoDioErr', 'nrrdResample_t',
+           'gageOptimSigErrorPlotSliding', 'nrrdUnaryOpRoundDown',
+           'coilVerbose', 'pullProcessMode', 'airArrayPointerCB',
+           'airEnumCheck', 'nrrdOriginStatusUnknown',
+           'nrrdKind2Vector', 'nrrdEnvVarDefaultKernelParm0',
+           'nrrdAxisInfoIdxRange', 'echoMatterLight', 'pullCondNew',
+           'tijk_2o3d_sym', 'gageDeconvolve', 'nrrdKernelSpecCompare',
+           'gageSclHessEval1', 'gageSclHessEval0', 'gageSclHessEval2',
            'nrrdDeringThetaNumSet', 'tenEstimateLinear4D',
            'nrrdDefaultGetenv']
 
@@ -9704,11 +9891,11 @@
 # This is created by something akin to grep'ing through the
 # public header files, with some extra filters.
 
-TEEM_VERSION_MAJOR = 1   # must be 1 digit 
-TEEM_VERSION_MINOR = 11   # 1 or 2 digits 
-TEEM_VERSION_PATCH = 00   # 1 or 2 digits 
-TEEM_VERSION = 11100   # must be 5 digits, to facilitate
-TEEM_VERSION_STRING = "1.11.0" # cannot be so easily compared 
+TEEM_VERSION_MAJOR = 1   # must be 1 digit
+TEEM_VERSION_MINOR = 11   # 1 or 2 digits
+TEEM_VERSION_PATCH = 01   # 1 or 2 digits
+TEEM_VERSION = 11101   # must be 5 digits, to facilitate
+TEEM_VERSION_STRING = "1.11.1" # cannot be so easily compared
 AIR_PI = 3.14159265358979323846
 AIR_E = 2.71828182845904523536
 AIR_STRLEN_SMALL = (128+1) # has to be big enough to hold:
@@ -9744,10 +9931,10 @@
 ECHO = echoBiffKey
 ECHO_LIST_OBJECT_INCR = 32
 ECHO_IMG_CHANNELS = 5
-ECHO_EPSILON = 0.00005      # used for adjusting ray positions 
-ECHO_NEAR0 = 0.004          # used for comparing transparency to zero 
-ECHO_LEN_SMALL_ENOUGH = 5   # to control splitting for split objects 
-ECHO_THREAD_MAX = 512       # max number of threads 
+ECHO_EPSILON = 0.00005      # used for adjusting ray positions
+ECHO_NEAR0 = 0.004          # used for comparing transparency to zero
+ECHO_LEN_SMALL_ENOUGH = 5   # to control splitting for split objects
+ECHO_THREAD_MAX = 512       # max number of threads
 ECHO_JITTER_NUM = 4
 ECHO_JITTABLE_NUM = 7
 ECHO_MATTER_MAX = 4
@@ -9763,9 +9950,10 @@
 GAGE_PVL_FLAG_MAX = 3
 GAGE_KERNEL_MAX = 7
 GAGE_ITEM_PREREQ_MAXNUM = 8
-GAGE_SCL_ITEM_MAX = 35
+GAGE_SCL_ITEM_MAX = 36
 GAGE_VEC_ITEM_MAX = 31
 GAGE_ITEM_PACK_PART_MAX = 11
+GAGE_SIGMA_SAMPLING_MAX = 3
 GAGE_QUERY_BYTES_NUM = 32
 GAGE_ITEM_MAX = ((8*GAGE_QUERY_BYTES_NUM)-1)
 GAGE_PERVOLUME_ARR_INCR = 32
@@ -9793,7 +9981,7 @@
 MOSS = mossBiffKey
 MOSS_FLAG_NUM = 2
 NRRD = nrrdBiffKey
-NRRD_DIM_MAX = 16            # Max array dimension (nrrd->dim) 
+NRRD_DIM_MAX = 16            # Max array dimension (nrrd->dim)
 NRRD_SPACE_DIM_MAX = 8       # Max dimension of "space" around array
 NRRD_EXT_NRRD = ".nrrd"
 NRRD_EXT_NHDR = ".nhdr"
@@ -9818,7 +10006,7 @@
 NRRD_FORMAT_TYPE_MAX = 6
 NRRD_BOUNDARY_MAX = 5
 NRRD_TYPE_MAX = 11
-NRRD_TYPE_SIZE_MAX = 8    # max(sizeof()) over all scalar types 
+NRRD_TYPE_SIZE_MAX = 8    # max(sizeof()) over all scalar types
 NRRD_ENCODING_TYPE_MAX = 5
 NRRD_ZLIB_STRATEGY_MAX = 3
 NRRD_CENTER_MAX = 2
@@ -9856,9 +10044,9 @@
 NRRD_HAS_NON_EXIST_MAX = 3
 NRRD_SPACE_MAX = 12
 NRRD_SPACING_STATUS_MAX = 4
-NRRD_MEASURE_MAX = 29
+NRRD_MEASURE_MAX = 30
 NRRD_BLIND_8BIT_RANGE_MAX = 3
-NRRD_UNARY_OP_MAX = 30
+NRRD_UNARY_OP_MAX = 32
 NRRD_BINARY_OP_MAX = 23
 NRRD_TERNARY_OP_MAX = 16
 NRRD_FFTW_PLAN_RIGOR_MAX = 4
@@ -9867,7 +10055,7 @@
 PULL_THREAD_MAXNUM = 512
 PULL_VOLUME_MAXNUM = 4
 PULL_POINT_NEIGH_INCR = 16
-PULL_BIN_MAXNUM = 40000000 # sanity check on max number bins 
+PULL_BIN_MAXNUM = 40000000 # sanity check on max number bins
 PULL_PHIST = 0
 PULL_HINTER = 0
 PULL_TANCOVAR = 1
@@ -9884,7 +10072,8 @@
 PULL_SOURCE_MAX = 2
 PULL_COUNT_MAX = 14
 PULL_TRACE_STOP_MAX = 5
-PULL_CONSTRAINT_FAIL_MAX = 4
+PULL_INIT_METHOD_MAX = 4
+PULL_CONSTRAINT_FAIL_MAX = 6
 PUSH = pushBiffKey
 PUSH_THREAD_MAXNUM = 512
 PUSH_ENERGY_TYPE_MAX = 5
@@ -9908,7 +10097,7 @@
 TEN_TRIPLE_TYPE_MAX = 9
 TEN_MODEL_B0_MAX = 65500    # HEY: fairly arbitrary, but is set to be
 TEN_MODEL_DIFF_MAX = 0.006  # in units of mm^2/sec; diffusivity of
-TEN_MODEL_PARM_GRAD_EPS = 0.000005 # for gradient calculations 
+TEN_MODEL_PARM_GRAD_EPS = 0.000005 # for gradient calculations
 TEN_MODEL_STR_ZERO = "zero"
 TEN_MODEL_STR_B0 = "b0"
 TEN_MODEL_STR_BALL = "ball"
@@ -9925,7 +10114,7 @@
 TIJK_TYPE_MAX_NUM = 45
 TIJK_CLASS_MAX = 3
 UNRRDU = unrrduBiffKey
-UNRRDU_COLUMNS = 78  # how many chars per line do we allow hest 
+UNRRDU_COLUMNS = 78  # how many chars per line do we allow hest
 
 # =============================================================
 # Make sure this shared library will work on this machine.
@@ -9941,8 +10130,8 @@
     raise ImportError
 
 # =============================================================
-# Its nice to have these FILE*s around for utility use, but they 
-# aren't available in a platform-independent way in ctypes. These 
+# Its nice to have these FILE*s around for utility use, but they
+# aren't available in a platform-independent way in ctypes. These
 # air functions were created for this purpose.
 stderr = airStderr()
 stdout = airStdout()
diff --color -ruN teem-1.11.0-src.orig/README.txt teem-1.11.0-src/README.txt
--- teem-1.11.0-src.orig/README.txt	2012-12-20 22:12:22.000000000 +0800
+++ teem-1.11.0-src/README.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
-=============== 
-  Teem: Tools to process and visualize scientific data and images              
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+===============
+  Teem: Tools to process and visualize scientific data and images
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -27,7 +27,7 @@
 "LICENSE.txt" in the "src" directory.  The SLUL is the GNU Lesser
 General Public License, plus an exception: statically-linked binaries
 that link with Teem can be destributed under the terms of your choice,
-with very modest provisions.  
+with very modest provisions.
 
 =============== How to compile
 
@@ -42,7 +42,7 @@
 =============== Directory Structure
 
 * src/
-  With one subdirectory for each of the teem libraries, all the 
+  With one subdirectory for each of the teem libraries, all the
   source for the libraries is in here.  See library listing below.
   The src/CODING.txt file documents Teem coding conventions.
   * src/make
@@ -62,10 +62,10 @@
   Files related to compiling Teem with CMake
 
 * Testing/
-  Tests run by CTest.  More are being added.
+  Tests run by CTest.  More should be added.
 
 * data/
-  Small reference datasets; more will be added for testing
+  Small reference datasets; more may be added for testing
 
 * arch/
   When using the old GNU make system, objects and binaries are put
@@ -73,9 +73,9 @@
   subdirectories, with a name which exactly matches valid settings
   for the environment variable TEEM_ARCH. Within these directories are:
   * lib/
-    all libraries put both their static/archive (.a) and 
+    all libraries put both their static/archive (.a) and
     shared/dynamic (.so) library files here (such as libnrrd.a)
-  * bin/ 
+  * bin/
     all libraries put their binaries here, hopefully in a way which
     doesn't cause name clashes
   * obj/
@@ -84,12 +84,12 @@
     can link against them there
 
 * python/
-  For python wrappings
+  For python wrappings, although these are not maintained.
   * python/ctypes
     Bindings for python via ctypes
 
 * Examples/
-  Place for examples of Teem-using programs, but unfortunately 
+  Place for examples of Teem-using programs, but unfortunately
   not populated by much right now.  A work in progress.
 
 =============== Teem libraries
@@ -100,12 +100,12 @@
 
 * air: Basic utility functions, used throughout Teem
 
-* hest: Command-line parsing (air) 
+* hest: Command-line parsing (air)
 
 * biff: Accumulation of error messages (air)
 
 * nrrd: Nearly Raw Raster Data- library for raster data manipulation,
-and support for NRRD file format (biff, hest, air) 
+and support for NRRD file format (biff, hest, air)
 
 * ell: Linear algebra: operations on vectors, matrices and quaternions,
 and solving cubic polynomials. (nrrd, biff, air)
@@ -155,7 +155,7 @@
 * mite: Hoover-based volume rendering with gage-based transfer functions
 (ten, hoover, limn, gage, ell, nrrd, biff, air)
 
-* meet: Uniform API to things common to all Teem libraries 
+* meet: Uniform API to things common to all Teem libraries
 (mite, push, coil, pull, elf, ten, seek, hoover, echo, limn, bane, dye,
 gage, tijk, moss, alan, unrrdu, ell, nrrd, biff, hest, air)
 
diff --color -ruN teem-1.11.0-src.orig/src/air/754.c teem-1.11.0-src/src/air/754.c
--- teem-1.11.0-src.orig/src/air/754.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/754.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -451,7 +451,7 @@
      completely zero, so that this function returned airFP_NEG_DENORM
      instead of airFP_QNAN" */
   FP_GET_D(sign, expo, mant0, mant1, dlit, dbig);
-  hibit = AIR_CAST(unsigned char, mant0 >> 19); /* mant0 20 bits wide: ok */
+  hibit = AIR_UCHAR(mant0 >> 19); /* mant0 20 bits wide: ok */
 
   indexv = ((!!sign) << 2) | ((!!expo) << 1) | (!!mant0 || !!mant1);
   switch(indexv) {
@@ -533,7 +533,7 @@
   _airFloatEndianBig fbig;
   unsigned int sign, expo, mant;
 
-  flit.v = fbig.v = AIR_CAST(float, g);
+  flit.v = fbig.v = AIR_FLOAT(g);
   FP_GET_F(sign, expo, mant, flit, fbig);
   AIR_UNUSED(sign);
   return (0xff == expo && mant);
@@ -623,7 +623,7 @@
   if (file) {
     flit.v = fbig.v = val;
     FP_GET_F(sign, expo, mant, flit, fbig);
-    fprintf(file, "%f: class %d; 0x%08x = ",val, airFPClass_f(val),
+    fprintf(file, "%.9g: class %d; 0x%08x = ",val, airFPClass_f(val),
             airEndianLittle == airMyEndian() ? flit.i : fbig.i);
     fprintf(file, "sign:0x%x, expo:0x%02x, mant:0x%06x = \n",
             sign, expo, mant);
@@ -654,7 +654,7 @@
 
   if (file) {
     dlit.v = dbig.v = val;
-    fprintf(file, "%f: class %d; 0x%08x %08x = \n",
+    fprintf(file, "%.17g: class %d; 0x%08x %08x = \n",
             val, airFPClass_d(val),
             (airEndianLittle == airMyEndian() ? dlit.h.half1 : dbig.h.half1),
             (airEndianLittle == airMyEndian() ? dlit.h.half0 : dbig.h.half0));
diff --color -ruN teem-1.11.0-src.orig/src/air/air.h teem-1.11.0-src/src/air/air.h
--- teem-1.11.0-src.orig/src/air/air.h	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/air.h	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2010 Thomas Schultz
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
@@ -53,11 +53,11 @@
 ** NOTE: ../../CMakeLists.txt's Teem_VERSION variables must be in sync
 */
 #define TEEM_VERSION_MAJOR       1   /* must be 1 digit */
-#define TEEM_VERSION_MINOR      11   /* 1 or 2 digits */
+#define TEEM_VERSION_MINOR      12   /* 1 or 2 digits */
 #define TEEM_VERSION_PATCH      00   /* 1 or 2 digits */
-#define TEEM_VERSION         11100   /* must be 5 digits, to facilitate
+#define TEEM_VERSION         11200   /* must be 5 digits, to facilitate
                                         easy numerical comparison */
-#define TEEM_VERSION_STRING "1.11.0" /* cannot be so easily compared */
+#define TEEM_VERSION_STRING "1.12.0" /* cannot be so easily compared */
 
 /* NrrdIO-hack-000 */
 
@@ -93,7 +93,6 @@
 #endif
 
 /* ---- BEGIN non-NrrdIO */
-/* This is annoying, thanks to windows */
 #define AIR_PI 3.14159265358979323846
 #define AIR_E  2.71828182845904523536
 /* ---- END non-NrrdIO */
@@ -141,6 +140,7 @@
   short **s;
   unsigned int **ui;
   int **i;
+  long int **li;
   float **f;
   double **d;
   void **v;
@@ -559,7 +559,9 @@
 
 /* miscAir.c */
 AIR_EXPORT const char *airTeemVersion;
+AIR_EXPORT const int airTeemReleaseDone;
 AIR_EXPORT const char *airTeemReleaseDate;
+AIR_EXPORT void airTeemVersionSprint(char buff[AIR_STRLEN_LARGE]);
 AIR_EXPORT void *airNull(void);
 AIR_EXPORT void *airSetNull(void **ptrP);
 AIR_EXPORT void *airFree(void *ptr);
@@ -576,6 +578,7 @@
 AIR_EXPORT FILE *airStderr(void);
 AIR_EXPORT FILE *airStdout(void);
 AIR_EXPORT FILE *airStdin(void);
+AIR_EXPORT unsigned int airBitsSet(unsigned int N);
 AIR_EXPORT unsigned int airIndex(double min, double val, double max,
                                  unsigned int N);
 AIR_EXPORT unsigned int airIndexClamp(double min, double val, double max,
@@ -625,6 +628,10 @@
 AIR_EXPORT double airBesselI1By0(double x);
 AIR_EXPORT double airBesselIn(int n, double x);
 AIR_EXPORT double airBesselInExpScaled(int n, double x);
+AIR_EXPORT double airTauOfTime(double tee);
+AIR_EXPORT double airTimeOfTau(double tau);
+AIR_EXPORT double airSigmaOfTau(double tau);
+AIR_EXPORT double airTauOfSigma(double sig);
 AIR_EXPORT double airVanDerCorput(unsigned int indx, unsigned int base);
 AIR_EXPORT void airHalton(double *out, unsigned int indx,
                           const unsigned int *base, unsigned int num);
@@ -717,6 +724,12 @@
 ** since casts should probably always be revisited and reconsidered.
 */
 #define AIR_CAST(t, v) ((t)(v))
+/* ---- BEGIN non-NrrdIO */
+#define AIR_UCHAR(x) AIR_CAST(unsigned char, x)
+#define AIR_USHORT(x) AIR_CAST(unsigned short, x)
+#define AIR_FLOAT(x) AIR_CAST(float, x)
+#define AIR_DOUBLE(x) AIR_CAST(double, x)
+/* ---- END non-NrrdIO */
 #define AIR_UINT(x) AIR_CAST(unsigned int, x)
 #define AIR_INT(x) AIR_CAST(int, x)
 
@@ -807,7 +820,13 @@
 ** "invalid operands to binary ^ (have ‘int’ and ‘int’)" but these
 ** problems oddly went away with the explicit cast to int.
 */
-#if defined(_WIN32) || defined(__ECC) /* NrrdIO-hack-002 */
+/* ---- BEGIN non-NrrdIO */
+#if !defined(TEEM_NON_CMAKE)
+#  include "teem/airExistsConf.h"
+#endif
+/* ---- END non-NrrdIO */
+
+#if defined(_WIN32) || defined(__ECC) || defined(AIR_EXISTS_MACRO_FAILS) /* NrrdIO-hack-002 */
 #define AIR_EXISTS(x) (airExists(x))
 #else
 #define AIR_EXISTS(x) (AIR_CAST(int, !((x) - (x))))
diff --color -ruN teem-1.11.0-src.orig/src/air/array.c teem-1.11.0-src/src/air/array.c
--- teem-1.11.0-src.orig/src/air/array.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/array.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -66,7 +66,7 @@
 airArrayNew(void **dataP, unsigned int *lenP, size_t unit, unsigned int incr) {
   airArray *a;
 
-  if (unit<=0 || incr<=0) {
+  if (!unit || !incr) {
     return NULL;
   }
 
diff --color -ruN teem-1.11.0-src.orig/src/air/CMakeLists.txt teem-1.11.0-src/src/air/CMakeLists.txt
--- teem-1.11.0-src.orig/src/air/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/air/CMakeLists.txt	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,24 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(AIR_SOURCES
+  754.c
+  air.h
+  array.c
+  dio.c
+  endianAir.c
+  enum.c
+  heap.c
+  math.c
+  miscAir.c
+  mop.c
+  parseAir.c
+  privateAir.h
+  randMT.c
+  sane.c
+  string.c
+  threadAir.c
+  )
+
+target_sources(teem PRIVATE ${AIR_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( air FILES ${AIR_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/air/dio.c teem-1.11.0-src/src/air/dio.c
--- teem-1.11.0-src.orig/src/air/dio.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/dio.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/endianAir.c teem-1.11.0-src/src/air/endianAir.c
--- teem-1.11.0-src.orig/src/air/endianAir.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/endianAir.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/enum.c teem-1.11.0-src/src/air/enum.c
--- teem-1.11.0-src.orig/src/air/enum.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/enum.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -241,7 +241,7 @@
   if (enm->val) {
     fprintf(file, "Values (%u valid) given explicitly\n", enm->M);
     fprintf(file, "--- (0) %d: \"%s\"\n", enm->val[0], enm->str[0]);
-    for (ii=1; ii<=AIR_CAST(int, enm->M); ii++) {
+    for (ii=1; ii<=AIR_INT(enm->M); ii++) {
       fprintf(file, "--- (%d) %d: \"%s\" == \"%s\"\n", ii,
               enm->val[ii], enm->str[ii],
               airEnumStr(enm, enm->val[ii]));
@@ -251,7 +251,7 @@
     /* enm->val NULL */
     fprintf(file, "Values implicit; [1,%u] valid\n", enm->M);
     fprintf(file, "--- 0: \"%s\"\n", enm->str[0]);
-    for (ii=1; ii<=AIR_CAST(int, enm->M); ii++) {
+    for (ii=1; ii<=AIR_INT(enm->M); ii++) {
       fprintf(file, "--- %d: %s == %s\n", ii, enm->str[ii],
               airEnumStr(enm, ii));
       _enumPrintVal(file, enm, ii);
@@ -321,6 +321,12 @@
     /* make sure there are no duplicates among the strings,
        including remapping the case in case of case insensitivity */
     for (jj=ii+1; jj<=enm->M; jj++) {
+      if (!enm->str[jj]) {
+        if (err) {
+          snprintf(err, ASL, "%s(%s): enm->str[%u] NULL", me, enm->name, jj);
+        }
+        return 1;
+      }
       if (!strcmp(enm->str[ii], enm->str[jj])) {
         if (err) {
           snprintf(err, ASL, "%s(%s): str[%d] and [%u] both \"%s\"",
@@ -426,7 +432,7 @@
     /* make sure eqv strings contain the canonical string */
     for (ii=1; ii<=enm->M; ii++) {
       int eval, rval;
-      eval = (enm->val ? enm->val[ii] : AIR_CAST(int, ii));
+      eval = (enm->val ? enm->val[ii] : AIR_INT(ii));
       rval = airEnumVal(enm, enm->str[ii]);
       if (eval != rval) {
         if (err) {
diff --color -ruN teem-1.11.0-src.orig/src/air/GNUmakefile teem-1.11.0-src/src/air/GNUmakefile
--- teem-1.11.0-src.orig/src/air/GNUmakefile	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/GNUmakefile	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -52,7 +52,7 @@
 $(L).OBJS = 754.o randMT.o array.o miscAir.o parseAir.o math.o \
 	endianAir.o dio.o mop.o enum.o sane.o string.o threadAir.o heap.o
 $(L).TESTS = test/floatprint test/doubleprint test/tok \
-	test/tmop test/tline test/fp test/trand test/tdio \
+	test/tmop test/tline test/fp test/trand test/tmisc test/tdio \
         test/bessy test/tarr test/texp test/logrice test/tprint
 
 $(L).NEED_QNANHIBIT = true
diff --color -ruN teem-1.11.0-src.orig/src/air/math.c teem-1.11.0-src/src/air/math.c
--- teem-1.11.0-src.orig/src/air/math.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/math.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -57,7 +57,7 @@
   /* HEY: COPY AND PASTE from airMyEndian */
   tmpI = 1;
   EXPI = *(AIR_CAST(char*, &tmpI));
-  eco.nn[EXPI] = AIR_CAST(int, (EXPA*(val)) + (1072693248 - EXPC));
+  eco.nn[EXPI] = AIR_INT((EXPA*(val)) + (1072693248 - EXPC));
   eco.nn[1-EXPI] = 0;
   ret = (eco.dd > 0.0
          ? eco.dd
@@ -674,7 +674,7 @@
   tax = 2.0/AIR_ABS(xx);
   bip = bb = 0.0;
   bi = 1.0;
-  top = 2*(an + AIR_CAST(int, sqrt(40.0*an)));
+  top = 2*(an + AIR_INT(sqrt(40.0*an)));
   for (ii=top; ii > 0; ii--) {
     bim = bip + ii*tax*bi;
     bip = bi;
@@ -701,7 +701,7 @@
 */
 double
 airBesselInExpScaled(int nn, double xx) {
-  double tax, bb, bi, bim, bip;
+  double tax, bb, bi, bim, bip, eps;
   int top, ii, an;
 
   an = AIR_ABS(nn);
@@ -723,15 +723,16 @@
      problem was detected because of glitches in the highest blurring
      levels for scale-space feature detection; but that didn't quite
      work either; this will have to be debugged further! */
-  top = 2*(an + AIR_CAST(int, sqrt(40.0*an)));
+  top = 2*(an + AIR_INT(sqrt(40.0*an)));
+  eps = 1.0e-10;
   for (ii=top; ii > 0; ii--) {
     bim = bip + ii*tax*bi;
     bip = bi;
     bi = bim;
-    if (AIR_ABS(bi) > 1.0e10) {
-      bb *= 1.0e-10;
-      bi *= 1.0e-10;
-      bip*= 1.0e-10;
+    if (AIR_ABS(bi) > 1.0/eps) {
+      bb *= eps;
+      bi *= eps;
+      bip*= eps;
     }
     if (ii == an) {
       bb = bip;
@@ -741,6 +742,122 @@
   return (xx < 0.0 ? -bb : bb);
 }
 
+/*
+** based on: T. Lindeberg. "Effective Scale: A Natural Unit For
+** Measuring Scale-Space Lifetime" IEEE PAMI, 15:1068-1074 (1993)
+**
+** which includes tau(tee) as equation (29),
+** here taking A'' == 0 and B'' == 1, with
+** a0 and a1 as defined by eqs (22) and (23)
+**
+** Used MiniMaxApproximation[] from Mathematica (see
+** ~gk/papers/ssp/nb/effective-scale-TauOfTee.nb) to get functions,
+** but the specific functions and their domains could certainly be
+** improved upon.  Also, the absence of conversions directly between
+** tau and sigma is quite unfortunate: going through tee loses
+** precision and takes more time.
+**
+** ACCURATE: can set this to 0 or 1:
+** 0: use a quick-and-dirty approximation to tau(tee), which
+** uses a straight line segment for small scales, and then
+** has a C^1-continuous transition to the large-scale approximation eq (33)
+** 1: careful approximation based on the MiniMaxApproximation[]s
+*/
+#define ACCURATE 1
+double
+airTauOfTime(double tee) {
+  double tau;
+
+  if (tee < 0) {
+    tau = 0;
+#if ACCURATE
+  } else if (tee < 1.49807) {
+    /* mmtau0tweaked */
+    tau = (tee*(0.2756644487429131 + tee*(0.10594329088466668 + tee*(0.05514331911165778 + (0.021449249669475232 + 0.004417835440932558*tee)*tee))))/
+      (1.0 + tee*(-0.08684532328108877 + tee*(0.1792830876099199 + tee*(0.07468999631784223 + (0.012123550696192354 + 0.0021535864222409365*tee)*tee))));
+  } else if (tee < 4.96757) {
+    /* mmtau1 */
+    tau = (0.0076145275813930356 + tee*(0.24811886965997867 + tee*(0.048329025380584194 +
+                                                                   tee*(0.04227260554167517 + (0.0084221516844712 + 0.0092075782656669*tee)*tee))))/
+      (1.0 + tee*(-0.43596678272093764 + tee*(0.38077975530585234 + tee*(-0.049133766853683175 + (0.030319379462443567 + 0.0034126333151669654*tee)*tee))));
+  } else if (tee < 15.4583) {
+    /* mmtau2 */
+    tau = (-0.2897145176074084 + tee*(1.3527948686285203 + tee*(-0.47099157589904095 +
+           tee*(-0.16031981786376195 + (-0.004820970155881798 - 4.149777202275125e-6*tee)*tee))))/
+      (1.0 + tee*(0.3662508612514773 + tee*(-0.5357849572367938 + (-0.0805122462310566 - 0.0015558889784971902*tee)*tee)));
+  } else if (tee < 420.787) {
+    /* mmtau3 */
+    tau = (-4.2037874383990445e9 + tee*(2.838805157541766e9 + tee*(4.032410315406513e8 + tee*(5.392017876788518e6 + tee*(9135.49750298428 + tee)))))/
+      (tee*(2.326563899563907e9 + tee*(1.6920560224321905e8 + tee*(1.613645012626063e6 + (2049.748257887103 + 0.1617034516398788*tee)*tee))));
+#else /* quick and dirty approximation */
+  } else if (tee < 1.3741310015234351) {
+    tau = 0.600069568241882*tee/1.3741310015234351;
+#endif
+  } else {
+    /* lindtau = eq (33) in paper */
+    tau = 0.53653222368715360118 + log(tee)/2.0 + log(1.0 - 1.0/(8.0*tee));
+  }
+  return tau;
+}
+
+double
+airTimeOfTau(double tau) {
+  double tee;
+
+  /* the number of branches here is not good; needs re-working */
+  if (tau < 0) {
+    tee = 0;
+#if ACCURATE
+  } else
+    if (tau < 0.611262) {
+    /* mmtee0tweaked */
+    tee = (tau*(3.6275987317285265 + tau*(11.774700160760132 + tau*(4.52406587856803 + tau*(-14.125688866786549 + tau*(-0.725387283317479 + 3.5113122862478865*tau))))))/
+      (1.0 + tau*(4.955066250765395 + tau*(4.6850073321973404 + tau*(-6.407987550661679 + tau*(-6.398430668865182 + 5.213709282093169*tau)))));
+  } else if (tau < 1.31281) {
+    /* mmtee1 */
+    tee = (1.9887378739371435e49 + tau*(-2.681749984485673e50 + tau*(-4.23360463718195e50 + tau*(2.09694591123974e51 + tau*(-2.7561518523389087e51 + (1.661629137055526e51 - 4.471073383223687e50*tau)*tau)))))/
+      (1.0 + tau*(-5.920734745050949e50 + tau*(1.580953446553531e51 + tau*(-1.799463907469813e51 + tau*(1.0766702953985062e51 + tau*(-3.57278667155516e50 + 5.008335824520649e49*tau))))));
+  } else if (tau < 1.64767) {
+    /* mmtee2 */
+    tee = (7.929177830383403 + tau*(-26.12773195115971 + tau*(40.13296225515305 + tau*(-25.041659428733585 + 11.357596970027744*tau))))/
+      (1.0 + tau*(-2.3694595653302377 + tau*(7.324354882915464 + (-3.5335141717471314 + 0.4916661013041915*tau)*tau)));
+  } else if (tau < 1.88714) {
+    /* mmtee3 */
+    tee = (0.8334252264680793 + tau*(-0.2388940380698891 + (0.6057616935583752 - 0.01610044688317929*tau)*tau))/(1.0 + tau*(-0.7723301124908083 + (0.21283962841683607 - 0.020834957466407206*tau)*tau));
+  } else if (tau < 2.23845) {
+    /* mmtee4 */
+    tee = (0.6376900379835665 + tau*(0.3177131886056259 + (0.1844114646774132 + 0.2001613331260136*tau)*tau))/(1.0 + tau*(-0.6685635461372561 + (0.15860524381878136 - 0.013304300252332686*tau)*tau));
+  } else if (tau < 2.6065) {
+    /* mmtee5 */
+    tee = (1.3420027677612982 + (-0.939215712453483 + 0.9586140009249253*tau)*tau)/(1.0 + tau*(-0.6923014141351673 + (0.16834190074776287 - 0.014312833444962668*tau)*tau));
+  } else if (tau < 3.14419) {
+    /* mmtee6 */
+    tee = (tau*(190.2181493338235 + tau*(-120.16652155353106 + 60.*tau)))/(76.13355144582292 + tau*(-42.019121363472614 + (8.023304636521623 - 0.5281725039404653*tau)*tau));
+#else /* quick and dirty approximation */
+  } else if (tau < 0.600069568241882) {
+    tee = 1.3741310015234351*tau/0.600069568241882;
+#endif
+  } else {
+    /* lindtee = lindtau^{-1} */
+    double ee;
+    ee = exp(2.0*tau);
+    tee = 0.0063325739776461107152*(27.0*ee + 2*AIR_PI*AIR_PI + 3.0*sqrt(81.0*ee*ee + 12*ee*AIR_PI*AIR_PI));
+  }
+  return tee;
+}
+
+double
+airSigmaOfTau(double tau) {
+
+  return sqrt(airTimeOfTau(tau));
+}
+
+double
+airTauOfSigma(double sig) {
+
+  return airTauOfTime(sig*sig);
+}
+
 /*  http://en.wikipedia.org/wiki/Halton_sequences */
 double
 airVanDerCorput(unsigned int indx, unsigned int base) {
diff --color -ruN teem-1.11.0-src.orig/src/air/miscAir.c teem-1.11.0-src/src/air/miscAir.c
--- teem-1.11.0-src.orig/src/air/miscAir.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/miscAir.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -34,6 +34,7 @@
 
 /*
 ******** airTeemVersion
+******** airTeemReleaseDone
 ******** airTeemReleaseDate
 **
 ** updated with each release to contain a string representation of
@@ -42,8 +43,25 @@
 */
 const char *
 airTeemVersion = TEEM_VERSION_STRING;
+const int
+airTeemReleaseDone = AIR_FALSE;
 const char *
-airTeemReleaseDate = "19 Dec 2012";
+airTeemReleaseDate = "maybe 2019 or 2020";
+
+/*
+******** airTeemVersionSprint
+**
+** uniform way of printing information about the Teem version
+*/
+void
+airTeemVersionSprint(char buff[AIR_STRLEN_LARGE]) {
+  sprintf(buff, "Teem version %s, %s%s%s",
+          airTeemVersion,
+          airTeemReleaseDone ? "released on " : "",
+          airTeemReleaseDate,
+          airTeemReleaseDone ? "" : " (not yet released)");
+  return;
+}
 
 double
 _airSanityHelper(double val) {
@@ -116,7 +134,6 @@
   return ret;
 }
 
-
 /*
 ******** airFclose()
 **
@@ -380,6 +397,18 @@
   return stdin;
 }
 
+unsigned int
+airBitsSet(unsigned int vv) {
+  /* http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan */
+  unsigned int cc;
+  for (cc=0; vv; cc++) {
+    /* wherever lowest bit is on in vv; vv-1 will have it off, and leave
+       unchanged all the higher bits */
+    vv &= vv - 1;
+  }
+  return cc;
+}
+
 /*
 ******** AIR_INDEX(i,x,I,L,t)
 **
@@ -434,7 +463,27 @@
 /*
 ******* airIndex
 **
-** replaces AIR_INDEX macro; see above
+** Given a value range [min,max], a single input value val inside the range,
+** and a number of intervals N spanning and evenly dividing that range,
+** airIndex returns the index of the interval containing val:
+**
+**  input value range: min                     max
+**   val somewhere in:  |-----|-----|-----|-----|
+**        N intervals:  [    )[    )[    )[     ]  (for N=4)
+**       output index:     0     1     2     3
+**
+** This can be used (as in nrrdHisto and other histogramming functions) to
+** represent the range [min,max] with N samples between 0 and N-1.  Those
+** samples are cell-centered, because "0" is logically located (in the
+** continuous input range) in the *middle* of the first of the N intervals.
+** In contrast, the *endpoints* of the N intervals (the 5 "|" in the picture
+** above) form N+1 *node*-centered samples from min to max.
+**
+** If max < min, then "min" and "max" would be swapped in the diagram
+** above and their roles are switched. This overdue fix was only added
+** in version 1.11.
+**
+** NOTE: This does not do bounds checking; for that use airIndexClamp
 */
 unsigned int
 airIndex(double min, double val, double max, unsigned int N) {
@@ -442,9 +491,13 @@
   double mnm;
 
   mnm = max - min;
-  if (mnm) {
+  if (mnm > 0) {
     idx = AIR_UINT(N*(val - min)/mnm);
     idx -= (idx == N);
+  } else if (mnm < 0) {
+    idx = AIR_UINT(N*(val - max)/(-mnm));
+    idx -= (idx == N);
+    idx = N-1-idx;
   } else {
     idx = 0;
   }
@@ -456,14 +509,16 @@
   unsigned int idx;
   double mnm;
 
-  /* NOTE: now that unsigned types are used more widely in Teem, the
-     clamping that used to happen after index generation now must
-     happen prior to index generation */
   mnm = max - min;
-  if (mnm) {
+  if (mnm > 0) {
     val = AIR_MAX(min, val);
     idx = AIR_UINT(N*(val - min)/mnm);
     idx = AIR_MIN(idx, N-1);
+  } else if (mnm < 0) {
+    val = AIR_MAX(max, val);
+    idx = AIR_UINT(N*(val - max)/(-mnm));
+    idx = AIR_MIN(idx, N-1);
+    idx = N-1-idx;
   } else {
     idx = 0;
   }
@@ -473,6 +528,12 @@
 airULLong
 airIndexULL(double min, double val, double max, airULLong N) {
   airULLong idx;
+  if (min == max) {
+    return 0;
+  }
+  if (min > max) {
+    return N-1-airIndexULL(max, val, min, N);
+  }
 #if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__MINGW32__)
   /* compile error on Win32-vs60: "error C2520: conversion from
      unsigned __int64 to double not implemented, use signed __int64 */
@@ -489,6 +550,12 @@
 airULLong
 airIndexClampULL(double min, double val, double max, airULLong N) {
   airULLong idx;
+  if (min == max) {
+    return 0;
+  }
+  if (min > max) {
+    return N-1-airIndexULL(max, val, min, N);
+  }
 #if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__MINGW32__)
   airLLong sidx;
   val = AIR_MAX(min, val); /* see note in airIndexClamp */
@@ -686,7 +753,8 @@
 /*
 ******** airEqvAdd
 **
-** adds another equivalence class
+** adds another equivalence (which may or may not amount to adding
+** a new class; that will be determined later)
 */
 void
 airEqvAdd(airArray *eqvArr, unsigned int j, unsigned int k) {
diff --color -ruN teem-1.11.0-src.orig/src/air/mop.c teem-1.11.0-src/src/air/mop.c
--- teem-1.11.0-src.orig/src/air/mop.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/mop.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/parseAir.c teem-1.11.0-src/src/air/parseAir.c
--- teem-1.11.0-src.orig/src/air/parseAir.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/parseAir.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -97,6 +97,9 @@
       val = AIR_NAN;
     }
 /* ---- BEGIN non-NrrdIO */
+    else if (strstr(tmp, "-pi")) {
+      val = -AIR_PI;
+    }
     else if (strstr(tmp, "pi")) {
       val = AIR_PI;
     }
@@ -109,7 +112,9 @@
     }
     else {
       /* nothing special matched; pass it off to sscanf() */
+      /* (save setlocale here) */
       ret = sscanf(str, fmt, ptr);
+      /* (return setlocale here) */
       free(tmp);
       return ret;
     }
@@ -120,7 +125,7 @@
     }
     else {
       /* we were given a float pointer */
-      *((float *)(ptr)) = AIR_CAST(float, val);
+      *((float *)(ptr)) = AIR_FLOAT(val);
     }
     free(tmp);
     return 1;
@@ -130,7 +135,7 @@
     const char *chh = str; /* char here */
     while (chh) {
       int dig;
-      dig = AIR_CAST(int, *chh - '0');
+      dig = AIR_INT(*chh - '0');
       if (AIR_IN_CL(0, dig, 9)) {
         tsz = 10*tsz + AIR_CAST(size_t, dig);
       } else {
diff --color -ruN teem-1.11.0-src.orig/src/air/privateAir.h teem-1.11.0-src/src/air/privateAir.h
--- teem-1.11.0-src.orig/src/air/privateAir.h	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/privateAir.h	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/randMT.c teem-1.11.0-src/src/air/randMT.c
--- teem-1.11.0-src.orig/src/air/randMT.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/randMT.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/sane.c teem-1.11.0-src/src/air/sane.c
--- teem-1.11.0-src.orig/src/air/sane.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/sane.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -64,7 +64,7 @@
 
   /* checks on sizes of uchar, float, int, double, airLLong */
   uc0 = 255;
-  uc1 = AIR_CAST(unsigned char, AIR_INT(uc0) + 1); /* want to overflow */
+  uc1 = AIR_UCHAR(AIR_INT(uc0) + 1); /* want to overflow */
   if (!( 255 == uc0 && 0 == uc1 )) {
     return airInsane_UCSize;
   }
@@ -77,16 +77,34 @@
   }
 
   /* run-time NaN checks */
-  pinf = DBL_MAX;
+  ninf = -DBL_MAX;
+  ninf = _airSanityHelper(ninf);
+  ninf = _airSanityHelper(ninf);
+  ninf = _airSanityHelper(ninf);
+  if (AIR_EXISTS(ninf)) {
+    return airInsane_nInfExists;
+  }
+  pinf = 1e+308; /* almost DBL_MAX */
   pinf = _airSanityHelper(pinf);
   pinf = _airSanityHelper(pinf);
   pinf = _airSanityHelper(pinf);
   if (AIR_EXISTS(pinf)) {
-    return airInsane_pInfExists;
-  }
-  ninf = -pinf;
-  if (AIR_EXISTS(ninf)) {
-    return airInsane_nInfExists;
+    /* on at least one computer GLK used, if fesetround(FE_DOWNWARD) has been
+       called, then the above run-time generation of positive infinity fails;
+       it instead rounds down to DBL_MAX. We err on the side of
+       permissiveness, and opt not to try to detect the current rounding mode
+       (because doing so in a C89-compliant way would be a pain), and thus
+       flag AIR_EXISTS(pinf) as a problem only if pinf != DBL_MAX. On that
+       one computer, fesetround(FE_UPWARD) did not hamper the above run-time
+       negative infinity generation */
+    if (pinf != DBL_MAX) {
+      return airInsane_pInfExists;
+    } else {
+      /* as best we can tell, pinf would have been +inf if it
+         weren't for fesetround(FE_DOWNWARD), so fix pinf so that
+         later tests can use it. */
+      pinf = -ninf;
+    }
   }
   nanValue = pinf / pinf;
   if (AIR_EXISTS(nanValue)) {
diff --color -ruN teem-1.11.0-src.orig/src/air/sources.cmake teem-1.11.0-src/src/air/sources.cmake
--- teem-1.11.0-src.orig/src/air/sources.cmake	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(AIR_SOURCES
-  754.c
-  air.h
-  array.c
-  dio.c
-  endianAir.c
-  enum.c
-  heap.c
-  math.c
-  miscAir.c
-  mop.c
-  parseAir.c
-  privateAir.h
-  randMT.c
-  sane.c
-  string.c
-  threadAir.c
-  )
-
-ADD_TEEM_LIBRARY(air ${AIR_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/air/string.c teem-1.11.0-src/src/air/string.c
--- teem-1.11.0-src.orig/src/air/string.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/string.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -71,17 +71,24 @@
 /*
 ******** airStrcmp
 **
-** just like strcmp, but safe to call with NULL strings
+** like strcmp, but:
+** safe to call with NULL strings,
+** and, a NULL string is treated same as an empty string
 */
 int
-airStrcmp(const char *s1, const char *s2) {
+airStrcmp(const char *_s1, const char *_s2) {
+  static const char empty[]="";
+  const char *s1, *s2;
   int ret;
 
-  if (!( s1 && s2 )) {
-    ret = !!s1 - !!s2;
-  } else {
-    ret = strcmp(s1, s2);
-  }
+  s1 = _s1 ? _s1 : empty;
+  s2 = _s2 ? _s2 : empty;
+  /*
+  fprintf(stderr, "airStrcmp: _s1=|%s|->s1=|%s| _s2=|%s|->s2=|%s|\n",
+          _s1 ? _s1 : "(NULL)", s1,
+          _s2 ? _s2 : "(NULL)", s2);
+  */
+  ret = strcmp(s1, s2);
   return ret;
 }
 
@@ -284,16 +291,18 @@
 
   /* convert white space to space (' '), and delete unprintables */
   for (i=0; i<len; i++) {
-    if (isspace(AIR_CAST(int, s[i]))) {
+    if (isspace(AIR_INT(s[i]))) {
       s[i] = ' ';
       continue;
     }
-    if (!isprint(AIR_CAST(int, s[i]))) {
+    if (!isprint(AIR_INT(s[i]))) {
       for (j=i; j<len; j++) {
         /* this will copy the '\0' at the end */
         s[j] = s[j+1];
       }
       i--;
+      /* string got shorter (prevent ininite loop) */
+      len--;
       continue;
     }
   }
@@ -359,7 +368,7 @@
 /*
 ******** airOneLine()
 **
-** gets one line from "file", putting it into an array if given size.
+** gets one line from "file", putting it into an array of given size.
 ** "size" must be the size of line buffer "line": the size which
 ** "line" was allocated for, not the number of non-null characters it
 ** was meant to hold.  "size" must be at least 3.  Always
diff --color -ruN teem-1.11.0-src.orig/src/air/test/bessy.c teem-1.11.0-src/src/air/test/bessy.c
--- teem-1.11.0-src.orig/src/air/test/bessy.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/bessy.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/test/doubleprint.c teem-1.11.0-src/src/air/test/doubleprint.c
--- teem-1.11.0-src.orig/src/air/test/doubleprint.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/doubleprint.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -53,7 +53,7 @@
     printf("%s: sscanf result (%f) != airSingleSscanf (%f)!!!\n", me, sd, d);
     printf("\n");
   }
-  f = d;
+  f = AIR_FLOAT(d);
   airSinglePrintf(NULL, buff, "%f", f);
   printf("%s: printf/airSinglePrintf as float:\n%f\n%s\n", me, f, buff);
   airSinglePrintf(NULL, buff, "%lf", d);
diff --color -ruN teem-1.11.0-src.orig/src/air/test/floatprint.c teem-1.11.0-src/src/air/test/floatprint.c
--- teem-1.11.0-src.orig/src/air/test/floatprint.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/floatprint.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -62,5 +62,16 @@
   printf("\n");
   printf("%s: airFPFprintf_f:\n", me);
   airFPFprintf_f(stderr, f);
+
+  {
+    double l2d = log2(AIR_ABS(d));
+    double fl2d = floor(l2d)+1;
+    double ss = l2d - fl2d;
+    double ess = pow(2,ss);
+    int ee;
+    double frx = frexp(d, &ee);
+      printf("d=%.17g -> l2d=%.17g -> fl2d=%.17g\n -> ss=%.17g -> ess=%.17g vs %0.17g|%d\n",
+             d, l2d, fl2d, ss, ess, frx, ee);
+  }
   exit(0);
 }
diff --color -ruN teem-1.11.0-src.orig/src/air/test/fp.c teem-1.11.0-src/src/air/test/fp.c
--- teem-1.11.0-src.orig/src/air/test/fp.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/fp.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -72,7 +72,7 @@
     d = f;
     /* I think solaris turns the SNAN into a QNAN */
     printf("to double and back:\n");
-    airFPFprintf_f(stdout, d);
+    airFPFprintf_f(stdout, AIR_FLOAT(d));
     printf("AIR_ISNAN_F = %d\n", AIR_ISNAN_F(f));
   }
 
@@ -105,7 +105,7 @@
   g = f*f;
   printf("g = f*f = %f\n", g);
   airFPFprintf_f(stdout, g);
-  g = sin(f);
+  g = sinf(f);
   printf("g = sin(f) = %f\n", g);
   airFPFprintf_f(stdout, g);
 
diff --color -ruN teem-1.11.0-src.orig/src/air/test/logrice.c teem-1.11.0-src/src/air/test/logrice.c
--- teem-1.11.0-src.orig/src/air/test/logrice.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/logrice.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/test/tarr.c teem-1.11.0-src/src/air/test/tarr.c
--- teem-1.11.0-src.orig/src/air/test/tarr.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/tarr.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -107,7 +107,7 @@
       airMopError(mop); return 1;
     }
     /* now "data" is the address of a sufficiently large array */
-    data[numRed++] = datum;
+    data[numRed++] = AIR_UCHAR(datum);
     datum = fgetc(file);
   }
   /* loop finishes when there's nothing more to read from file */
diff --color -ruN teem-1.11.0-src.orig/src/air/test/tdio.c teem-1.11.0-src/src/air/test/tdio.c
--- teem-1.11.0-src.orig/src/air/test/tdio.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/tdio.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/test/texp.c teem-1.11.0-src/src/air/test/texp.c
--- teem-1.11.0-src.orig/src/air/test/texp.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/texp.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/test/tline.c teem-1.11.0-src/src/air/test/tline.c
--- teem-1.11.0-src.orig/src/air/test/tline.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/tline.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/test/tmisc.c teem-1.11.0-src/src/air/test/tmisc.c
--- teem-1.11.0-src.orig/src/air/test/tmisc.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/air/test/tmisc.c	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,55 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+
+#include "../air.h"
+
+int
+main(int argc, char *argv[]) {
+  char *me, *ns;
+  unsigned int cc, nn;
+
+  char str[]="this is a line";
+  char *dup = airStrdup(str);
+  str[5] = (char)130;
+  printf("str\n|%s| == |%s|\n", str, dup);
+  airOneLinify(dup);
+  printf("|%s|\n", dup);
+
+  me = argv[0];
+  if (2 != argc) {
+    /*                       0  1   (2) */
+    fprintf(stderr, "usage: %s <n>\n", me);
+    exit(1);
+  }
+  ns = argv[1];
+  if (1 != sscanf(ns, "%u", &nn)) {
+    fprintf(stderr, "%s: couldn't parse %s as uint N\n", me, ns);
+    exit(1);
+  }
+
+  cc = airBitsSet(nn);
+  printf("%u bits set in %u\n", cc, nn);
+
+  exit(0);
+}
diff --color -ruN teem-1.11.0-src.orig/src/air/test/tmop.c teem-1.11.0-src/src/air/test/tmop.c
--- teem-1.11.0-src.orig/src/air/test/tmop.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/tmop.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -47,7 +47,7 @@
   mop = airMopNew();
   str = airStrdup("this is just a test");
   printf("%s: str = \"%s\", str = 0x%p, &str = 0x%p\n", me,
-         str, str, AIR_CAST(void*, &str));
+         str, AIR_VOIDP(str), AIR_VOIDP(&str));
   airMopMem(mop, &str, airMopAlways);
   airMopDebug(mop);
   airMopOkay(mop);
diff --color -ruN teem-1.11.0-src.orig/src/air/test/tok.c teem-1.11.0-src/src/air/test/tok.c
--- teem-1.11.0-src.orig/src/air/test/tok.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/tok.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/test/tprint.c teem-1.11.0-src/src/air/test/tprint.c
--- teem-1.11.0-src.orig/src/air/test/tprint.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/tprint.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/test/trand.c teem-1.11.0-src/src/air/test/trand.c
--- teem-1.11.0-src.orig/src/air/test/trand.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/air/test/trand.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/threadAir.c teem-1.11.0-src/src/air/threadAir.c
--- teem-1.11.0-src.orig/src/air/threadAir.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/threadAir.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/air/TODO.txt teem-1.11.0-src/src/air/TODO.txt
--- teem-1.11.0-src.orig/src/air/TODO.txt	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/air/TODO.txt	2021-02-18 15:42:32.000000000 +0800
@@ -1,29 +1,3 @@
-
-Things that would be good for a future airString or airBuffer
- * string dynamically reallocated on write, with optional cap on
-   allowed size, maybe allowing control of whether reaching that size
-   is an error
- * when reading from a file, allow the file to be gzip'd, so that
-   all the subsequent IO can be blind to whether the file was
-   compressed or not
- * unify sprint'ing into string, or fwrite'ing to file
- * unify reading from string, or from file
- * when writing to string, should be remembering where last output is,
-   to avoid needless repeated calls to strlen
- * should this be the thing that can make stdin fseek-able?
- * could use one of these as wrapper around stderr for normal output of
-   unrrduCmds, but allowing it to be saved to string in case the command
-   is being invoked from C
- * remember comment from nrrd/formatPNG.c:
-      /* Reading PNGs teaches Gordon that his scheme for parsing nrrd header
-         information is inappropriately specific to reading PNMs and NRRDs,
-         since in this case the text from which we parse a nrrd field
-         descriptor did NOT come from a line of text as read by
-         _nrrdOneLine */
-      nio->line = (char *)airFree(nio->line);
-      nio->line = airStrdup(txt[i].text);
-
-
 An OS-general means of:
 * generating a unique temp file name
 * removing a given file (for cleaning up temp file)
diff --color -ruN teem-1.11.0-src.orig/src/alan/alan.h teem-1.11.0-src/src/alan/alan.h
--- teem-1.11.0-src.orig/src/alan/alan.h	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/alan/alan.h	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/alan/CMakeLists.txt teem-1.11.0-src/src/alan/CMakeLists.txt
--- teem-1.11.0-src.orig/src/alan/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/alan/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -0,0 +1,12 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(ALAN_SOURCES
+  alan.h
+  coreAlan.c
+  enumsAlan.c
+  methodsAlan.c
+  )
+
+target_sources(teem PRIVATE ${ALAN_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( alan FILES ${ALAN_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/alan/coreAlan.c teem-1.11.0-src/src/alan/coreAlan.c
--- teem-1.11.0-src.orig/src/alan/coreAlan.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/alan/coreAlan.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/alan/enumsAlan.c teem-1.11.0-src/src/alan/enumsAlan.c
--- teem-1.11.0-src.orig/src/alan/enumsAlan.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/alan/enumsAlan.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/alan/GNUmakefile teem-1.11.0-src/src/alan/GNUmakefile
--- teem-1.11.0-src.orig/src/alan/GNUmakefile	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/alan/GNUmakefile	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/alan/methodsAlan.c teem-1.11.0-src/src/alan/methodsAlan.c
--- teem-1.11.0-src.orig/src/alan/methodsAlan.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/alan/methodsAlan.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/alan/sources.cmake teem-1.11.0-src/src/alan/sources.cmake
--- teem-1.11.0-src.orig/src/alan/sources.cmake	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/alan/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,10 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(ALAN_SOURCES
-  alan.h
-  coreAlan.c
-  enumsAlan.c
-  methodsAlan.c
-  )
-
-ADD_TEEM_LIBRARY(alan ${ALAN_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/alan/test/tspot.c teem-1.11.0-src/src/alan/test/tspot.c
--- teem-1.11.0-src.orig/src/alan/test/tspot.c	2012-12-20 22:08:20.000000000 +0800
+++ teem-1.11.0-src/src/alan/test/tspot.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/bane.h teem-1.11.0-src/src/bane/bane.h
--- teem-1.11.0-src.orig/src/bane/bane.h	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/bane.h	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/clip.c teem-1.11.0-src/src/bane/clip.c
--- teem-1.11.0-src.orig/src/bane/clip.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/clip.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/CMakeLists.txt teem-1.11.0-src/src/bane/CMakeLists.txt
--- teem-1.11.0-src.orig/src/bane/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/bane/CMakeLists.txt	2021-02-18 15:42:34.000000000 +0800
@@ -0,0 +1,29 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(BANE_SOURCES
+  bane.h
+  clip.c
+  defaultsBane.c
+  gkmsFlotsam.c
+  gkmsHvol.c
+  gkmsInfo.c
+  gkmsMite.c
+  gkmsOpac.c
+  gkmsPvg.c
+  gkmsScat.c
+  gkmsTxf.c
+  hvol.c
+  inc.c
+  measr.c
+  methodsBane.c
+  privateBane.h
+  rangeBane.c
+  scat.c
+  trex.c
+  trnsf.c
+  valid.c
+  )
+
+target_sources(teem PRIVATE ${BANE_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( bane FILES ${BANE_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/bane/defaultsBane.c teem-1.11.0-src/src/bane/defaultsBane.c
--- teem-1.11.0-src.orig/src/bane/defaultsBane.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/defaultsBane.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/gkmsFlotsam.c teem-1.11.0-src/src/bane/gkmsFlotsam.c
--- teem-1.11.0-src.orig/src/bane/gkmsFlotsam.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/gkmsFlotsam.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -35,7 +35,8 @@
 ** inc[1], inc[2] ... : incParm[0], incParm[1] ...
 */
 int
-baneGkmsParseIncStrategy(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+baneGkmsParseIncStrategy(void *ptr, const char *str,
+                         char err[AIR_STRLEN_HUGE]) {
   char me[]="baneGkmsParseIncStrategy";
   double *inc, *incParm;
   int i, bins;
@@ -96,7 +97,7 @@
 /* ----------------------------------------------------------- */
 
 int
-baneGkmsParseBEF(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+baneGkmsParseBEF(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   char me[]="baneGkmsParseBEF", mesg[AIR_STRLEN_MED], *nerr;
   float cent, width, shape, alpha, off, *bef;
   Nrrd **nrrdP;
@@ -119,7 +120,7 @@
       return 1;
     }
     bef = (float *)((*nrrdP)->data);
-    off = AIR_CAST(float, AIR_AFFINE(0.0, shape, 1.0, 0.0, width/2));
+    off = AIR_FLOAT(AIR_AFFINE(0.0, shape, 1.0, 0.0, width/2));
     /* positions */
     bef[0 + 2*0] = cent - 2*width;
     bef[0 + 2*1] = cent - width/2 - off;
@@ -176,7 +177,7 @@
 ** gthr[1] = the scaling, or the absolute
 */
 int
-baneGkmsParseGthresh(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+baneGkmsParseGthresh(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   char me[]="baneGkmsParseGthresh";
   float *gthr;
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/gkmsHvol.c teem-1.11.0-src/src/bane/gkmsHvol.c
--- teem-1.11.0-src.orig/src/bane/gkmsHvol.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/gkmsHvol.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/gkmsInfo.c teem-1.11.0-src/src/bane/gkmsInfo.c
--- teem-1.11.0-src.orig/src/bane/gkmsInfo.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/gkmsInfo.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/gkmsMite.c teem-1.11.0-src/src/bane/gkmsMite.c
--- teem-1.11.0-src.orig/src/bane/gkmsMite.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/gkmsMite.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/gkmsOpac.c teem-1.11.0-src/src/bane/gkmsOpac.c
--- teem-1.11.0-src.orig/src/bane/gkmsOpac.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/gkmsOpac.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -111,7 +111,7 @@
     gthresh = gthrInfo[1];
   } else {
     if (2 == idim) {
-      gthresh = AIR_CAST(float, gthrInfo[1]*ninfo->axis[2].max);
+      gthresh = AIR_FLOAT(gthrInfo[1]*ninfo->axis[2].max);
     }
     else {
       if (nrrdProject(nmax, ninfo, 1, nrrdMeasureMax, nrrdTypeDefault)) {
diff --color -ruN teem-1.11.0-src.orig/src/bane/gkmsPvg.c teem-1.11.0-src/src/bane/gkmsPvg.c
--- teem-1.11.0-src.orig/src/bane/gkmsPvg.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/gkmsPvg.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -138,8 +138,8 @@
     biffAddf(BANE, "%s: trouble calculating position", me);
     airMopError(mop); return 1;
   }
-  sv = nposA->axis[0].size;
-  sg = nposA->axis[1].size;
+  sv = AIR_INT(nposA->axis[0].size); /* HEY should be unsigned */
+  sg = AIR_INT(nposA->axis[1].size); /* HEY should be unsigned */
   pos = (float *)nposA->data;
 
   /* find min, max, sml, smlI: histo-eq will warp values around such
@@ -191,9 +191,9 @@
       continue;
     }
     if (pos[i] < newsml) {
-      pos[i] = AIR_CAST(float, AIR_AFFINE(min, pos[i], newsml, newmin, 0.0));
+      pos[i] = AIR_FLOAT(AIR_AFFINE(min, pos[i], newsml, newmin, 0.0));
     } else {
-      pos[i] = AIR_CAST(float, AIR_AFFINE(newsml, pos[i], max, 0.0, newmax));
+      pos[i] = AIR_FLOAT(AIR_AFFINE(newsml, pos[i], max, 0.0, newmax));
     }
   }
   range = nrrdRangeNew(newmin, newmax);
diff --color -ruN teem-1.11.0-src.orig/src/bane/gkmsScat.c teem-1.11.0-src/src/bane/gkmsScat.c
--- teem-1.11.0-src.orig/src/bane/gkmsScat.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/gkmsScat.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -40,9 +40,9 @@
   NrrdRange *vgRange, *vhRange;
   airArray *mop;
   int pret, E;
-  double gamma;
+  double _gamma;
 
-  hestOptAdd(&opt, "g", "gamma", airTypeDouble, 1, 1, &gamma, "1.0",
+  hestOptAdd(&opt, "g", "gamma", airTypeDouble, 1, 1, &_gamma, "1.0",
              "gamma used to brighten/darken scatterplots. "
              "gamma > 1.0 brightens; gamma < 1.0 darkens. "
              "Negative gammas invert values (like in xv). ");
@@ -77,8 +77,8 @@
   airMopAdd(mop, vgRange, (airMopper)nrrdRangeNix, airMopAlways);
   airMopAdd(mop, vhRange, (airMopper)nrrdRangeNix, airMopAlways);
   E = 0;
-  if (!E) E |= nrrdArithGamma(nvgRaw, nvgRaw, vgRange, gamma);
-  if (!E) E |= nrrdArithGamma(nvhRaw, nvhRaw, vhRange, gamma);
+  if (!E) E |= nrrdArithGamma(nvgRaw, nvgRaw, vgRange, _gamma);
+  if (!E) E |= nrrdArithGamma(nvhRaw, nvhRaw, vhRange, _gamma);
   if (!E) E |= nrrdQuantize(nvgQuant, nvgRaw, vgRange, 8);
   if (!E) E |= nrrdQuantize(nvhQuant, nvhRaw, vhRange, 8);
   if (E) {
diff --color -ruN teem-1.11.0-src.orig/src/bane/gkmsTxf.c teem-1.11.0-src/src/bane/gkmsTxf.c
--- teem-1.11.0-src.orig/src/bane/gkmsTxf.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/gkmsTxf.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -101,24 +101,24 @@
   tvr = top[0] + width/2;
   mwidth /= 2;
   for (gi=0; gi<res[1]; gi++) {
-    g = AIR_CAST(float, NRRD_CELL_POS(min[1], max[1], res[1], gi));
+    g = AIR_FLOAT(NRRD_CELL_POS(min[1], max[1], res[1], gi));
     for (vi=0; vi<res[0]; vi++) {
-      v = AIR_CAST(float, NRRD_CELL_POS(min[0], max[0], res[0], vi));
-      vl = AIR_CAST(float, AIR_AFFINE(0, g, top[1], v0-mwidth, tvl));
-      vr = AIR_CAST(float, AIR_AFFINE(0, g, top[1], v0+mwidth, tvr));
+      v = AIR_FLOAT(NRRD_CELL_POS(min[0], max[0], res[0], vi));
+      vl = AIR_FLOAT(AIR_AFFINE(0, g, top[1], v0-mwidth, tvl));
+      vr = AIR_FLOAT(AIR_AFFINE(0, g, top[1], v0+mwidth, tvr));
       if (g > top[1]) {
         data[vi + res[0]*gi] = 0;
         continue;
       }
-      tmp = AIR_CAST(float, (v - vl)/(0.00001 + vr - vl));
+      tmp = AIR_FLOAT((v - vl)/(0.00001 + vr - vl));
       tmp = 1 - AIR_ABS(2*tmp - 1);
       if (step && v > (vr + vl)/2) {
         tmp = 1;
       }
       tmp = AIR_MAX(0, tmp);
       data[vi + res[0]*gi] = tmp*maxa;
-      tmp = AIR_CAST(float, AIR_AFFINE(g0 - gwidth/2, g, g0 + gwidth/2,
-                                       0.0, 1.0));
+      tmp = AIR_FLOAT(AIR_AFFINE(g0 - gwidth/2, g, g0 + gwidth/2,
+                                 0.0, 1.0));
       tmp = AIR_CLAMP(0, tmp, 1);
       data[vi + res[0]*gi] *= tmp;
     }
diff --color -ruN teem-1.11.0-src.orig/src/bane/GNUmakefile teem-1.11.0-src/src/bane/GNUmakefile
--- teem-1.11.0-src.orig/src/bane/GNUmakefile	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/GNUmakefile	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/bane/hvol.c teem-1.11.0-src/src/bane/hvol.c
--- teem-1.11.0-src.orig/src/bane/hvol.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/hvol.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -74,9 +74,9 @@
     val[1] = baneMeasrAnswer(hvp->axis[1].measr, ctx);
     val[2] = baneMeasrAnswer(hvp->axis[2].measr, ctx);
     if (hvp->makeMeasrVol) {
-      data[0] = AIR_CAST(float, val[0]);
-      data[1] = AIR_CAST(float, val[1]);
-      data[2] = AIR_CAST(float, val[2]);
+      data[0] = AIR_FLOAT(val[0]);
+      data[1] = AIR_FLOAT(val[1]);
+      data[2] = AIR_FLOAT(val[2]);
     }
   } else {
     val[0] = data[0];
@@ -100,9 +100,9 @@
   double val[3];
 
   /* conveniance copies */
-  sx = nin->axis[0].size;
-  sy = nin->axis[1].size;
-  sz = nin->axis[2].size;
+  sx = AIR_INT(nin->axis[0].size); /* HEY should be unsigned */
+  sy = AIR_INT(nin->axis[1].size); /* HEY should be unsigned */
+  sz = AIR_INT(nin->axis[2].size); /* HEY should be unsigned */
   inc[0] = hvp->axis[0].inc;
   inc[1] = hvp->axis[1].inc;
   inc[2] = hvp->axis[2].inc;
@@ -268,7 +268,7 @@
   gageContext *ctx;
   gagePerVolume *pvl;
   int E, sx, sy, sz, shx, shy, shz, x, y, z, hx, hy, hz,
-    *rhvdata, clipVal, hval, pad;
+    *rhvdata, clipVal, pad;
   /* these are doubles because ultimately the inclusion functions
      use doubles, because I wanted the most generality */
   double val[3], min[3], max[3];
@@ -288,9 +288,9 @@
   }
 
   /* set up */
-  sx = nin->axis[0].size;
-  sy = nin->axis[1].size;
-  sz = nin->axis[2].size;
+  sx = AIR_INT(nin->axis[0].size); /* HEY should be unsigned */
+  sy = AIR_INT(nin->axis[1].size); /* HEY should be unsigned */
+  sz = AIR_INT(nin->axis[2].size); /* HEY should be unsigned */
 
   mop = airMopNew();
   ctx = gageContextNew();
@@ -448,8 +448,8 @@
       }
       for (hx=0; hx<shx; hx++) {
         hidx = hx + shx*(hy + shy*hz);
-        hval = airIndexClamp(0, rhvdata[hidx], clipVal, 256);
-        nhvdata[hidx] = hval;
+        nhvdata[hidx] = AIR_UCHAR(airIndexClamp(0, rhvdata[hidx],
+                                                clipVal, 256));
       }
     }
   }
diff --color -ruN teem-1.11.0-src.orig/src/bane/inc.c teem-1.11.0-src/src/bane/inc.c
--- teem-1.11.0-src.orig/src/bane/inc.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/inc.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -56,7 +56,7 @@
   unsigned int idx;
 
   idx = airIndex(inc->nhist->axis[0].min, val, inc->nhist->axis[0].max,
-                 inc->nhist->axis[0].size);
+                 AIR_UINT(inc->nhist->axis[0].size));
   /*
   fprintf(stderr, "## _baneInc_HistFill: (%g,%g,%g) %d ---> %d\n",
           inc->nhist->axis[0].min, val, inc->nhist->axis[0].max,
@@ -135,7 +135,7 @@
   /* integrate histogram and determine how many hits to exclude */
   sum = 0;
   hist = (int *)nhist->data;
-  histSize = nhist->axis[0].size;
+  histSize = AIR_INT(nhist->axis[0].size); /* HEY should be unsigned */
   for (i=0; i<histSize; i++) {
     sum += hist[i];
   }
@@ -147,7 +147,7 @@
   sprintf(err, "%03d-histo.nrrd", baneHack); nrrdSave(err, nhist, NULL);
   baneHack++;
   */
-  out = AIR_CAST(float, sum*incParm[1]/100.0);
+  out = AIR_FLOAT(sum*incParm[1]/100.0);
   fprintf(stderr, "##%s: hist's size=%d, sum=%d --> out = %g\n", me,
           histSize, sum, out);
   if (range->answer(&min, &max, nhist->axis[0].min, nhist->axis[0].max)) {
@@ -157,9 +157,9 @@
           me, nhist->axis[0].min, nhist->axis[0].max,
           range->name, min, max);
   if (baneRangeAnywhere == range->type) {
-    mid = AIR_CAST(float, (AIR_EXISTS(range->center)
-                           ? range->center
-                           : (min + max)/2));
+    mid = AIR_FLOAT((AIR_EXISTS(range->center)
+                     ? range->center
+                     : (min + max)/2));
   } else {
     mid = 0;
     /* yes, this is okay.  The "mid" is the value we march towards
@@ -173,23 +173,21 @@
   if (max-mid > mid-min) {
     /* the max is further from the mid than the min */
     maxIncr = 1;
-    minIncr = AIR_CAST(float, (mid-min)/(max-mid));
+    minIncr = AIR_FLOAT((mid-min)/(max-mid));
   } else {
     /* the min is further */
     minIncr = 1;
-    maxIncr = AIR_CAST(float, (max-mid)/(mid-min));
+    maxIncr = AIR_FLOAT((max-mid)/(mid-min));
   }
   if (!( AIR_EXISTS(minIncr) && AIR_EXISTS(maxIncr) )) {
     biffAddf(BANE, "%s: minIncr, maxIncr don't both exist", me);
     return 1;
   }
   fprintf(stderr, "##%s: --> {min,max}Incr = %g,%g\n", me, minIncr, maxIncr);
-  minIdx = AIR_CAST(float,
-                    AIR_AFFINE(nhist->axis[0].min, min, nhist->axis[0].max,
-                               0, histSize-1));
-  maxIdx = AIR_CAST(float,
-                    AIR_AFFINE(nhist->axis[0].min, max, nhist->axis[0].max,
-                               0, histSize-1));
+  minIdx = AIR_FLOAT(AIR_AFFINE(nhist->axis[0].min, min, nhist->axis[0].max,
+                                0, histSize-1));
+  maxIdx = AIR_FLOAT(AIR_AFFINE(nhist->axis[0].min, max, nhist->axis[0].max,
+                                0, histSize-1));
   outsofar = 0;
   while (outsofar < out) {
     if (AIR_IN_CL(0, minIdx, histSize-1)) {
@@ -226,11 +224,11 @@
   float SS, stdv, mid, mean, width;
   int count;
 
-  count = hist->axis[1].size;
-  mean = AIR_CAST(float, hist->axis[1].min/count);
-  SS = AIR_CAST(float, hist->axis[1].max/count);
-  stdv = AIR_CAST(float, sqrt(SS - mean*mean));
-  width = AIR_CAST(float, incParm[0]*stdv);
+  count = AIR_INT(hist->axis[1].size); /* HEY should be unsigned */
+  mean = AIR_FLOAT(hist->axis[1].min/count);
+  SS = AIR_FLOAT(hist->axis[1].max/count);
+  stdv = AIR_FLOAT(sqrt(SS - mean*mean));
+  width = AIR_FLOAT(incParm[0]*stdv);
   fprintf(stderr, "##%s: mean=%g, stdv=%g --> width=%g\n",
           "_baneIncAnswer_Stdv", mean, stdv, width);
   switch (range->type) {
@@ -247,7 +245,7 @@
     *maxP = width/2;
     break;
   case baneRangeAnywhere:
-    mid = AIR_CAST(float, AIR_EXISTS(range->center) ? range->center : mean);
+    mid = AIR_FLOAT(AIR_EXISTS(range->center) ? range->center : mean);
     *minP = mid - width/2;
     *maxP = mid + width/2;
     break;
diff --color -ruN teem-1.11.0-src.orig/src/bane/measr.c teem-1.11.0-src/src/bane/measr.c
--- teem-1.11.0-src.orig/src/bane/measr.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/measr.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/methodsBane.c teem-1.11.0-src/src/bane/methodsBane.c
--- teem-1.11.0-src.orig/src/bane/methodsBane.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/methodsBane.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/privateBane.h teem-1.11.0-src/src/bane/privateBane.h
--- teem-1.11.0-src.orig/src/bane/privateBane.h	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/privateBane.h	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -32,7 +32,8 @@
 extern int _baneAxisCheck(baneAxis *axis);
 
 #define BANE_GKMS_CMD(name, info) \
-unrrduCmd baneGkms_##name##Cmd = { #name, info, baneGkms_##name##Main }
+unrrduCmd baneGkms_##name##Cmd = { #name, info, \
+                                   baneGkms_##name##Main, AIR_FALSE }
 
 /* USAGE, PARSE
    all copied from unrrdu/privateUnrrdu.h */
diff --color -ruN teem-1.11.0-src.orig/src/bane/rangeBane.c teem-1.11.0-src/src/bane/rangeBane.c
--- teem-1.11.0-src.orig/src/bane/rangeBane.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/rangeBane.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/scat.c teem-1.11.0-src/src/bane/scat.c
--- teem-1.11.0-src.orig/src/bane/scat.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/scat.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/sources.cmake teem-1.11.0-src/src/bane/sources.cmake
--- teem-1.11.0-src.orig/src/bane/sources.cmake	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(BANE_SOURCES
-  bane.h
-  clip.c
-  defaultsBane.c
-  gkmsFlotsam.c
-  gkmsHvol.c
-  gkmsInfo.c
-  gkmsMite.c
-  gkmsOpac.c
-  gkmsPvg.c
-  gkmsScat.c
-  gkmsTxf.c
-  hvol.c
-  inc.c
-  measr.c
-  methodsBane.c
-  privateBane.h
-  rangeBane.c
-  scat.c
-  trex.c
-  trnsf.c
-  valid.c
-  )
-
-ADD_TEEM_LIBRARY(bane ${BANE_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/bane/test/apply.c teem-1.11.0-src/src/bane/test/apply.c
--- teem-1.11.0-src.orig/src/bane/test/apply.c	2012-12-20 22:08:03.000000000 +0800
+++ teem-1.11.0-src/src/bane/test/apply.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/test/htrnsf.c teem-1.11.0-src/src/bane/test/htrnsf.c
--- teem-1.11.0-src.orig/src/bane/test/htrnsf.c	2012-12-20 22:08:03.000000000 +0800
+++ teem-1.11.0-src/src/bane/test/htrnsf.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/test/opac.c teem-1.11.0-src/src/bane/test/opac.c
--- teem-1.11.0-src.orig/src/bane/test/opac.c	2012-12-20 22:08:03.000000000 +0800
+++ teem-1.11.0-src/src/bane/test/opac.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/test/pos.c teem-1.11.0-src/src/bane/test/pos.c
--- teem-1.11.0-src.orig/src/bane/test/pos.c	2012-12-20 22:08:03.000000000 +0800
+++ teem-1.11.0-src/src/bane/test/pos.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/test/pvg.c teem-1.11.0-src/src/bane/test/pvg.c
--- teem-1.11.0-src.orig/src/bane/test/pvg.c	2012-12-20 22:08:03.000000000 +0800
+++ teem-1.11.0-src/src/bane/test/pvg.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/test/sigma.c teem-1.11.0-src/src/bane/test/sigma.c
--- teem-1.11.0-src.orig/src/bane/test/sigma.c	2012-12-20 22:08:03.000000000 +0800
+++ teem-1.11.0-src/src/bane/test/sigma.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/test/tblah.c teem-1.11.0-src/src/bane/test/tblah.c
--- teem-1.11.0-src.orig/src/bane/test/tblah.c	2012-12-20 22:08:03.000000000 +0800
+++ teem-1.11.0-src/src/bane/test/tblah.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/test/tinfo.c teem-1.11.0-src/src/bane/test/tinfo.c
--- teem-1.11.0-src.orig/src/bane/test/tinfo.c	2012-12-20 22:08:03.000000000 +0800
+++ teem-1.11.0-src/src/bane/test/tinfo.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/TODO.txt teem-1.11.0-src/src/bane/TODO.txt
--- teem-1.11.0-src.orig/src/bane/TODO.txt	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/TODO.txt	2021-02-18 15:42:33.000000000 +0800
@@ -2,7 +2,7 @@
 - limit to only going upstream or downstream
 - threshold on grad mag
 - threshold on distance travelled
-- mirror based on 
+- mirror based on
 
 
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/trex.c teem-1.11.0-src/src/bane/trex.c
--- teem-1.11.0-src.orig/src/bane/trex.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/trex.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bane/trnsf.c teem-1.11.0-src/src/bane/trnsf.c
--- teem-1.11.0-src.orig/src/bane/trnsf.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/trnsf.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -56,7 +56,7 @@
     return 1;
   }
   if (1 == dim) {
-    len = hvol->axis[2].size;
+    len = AIR_INT(hvol->axis[2].size); /* HEY should be unsigned */
     if (nrrdMaybeAlloc_va(info, nrrdTypeFloat, 2,
                           AIR_CAST(size_t, 2),
                           AIR_CAST(size_t, len))) {
@@ -108,8 +108,8 @@
   else {
     /* 2 == dim */
     /* hvol axes: 0: grad, 1: 2nd deriv: 2: data value */
-    sv = hvol->axis[2].size;
-    sg = hvol->axis[0].size;
+    sv = AIR_INT(hvol->axis[2].size); /* HEY should be unsigned */
+    sg = AIR_INT(hvol->axis[0].size); /* HEY should be unsigned */
     if (nrrdMaybeAlloc_va(info, nrrdTypeFloat, 3,
                           AIR_CAST(size_t, 2),
                           AIR_CAST(size_t, sv),
@@ -176,7 +176,7 @@
     return 1;
   }
 
-  len = info2D->axis[1].size;
+  len = AIR_INT(info2D->axis[1].size); /* HEY should be unsigned */
   if (nrrdProject(projH2=nrrdNew(), info2D, 0,
                   nrrdMeasureProduct, nrrdTypeDefault)
       || nrrdProject(projH1=nrrdNew(), projH2, 1,
@@ -217,7 +217,7 @@
   int i, len;
   float maxg, maxh, minh, *data;
 
-  len = info1D->axis[1].size;
+  len = AIR_INT(info1D->axis[1].size); /* HEY should be unsigned */
   data = (float *)info1D->data;
   maxg = -1;
   maxh = -1;
@@ -239,7 +239,7 @@
   /* This is after the typo report by Fernando Vega Higuera;
      the previous version of the code had a bug caused by
      mindless transcription of the erroneous equation 5.8 */
-  *sP = AIR_CAST(float, 2*maxg/(sqrt(AIR_E)*(maxh - minh)));
+  *sP = AIR_FLOAT(2*maxg/(sqrt(AIR_E)*(maxh - minh)));
 
   return 0;
 }
@@ -290,7 +290,7 @@
   }
   d = info->dim-1;
   if (1 == d) {
-    len = info->axis[1].size;
+    len = AIR_INT(info->axis[1].size); /* HEY should be unsigned */
     if (nrrdMaybeAlloc_va(pos,  nrrdTypeFloat, 1,
                           AIR_CAST(size_t, len))) {
       biffMovef(BANE, NRRD, BIFF_NRRDALLOC, me);
@@ -314,8 +314,8 @@
   }
   else {
     /* 2 == d */
-    sv = info->axis[1].size;
-    sg = info->axis[2].size;
+    sv = AIR_INT(info->axis[1].size); /* HEY should be unsigned */
+    sg = AIR_INT(info->axis[2].size); /* HEY should be unsigned */
     if (nrrdMaybeAlloc_va(pos, nrrdTypeFloat, 2,
                           AIR_CAST(size_t, sv),
                           AIR_CAST(size_t, sg))) {
@@ -327,8 +327,8 @@
     pos->axis[1].max = info->axis[2].max;
     posData = (float *)pos->data;
     for (gi=0; gi<sg; gi++) {
-      g = AIR_CAST(float, AIR_AFFINE(0, gi, sg-1,
-                                     info->axis[2].min, info->axis[2].max));
+      g = AIR_FLOAT(AIR_AFFINE(0, gi, sg-1,
+                               info->axis[2].min, info->axis[2].max));
       for (vi=0; vi<sv; vi++) {
         h = nrrdFLookup[info->type](info->data, 0 + 2*(vi + sv*gi));
         /* from pg. 61 of GK's MS */
@@ -370,8 +370,8 @@
     for (j=1; j<numCpts; j++)
       if (p < xo[0 + 2*j])
         break;
-    opacLut[i] = AIR_CAST(float, AIR_AFFINE(xo[0 + 2*(j-1)], p, xo[0 + 2*j],
-                                            xo[1 + 2*(j-1)], xo[1 + 2*j]));
+    opacLut[i] = AIR_FLOAT(AIR_AFFINE(xo[0 + 2*(j-1)], p, xo[0 + 2*j],
+                                      xo[1 + 2*(j-1)], xo[1 + 2*j]));
   }
   /*
   for (i=0; i<numCpts; i++)
@@ -423,7 +423,7 @@
         break;
     op = AIR_AFFINE(x[j-1], p, x[j], o[j-1], o[j]);
   endloop:
-    opacLut[i] = AIR_CAST(float, op);
+    opacLut[i] = AIR_FLOAT(op);
     /*
     printf("opac[%d] = %g\n", i, op);
     */
@@ -452,7 +452,7 @@
   }
   dim = pos->dim;
   if (1 == dim) {
-    len = pos->axis[0].size;
+    len = AIR_INT(pos->axis[0].size); /* HEY should be unsigned */
     if (nrrdMaybeAlloc_va(opac, nrrdTypeFloat, 1,
                           AIR_CAST(size_t, len))) {
       biffMovef(BANE, NRRD, BIFF_NRRDALLOC, me); return 1;
@@ -462,12 +462,12 @@
     odata = (float *)opac->data;
     bdata = (float *)Bcpts->data;
     pdata = (float *)pos->data;
-    npts = Bcpts->axis[1].size;
+    npts = AIR_INT(Bcpts->axis[1].size); /* HEY should be unsigned */
     _baneOpacCalcA(len, odata, npts, bdata, pdata);
   }
   else {
-    sv = pos->axis[0].size;
-    sg = pos->axis[1].size;
+    sv = AIR_INT(pos->axis[0].size); /* HEY should be unsigned */
+    sg = AIR_INT(pos->axis[1].size); /* HEY should be unsigned */
     if (nrrdMaybeAlloc_va(opac, nrrdTypeFloat, 2,
                           AIR_CAST(size_t, sv),
                           AIR_CAST(size_t, sg))) {
@@ -480,7 +480,7 @@
     odata = (float *)opac->data;
     bdata = (float *)Bcpts->data;
     pdata = (float *)pos->data;
-    npts = Bcpts->axis[1].size;
+    npts = AIR_INT(Bcpts->axis[1].size); /* HEY should be unsigned */
     _baneOpacCalcA(sv*sg, odata, npts, bdata, pdata);
   }
   return 0;
diff --color -ruN teem-1.11.0-src.orig/src/bane/valid.c teem-1.11.0-src/src/bane/valid.c
--- teem-1.11.0-src.orig/src/bane/valid.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/bane/valid.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -202,7 +202,7 @@
     biffAddf(BANE, "%s: need data of type float", me);
     return 1;
   }
-  len = Bcpts->axis[1].size;
+  len = AIR_INT(Bcpts->axis[1].size); /* HEY should be unsigned */
   data = (float *)Bcpts->data;
   for (i=0; i<=len-2; i++) {
     if (!(data[0 + 2*i] <= data[0 + 2*(i+1)])) {
diff --color -ruN teem-1.11.0-src.orig/src/biff/biffbiff.c teem-1.11.0-src/src/biff/biffbiff.c
--- teem-1.11.0-src.orig/src/biff/biffbiff.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/biff/biffbiff.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/biff/biff.h teem-1.11.0-src/src/biff/biff.h
--- teem-1.11.0-src.orig/src/biff/biff.h	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/biff/biff.h	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/biff/biffmsg.c teem-1.11.0-src/src/biff/biffmsg.c
--- teem-1.11.0-src.orig/src/biff/biffmsg.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/biff/biffmsg.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -96,16 +96,16 @@
   if (!( msg && err )) {
     fprintf(stderr, "%s: PANIC got NULL msg (%p) or err (%p)\n", me,
             AIR_VOIDP(msg), AIR_CVOIDP(err));
-    /* exit(1); */
+    return; /* exit(1); */
   }
   idx = airArrayLenIncr(msg->errArr, 1);
   if (!msg->err) {
     fprintf(stderr, "%s: PANIC: couldn't add message to %s\n", me, msg->key);
-    /* exit(1); */
+    return; /* exit(1); */
   }
   if (!( msg->err[idx] = airOneLinify(airStrdup(err)) )) {
     fprintf(stderr, "%s: PANIC: couldn't alloc message to %s\n", me, msg->key);
-    /* exit(1); */
+    return; /* exit(1); */
   }
   return;
 }
@@ -177,7 +177,7 @@
   if (!( dest && src )) {
     fprintf(stderr, "%s: PANIC got NULL msg (%p %p)\n", me,
             AIR_VOIDP(dest), AIR_VOIDP(src));
-    /* exit(1); */
+    return; /* exit(1); */
   }
   /* if src and dest are same, this degenerates to biffMsgAdd */
   if (dest == src && airStrlen(err)) {
@@ -188,7 +188,7 @@
   buff = AIR_CALLOC(biffMsgLineLenMax(src)+1, char);
   if (!buff) {
     fprintf(stderr, "%s: PANIC: can't allocate buffer\n", me);
-    /* exit(1); */
+    return; /* exit(1); */
   }
   for (ii=0; ii<src->errNum; ii++) {
     sprintf(buff, "[%s] %s", src->key, src->err[ii]);
@@ -297,10 +297,14 @@
   if (biffMsgNoop == msg) {
     return;
   }
+  if (!ret) {
+    fprintf(stderr, "%s: PANIC got NULL ret", me);
+    return;
+  }
   buff = AIR_CALLOC(biffMsgLineLenMax(msg)+1, char);
   if (!buff) {
     fprintf(stderr, "%s: PANIC couldn't alloc buffer", me);
-    /* exit(1); */
+    return; /* exit(1); */
   }
   strcpy(ret, "");
   for (ii=msg->errNum; ii>0; ii--) {
diff --color -ruN teem-1.11.0-src.orig/src/biff/CMakeLists.txt teem-1.11.0-src/src/biff/CMakeLists.txt
--- teem-1.11.0-src.orig/src/biff/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/biff/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -0,0 +1,12 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(BIFF_SOURCES
+  privateBiff.h
+  biff.h
+  biffmsg.c
+  biffbiff.c
+  )
+
+target_sources(teem PRIVATE ${BIFF_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( BIFF FILES ${BIFF_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/biff/GNUmakefile teem-1.11.0-src/src/biff/GNUmakefile
--- teem-1.11.0-src.orig/src/biff/GNUmakefile	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/biff/GNUmakefile	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/biff/privateBiff.h teem-1.11.0-src/src/biff/privateBiff.h
--- teem-1.11.0-src.orig/src/biff/privateBiff.h	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/biff/privateBiff.h	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/biff/sources.cmake teem-1.11.0-src/src/biff/sources.cmake
--- teem-1.11.0-src.orig/src/biff/sources.cmake	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/biff/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,10 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(BIFF_SOURCES
-  privateBiff.h
-  biff.h
-  biffmsg.c
-  biffbiff.c
-  )
-
-ADD_TEEM_LIBRARY(biff ${BIFF_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/biff/test/test.c teem-1.11.0-src/src/biff/test/test.c
--- teem-1.11.0-src.orig/src/biff/test/test.c	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/biff/test/test.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/biff/TODO.txt teem-1.11.0-src/src/biff/TODO.txt
--- teem-1.11.0-src.orig/src/biff/TODO.txt	2012-12-20 22:08:04.000000000 +0800
+++ teem-1.11.0-src/src/biff/TODO.txt	2021-02-18 15:42:38.000000000 +0800
@@ -4,6 +4,35 @@
  [gage] gageKindCheck: kind "tensor" item max 65 > GAGE_ITEM_MAX 63
 
 
+/Users/gk/teem/src/meet/test/strace: trouble with volumes or infos:
+[meet] meetPullVolLoadMulti: trouble getting volume stack ("blur/VS-%03u-199.nrrd")
+[meet] [gage] gageStackBlurManage: trouble saving blurrings
+[meet] [gage] [nrrd] nrrdSaveMulti: trouble saving nin[0] to blur/VS-000-199.nrrd
+[meet] [gage] [nrrd] nrrdSave:
+[meet] [gage] [nrrd] nrrdWrite: trouble
+[meet] [gage] [nrrd] _nrrdWrite:
+[meet] [gage] [nrrd] nrrdCheck: trouble
+[meet] [gage] [nrrd] _nrrdCheck: nrrd 0x1003571d0 has NULL data pointer
+
+
+/Users/gk/teem/src/meet/test/strace: trouble with volumes or infos:
+[meet] meetPullVolLoadMulti: trouble getting volume stack ("blur/VS-%03u-199.nrrd")
+[meet] [gage] gageStackBlurManage: trouble saving blurrings
+[meet] [gage] [nrrd] nrrdSaveMulti: trouble saving nin[0] to blur/VS-000-199.nrrd
+[meet] [gage] [nrrd] nrrdSave:
+[meet] [gage] [nrrd] nrrdWrite: trouble
+[meet] [gage] [nrrd] _nrrdWrite:
+[meet] [gage] [nrrd] nrrdCheck: trouble
+[meet] [gage] [nrrd] _nrrdCheck: nrrd 0x7fcce380be00 has NULL data pointer
+[meet] [gage] [nrrd] nrrdSave:
+[meet] [gage] [nrrd] nrrdWrite: trouble
+[meet] [gage] [nrrd] _nrrdWrite:
+[meet] [gage] [nrrd] nrrdCheck: trouble
+[meet] [gage] [nrrd] _nrrdCheck: trouble with space field
+[meet] [gage] [nrrd] _nrrdFieldCheck_space: trouble
+[meet] [gage] [nrrd] _nrrdFieldCheckSpaceInfo: spaceDim is 0, but space directions are set
+
+
 *** fix memory-in-use problem after a biffGetDone()
 
 biffDisable()
diff --color -ruN teem-1.11.0-src.orig/src/bin/airSanity.c teem-1.11.0-src/src/bin/airSanity.c
--- teem-1.11.0-src.orig/src/bin/airSanity.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/airSanity.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bin/CMakeLists.txt teem-1.11.0-src/src/bin/CMakeLists.txt
--- teem-1.11.0-src.orig/src/bin/CMakeLists.txt	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/CMakeLists.txt	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images             .
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -21,16 +21,17 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-MACRO(CREATE_EXEC name sources)
-  ADD_EXECUTABLE(${name} ${sources})
-  TARGET_LINK_LIBRARIES(${name} teem)
-  INSTALL(TARGETS ${name}
+macro(CREATE_EXEC name sources)
+  add_executable(${name} ${sources})
+  target_link_libraries(${name} teem)
+  install(TARGETS ${name}
     RUNTIME DESTINATION bin
+    COMPONENT Runtime
     )
-  SET_TARGET_PROPERTIES(${name} PROPERTIES
+  set_target_properties(${name} PROPERTIES
     INSTALL_RPATH ${CMAKE_INSTALL_PREFIX}/lib
     )
-ENDMACRO(CREATE_EXEC)
+endmacro()
 
 # These binaries should not be depending on BUILD_EXPERIMENTAL_LIBS
 CREATE_EXEC(nrrdSanity nrrdSanity.c)
@@ -40,6 +41,7 @@
 CREATE_EXEC(miter miter.c)
 CREATE_EXEC(vprobe vprobe.c)
 CREATE_EXEC(gprobe gprobe.c)
+CREATE_EXEC(ninspect ninspect.c)
 CREATE_EXEC(unu unu.c)
 CREATE_EXEC(puller puller.c)
 CREATE_EXEC(tend tend.c)
@@ -47,23 +49,17 @@
 # NOTE: The BUILD_EXPERIMENTAL_LIBS-dependent inclusion of binaries has to be
 # done with knowledge of how BUILD_EXPERIMENTAL_LIBS behaves in the top-level
 # CMakeLists.txt file
-IF(BUILD_EXPERIMENTAL_APPS)
+if(BUILD_EXPERIMENTAL_APPS)
   CREATE_EXEC(airSanity airSanity.c)
   CREATE_EXEC(cubic cubic.c)
-  CREATE_EXEC(undos undos.c)
   CREATE_EXEC(qbert qbert.c)
   CREATE_EXEC(emap emap.c)
   CREATE_EXEC(talkweb talkweb.c)
   CREATE_EXEC(pprobe pprobe.c)
-  CREATE_EXEC(ninspect ninspect.c)
   CREATE_EXEC(ungantry ungantry.c)
   CREATE_EXEC(deconv deconv.c)
-  IF(BUILD_EXPERIMENTAL_LIBS)
+  if(BUILD_EXPERIMENTAL_LIBS)
     CREATE_EXEC(gkms gkms.c)
     CREATE_EXEC(spots spots.c)
-  ENDIF(BUILD_EXPERIMENTAL_LIBS)
-ENDIF(BUILD_EXPERIMENTAL_APPS)
-
-#IF(BUILD_TESTING)
-#  ADD_TEST(nrrd.Sanity ${EXECUTABLE_OUTPUT_PATH}/nrrdSanity)
-#ENDIF(BUILD_TESTING)
+  endif()
+endif()
diff --color -ruN teem-1.11.0-src.orig/src/bin/cubic.c teem-1.11.0-src/src/bin/cubic.c
--- teem-1.11.0-src.orig/src/bin/cubic.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/cubic.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bin/deconv.c teem-1.11.0-src/src/bin/deconv.c
--- teem-1.11.0-src.orig/src/bin/deconv.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/deconv.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bin/emap.c teem-1.11.0-src/src/bin/emap.c
--- teem-1.11.0-src.orig/src/bin/emap.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/emap.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -46,7 +46,7 @@
   const char *me;
   char *outS, *errS, *debugS;
   airArray *mop;
-  float amb[3], *linfo, *debug, *map;
+  float amb[3], *linfo, *debug, *map, vscl;
   unsigned li, ui, vi;
   int qn, bits, method, doerr;
   limnLight *light;
@@ -76,6 +76,9 @@
              "camera pseudo-up vector, used to determine view coordinates");
   hestOptAdd(&hopt, "rh", NULL, airTypeInt, 0, 0, &(cam->rightHanded), NULL,
              "use a right-handed UVN frame (V points down)");
+  hestOptAdd(&hopt, "vs", "view-dir scaling", airTypeFloat, 1, 1, &vscl, "1",
+             "scaling along view-direction of location of "
+             "view-space lights");
   hestOptAdd(&hopt, "o", "filename", airTypeString, 1, 1, &outS, NULL,
              "file to write output envmap to");
   hestOptAdd(&hopt, "d", "filename", airTypeString, 1, 1, &debugS, "",
@@ -117,26 +120,38 @@
             me, LIMN_LIGHT_NUM);
     airMopError(mop); return 1;
   }
+
+  cam->neer = -0.000000001;
+  cam->dist = 0;
+  cam->faar = 0.0000000001;
+  cam->atRelative = AIR_TRUE;
+  if (limnCameraUpdate(cam)) {
+    airMopAdd(mop, errS = biffGetDone(LIMN), airFree, airMopAlways);
+    fprintf(stderr, "%s: problem with camera:\n%s\n", me, errS);
+    airMopError(mop); return 1;
+  }
+
   light = limnLightNew();
   airMopAdd(mop, light, (airMopper)limnLightNix, airMopAlways);
-
   limnLightAmbientSet(light, amb[0], amb[1], amb[2]);
   for (li=0; li<nlight->axis[1].size; li++) {
+    int vsp;
+    float lxyz[3];
     linfo = (float *)(nlight->data) + 7*li;
-    limnLightSet(light, li, !!linfo[0],
-                 linfo[1], linfo[2], linfo[3],
-                 linfo[4], linfo[5], linfo[6]);
+    vsp = !!linfo[0];
+    ELL_3V_COPY(lxyz, linfo + 4);
+    if (vsp) {
+      lxyz[2] *= vscl;
+    }
+    limnLightSet(light, li, vsp,
+                 linfo[1], linfo[2], linfo[3], lxyz[0], lxyz[1], lxyz[2]);
   }
-
-  cam->neer = -0.000000001;
-  cam->dist = 0;
-  cam->faar = 0.0000000001;
-  cam->atRelative = AIR_TRUE;
-  if (limnCameraUpdate(cam) || limnLightUpdate(light, cam)) {
+  if (limnLightUpdate(light, cam)) {
     airMopAdd(mop, errS = biffGetDone(LIMN), airFree, airMopAlways);
-    fprintf(stderr, "%s: problem with camera or lights:\n%s\n", me, errS);
+    fprintf(stderr, "%s: problem with lights:\n%s\n", me, errS);
     airMopError(mop); return 1;
   }
+
   nmap=nrrdNew();
   airMopAdd(mop, nmap, (airMopper)nrrdNuke, airMopAlways);
   if (limnEnvMapFill(nmap, limnLightDiffuseCB, method, light)) {
diff --color -ruN teem-1.11.0-src.orig/src/bin/gkms.c teem-1.11.0-src/src/bin/gkms.c
--- teem-1.11.0-src.orig/src/bin/gkms.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/gkms.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bin/GNUmakefile teem-1.11.0-src/src/bin/GNUmakefile
--- teem-1.11.0-src.orig/src/bin/GNUmakefile	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/GNUmakefile	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -49,7 +49,7 @@
 
 ## BINS: all the command-line executables associated with teem
 ##
-BINS = airSanity cubic nrrdSanity overrgb emap undos talkweb \
+BINS = airSanity cubic nrrdSanity overrgb emap talkweb \
   unu pprobe vprobe gprobe qbert mrender miter gkms ungantry ilk \
   tend spots ninspect deconv puller
 
diff --color -ruN teem-1.11.0-src.orig/src/bin/gprobe.c teem-1.11.0-src/src/bin/gprobe.c
--- teem-1.11.0-src.orig/src/bin/gprobe.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/gprobe.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -47,7 +47,8 @@
 static int
 gridProbe(gageContext *ctx, gagePerVolume *pvl, int what,
           Nrrd *nout, int typeOut, Nrrd *_ngrid,
-          int indexSpace, int verbose, int clamp) {
+          int indexSpace, int verbose, int clamp, int scaleIsTau,
+          double eft, double eftVal) {
   char me[]="gridProbe";
   Nrrd *ngrid;
   airArray *mop;
@@ -140,13 +141,14 @@
   ins = nrrdDInsert[nout->type];
   for (II=0; II<NN; II++) {
     int E;
-    if (verbose && 3 == gridDim && !coordOut[0] && !coordOut[1]) {
+    if (verbose && 3 == gridDim
+        && !coordOut[0+baseDim] && !coordOut[1+baseDim]) {
       if (verbose > 1) {
         fprintf(stderr, "z = ");
       }
       fprintf(stderr, " %s/%s",
-              airSprintSize_t(stmp[0], coordOut[2]),
-              airSprintSize_t(stmp[1], sizeOut[2]));
+              airSprintSize_t(stmp[0], coordOut[2+baseDim]),
+              airSprintSize_t(stmp[1], sizeOut[2+baseDim]));
       fflush(stderr);
       if (verbose > 1) {
         fprintf(stderr, "\n");
@@ -158,6 +160,10 @@
                         AIR_CAST(double, coordOut[aidx + baseDim]),
                         grid + 1 + 5*(1+aidx));
     }
+    if (scaleIsTau && ctx->stackPos) {
+      /* have to convert given tau values to sigma */
+      pos[3] = airSigmaOfTau(pos[3]);
+    }
     /*
     printf("%s: %u -> (%u %u) -> %g %g %g %g (%s)\n", me,
            AIR_UINT(II),
@@ -179,10 +185,14 @@
       airMopError(mop); return 1;
     }
     if (1 == ansLen) {
-      ins(nout->data, II, *answer);
+      ins(nout->data, II, (ctx->edgeFrac > eft
+                           ? eftVal
+                           : *answer));
     } else {
       for (aidx=0; aidx<ansLen; aidx++) {
-        ins(nout->data, aidx + ansLen*II, answer[aidx]);
+        ins(nout->data, aidx + ansLen*II, (ctx->edgeFrac > eft
+                                           ? eftVal
+                                           : answer[aidx]));
       }
     }
     NRRD_COORD_INCR(coordOut, sizeOut, dim, baseDim);
@@ -191,6 +201,20 @@
     fprintf(stderr, "\n");
   }
 
+  if (!indexSpace) {
+    /* set the output space directions, but (being conservative/cautious)
+       only do so when grid had specified world-space positions */
+    /* HEY: untested! whipped up out of frustration for GLK Bonn talk */
+    nout->spaceDim = 3;
+    if (baseDim) {
+      nrrdSpaceVecSetNaN(nout->axis[0].spaceDirection);
+    }
+    nrrdSpaceVecCopy(nout->spaceOrigin, grid + 1 + 5*0);
+    for (aidx=0; aidx<gridDim; aidx++) {
+      nrrdSpaceVecCopy(nout->axis[baseDim+aidx].spaceDirection,
+                       grid + 1 + 5*(1+aidx));
+    }
+  }
   airMopOkay(mop);
   return 0;
 }
@@ -208,7 +232,7 @@
   hestParm *hparm;
   hestOpt *hopt = NULL;
   NrrdKernelSpec *k00, *k11, *k22, *kSS, *kSSblur;
-  int what, E=0, renorm, uniformSS, optimSS, verbose,
+  int what, E=0, renorm, uniformSS, optimSS, verbose, zeroZ,
     orientationFromSpacing, probeSpaceIndex, normdSS;
   unsigned int iBaseDim, oBaseDim, axi, numSS, seed;
   const double *answer;
@@ -216,14 +240,16 @@
   Nrrd *ngrad=NULL, *nbmat=NULL;
   size_t six, siy, siz, sox, soy, soz;
   double bval=0, eps, gmc, rangeSS[2], *pntPos, scale[3], posSS, biasSS,
-    dsix, dsiy, dsiz, dsox, dsoy, dsoz;
+    dsix, dsiy, dsiz, dsox, dsoy, dsoz, edgeFracInfo[2];
   gageContext *ctx;
   gagePerVolume *pvl=NULL;
   double t0, t1, rscl[3], min[3], maxOut[3], maxIn[3];
   airArray *mop;
-  unsigned int ansLen, *skip, skipNum, pntPosNum;
-  gageStackBlurParm *sbp;
-  int otype, clamp;
+#define NON_SBP_OPT_NUM 5
+  unsigned int ansLen, *skip, skipNum, pntPosNum,
+    nonSbpOpi[NON_SBP_OPT_NUM], nsi;
+  gageStackBlurParm *sbpIN, *sbpCL, *sbp;
+  int otype, clamp, scaleIsTau;
   char stmp[4][AIR_STRLEN_SMALL];
 
   me = argv[0];
@@ -276,6 +302,18 @@
              "RNG seed; mostly for debugging");
   hestOptAdd(&hopt, "c", "bool", airTypeBool, 1, 1, &clamp, "false",
              "clamp positions as part of probing");
+  hestOptAdd(&hopt, "ev", "thresh val", airTypeDouble, 2, 2,
+             edgeFracInfo, "1 0",
+             "if using position clamping (with \"-c true\"), the fraction "
+             "of values invented for the kernel support, or \"edge frac\" "
+             "is saved per probe (0 means kernel support was entirely within "
+             "data; 1 means everything was invented). "
+             "If this frac exceeds the first \"thresh\" "
+             "value given here, then the saved value for the probe will be "
+             "the second value \"val\" given here");
+  hestOptAdd(&hopt, "zz", "bool", airTypeBool, 1, 1, &zeroZ, "false",
+             "enable \"zeroZ\" behavior in gage that partially "
+             "implements working with 3D images as if they are 2D");
 
   hestOptAdd(&hopt, "k00", "kern00", airTypeOther, 1, 1, &k00,
              "tent", "kernel for gageKernel00",
@@ -291,27 +329,42 @@
              "\"Accurate\" kernels don't need this; doing it always "
              "makes things go slower");
 
+  nsi = 0;
+  nonSbpOpi[nsi++] =
   hestOptAdd(&hopt, "ssn", "SS #", airTypeUInt, 1, 1, &numSS,
              "0", "how many scale-space samples to evaluate, or, "
              "0 to turn-off all scale-space behavior");
+  nonSbpOpi[nsi++] =
   hestOptAdd(&hopt, "ssr", "scale range", airTypeDouble, 2, 2, rangeSS,
              "nan nan", "range of scales in scale-space");
-  hestOptAdd(&hopt, "kssb", "kernel", airTypeOther, 1, 1, &kSSblur,
-             "dgauss:1,5", "blurring kernel, to sample scale space",
-             NULL, NULL, nrrdHestKernelSpec);
-  hestOptAdd(&hopt, "kssr", "kernel", airTypeOther, 1, 1, &kSS,
-             "hermite", "kernel for reconstructing from scale space samples",
-             NULL, NULL, nrrdHestKernelSpec);
+  nonSbpOpi[nsi++] =
   hestOptAdd(&hopt, "ssu", NULL, airTypeInt, 0, 0, &uniformSS, NULL,
              "do uniform samples along sigma, and not (by default) "
              "samples according to the effective diffusion scale");
+  nonSbpOpi[nsi++] =
   hestOptAdd(&hopt, "sso", NULL, airTypeInt, 0, 0, &optimSS, NULL,
              "if not using \"-ssu\", use pre-computed optimal "
              "sigmas when possible");
+  nonSbpOpi[nsi++] =
+  hestOptAdd(&hopt, "kssb", "kernel", airTypeOther, 1, 1, &kSSblur,
+             "dgauss:1,5", "blurring kernel, to sample scale space",
+             NULL, NULL, nrrdHestKernelSpec);
+  if (nsi != NON_SBP_OPT_NUM) {
+    fprintf(stderr, "%s: PANIC nsi %u != %u", me, nsi, NON_SBP_OPT_NUM);
+    exit(1);
+  }
+  hestOptAdd(&hopt, "sbp", "blur spec", airTypeOther, 1, 1, &sbpCL, "",
+             "complete specification of stack blur parms; "
+             "over-rides all previous \"ss\" options",
+             NULL, NULL, gageHestStackBlurParm);
+  /* These two options are needed even if sbp is used, because they are *not*
+     part of the gageStackBlurParm.  In meet, this info is handled by the
+     extraFlag/extraParm construct, which is not available here */
   hestOptAdd(&hopt, "ssnd", NULL, airTypeInt, 0, 0, &normdSS, NULL,
              "normalize derivatives by scale");
   hestOptAdd(&hopt, "ssnb", "bias", airTypeDouble, 1, 1, &biasSS, "0.0",
              "bias on scale-based derivative normalization");
+
   hestOptAdd(&hopt, "ssf", "SS read/save format", airTypeString, 1, 1,
              &stackFnameFormat, "",
              "printf-style format (including a \"%u\") for the "
@@ -321,10 +374,17 @@
              "them if they had to be re-computed.  Leave this as empty "
              "string to disable this.");
 
+  hestOptAdd(&hopt, "kssr", "kernel", airTypeOther, 1, 1, &kSS,
+             "hermite", "kernel for reconstructing from scale space samples",
+             NULL, NULL, nrrdHestKernelSpec);
+  hestOptAdd(&hopt, "sit", "sit", airTypeBool, 1, 1, &scaleIsTau, "false",
+             "in some places, scale should be interpreted as tau, not "
+             "sigma. Currently limited to grid probing (via \"-pg\")");
+
   hestOptAdd(&hopt, "s", "sclX sclY sxlZ", airTypeDouble, 3, 3, scale,
              "1 1 1",
              "scaling factor for resampling on each axis "
-             "(>1.0 : supersampling); use \"-ssp\" (and \"-psi\")"
+             "(>1.0: supersampling); use \"-ssp\" (and \"-psi\") "
              "to specify scale position of sampling");
   hestOptAdd(&hopt, "ssp", "pos", airTypeDouble, 1, 1, &posSS, "0",
              "when using scale-space, scale-position at which to probe");
@@ -333,7 +393,7 @@
              "2-D nrrd which specifies origin and direction vectors "
              "for sampling grid", NULL, NULL, nrrdHestNrrd);
   hestOptAdd(&hopt, "pi", "nrrd", airTypeOther, 1, 1, &_npos, "",
-             "overrides \"-pv\": probes at this list of 3-vec or "
+             "overrides \"-pg\": probes at this list of 3-vec or "
              "4-vec positions", NULL, NULL, nrrdHestNrrd);
   hestOptAdd(&hopt, "pp", "pos", airTypeDouble, 3, 4, &pntPos,
              "nan nan nan",
@@ -389,34 +449,74 @@
   }
 
   /* for setting up pre-blurred scale-space samples */
-  if (numSS) {
+  if (numSS || sbpCL) {
     unsigned int vi;
-    int recompute;
+    int recompute, gotOld;
 
-    sbp = gageStackBlurParmNew();
-    airMopAdd(mop, sbp, (airMopper)gageStackBlurParmNix, airMopAlways);
-    if (gageStackBlurParmScaleSet(sbp, numSS, rangeSS[0], rangeSS[1],
-                                  uniformSS, optimSS)
-        || gageStackBlurParmKernelSet(sbp, kSSblur, AIR_TRUE)
-        || gageStackBlurParmBoundarySet(sbp, nrrdBoundaryBleed, AIR_NAN)
-        || gageStackBlurParmVerboseSet(sbp, verbose)
-        || gageStackBlurManage(&ninSS, &recompute, sbp,
-                               stackFnameFormat, AIR_TRUE, NULL,
-                               nin, kind)) {
-      airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
-      fprintf(stderr, "%s: trouble getting volume stack:\n%s\n", me, err);
-      airMopError(mop); return 1;
-    }
-    airMopAdd(mop, ninSS, airFree, airMopAlways);
-    if (verbose > 2) {
-      fprintf(stderr, "%s: sampling scale range %g--%g %suniformly:\n", me,
-              rangeSS[0], rangeSS[1], uniformSS ? "" : "non-");
-      for (vi=0; vi<numSS; vi++) {
-        fprintf(stderr, "    scalePos[%u] = %g\n", vi, sbp->scale[vi]);
+    if (sbpCL) {
+      /* we got the whole stack blar parm here */
+      gotOld = AIR_FALSE;
+      for (nsi=0; nsi<NON_SBP_OPT_NUM; nsi++) {
+        gotOld |= (hestSourceUser == hopt[nonSbpOpi[nsi]].source);
+      }
+      if (gotOld) {
+        fprintf(stderr, "%s: with new -sbp option; can't also use older "
+                "scale-space options (used", me);
+        for (nsi=0; nsi<NON_SBP_OPT_NUM; nsi++) {
+          if (hestSourceUser == hopt[nonSbpOpi[nsi]].source) {
+            fprintf(stderr, " -%s", hopt[nonSbpOpi[nsi]].flag);
+          }
+        }
+        fprintf(stderr, ")\n");
+        airMopError(mop); return 1;
+      }
+      if (gageStackBlurManage(&ninSS, &recompute, sbpCL,
+                              stackFnameFormat, AIR_TRUE, NULL,
+                              nin, kind)) {
+        airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
+        fprintf(stderr, "%s: trouble getting volume stack:\n%s\n", me, err);
+        airMopError(mop); return 1;
+      }
+      if (sbpCL->verbose > 2) {
+        fprintf(stderr, "%s: sampling scale range %g--%g via %s:\n", me,
+                sbpCL->sigmaRange[0], sbpCL->sigmaRange[1],
+                airEnumStr(gageSigmaSampling, sbpCL->sigmaSampling));
+        for (vi=0; vi<sbpCL->num; vi++) {
+          fprintf(stderr, "    sigma[%u] = %g\n", vi, sbpCL->sigma[vi]);
+        }
       }
+      sbp = sbpCL;
+    } else {
+      /* old way of doing things; depending on many separate options
+         to set numSS, rangeSS, uniformSS, optimSS, etc */
+      sbpIN = gageStackBlurParmNew();
+      airMopAdd(mop, sbpIN, (airMopper)gageStackBlurParmNix, airMopAlways);
+      if (gageStackBlurParmVerboseSet(sbpIN, verbose)
+          || gageStackBlurParmScaleSet(sbpIN, numSS, rangeSS[0], rangeSS[1],
+                                       uniformSS, optimSS)
+          || gageStackBlurParmKernelSet(sbpIN, kSSblur)
+          || gageStackBlurParmRenormalizeSet(sbpIN, AIR_TRUE)
+          || gageStackBlurParmBoundarySet(sbpIN, nrrdBoundaryBleed, AIR_NAN)
+          || gageStackBlurManage(&ninSS, &recompute, sbpIN,
+                                 stackFnameFormat, AIR_TRUE, NULL,
+                                 nin, kind)) {
+        airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
+        fprintf(stderr, "%s: trouble getting volume stack:\n%s\n", me, err);
+        airMopError(mop); return 1;
+      }
+      if (verbose > 2) {
+        fprintf(stderr, "%s: sampling scale range %g--%g %suniformly:\n", me,
+                rangeSS[0], rangeSS[1], uniformSS ? "" : "non-");
+        for (vi=0; vi<numSS; vi++) {
+          fprintf(stderr, "    scalePos[%u] = %g\n", vi, sbpIN->sigma[vi]);
+        }
+      }
+      sbp = sbpIN;
     }
+    airMopAdd(mop, ninSS, airFree, airMopAlways);
   } else {
     ninSS = NULL;
+    sbpIN = NULL;
     sbp = NULL;
   }
 
@@ -429,6 +529,7 @@
   airMopAdd(mop, ctx, AIR_CAST(airMopper, gageContextNix), airMopAlways);
   gageParmSet(ctx, gageParmGradMagCurvMin, gmc);
   gageParmSet(ctx, gageParmVerbose, verbose);
+  gageParmSet(ctx, gageParmTwoDimZeroZ, zeroZ);
   gageParmSet(ctx, gageParmRenormalize, renorm ? AIR_TRUE : AIR_FALSE);
   gageParmSet(ctx, gageParmCheckIntegrals, AIR_TRUE);
   gageParmSet(ctx, gageParmOrientationFromSpacing, orientationFromSpacing);
@@ -437,18 +538,19 @@
   if (!E) E |= gageKernelSet(ctx, gageKernel00, k00->kernel, k00->parm);
   if (!E) E |= gageKernelSet(ctx, gageKernel11, k11->kernel, k11->parm);
   if (!E) E |= gageKernelSet(ctx, gageKernel22, k22->kernel, k22->parm);
-  if (numSS) {
+  if (sbp) {
     gagePerVolume **pvlSS;
     gageParmSet(ctx, gageParmStackUse, AIR_TRUE);
-    gageParmSet(ctx, gageParmStackNormalizeDerivBias, biasSS);
     gageParmSet(ctx, gageParmStackNormalizeDeriv, normdSS);
+    gageParmSet(ctx, gageParmStackNormalizeDerivBias, biasSS);
     if (!E) E |= !(pvlSS = AIR_CAST(gagePerVolume **,
-                                    calloc(numSS, sizeof(gagePerVolume *))));
+                                    calloc(sbp->num, sizeof(gagePerVolume *))));
     if (!E) airMopAdd(mop, pvlSS, (airMopper)airFree, airMopAlways);
     if (!E) E |= gageStackPerVolumeNew(ctx, pvlSS,
                                        AIR_CAST(const Nrrd*const*, ninSS),
-                                       numSS, kind);
-    if (!E) E |= gageStackPerVolumeAttach(ctx, pvl, pvlSS, sbp->scale, numSS);
+                                       sbp->num, kind);
+    if (!E) E |= gageStackPerVolumeAttach(ctx, pvl, pvlSS,
+                                          sbp->sigma, sbp->num);
     if (!E) E |= gageKernelSet(ctx, gageKernelStack, kSS->kernel, kSS->parm);
   } else {
     if (!E) E |= gagePerVolumeAttach(ctx, pvl);
@@ -473,18 +575,18 @@
   if (ELL_3V_EXISTS(pntPos)) {
     /* only interested in a single point, make sure we have the right
        info about the point WRT scale stuff */
-    if (numSS) {
+    if (sbp) {
       if (!(4 == pntPosNum && ELL_4V_EXISTS(pntPos))) {
-        fprintf(stderr, "%s: need a 4-vec position with scale-space", me);
+        fprintf(stderr, "%s: need a 4-vec position with scale-space\n", me);
         airMopError(mop); return 1;
       }
     } else {
       if (!(3 == pntPosNum)) {
-        fprintf(stderr, "%s: need a 3-vec position (w/out scale-space)", me);
+        fprintf(stderr, "%s: need a 3-vec position (w/out scale-space)\n", me);
         airMopError(mop); return 1;
       }
     }
-    if (numSS
+    if (sbp
         ? gageStackProbeSpace(ctx,
                               pntPos[0], pntPos[1], pntPos[2], pntPos[3],
                               probeSpaceIndex, clamp)
@@ -495,7 +597,7 @@
               ctx->errNum, ctx->errStr);
       airMopError(mop); return 1;
     }
-    if (numSS) {
+    if (sbp) {
       printf("%s: %s(%s:%g,%g,%g,%g) = ", me, airEnumStr(kind->enm, what),
              probeSpaceIndex ? "index" : "world",
              pntPos[0], pntPos[1], pntPos[2], pntPos[3]);
@@ -518,7 +620,7 @@
       }
       gageParmSet(ctx, gageParmVerbose, 0);
 #define PROBE(x, y, z)                                                  \
-      ((numSS                                                           \
+      ((sbp                                                             \
         ? gageStackProbeSpace(ctx, x, y, z, posSS,                      \
                               probeSpaceIndex, clamp)                   \
         : gageProbeSpace(ctx, x, y, z, probeSpaceIndex,                 \
@@ -566,11 +668,11 @@
               AIR_UINT(_npos->axis[0].size));
       airMopError(mop); return 1;
     }
-    if ((numSS && 3 == _npos->axis[0].size)
-        || (!numSS && 4 == _npos->axis[0].size)) {
+    if ((sbp && 3 == _npos->axis[0].size)
+        || (!sbp && 4 == _npos->axis[0].size)) {
       fprintf(stderr, "%s: have %u point coords but %s using scale-space\n",
               me, AIR_UINT(_npos->axis[0].size),
-              numSS ? "are" : "are not");
+              sbp ? "are" : "are not");
       airMopError(mop); return 1;
     }
     NN = _npos->axis[1].size;
@@ -590,7 +692,7 @@
     pos = AIR_CAST(double *, npos->data);
     ins = nrrdDInsert[nout->type];
     for (II=0; II<NN; II++) {
-      if (numSS) {
+      if (sbp) {
         gageStackProbeSpace(ctx, pos[0], pos[1], pos[2], pos[3],
                             probeSpaceIndex, clamp);
       } else {
@@ -598,14 +700,18 @@
                        probeSpaceIndex, clamp);
       }
       if (1 == ansLen) {
-        ins(nout->data, II, *answer);
+        ins(nout->data, II, (ctx->edgeFrac > edgeFracInfo[0]
+                             ? edgeFracInfo[1]
+                             : *answer));
       } else {
         for (aidx=0; aidx<ansLen; aidx++) {
-          ins(nout->data, aidx + ansLen*II, answer[aidx]);
+          ins(nout->data, aidx + ansLen*II, (ctx->edgeFrac > edgeFracInfo[0]
+                                             ? edgeFracInfo[1]
+                                             : answer[aidx]));
         }
       }
       /*
-      if (numSS) {
+      if (sbp) {
         printf("%s: %s(%s:%g,%g,%g,%g) = ", me, airEnumStr(kind->enm, what),
                probeSpaceIndex ? "index" : "world",
                pos[0], pos[1], pos[2], pos[3]);
@@ -664,7 +770,7 @@
       fprintf(stderr, "%s: effective scaling is %g %g %g\n", me,
               rscl[0], rscl[1], rscl[2]);
     }
-    gridSize[0] = numSS ? 5 : 4;
+    gridSize[0] = sbp ? 5 : 4;
     gridSize[1] = 4;
     if (nrrdMaybeAlloc_nva(ngrid, nrrdTypeDouble, 2, gridSize)) {
       airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
@@ -697,7 +803,7 @@
                0,
                0,
                AIR_DELTA(min[2], 1, maxOut[2], min[2], maxIn[2]));
-    if (numSS) {
+    if (sbp) {
       if (!probeSpaceIndex) {
         double idxSS = AIR_NAN;
         unsigned int vi;
@@ -709,23 +815,23 @@
            defined. So, we have to actually replicate work that is done
            by _gageProbeSpace() in converting from world to index space */
         /* HEY: the way that idxSS is set is very strange */
-        for (vi=0; vi<numSS-1; vi++) {
-          if (AIR_IN_CL(sbp->scale[vi], posSS, sbp->scale[vi+1])) {
-            idxSS = vi + AIR_AFFINE(sbp->scale[vi], posSS, sbp->scale[vi+1],
+        for (vi=0; vi<sbp->num-1; vi++) {
+          if (AIR_IN_CL(sbp->sigma[vi], posSS, sbp->sigma[vi+1])) {
+            idxSS = vi + AIR_AFFINE(sbp->sigma[vi], posSS, sbp->sigma[vi+1],
                                     0, 1);
             if (verbose > 1) {
               fprintf(stderr, "%s: scale pos %g -> idx %g = %u + %g\n", me,
                       posSS, idxSS, vi,
-                      AIR_AFFINE(sbp->scale[vi], posSS, sbp->scale[vi+1],
+                      AIR_AFFINE(sbp->sigma[vi], posSS, sbp->sigma[vi+1],
                                  0, 1));
             }
             break;
           }
         }
-        if (vi == numSS-1) {
+        if (vi == sbp->num-1) {
           fprintf(stderr, "%s: scale pos %g outside range %g=%g, %g=%g\n", me,
-                  posSS, rangeSS[0], sbp->scale[0],
-                  rangeSS[1], sbp->scale[numSS-1]);
+                  posSS, rangeSS[0], sbp->sigma[0],
+                  rangeSS[1], sbp->sigma[sbp->num-1]);
           airMopError(mop); return 1;
         }
         grid[4 + 5*0] = idxSS;
@@ -757,7 +863,8 @@
                 (_ngrid
                  ? probeSpaceIndex  /* user specifies grid space */
                  : AIR_TRUE),       /* copying vprobe index-space behavior */
-                verbose, clamp)) {
+                verbose, clamp, scaleIsTau,
+                edgeFracInfo[0], edgeFracInfo[1])) {
     /* note hijacking of GAGE key */
     airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
     fprintf(stderr, "%s: trouble probing on grid:\n%s\n", me, err);
diff --color -ruN teem-1.11.0-src.orig/src/bin/ilk.c teem-1.11.0-src/src/bin/ilk.c
--- teem-1.11.0-src.orig/src/bin/ilk.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/ilk.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -43,8 +43,8 @@
   double mat[6], **matList, *origInfo, origMat[6], origInvMat[6], ox, oy,
     min[2], max[2];
   int d, bound, ax0, size[2]; /* HEY size[] should be size_t */
-  unsigned int matListLen, _bkgLen, i, avgNum;
-  float *bkg, *_bkg, scale[4];
+  unsigned int matListLen, _bkgLen, i, avgNum, bkgIdx;
+  float *_bkg, *bkg, scale[4];
 
   me = argv[0];
   mop = airMopNew();
@@ -95,6 +95,7 @@
              "\b\bo \"wrap\": do wrap-around on image locations\n "
              "\b\bo \"pad\": use a given background value (via \"-bg\")",
              NULL, nrrdBoundary);
+  bkgIdx =
   hestOptAdd(&hopt, "bg", "bg0 bg1", airTypeFloat, 1, -1, &_bkg, "nan",
              "background color to use with boundary behavior \"pad\". "
              "Defaults to all zeroes.",
@@ -128,16 +129,18 @@
   if (nrrdBoundaryPad == bound) {
     if (_bkgLen != MOSS_NCOL(nin)) {
       char stmp[AIR_STRLEN_SMALL];
-      fprintf(stderr, "%s: got %d background colors, image has %s colors\n",
+      fprintf(stderr, "%s: got %u background colors, image has %s colors\n",
               me, _bkgLen, airSprintSize_t(stmp, MOSS_NCOL(nin)));
       airMopError(mop); return 1;
     } else {
       bkg = _bkg;
     }
   } else {
-    /* maybe warn user if they gave a background that won't be used? */
-    /* No- because hest is stupid, and right now we always parse the
-       single (default) "nan" for this argument! */
+    if (hestSourceUser == hopt[bkgIdx].source) {
+      fprintf(stderr, "%s: WARNING: got %u background colors, but with %s "
+              "padding, they will not be used\n", me,
+              _bkgLen, airEnumStr(nrrdBoundary, bound));
+    }
     bkg = NULL;
   }
 
@@ -154,24 +157,27 @@
   max[0] = AIR_EXISTS(max[0]) ? max[0] : nin->axis[ax0+0].max;
   min[1] = AIR_EXISTS(min[1]) ? min[1] : nin->axis[ax0+1].min;
   max[1] = AIR_EXISTS(max[1]) ? max[1] : nin->axis[ax0+1].max;
+
   for (d=0; d<2; d++) {
-    switch(AIR_CAST(int, scale[0 + 2*d])) {
+    fprintf(stderr, "%s: scale[0 + 2*%d] = %d\n", me, d,
+            AIR_INT(scale[0 + 2*d]));
+    switch(AIR_INT(scale[0 + 2*d])) {
     case 0:
       /* same number of samples as input */
-      size[d] = AIR_CAST(int, nin->axis[ax0+d].size);
+      size[d] = AIR_INT(nin->axis[ax0+d].size);
       break;
     case 1:
       /* scaling of input # samples */
-      size[d] = AIR_CAST(int, scale[1 + 2*d]*nin->axis[ax0+d].size);
+      size[d] = AIR_INT(scale[1 + 2*d]*nin->axis[ax0+d].size);
       break;
     case 2:
       /* explicit # of samples */
-      size[d] = AIR_CAST(int, scale[1 + 2*d]);
+      size[d] = AIR_INT(scale[1 + 2*d]);
       break;
     default:
       /* error */
       fprintf(stderr, "%s: scale[0 + 2*%d] == %d unexpected\n",
-              me, AIR_CAST(int, scale[0 + 2*d]), d);
+              me, AIR_INT(scale[0 + 2*d]), d);
       airMopError(mop); return 1;
     }
   }
diff --color -ruN teem-1.11.0-src.orig/src/bin/miter.c teem-1.11.0-src/src/bin/miter.c
--- teem-1.11.0-src.orig/src/bin/miter.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/miter.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -173,8 +173,8 @@
   if (offfr) {
     ELL_3V_INCR(muu->hctx->cam->from, muu->hctx->cam->at);
   }
-  muu->hctx->imgSize[0] = AIR_CAST(int, isScale*muu->hctx->imgSize[0]);
-  muu->hctx->imgSize[1] = AIR_CAST(int, isScale*muu->hctx->imgSize[1]);
+  muu->hctx->imgSize[0] = AIR_INT(isScale*muu->hctx->imgSize[0]);
+  muu->hctx->imgSize[1] = AIR_INT(isScale*muu->hctx->imgSize[1]);
 
   muu->nout = nrrdNew();
   airMopAdd(mop, muu->nout, (airMopper)nrrdNuke, airMopAlways);
diff --color -ruN teem-1.11.0-src.orig/src/bin/mrender.c teem-1.11.0-src/src/bin/mrender.c
--- teem-1.11.0-src.orig/src/bin/mrender.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/mrender.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -545,8 +545,8 @@
                  me, info, AIR_TRUE, AIR_TRUE, AIR_TRUE);
   airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);
 
-  uu->hctx->imgSize[0] = AIR_CAST(int, isScale*uu->hctx->imgSize[0]);
-  uu->hctx->imgSize[1] = AIR_CAST(int, isScale*uu->hctx->imgSize[1]);
+  uu->hctx->imgSize[0] = AIR_INT(isScale*uu->hctx->imgSize[0]);
+  uu->hctx->imgSize[1] = AIR_INT(isScale*uu->hctx->imgSize[1]);
 
   uu->whatq = airEnumVal(uu->kind->enm, whatS);
   if (-1 == uu->whatq) {
diff --color -ruN teem-1.11.0-src.orig/src/bin/ninspect.c teem-1.11.0-src/src/bin/ninspect.c
--- teem-1.11.0-src.orig/src/bin/ninspect.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/ninspect.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -31,16 +31,17 @@
 #define NINSPECT "ninspect"
 
 int
-fixproj(Nrrd *nproj[3], Nrrd *nvol) {
+fixproj(Nrrd *nproj[3], const Nrrd *nvol) {
   static const char me[]="fixproj";
   airArray *mop;
   Nrrd *ntmp[3], *nt;
-  int sz[3], ii, map[3], h[3], E, mi;
-  size_t rsz[3];
+  int ii, jj, map[3], h[3], E, mi;
+  size_t rsz[3][3];
   double vec[3][3], dot[3], sp[3], parm[NRRD_KERNEL_PARMS_NUM];
+  unsigned int sz[3];
 
   mop = airMopNew();
-
+  fprintf(stderr, "%s: fixing projections\n", me);
   if (!( ELL_3V_EXISTS(nvol->axis[0].spaceDirection)
          && ELL_3V_EXISTS(nvol->axis[1].spaceDirection)
          && ELL_3V_EXISTS(nvol->axis[2].spaceDirection) )) {
@@ -69,11 +70,11 @@
   ELL_3V_SET(h, 1, 0, 0);
   E = 0;
   for (ii=0; ii<3; ii++) {
-    if (h[map[ii]] != map[h[ii]]) {
-      if (!E) E |= nrrdAxesSwap(ntmp[ii], nproj[map[ii]], 1, 2);
-    } else {
-      if (!E) E |= nrrdCopy(ntmp[ii], nproj[map[ii]]);
-    }
+      if (h[map[ii]] != map[h[ii]]) {
+          if (!E) E |= nrrdAxesSwap(ntmp[ii], nproj[map[ii]], 1, 2);
+      } else {
+          if (!E) E |= nrrdCopy(ntmp[ii], nproj[map[ii]]);
+      }
   }
   if (E) {
     biffMovef(NINSPECT, NRRD, "%s: trouble with nrrd operations", me);
@@ -104,28 +105,52 @@
   }
 
   for (ii=0; ii<3; ii++) {
-    sz[ii] = nvol->axis[map[ii]].size;
+    sz[ii] = AIR_UINT(nvol->axis[map[ii]].size);
     sp[ii] = ELL_3V_LEN(nvol->axis[map[ii]].spaceDirection);
   }
   mi = ELL_MIN3_IDX(sp[0], sp[1], sp[2]);
-  sz[0] = (int)(sz[0]*sp[0]/sp[mi]);
-  sz[1] = (int)(sz[1]*sp[1]/sp[mi]);
-  sz[2] = (int)(sz[2]*sp[2]/sp[mi]);
+  sz[0] = AIR_UINT(sz[0]*sp[0]/sp[mi]);
+  sz[1] = AIR_UINT(sz[1]*sp[1]/sp[mi]);
+  sz[2] = AIR_UINT(sz[2]*sp[2]/sp[mi]);
 
   parm[0] = 1;
-  ELL_3V_SET(rsz, 3, sz[1], sz[2]);
-  nrrdSimpleResample(nproj[0], ntmp[0], nrrdKernelBox, parm, rsz, NULL);
-  ELL_3V_SET(rsz, 3, sz[0], sz[2]);
-  nrrdSimpleResample(nproj[1], ntmp[1], nrrdKernelBox, parm, rsz, NULL);
-  ELL_3V_SET(rsz, 3, sz[0], sz[1]);
-  nrrdSimpleResample(nproj[2], ntmp[2], nrrdKernelBox, parm, rsz, NULL);
+  ELL_3V_SET(rsz[0], 3, sz[1], sz[2]);
+  ELL_3V_SET(rsz[1], 3, sz[0], sz[2]);
+  ELL_3V_SET(rsz[2], 3, sz[0], sz[1]);
+  for (ii=0; ii<3; ii++) {
+      for (jj=0; jj<3; jj++) {
+          /* we own these projections, and our use of nrrdSimpleResample is to
+             simplify things (like not resample the color axis) that might be done
+             more carefully in other settings. onward. */
+          ntmp[ii]->axis[jj].center = nrrdCenterCell;
+          ntmp[ii]->axis[jj].min = 0;
+          ntmp[ii]->axis[jj].max = ntmp[ii]->axis[jj].size;
+          /* sanity check: cancel crazy upsampling */
+          if (rsz[ii][jj] > 5*ntmp[ii]->axis[jj].size) {
+              rsz[ii][jj] = ntmp[ii]->axis[jj].size;
+          }
+      }
+      printf("%s: resampling proj %d : (%u,%u,%u) -> (%u,%u,%u)\n", me, ii,
+             (unsigned int)ntmp[ii]->axis[0].size,
+             (unsigned int)ntmp[ii]->axis[1].size,
+             (unsigned int)ntmp[ii]->axis[2].size,
+             (unsigned int)rsz[ii][0],
+             (unsigned int)rsz[ii][1],
+             (unsigned int)rsz[ii][2]);
+      if (nrrdSimpleResample(nproj[ii], ntmp[ii], nrrdKernelBox,
+                             parm, rsz[ii], NULL)) {
+          biffMovef(NINSPECT, NRRD, "%s: trouble resampling projection %d",
+                    me, ii);
+          airMopError(mop); return 1;
+      }
+  }
 
   airMopOkay(mop);
   return 0;
 }
 
 int
-ninspect_proj(Nrrd *nout, Nrrd *nin, int axis, int smart, float amount) {
+ninspect_proj(Nrrd *nout, const Nrrd *nin, int axis, int smart, float amount) {
   static const char me[]="ninspect_proj";
   airArray *mop;
   Nrrd *ntmpA, *ntmpB, **nrgb;
@@ -182,14 +207,17 @@
 }
 
 int
-doit(Nrrd *nout, Nrrd *nin, int smart, float amount) {
+doit(Nrrd *nout, const Nrrd *nin, int smart, float amount, unsigned int margin,
+     const unsigned char *back) {
   static const char me[]="doit";
   Nrrd *nproj[3];
   airArray *mop;
-  int axis, srl, sap, ssi, E, margin, which;
-  size_t min[3];
+  int E, which;
+  unsigned int axis, srl, sap, ssi;
+  size_t min[3], ii, nn;
+  unsigned char *out;
 
-  if (!(nout && nin)) {
+  if (!(nout && nin && back)) {
     biffAddf(NINSPECT, "%s: got NULL pointer", me);
     return 1;
   }
@@ -204,9 +232,6 @@
   airMopAdd(mop, nproj[1]=nrrdNew(), (airMopper)nrrdNuke, airMopAlways);
   airMopAdd(mop, nproj[2]=nrrdNew(), (airMopper)nrrdNuke, airMopAlways);
 
-  /* how much space to put between and around the projections */
-  margin = 6;
-
   /* do projections for each axis, with some progress indication to sterr */
   for (axis=0; axis<=2; axis++) {
     fprintf(stderr, "%s: doing axis %d projections ... ", me, axis);
@@ -220,16 +245,27 @@
     fprintf(stderr, "done\n");
   }
 
-  if (nrrdSpaceRightAnteriorSuperior == nin->space) {
-    if (fixproj(nproj, nin)) {
-      fprintf(stderr, "ERROR\n");
-      biffAddf(NINSPECT, "%s: trouble orienting projections", me);
-      airMopError(mop); return 1;
-    }
-  }
-  srl = nproj[1]->axis[0+1].size;
-  sap = nproj[0]->axis[0+1].size;
-  ssi = nproj[1]->axis[1+1].size;
+  if ((nrrdSpaceRightAnteriorSuperior == nin->space
+       || nrrdSpaceLeftPosteriorSuperior == nin->space)) {
+      double ejl[3], thresh=0.001;
+      for (ii=0; ii<3; ii++) {
+          ejl[ii] = ELL_3V_LEN(nin->axis[ii].spaceDirection);
+      }
+      if (ejl[0] > thresh && ejl[1] > thresh && ejl[2] > thresh) {
+          if (fixproj(nproj, nin)) {
+              fprintf(stderr, "ERROR\n");
+              biffAddf(NINSPECT, "%s: trouble reorienting/resampling "
+                       "projections", me);
+              airMopError(mop); return 1;
+          }
+      } else {
+          printf("%s not reorienting/resampling projections with edge "
+                 "lens %g,%g,%g\n", me, ejl[0], ejl[1], ejl[2]);
+      }
+  }
+  srl = AIR_UINT(nproj[1]->axis[0+1].size);
+  sap = AIR_UINT(nproj[0]->axis[0+1].size);
+  ssi = AIR_UINT(nproj[1]->axis[1+1].size);
 
   /* allocate output as 8-bit color image.  We know output type is
      nrrdTypeUChar because ninspect_proj finishes each projection
@@ -242,6 +278,12 @@
     airMopError(mop); return 1;
   }
 
+  nn = nout->axis[1].size * nout->axis[2].size;
+  out = AIR_CAST(unsigned char *, nout->data);
+  for (ii=0; ii<nn; ii++) {
+    ELL_3V_COPY(out + 3*ii, back);
+  }
+
   min[0] = 0;
   E = 0;
   which = 0;
@@ -261,24 +303,12 @@
   return 0;
 }
 
-void
-ninspect_usage(void) {
-
-  fprintf(stderr, "\nusage: %s <input volume> <output image>\n\n",
-          NINSPECT);
-  fprintf(stderr, "<input volume>: must be a 3-D array in NRRD or "
-          "NRRD-compatible format.\n");
-  fprintf(stderr, "<output image>: will be saved out in whatever format "
-          "is implied by the\n");
-  fprintf(stderr, "   extension (if recognized), or else in NRRD format\n");
-}
-
 static const char *info =
   ("Quick way of seeing what's inside a 3D volume.  A color image "
    "of three axis-aligned projections is composed of histogram-"
    "equalized and quantized images of the summation (red), "
    "variance (green), and maximum (blue) intensity projections. "
-   "If volume is orientation in RAS space, then a standard "
+   "If volume is orientation in RAS or LPS space, then a standard "
    "orientation is used for projections and projections are "
    "upsampled (with box kernel) to have isotropic pixels.");
 
@@ -290,7 +320,10 @@
   char *outS, *err;
   Nrrd *nin, *nout;
   NrrdIoState *nio;
+  unsigned int margin;
   float heqamount;
+  unsigned int back[3];
+  unsigned char backUC[3];
 
   me = argv[0];
   mop = airMopNew();
@@ -300,6 +333,10 @@
              NULL, NULL, nrrdHestNrrd);
   hestOptAdd(&hopt, "amt", "heq", airTypeFloat, 1, 1, &heqamount, "0.5",
              "how much to apply histogram equalization to projection images");
+  hestOptAdd(&hopt, "m", "margin", airTypeUInt, 1, 1, &margin, "6",
+             "pixel size of margin on boundary, and space between the projections");
+  hestOptAdd(&hopt, "b", "background", airTypeUInt, 3, 3, back, "0 0 0",
+             "background color (8-bit RGB)");
   hestOptAdd(&hopt, "o", "img out", airTypeString, 1, 1, &outS,
              NULL, "output image to save to.  Will try to use whatever "
              "format is implied by extension, but will fall back to PPM.");
@@ -315,7 +352,8 @@
 
   nrrdStateDisableContent = AIR_TRUE;
 
-  if (doit(nout, nin, 1, heqamount)) {
+  ELL_3V_COPY_TT(backUC, unsigned char, back);
+  if (doit(nout, nin, 1, heqamount, margin, backUC)) {
     err=biffGetDone(NINSPECT);
     airMopAdd(mop, err, airFree, airMopAlways);
     fprintf(stderr, "%s: trouble creating output:\n%s", me, err);
diff --color -ruN teem-1.11.0-src.orig/src/bin/nrrdSanity.c teem-1.11.0-src/src/bin/nrrdSanity.c
--- teem-1.11.0-src.orig/src/bin/nrrdSanity.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/nrrdSanity.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -33,8 +33,9 @@
   me = argv[0];
   if (2 == argc) {
     if (!strcmp(argv[1], "--version")) {
-      printf("Teem version %s (%s)\n",
-             airTeemVersion, airTeemReleaseDate);
+      char vbuff[AIR_STRLEN_LARGE];
+      airTeemVersionSprint(vbuff);
+      printf("%s\n", vbuff);
       exit(0);
     } else if (!strcmp(argv[1], "--help")) {
       char par1[] = "\n Usage: nrrdSanity\n ";
diff --color -ruN teem-1.11.0-src.orig/src/bin/overrgb.c teem-1.11.0-src/src/bin/overrgb.c
--- teem-1.11.0-src.orig/src/bin/overrgb.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/overrgb.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -64,13 +64,15 @@
     *nbg,              /* resampled background image */
     *nrgbaD;           /* rgba input as double */
   const char *me;
-  char *outS, *errS;
-  double gamma, contr, cfp, cpow, back[3], *rgbaD, r, g, b, a;
+  char *outS, *errS, *gammaS;
+  double _gamma, contr, cfp, cpow, back[3], *rgbaD, r, g, b, a;
   airArray *mop;
-  int E;
+  int E, srgb;
+  unsigned int srgbIdx;
   size_t min[3], max[3], sx, sy, pi;
   unsigned char *outUC, *bgUC;
   NrrdResampleInfo *rinfo;
+  NrrdIoState *nio = NULL;
 
   me = argv[0];
   mop = airMopNew();
@@ -82,8 +84,21 @@
              "means a complete washout.");
   hestOptAdd(&hopt, "cfp", "fixed point", airTypeDouble, 1, 1, &cfp, "0.5",
              "component level that doesn't change with contrast");
-  hestOptAdd(&hopt, "g", "gamma", airTypeDouble, 1, 1, &gamma, "1.0",
-             "gamma to apply to image data, after contrast");
+  hestOptAdd(&hopt, "g", "gamma", airTypeString, 1, 1, &gammaS, "1.0",
+             "gamma to apply to image data, after contrast. Can be "
+             "a number (<1 to darken >1 to brighten) or the string "
+             "\"srgb\" to apply the roughly 2.2 gamma associated "
+             "with sRGB (see https://en.wikipedia.org/wiki/SRGB). ");
+  srgbIdx = /* HEY copied to unrrdu/quantize.c */
+  hestOptAdd(&hopt, "srgb", "intent", airTypeEnum, 1, 1, &srgb, "none",
+             /* the default is "none" for backwards compatibility: until now
+                Teem's support of PNG hasn't handled the sRGB intent, so
+                we shouldn't start using it without being asked */
+             "If saving to PNG (when supported), how to set the rendering "
+             "intent in the sRGB chunk of the PNG file format. Can be "
+             "absolute, relative, perceptual, saturation, or none. This is "
+             "independent of using \"srgb\" as the -g gamma",
+             NULL, nrrdFormatPNGsRGBIntent);
   hestOptAdd(&hopt, "b", "background", airTypeDouble, 3, 3, back, "0 0 0",
              "background color to composite against; white is "
              "1 1 1, not 255 255 255.");
@@ -106,6 +121,20 @@
             airEnumStr(nrrdType, nrrdTypeBlock));
     airMopError(mop); return 1;
   }
+  /* HEY copied to unrrdu/quantize.c */
+  if (!( !strcmp(gammaS, "srgb") || 1 == sscanf(gammaS, "%lf", &_gamma) )) {
+    fprintf(stderr, "%s: gamma \"%s\" neither \"srgb\" nor "
+            "parseable as double", me, gammaS);
+    airMopError(mop); return 1;
+  }
+
+  if (hestSourceUser == hopt[srgbIdx].source
+      && !nrrdFormatPNG->available()) {
+    fprintf(stderr, "%s: wanted to store sRGB intent \"%s\" in PNG output, but "
+            "this Teem build does not support the PNG file format.", me,
+            airEnumStr(nrrdFormatPNGsRGBIntent, srgb));
+    airMopError(mop); return 1;
+  }
 
   sx = nin->axis[1].size;
   sy = nin->axis[2].size;
@@ -145,8 +174,9 @@
       E = nrrdSpatialResample(nbg, _nbg, rinfo);
     }
     if (E) {
-      fprintf(stderr, "%s: trouble:\n%s", me, errS = biffGetDone(NRRD));
-      free(errS); return 1;
+      airMopAdd(mop, errS = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: trouble:\n%s", me, errS);
+      airMopError(mop); return 1;
     }
   } else {
     nbg = NULL;
@@ -174,8 +204,9 @@
   if (!E) E |= nrrdCrop(nrgbaD, ninD, min, max);
   if (!E) E |= nrrdPPM(nout, sx, sy);
   if (E) {
-    fprintf(stderr, "%s: trouble:\n%s", me, errS = biffGetDone(NRRD));
-    free(errS); return 1;
+    airMopAdd(mop, errS = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: trouble:\n%s", me, errS);
+    airMopError(mop); return 1;
   }
 
   contr = AIR_CLAMP(-1, contr, 1);
@@ -193,9 +224,15 @@
       g = docontrast(g, cfp, cpow);
       b = docontrast(b, cfp, cpow);
     }
-    r = pow(r, 1.0/gamma);
-    g = pow(g, 1.0/gamma);
-    b = pow(b, 1.0/gamma);
+    if (!strcmp(gammaS, "srgb")) {
+      r = nrrdSRGBGamma(r);
+      g = nrrdSRGBGamma(g);
+      b = nrrdSRGBGamma(b);
+    } else {
+      r = pow(r, 1.0/_gamma);
+      g = pow(g, 1.0/_gamma);
+      b = pow(b, 1.0/_gamma);
+    }
     if (bgUC) {
       r = a*r + (1-a)*bgUC[0 + 3*pi]/255;
       g = a*g + (1-a)*bgUC[1 + 3*pi]/255;
@@ -205,16 +242,25 @@
       g = a*g + (1-a)*back[1];
       b = a*b + (1-a)*back[2];
     }
-    outUC[0] = airIndex(0.0, r, 1.0, 256);
-    outUC[1] = airIndex(0.0, g, 1.0, 256);
-    outUC[2] = airIndex(0.0, b, 1.0, 256);
+    outUC[0] = AIR_UCHAR(airIndex(0.0, r, 1.0, 256));
+    outUC[1] = AIR_UCHAR(airIndex(0.0, g, 1.0, 256));
+    outUC[2] = AIR_UCHAR(airIndex(0.0, b, 1.0, 256));
     outUC += 3;
     rgbaD += 4;
   }
 
-  if (nrrdSave(outS, nout, NULL)) {
-    fprintf(stderr, "%s: trouble:\n%s", me, errS = biffGetDone(NRRD));
-    free(errS); return 1;
+  if (hestSourceUser == hopt[srgbIdx].source) {
+    /* HEY copied to unrrdu/quantize.c */
+    nio = nrrdIoStateNew();
+    airMopAdd(mop, nio, (airMopper)nrrdIoStateNix, airMopAlways);
+    nio->PNGsRGBIntentKnown = AIR_TRUE;
+    nio->PNGsRGBIntent = srgb; /* even if it is nrrdFormatPNGsRGBIntentNone;
+                                  that's handled by the writer */
+  }
+  if (nrrdSave(outS, nout, nio)) {
+    airMopAdd(mop, errS = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: trouble:\n%s", me, errS);
+    airMopError(mop); return 1;
   }
 
   airMopOkay(mop);
diff --color -ruN teem-1.11.0-src.orig/src/bin/pprobe.c teem-1.11.0-src/src/bin/pprobe.c
--- teem-1.11.0-src.orig/src/bin/pprobe.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/pprobe.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -229,7 +229,8 @@
     }
     if (gageStackBlurParmScaleSet(sbp, numSS, rangeSS[0], rangeSS[1],
                                   SSuniform, AIR_FALSE)
-        || gageStackBlurParmKernelSet(sbp, kSSblur, AIR_TRUE)
+        || gageStackBlurParmKernelSet(sbp, kSSblur)
+        || gageStackBlurParmRenormalizeSet(sbp, AIR_TRUE)
         || gageStackBlurParmBoundarySet(sbp, nrrdBoundaryBleed, AIR_NAN)
         || gageStackBlurParmVerboseSet(sbp, verbose)
         || gageStackBlur(ninSS, sbp, nin, kind)) {
@@ -276,7 +277,7 @@
     if (!E) E |= gageStackPerVolumeNew(ctx, pvlSS,
                                        AIR_CAST(const Nrrd*const*, ninSS),
                                        numSS, kind);
-    if (!E) E |= gageStackPerVolumeAttach(ctx, pvl, pvlSS, sbp->scale, numSS);
+    if (!E) E |= gageStackPerVolumeAttach(ctx, pvl, pvlSS, sbp->sigma, numSS);
     if (!E) E |= gageKernelSet(ctx, gageKernelStack, kSS->kernel, kSS->parm);
   } else {
     if (!E) E |= gagePerVolumeAttach(ctx, pvl);
diff --color -ruN teem-1.11.0-src.orig/src/bin/puller.c teem-1.11.0-src/src/bin/puller.c
--- teem-1.11.0-src.orig/src/bin/puller.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/puller.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -92,7 +92,7 @@
   val = (fltk::ValueInput *)widget;
   pullVerboseSet(bag->pctx, (int)val->value());
 }
-
+/* ... DEFT ... */
 void
 isovalue_cb(fltk::Widget *widget, pullBag *bag) {
   Deft::Slider *slider;
@@ -135,7 +135,7 @@
     free(err);
     exit(1);
   }
-
+  /* ... DEFT ... */
   cropMin[0] = 0;
   cropMin[1] = 0;
   cropMax[0] = 2;
@@ -163,7 +163,7 @@
     exit(1);
   }
 }
-
+/* ... DEFT ... */
 void
 outputShow(pullBag *bag) {
   char me[]="outputShow", *err;
@@ -195,6 +195,7 @@
   /* bag->ncval = bag->nstuck; */
   /* bag->ncval = bag->nscl; */
 
+  /* ... DEFT ... */
   if (bag->ncval) {
     nrrdRangeSet(bag->cvalRange, bag->ncval, AIR_FALSE);
   } else {
@@ -227,6 +228,7 @@
     bag->cvalRange->min = AIR_LERP(0.7, bag->cvalRange->min, emean - 2*estdv);
     bag->cvalRange->max = AIR_LERP(0.7, bag->cvalRange->max, emean + 2*estdv);
   }
+  /* ... DEFT ... */
   float *cmapOut;
   if (bag->ncmap
       && bag->ncval
@@ -256,6 +258,8 @@
     cmapOut = NULL;
   }
 
+  /* ... DEFT ... */
+
   idcc = AIR_CAST(unsigned int *, bag->nidcc->data);
   stuck = AIR_CAST(unsigned char *, bag->nstuck->data);
   nn = bag->nPosOut->axis[1].size;
@@ -280,6 +284,8 @@
   bag->icvalr[0] = bag->cvalRange->min;
   bag->icvalr[1] = bag->cvalRange->max;
 
+  /* ... DEFT ... */
+
   double *strnOut;
   strnOut = (bag->nstrn
              ? AIR_CAST(double *, bag->nstrn->data)
@@ -315,6 +321,9 @@
       */
     }
   }
+
+  /* ... DEFT ... */
+
   if (1) {
     float *ten, *pos;
     double *posOut;
@@ -351,6 +360,9 @@
       ten += 7;
     }
   }
+
+  /* ... DEFT ... */
+
   if (bag->nPosOut->axis[1].size) {
     bag->glyph->dataSet(bag->nPosOut->axis[1].size,
                         (float*)bag->nten->data, 7,
@@ -378,6 +390,8 @@
   outputShow(bag);
 }
 
+/* ... DEFT ... */
+
 void
 step_cb(fltk::Widget *, pullBag *bag) {
   /*  static double lastthresh = -42; */
@@ -406,6 +420,8 @@
   }
 }
 
+/* ... DEFT ... */
+
 void
 gammaSet_cb(fltk::Widget *, pullBag *bag) {
   char me[]="gammaSet_cb";
@@ -421,6 +437,8 @@
   bag->gamma->value(bag->pctx->sysParm.gamma);
 }
 
+/* ... DEFT ... */
+
 void
 cc_cb(fltk::Widget *, pullBag *bag) {
   char me[]="cc_cb";
@@ -459,6 +477,8 @@
   outputShow(bag);
 }
 
+/* ... DEFT ... */
+
 void
 ccSelect_cb(fltk::Widget *, pullBag *bag) {
 
@@ -476,6 +496,8 @@
   outputShow(bag);
 }
 
+/* ... DEFT ... */
+
 void
 reblur_cb(fltk::Widget *, pullBag *bag) {
   static const char me[]="reblur_cb";
@@ -511,6 +533,8 @@
   return;
 }
 
+/* ... DEFT ... */
+
 void
 scale_cb(fltk::Widget *, pullBag *bag) {
   double sclMean, sclWind;
@@ -540,6 +564,8 @@
   pullSysParmSet(bag->pctx, pullSysParmBeta, bag->beta->value());
 }
 
+/* ... DEFT ... */
+
 void
 cwell_cb(fltk::Widget *, pullBag *bag) {
   double *parm;
@@ -571,6 +597,8 @@
   pullSysParmSet(bag->pctx, pullSysParmGamma, bag->gamma->value());
 }
 
+/* ... DEFT ... */
+
 void
 strength_cb(fltk::Widget *, pullBag *bag) {
 
@@ -599,6 +627,8 @@
     return;
   }
 
+  /* ... DEFT ... */
+
   nPosSel = nrrdNew();
   if (bag->nstrn) {
     nStrnSel = nrrdNew();
@@ -642,6 +672,9 @@
     posAll += 4;
     ten += 7;
   }
+
+  /* ... DEFT ... */
+
   nrrdSave("pos-all.nrrd", bag->nPosOut, NULL);
   if (0) {
     nrrdSave("pos-sel.nrrd", nPosSel, NULL);
@@ -677,7 +710,7 @@
   return;
 }
 
-#endif
+#endif  /* DEFT */
 
 int
 main(int argc, const char **argv) {
@@ -693,7 +726,7 @@
   float anisoThresh, anisoThreshMin, glyphScale, haloTraceBound,
     glyphHaloWidth, glyphNormPow, glyphEvalPow, sqdSharp;
   int glyphType, glyphFacetRes, aniso;
-
+  double ssrange[2];
   pullBag bag;
 #endif
 
@@ -704,24 +737,25 @@
   Nrrd *nPosIn=NULL, *nPosOut;
   pullEnergySpec *enspR, *enspS, *enspWin;
   NrrdKernelSpec *k00, *k11, *k22, *kSSrecon, *kSSblur;
+  NrrdBoundarySpec *bspec;
   pullContext *pctx;
   int E=0, ret=0;
-  unsigned int vsi, vspecNum, idefNum;
-  double ssrange[2], scaleVec[3], glyphScaleRad;
+  unsigned int vspecNum, idefNum;
+  double scaleVec[3], glyphScaleRad;
   /* things that used to be set directly inside pullContext */
   int energyFromStrength, nixAtVolumeEdgeSpace, constraintBeforeSeedThresh,
     binSingle, liveThresholdOnInit, permuteOnRebin, noPopCntlWithZeroAlpha,
     useBetaForGammaLearn, restrictiveAddToBins, noAdd, unequalShapesAllow,
-    popCntlEnoughTest;
+    popCntlEnoughTest, convergenceIgnoresPopCntl, zeroZ;
   int verbose;
   int interType, allowCodimension3Constraints, scaleIsTau, useHalton,
     pointPerVoxel;
   unsigned int samplesAlongScaleNum, pointNumInitial,
     ppvZRange[2], snap, iterMax, stuckIterMax, constraintIterMax,
     popCntlPeriod, addDescent, iterCallback, rngSeed, progressBinMod,
-    threadNum, eipHalfLife;
+    threadNum, eipHalfLife, kssOpi, kssFinished, bspOpi, bspFinished;
   double jitter, stepInitial, constraintStepMin, radiusSpace, binWidthSpace,
-    radiusScale, alpha, beta, gamma, theta, wall, energyIncreasePermit,
+    radiusScale, alpha, beta, _gamma, wall, energyIncreasePermit,
     backStepScale, opporStepScale, energyDecreaseMin, energyDecreasePopCntlMin,
     neighborTrueProb, probeProb, fracNeighNixedMax;
 
@@ -780,7 +814,7 @@
              "hack: turn on fog");
   hestOptAdd(&hopt, "is", "su sv", airTypeInt, 2, 2, imgSize, "640 480",
              "initial window size");
-
+  /* ... DEFT ... */
   /* this tensor stuff is here because we're hijacking the tensor glyph
      object for doing the particle display ... */
   hestOptAdd(&hopt, "a", "aniso", airTypeEnum, 1, 1, &aniso, NULL,
@@ -815,8 +849,7 @@
              "for superquadric glyphs, how much to sharp edges form as a "
              "function of differences between eigenvalues.  Higher values "
              "mean that edges form more easily");
-
-#endif
+#endif /* DEFT */
 
   hestOptAdd(&hopt, "int", "int", airTypeEnum, 1, 1, &interType,
              "justr", "inter-particle energy type", NULL, pullInterType);
@@ -830,6 +863,8 @@
              "butter:16,0.8", "windowing to create locality with additive "
              "scale-space interaction (\"-int add\")",
              NULL, NULL, pullHestEnergySpec);
+  hestOptAdd(&hopt, "zz", "bool", airTypeBool, 1, 1, &zeroZ, "false",
+             "always constrain Z=0, to process 2D images");
   hestOptAdd(&hopt, "efs", "bool", airTypeBool, 1, 1,
              &energyFromStrength, "false",
              "whether or not strength contributes to particle-image energy");
@@ -850,6 +885,9 @@
   hestOptAdd(&hopt, "pcet", "bool", airTypeBool, 1, 1, &popCntlEnoughTest,
              "true", "use neighbor-counting \"enough\" heuristic to "
              "bail out of pop cntl");
+  hestOptAdd(&hopt, "cipc", "bool", airTypeBool, 1, 1, &convergenceIgnoresPopCntl,
+             "false", "convergence test doesn't care if there has been "
+             "recent changes due to population control");
   hestOptAdd(&hopt, "nobin", NULL, airTypeBool, 0, 0,
              &binSingle, NULL,
              "turn off spatial binning (which prevents multi-threading "
@@ -897,9 +935,14 @@
   hestOptAdd(&hopt, "sscp", "path", airTypeString, 1, 1, &cachePathSS, "./",
              "path (without trailing /) for where to read/write "
              "pre-blurred volumes for scale-space");
+  kssOpi =
   hestOptAdd(&hopt, "kssb", "kernel", airTypeOther, 1, 1, &kSSblur,
-             "ds:1,5", "blurring kernel, to sample scale space",
+             "dgauss:1,5", "default blurring kernel, to sample scale space",
              NULL, NULL, nrrdHestKernelSpec);
+  bspOpi =
+  hestOptAdd(&hopt, "bsp", "boundary", airTypeOther, 1, 1, &bspec,
+             "wrap", "default boundary behavior of scale-space blurring",
+             NULL, NULL, nrrdHestBoundarySpec);
   hestOptAdd(&hopt, "kssr", "kernel", airTypeOther, 1, 1, &kSSrecon,
              "hermite", "kernel for reconstructing from scale space samples",
              NULL, NULL, nrrdHestKernelSpec);
@@ -967,11 +1010,8 @@
              "space repulsion (beta=0) and "
              "scale attraction (beta=1)");
   hestOptAdd(&hopt, "gamma", "gamma", airTypeDouble, 1, 1,
-             &gamma, "1.0",
+             &_gamma, "1.0",
              "scaling factor on energy from strength");
-  hestOptAdd(&hopt, "theta", "theta", airTypeDouble, 1, 1,
-             &theta, "0.0",
-             "slope of increasing livethresh wrt scale");
   hestOptAdd(&hopt, "wall", "k", airTypeDouble, 1, 1,
              &wall, "0.0",
              "spring constant on walls");
@@ -1076,11 +1116,14 @@
   pctx = pullContextNew();
   airMopAdd(mop, pctx, (airMopper)pullContextNix, airMopAlways);
   if (pullVerboseSet(pctx, verbose)
+      || pullFlagSet(pctx, pullFlagZeroZ, zeroZ)
       || pullFlagSet(pctx, pullFlagEnergyFromStrength, energyFromStrength)
       || pullFlagSet(pctx, pullFlagNixAtVolumeEdgeSpace, nixAtVolumeEdgeSpace)
       || pullFlagSet(pctx, pullFlagConstraintBeforeSeedThresh,
                      constraintBeforeSeedThresh)
       || pullFlagSet(pctx, pullFlagPopCntlEnoughTest, popCntlEnoughTest)
+      || pullFlagSet(pctx, pullFlagConvergenceIgnoresPopCntl,
+                     convergenceIgnoresPopCntl)
       || pullFlagSet(pctx, pullFlagBinSingle, binSingle)
       || pullFlagSet(pctx, pullFlagNoAdd, noAdd)
       || pullFlagSet(pctx, pullFlagPermuteOnRebin, permuteOnRebin)
@@ -1110,8 +1153,7 @@
       || pullSysParmSet(pctx, pullSysParmBinWidthSpace, binWidthSpace)
       || pullSysParmSet(pctx, pullSysParmAlpha, alpha)
       || pullSysParmSet(pctx, pullSysParmBeta, beta)
-      || pullSysParmSet(pctx, pullSysParmGamma, gamma)
-      || pullSysParmSet(pctx, pullSysParmTheta, theta)
+      || pullSysParmSet(pctx, pullSysParmGamma, _gamma)
       || pullSysParmSet(pctx, pullSysParmWall, wall)
       || pullSysParmSet(pctx, pullSysParmEnergyIncreasePermit,
                         energyIncreasePermit)
@@ -1153,9 +1195,10 @@
     fprintf(stderr, "%s: trouble with flags:\n%s", me, err);
     airMopError(mop); return 1;
   }
-  if (meetPullVolLoadMulti(vspec, vspecNum, cachePathSS,
-                           kSSblur, nrrdBoundaryBleed, AIR_NAN,
-                           verbose)
+  if (meetPullVolStackBlurParmFinishMulti(vspec, vspecNum,
+                                          &kssFinished, &bspFinished,
+                                          kSSblur, bspec)
+      || meetPullVolLoadMulti(vspec, vspecNum, cachePathSS, verbose)
       || meetPullVolAddMulti(pctx, vspec, vspecNum,
                              k00, k11, k22, kSSrecon)
       || meetPullInfoAddMulti(pctx, idef, idefNum)) {
@@ -1163,7 +1206,16 @@
     fprintf(stderr, "%s: trouble with volumes or infos:\n%s", me, err);
     airMopError(mop); return 1;
   }
-
+  if (!kssFinished && hestSourceUser == hopt[kssOpi].source) {
+    fprintf(stderr, "\n\n%s: WARNING! Used the -%s flag, but the "
+            "meetPullVol specified blurring kernels\n\n\n", me,
+            hopt[kssOpi].flag);
+  }
+  if (!bspFinished && hestSourceUser == hopt[bspOpi].source) {
+    fprintf(stderr, "\n\n%s: WARNING! Used the -%s flag, but the "
+            "meetPullVol specified boundary specs\n\n\n", me,
+            hopt[bspOpi].flag);
+  }
   if (pullStart(pctx)) {
     airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
     fprintf(stderr, "%s: trouble starting system:\n%s", me, err);
@@ -1183,6 +1235,7 @@
    *      all lines:    +1      evec0    evec1     -1
    */
 
+#ifdef DEFT
   ssrange[0] = FLT_MAX;
   ssrange[1] = -FLT_MAX;
   for (vsi=0; vsi<vspecNum; vsi++) {
@@ -1197,8 +1250,6 @@
     ssrange[0] = gageTauOfSig(ssrange[0]);
     ssrange[1] = gageTauOfSig(ssrange[1]);
   }
-
-#ifdef DEFT
   /* -------------------------------------------------- */
   /* initialize bag and its UI */
   bag.pctx = pctx;
diff --color -ruN teem-1.11.0-src.orig/src/bin/qbert.c teem-1.11.0-src/src/bin/qbert.c
--- teem-1.11.0-src.orig/src/bin/qbert.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/qbert.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -53,7 +53,7 @@
   anyneed = 0;
   if (uk) {
     for (i=0; i<=2; i++) {
-      anyneed |= need = sz[i] - nin->axis[i].size;
+      anyneed |= !!(need = AIR_INT(sz[i]) - AIR_INT(nin->axis[i].size));
       fprintf(stderr, "%s: sz[%d] = %u -> need = %d --> ",
               me, i, AIR_UINT(nin->axis[i].size), need);
       need = AIR_MAX(0, need);
@@ -90,7 +90,7 @@
   } else {
     for (i=0; i<=2; i++) {
       char stmp[AIR_STRLEN_SMALL];
-      anyneed |= need = sz[i] - nin->axis[i].size;
+      anyneed |= !!(need = AIR_INT(sz[i]) - AIR_INT(nin->axis[i].size));
       fprintf(stderr, "%s: sz[%d] = %s -> need = %d --> ", me, i,
               airSprintSize_t(stmp, nin->axis[i].size), need);
       need = AIR_MAX(0, need);
@@ -98,8 +98,8 @@
       padMin[i] = 0 - (int)floor(need/2.0);
       padMax[i] = nin->axis[i].size - 1 + (int)ceil(need/2.0);
       fprintf(stderr, "pad indices: [%d..%d]\n",
-              AIR_CAST(int, padMin[i]),
-              AIR_CAST(int, padMax[i]));
+              AIR_INT(padMin[i]),
+              AIR_INT(padMax[i]));
     }
     if (anyneed) {
       fprintf(stderr, "%s: padding ... ", me); fflush(stderr);
@@ -264,10 +264,10 @@
       }
       for (i=0; i<sz[0]; i++) {
         gageProbe(ctx, i, j, k);
-        vghF[0] = AIR_CAST(float, *val);
-        vghF[1] = AIR_CAST(float, *gmag);
+        vghF[0] = AIR_FLOAT(*val);
+        vghF[1] = AIR_FLOAT(*gmag);
         if (doH) {
-          vghF[2] = AIR_CAST(float, *scnd);
+          vghF[2] = AIR_FLOAT(*scnd);
         }
         vghF += 2+doH;
       }
@@ -294,10 +294,10 @@
   char me[]="qbertMakeVghHists";
   double minv, maxv, ming, maxg, minh=0, maxh=0;
   float *vghF;
-  unsigned int i;
-  int nval, doH, E, *vhist, *ghist, *hhist=NULL, vi, gi, hi;
+  unsigned int i, nval;
+  int doH, E, *vhist, *ghist, *hhist=NULL, vi, gi, hi;
 
-  nval = nvghF->axis[0].size;
+  nval = AIR_UINT(nvghF->axis[0].size);
   doH = !!(nval == 3);
   vghF = (float *)nvghF->data;
   minv = maxv = vghF[0 + nval*0];
@@ -395,12 +395,12 @@
              Nrrd *nvghF) {
   char me[]="qbertMakeVgh", cmt[AIR_STRLEN_SMALL];
   double minv, maxv, ming, maxg, minh=0, maxh=0;
-  int lose, *vhist, *ghist, *hhist=NULL, bins, vi, gi, hi, nval, doH;
-  unsigned int i;
+  int lose, *vhist, *ghist, *hhist=NULL, vi, gi, hi, doH;
+  unsigned int i, nval, bins;
   unsigned char *vgh;
   float *vghF;
 
-  nval = nvghF->axis[0].size;
+  nval = AIR_UINT(nvghF->axis[0].size);
   doH = !!(nval == 3);
   minv = nvhist->axis[0].min;   maxv = nvhist->axis[0].max;
   ming = nghist->axis[0].min;   maxg = nghist->axis[0].max;
@@ -412,7 +412,7 @@
   }
 
   lose = (int)(perc[0]*sz[0]*sz[1]*sz[2]/100);
-  bins = nvhist->axis[0].size;
+  bins = AIR_UINT(nvhist->axis[0].size);
   i = bins-1;
   while (lose > 0) {
     /* HEY: we're nibbling only from top, even though for signed
@@ -423,7 +423,7 @@
   maxv = AIR_AFFINE(0, i, bins-1, minv, maxv);
 
   lose = (int)(perc[1]*sz[0]*sz[1]*sz[2]/100);
-  bins = nghist->axis[0].size;
+  bins = AIR_UINT(nghist->axis[0].size);
   i = bins-1;
   while (lose > 0) {
     /* nibble from top */
@@ -433,7 +433,7 @@
 
   if (doH) {
     lose = (int)(perc[2]*sz[0]*sz[1]*sz[2]/100);
-    bins = nhhist->axis[0].size;
+    bins = AIR_UINT(nhhist->axis[0].size);
     i = 0;
     while (lose > 0) {
       /* nibble from top and bottom at equal rates */
@@ -467,12 +467,12 @@
   vghF = (float*)nvghF->data;
   for (i=0; i<sz[0]*sz[1]*sz[2]; i++) {
     vi = airIndex(minv, vghF[0], maxv, 254);
-    vgh[0] = AIR_CLAMP(1, vi+1, 254);
+    vgh[0] = AIR_UCHAR(AIR_CLAMP(1, vi+1, 254));
     gi = airIndex(ming, vghF[1], maxg, 254);
-    vgh[1] = AIR_CLAMP(1, gi+1, 254);
+    vgh[1] = AIR_UCHAR(AIR_CLAMP(1, gi+1, 254));
     if (doH) {
       hi = airIndex(minh, vghF[2], maxh, 168);
-      vgh[2] = AIR_CLAMP(1, hi+1, 169);
+      vgh[2] = AIR_UCHAR(AIR_CLAMP(1, hi+1, 169));
     }
     vgh += nval;
     vghF += nval;
diff --color -ruN teem-1.11.0-src.orig/src/bin/spots.c teem-1.11.0-src/src/bin/spots.c
--- teem-1.11.0-src.orig/src/bin/spots.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/spots.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bin/talkweb.c teem-1.11.0-src/src/bin/talkweb.c
--- teem-1.11.0-src.orig/src/bin/talkweb.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/talkweb.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/bin/tend.c teem-1.11.0-src/src/bin/tend.c
--- teem-1.11.0-src.orig/src/bin/tend.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/tend.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -64,8 +64,9 @@
   }
   /* else, we see if its --version */
   if (!strcmp("--version", argv[1])) {
-    printf("Teem version %s (%s)\n",
-           airTeemVersion, airTeemReleaseDate);
+    char vbuff[AIR_STRLEN_LARGE];
+    airTeemVersionSprint(vbuff);
+    printf("%s\n", vbuff);
     exit(0);
   }
   /* else, we should see if they're asking for a command we know about */
@@ -84,7 +85,7 @@
     airMopMem(mop, &argv0, airMopAlways);
     sprintf(argv0, "%s %s", TEND, argv[1]);
 
-    /* run the individual unu program, saving its exit status */
+    /* run the individual tend program, saving its exit status */
     ret = tendCmdList[i]->main(argc-2, argv+2, argv0, hparm);
   } else {
     fprintf(stderr, "%s: unrecognized command: \"%s\"; type \"%s\" for "
diff --color -ruN teem-1.11.0-src.orig/src/bin/undos.c teem-1.11.0-src/src/bin/undos.c
--- teem-1.11.0-src.orig/src/bin/undos.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/undos.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,255 +0,0 @@
-/*
-  Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
-  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
-  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public License
-  (LGPL) as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-  The terms of redistributing and/or modifying this software also
-  include exceptions to the LGPL that facilitate static linking.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this library; if not, write to Free Software Foundation, Inc.,
-  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include <ctype.h>
-#include <errno.h>
-
-#include <teem/air.h>
-#include <teem/hest.h>
-
-static const char *info =
-  ("Converts from DOS text files to normal (converting LF-CR pairs "
-   "to just CR), or, with the \"-r\" option, convert back to DOS, "
-   "for whatever sick and twisted reason you'd have to do that. "
-   "Can also handle legacy MAC text files (only LF). "
-   "Unlike the simple sed or perl scripts for this purpose, "
-   "this program is careful to be idempotent.  Also, this makes "
-   "an effort to not meddle with binary files (on which this may "
-   "be mistakenly invoked).  A message is printed "
-   "to stderr for all the files actually modified. ");
-
-#define CR 10
-#define LF 13
-#define BAD_PERC 5.0
-
-void
-undosConvert(const char *me, char *name, int reverse, int mac,
-             int quiet, int noAction) {
-  airArray *mop;
-  FILE *fin, *fout;
-  char *data=NULL;
-  airArray *dataArr;
-  unsigned int ci;
-  int car, numBad, willConvert;
-  airPtrPtrUnion appu;
-
-  mop = airMopNew();
-  if (!airStrlen(name)) {
-    fprintf(stderr, "%s: empty filename\n", me);
-    airMopError(mop); return;
-  }
-
-  /* -------------------------------------------------------- */
-  /* open input file  */
-  fin = airFopen(name, stdin, "rb");
-  if (!fin) {
-    if (!quiet) {
-      fprintf(stderr, "%s: couldn't open \"%s\" for reading: \"%s\"\n",
-              me, name, strerror(errno));
-    }
-    airMopError(mop); return;
-  }
-  airMopAdd(mop, fin, (airMopper)airFclose, airMopOnError);
-
-  /* -------------------------------------------------------- */
-  /* create buffer */
-  appu.c = &data;
-  dataArr = airArrayNew(appu.v, NULL, sizeof(char), AIR_STRLEN_HUGE);
-  if (!dataArr) {
-    if (!quiet) {
-      fprintf(stderr, "%s: internal allocation error #1\n", me);
-    }
-    airMopError(mop); return;
-  }
-  airMopAdd(mop, dataArr, (airMopper)airArrayNuke, airMopAlways);
-
-  /* -------------------------------------------------------- */
-  /* read input file, testing for binary-ness along the way */
-  numBad = 0;
-  car = getc(fin);
-  if (EOF == car) {
-    if (!quiet) {
-      fprintf(stderr, "%s: \"%s\" is empty, skipping ...\n", me, name);
-    }
-    airMopError(mop); return;
-  }
-  do {
-    ci = airArrayLenIncr(dataArr, 1);
-    if (!dataArr->data) {
-      if (!quiet) {
-        fprintf(stderr, "%s: internal allocation error #2\n", me);
-      }
-      airMopError(mop); return;
-    }
-    data[ci] = car;
-    numBad += !(isprint(car) || isspace(car));
-    car = getc(fin);
-  } while (EOF != car && BAD_PERC > 100.0*numBad/dataArr->len);
-  if (EOF != car) {
-    if (!quiet) {
-      fprintf(stderr, "%s: more than %g%% of \"%s\" is non-printing, "
-              "skipping ...\n", me, BAD_PERC, name);
-    }
-    airMopError(mop); return;
-  }
-  fin = airFclose(fin);
-
-  /* -------------------------------------------------------- */
-  /* see if we really need to do anything */
-  willConvert = AIR_FALSE;
-  if (!strcmp("-", name)) {
-    willConvert = AIR_TRUE;
-  } else if (reverse) {
-    for (ci=0; ci<dataArr->len; ci++) {
-      if (mac) {
-        if (CR == data[ci]) {
-          willConvert = AIR_TRUE;
-          break;
-        }
-      } else {
-        if (CR == data[ci] && (ci && LF != data[ci-1])) {
-          willConvert = AIR_TRUE;
-          break;
-        }
-      }
-    }
-  } else {
-    for (ci=0; ci<dataArr->len; ci++) {
-      if (mac) {
-        if (LF == data[ci]) {
-          willConvert = AIR_TRUE;
-          break;
-        }
-      } else {
-        if (LF == data[ci] && (ci+1<dataArr->len && CR == data[ci+1])) {
-          willConvert = AIR_TRUE;
-          break;
-        }
-      }
-    }
-  }
-  if (!willConvert) {
-    /* no, we don't need to do anything; quietly quit */
-    airMopOkay(mop);
-    return;
-  } else {
-    if (!quiet) {
-      fprintf(stderr, "%s: %s \"%s\" %s %s ... \n", me,
-              noAction ? "would convert" : "converting",
-              name,
-              reverse ? "to" : "from",
-              mac ? "MAC" : "DOS");
-    }
-  }
-  if (noAction) {
-    /* just joking, we won't actually write anything.
-       (yes, even if input was stdin) */
-    airMopOkay(mop);
-    return;
-  }
-
-  /* -------------------------------------------------------- */
-  /* open output file */
-  fout = airFopen(name, stdout, "wb");
-  if (!fout) {
-    if (!quiet) {
-      fprintf(stderr, "%s: couldn't open \"%s\" for writing: \"%s\"\n",
-              me, name, strerror(errno));
-    }
-    airMopError(mop); return;
-  }
-  airMopAdd(mop, fout, (airMopper)airFclose, airMopOnError);
-
-  /* -------------------------------------------------------- */
-  /* write output file */
-  car = 'a';
-  if (reverse) {
-    for (ci=0; ci<dataArr->len; ci++) {
-      if ((mac && CR == data[ci])
-          || (CR == data[ci] && (ci && LF != data[ci-1]))) {
-        car = putc(LF, fout);
-        if (!mac && EOF != car) {
-          car = putc(CR, fout);
-        }
-      } else {
-        car = putc(data[ci], fout);
-      }
-    }
-  } else {
-    for (ci=0; EOF != car && ci<dataArr->len; ci++) {
-      if ((mac && LF == data[ci])
-          || (LF == data[ci] && (ci+1<dataArr->len && CR == data[ci+1]))) {
-        car = putc(CR, fout);
-        ci += !mac;
-      } else {
-        car = putc(data[ci], fout);
-      }
-    }
-  }
-  if (EOF == car) {
-    if (!quiet) {
-      fprintf(stderr, "%s: ERROR writing \"%s\" possible data loss !!! "
-              "(sorry)\n", me, name);
-    }
-  }
-  fout = airFclose(fout);
-
-  airMopOkay(mop);
-  return;
-}
-
-int
-main(int argc, const char *argv[]) {
-  const char *me;
-  char **name;
-  int lenName, ni, reverse, quiet, noAction, mac;
-  hestOpt *hopt = NULL;
-  airArray *mop;
-
-  me = argv[0];
-  hestOptAdd(&hopt, "r", NULL, airTypeInt, 0, 0, &reverse, NULL,
-             "convert back to DOS, instead of converting from DOS to normal");
-  hestOptAdd(&hopt, "q", NULL, airTypeInt, 0, 0, &quiet, NULL,
-             "never print anything to stderr, even for errors.");
-  hestOptAdd(&hopt, "m", NULL, airTypeInt, 0, 0, &mac, NULL,
-             "deal with legacy MAC text files.");
-  hestOptAdd(&hopt, "n", NULL, airTypeInt, 0, 0, &noAction, NULL,
-             "don't actually write converted files, just pretend to. "
-             "This is useful to see which files WOULD be converted. ");
-  hestOptAdd(&hopt, NULL, "file", airTypeString, 1, -1, &name, NULL,
-             "all the files to convert.  Each file will be over-written "
-             "with its converted contents.  Use \"-\" to read from stdin "
-             "and write to stdout", &lenName);
-  hestParseOrDie(hopt, argc-1, argv+1, NULL, me, info,
-                 AIR_TRUE, AIR_TRUE, AIR_TRUE);
-  mop = airMopNew();
-  airMopAdd(mop, hopt, (airMopper)hestOptFree, airMopAlways);
-  airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);
-
-  for (ni=0; ni<lenName; ni++) {
-    undosConvert(me, name[ni], reverse, mac, quiet, noAction);
-  }
-
-  airMopOkay(mop);
-  return 0;
-}
diff --color -ruN teem-1.11.0-src.orig/src/bin/ungantry.c teem-1.11.0-src/src/bin/ungantry.c
--- teem-1.11.0-src.orig/src/bin/ungantry.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/ungantry.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -44,7 +44,8 @@
   float angle;
   double xs, ys, zs, y, z, padval;
   const double *val;
-  int sx, sy, sz, E, xi, yi, zi, clamp;
+  int E, clamp;
+  unsigned int sx, sy, sz, xi, yi, zi;
   NrrdKernelSpec *gantric;
   void *out;
   double (*insert)(void *v, size_t I, double d);
@@ -86,9 +87,9 @@
   hestParseOrDie(hopt, argc-1, argv+1, hparm,
                  me, info, AIR_TRUE, AIR_TRUE, AIR_TRUE);
 
-  sx = nin->axis[0].size;
-  sy = nin->axis[1].size;
-  sz = nin->axis[2].size;
+  sx = AIR_UINT(nin->axis[0].size);
+  sy = AIR_UINT(nin->axis[1].size);
+  sz = AIR_UINT(nin->axis[2].size);
   xs = nin->axis[0].spacing;
   ys = nin->axis[1].spacing;
   zs = nin->axis[2].spacing;
diff --color -ruN teem-1.11.0-src.orig/src/bin/unu.c teem-1.11.0-src/src/bin/unu.c
--- teem-1.11.0-src.orig/src/bin/unu.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/unu.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -88,8 +88,9 @@
   }
   /* else, we see if its --version */
   if (!strcmp("--version", argv[1])) {
-    printf("Teem version %s (%s)\n",
-           airTeemVersion, airTeemReleaseDate);
+    char vbuff[AIR_STRLEN_LARGE];
+    airTeemVersionSprint(vbuff);
+    printf("%s\n", vbuff);
     exit(0);
   }
   /* else, we should see if they're asking for a command we know about */
diff --color -ruN teem-1.11.0-src.orig/src/bin/vprobe.c teem-1.11.0-src/src/bin/vprobe.c
--- teem-1.11.0-src.orig/src/bin/vprobe.c	2012-12-20 22:08:17.000000000 +0800
+++ teem-1.11.0-src/src/bin/vprobe.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -46,7 +46,7 @@
   hestParm *hparm;
   hestOpt *hopt = NULL;
   NrrdKernelSpec *k00, *k11, *k22, *kSS, *kSSblur;
-  int what, E=0, renorm, SSuniform, SSoptim, verbose,
+  int what, E=0, renorm, SSuniform, SSoptim, verbose, zeroZ,
     orientationFromSpacing, SSnormd;
   unsigned int iBaseDim, oBaseDim, axi, numSS, ninSSIdx, seed;
   const double *answer;
@@ -122,6 +122,9 @@
              NULL, NULL, nrrdHestKernelSpec);
   hestOptAdd(&hopt, "seed", "N", airTypeUInt, 1, 1, &seed, "42",
              "RNG seed; mostly for debugging");
+  hestOptAdd(&hopt, "zz", "bool", airTypeBool, 1, 1, &zeroZ, "false",
+             "enable \"zeroZ\" behavior in gage that partially "
+             "implements working with 3D images as if they are 2D");
 
   hestOptAdd(&hopt, "ssn", "SS #", airTypeUInt, 1, 1, &numSS,
              "0", "how many scale-space samples to evaluate, or, "
@@ -223,7 +226,8 @@
     }
     if (gageStackBlurParmScaleSet(sbp, numSS, rangeSS[0], rangeSS[1],
                                   SSuniform, SSoptim)
-        || gageStackBlurParmKernelSet(sbp, kSSblur, AIR_TRUE)
+        || gageStackBlurParmKernelSet(sbp, kSSblur)
+        || gageStackBlurParmRenormalizeSet(sbp, AIR_TRUE)
         || gageStackBlurParmBoundarySet(sbp, nrrdBoundaryBleed, AIR_NAN)
         || gageStackBlurParmVerboseSet(sbp, verbose)) {
       airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
@@ -268,20 +272,20 @@
        So here, we have to actually replicate work that is done by
        _gageProbeSpace() in converting from world to index space */
     for (vi=0; vi<numSS-1; vi++) {
-      if (AIR_IN_CL(sbp->scale[vi], wrlSS, sbp->scale[vi+1])) {
-        idxSS = vi + AIR_AFFINE(sbp->scale[vi], wrlSS, sbp->scale[vi+1], 0, 1);
+      if (AIR_IN_CL(sbp->sigma[vi], wrlSS, sbp->sigma[vi+1])) {
+        idxSS = vi + AIR_AFFINE(sbp->sigma[vi], wrlSS, sbp->sigma[vi+1], 0, 1);
         if (verbose > 1) {
           fprintf(stderr, "%s: scale pos %g -> idx %g = %u + %g\n", me,
                   wrlSS, idxSS, vi,
-                  AIR_AFFINE(sbp->scale[vi], wrlSS, sbp->scale[vi+1], 0, 1));
+                  AIR_AFFINE(sbp->sigma[vi], wrlSS, sbp->sigma[vi+1], 0, 1));
         }
         break;
       }
     }
     if (vi == numSS-1) {
       fprintf(stderr, "%s: scale pos %g outside range %g=%g, %g=%g\n", me,
-              wrlSS, rangeSS[0], sbp->scale[0],
-              rangeSS[1], sbp->scale[numSS-1]);
+              wrlSS, rangeSS[0], sbp->sigma[0],
+              rangeSS[1], sbp->sigma[numSS-1]);
       airMopError(mop); return 1;
     }
   } else {
@@ -298,6 +302,7 @@
   airMopAdd(mop, ctx, AIR_CAST(airMopper, gageContextNix), airMopAlways);
   gageParmSet(ctx, gageParmGradMagCurvMin, gmc);
   gageParmSet(ctx, gageParmVerbose, verbose);
+  gageParmSet(ctx, gageParmTwoDimZeroZ, zeroZ);
   gageParmSet(ctx, gageParmRenormalize, renorm ? AIR_TRUE : AIR_FALSE);
   gageParmSet(ctx, gageParmCheckIntegrals, AIR_TRUE);
   gageParmSet(ctx, gageParmOrientationFromSpacing, orientationFromSpacing);
@@ -316,7 +321,7 @@
     if (!E) E |= gageStackPerVolumeNew(ctx, pvlSS,
                                        AIR_CAST(const Nrrd*const*, ninSS),
                                        numSS, kind);
-    if (!E) E |= gageStackPerVolumeAttach(ctx, pvl, pvlSS, sbp->scale, numSS);
+    if (!E) E |= gageStackPerVolumeAttach(ctx, pvl, pvlSS, sbp->sigma, numSS);
     if (!E) E |= gageKernelSet(ctx, gageKernelStack, kSS->kernel, kSS->parm);
   } else {
     if (!E) E |= gagePerVolumeAttach(ctx, pvl);
@@ -390,13 +395,13 @@
     if (!E) E |= nrrdMaybeAlloc_va(nout=nrrdNew(), otype, 3,
                                    sox, soy, soz);
   }
-  airMopAdd(mop, nout, AIR_CAST(airMopper, nrrdNuke), airMopAlways);
   if (E) {
     airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
     fprintf(stderr, "%s: trouble:\n%s\n", me, err);
     airMopError(mop);
     return 1;
   }
+  airMopAdd(mop, nout, AIR_CAST(airMopper, nrrdNuke), airMopAlways);
 
   hackSet = nrrdGetenvUInt(&hackZi, &hackValStr, hackKeyStr);
   if (AIR_FALSE == hackSet) {
diff --color -ruN teem-1.11.0-src.orig/src/CODING.txt teem-1.11.0-src/src/CODING.txt
--- teem-1.11.0-src.orig/src/CODING.txt	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/CODING.txt	2021-02-18 15:42:38.000000000 +0800
@@ -72,7 +72,7 @@
 #  define COIL_TYPE_FLOAT 1
 #endif
 
-This is actually consequential; the current teem/python/ctypes/teem-gen.py
+This is actually consequential; the current teem/python/ctypes/gen-teem.py
 (automated ctypes wrapper generator) will skip over "# defines" and only
 reflect the setting of "#defines" in the python interface.  (It would
 obviously be better to generate python wrappings that reflected the correct
@@ -314,10 +314,10 @@
 read: read from file descriptors; a system call
 exp, log2: math functions, oops
 
-* It would be nice of Teem can compile without warnings as C++ code as well;
+* It would be nice if Teem can compile without warnings as C++ code;
 There are two main issues:
 - void* can't be implicitly cast to some other pointer type as part of
-  an assingment, so an explicit cast (via AIR_CAST or something else) is
+  an assignment, so an explicit cast (via AIR_CAST or something else) is
   needed.  This decreases the utility of airFree returning NULL for the
   "x = airFree(x)" idiom, but its usage was decreased anyway with compiler
   warnings about "x set but not used".
@@ -328,20 +328,10 @@
 doing this are not very slick, including the drawback that the information
 from ctypeslib is apparently randomly ordered: without changes in Teem, the
 generated teem.py will differ. Nonetheless, keeping teem.py up-to-date will
-avoid creating problems for users.  Here is the command that GLK uses to do
-this (including various paths that are specific to his laptop)
-
-    echo ===== cd ~/teem-svn && cd ~/teem-svn \
- && echo ===== svn update && svn update \
- && echo ===== cd ../teem-svn-build && cd ../teem-svn-build \
- && echo ===== make && make \
- && echo ===== make install && make install \
- && echo ===== cd ~/teem/python/ctypes && cd ~/teem/python/ctypes \
- && echo ===== python teem-gen.py ctypeslib-gccxml-0.9 ~/teem-svn-install \
-            && python teem-gen.py ctypeslib-gccxml-0.9 ~/teem-svn-install \
- && echo ===== svn diff && svn diff
-
-followed by "svn commit" if needed.
+avoid creating problems for users.  There is a new script for this in
+teem/python/ctypes/go-gen-teem.sh, which is pretty hacky right now (since
+it presumes the directory structure on GLK's laptop!); ideas for improvement
+are welcome.
 
 * Make casts grep-able.  This usually means using AIR_CAST, but can also mean
 using macros AIR_VOIDP, AIR_CVOIDP, AIR_UINT, AIR_INT, and the ell macros
diff --color -ruN teem-1.11.0-src.orig/src/coil/CMakeLists.txt teem-1.11.0-src/src/coil/CMakeLists.txt
--- teem-1.11.0-src.orig/src/coil/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/coil/CMakeLists.txt	2021-02-18 15:42:34.000000000 +0800
@@ -0,0 +1,16 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(COIL_SOURCES
+  coil.h
+  coreCoil.c
+  defaultsCoil.c
+  enumsCoil.c
+  methodsCoil.c
+  realmethods.c
+  scalarCoil.c
+  tensorCoil.c
+  )
+
+target_sources(teem PRIVATE ${COIL_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( coil FILES ${COIL_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/coil/coil.h teem-1.11.0-src/src/coil/coil.h
--- teem-1.11.0-src.orig/src/coil/coil.h	2012-12-20 22:08:41.000000000 +0800
+++ teem-1.11.0-src/src/coil/coil.h	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/coil/coreCoil.c teem-1.11.0-src/src/coil/coreCoil.c
--- teem-1.11.0-src.orig/src/coil/coreCoil.c	2012-12-20 22:08:41.000000000 +0800
+++ teem-1.11.0-src/src/coil/coreCoil.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -110,9 +110,10 @@
   return;
 }
 
-int
+unsigned int
 _coilThisZGet(coilTask *task, int doFilter) {
-  int thisZ, *thisFlag, *thatFlag;
+  int *thisFlag, *thatFlag;
+  unsigned int thisZ;
 
   if (doFilter) {
     thisFlag = &(task->cctx->todoFilter);
@@ -131,7 +132,7 @@
     task->cctx->nextSlice = 0;
     *thisFlag = AIR_FALSE;
   }
-  thisZ = task->cctx->nextSlice;
+  thisZ = AIR_UINT(task->cctx->nextSlice);
   if (task->cctx->nextSlice < task->cctx->size[2]) {
     task->cctx->nextSlice++;
     if (task->cctx->nextSlice == task->cctx->size[2]) {
@@ -148,16 +149,16 @@
 void
 _coilProcess(coilTask *task, int doFilter) {
   static const char me[]="_coilProcess";
-  int xi, yi, sizeX, sizeY, thisZ, sizeZ, valLen, radius;
+  unsigned int xi, yi, sizeX, sizeY, thisZ, sizeZ, valLen, radius;
   coil_t *here;
   void (*filter)(coil_t *delta, int xi, int yi, int zi,
                  coil_t **iv3, double spacing[3],
                  double parm[COIL_PARMS_NUM]);
 
-  sizeX = task->cctx->size[0];
-  sizeY = task->cctx->size[1];
-  sizeZ = task->cctx->size[2];
-  valLen = task->cctx->kind->valLen;
+  sizeX = AIR_UINT(task->cctx->size[0]);
+  sizeY = AIR_UINT(task->cctx->size[1]);
+  sizeZ = AIR_UINT(task->cctx->size[2]);
+  valLen = AIR_UINT(task->cctx->kind->valLen);
   radius = task->cctx->radius;
   filter = task->cctx->kind->filter[task->cctx->method->type];
   if (doFilter) {
diff --color -ruN teem-1.11.0-src.orig/src/coil/defaultsCoil.c teem-1.11.0-src/src/coil/defaultsCoil.c
--- teem-1.11.0-src.orig/src/coil/defaultsCoil.c	2012-12-20 22:08:41.000000000 +0800
+++ teem-1.11.0-src/src/coil/defaultsCoil.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/coil/enumsCoil.c teem-1.11.0-src/src/coil/enumsCoil.c
--- teem-1.11.0-src.orig/src/coil/enumsCoil.c	2012-12-20 22:08:41.000000000 +0800
+++ teem-1.11.0-src/src/coil/enumsCoil.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/coil/GNUmakefile teem-1.11.0-src/src/coil/GNUmakefile
--- teem-1.11.0-src.orig/src/coil/GNUmakefile	2012-12-20 22:08:41.000000000 +0800
+++ teem-1.11.0-src/src/coil/GNUmakefile	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/coil/methodsCoil.c teem-1.11.0-src/src/coil/methodsCoil.c
--- teem-1.11.0-src.orig/src/coil/methodsCoil.c	2012-12-20 22:08:41.000000000 +0800
+++ teem-1.11.0-src/src/coil/methodsCoil.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/coil/realmethods.c teem-1.11.0-src/src/coil/realmethods.c
--- teem-1.11.0-src.orig/src/coil/realmethods.c	2012-12-20 22:08:41.000000000 +0800
+++ teem-1.11.0-src/src/coil/realmethods.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/coil/scalarCoil.c teem-1.11.0-src/src/coil/scalarCoil.c
--- teem-1.11.0-src.orig/src/coil/scalarCoil.c	2012-12-20 22:08:41.000000000 +0800
+++ teem-1.11.0-src/src/coil/scalarCoil.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/coil/sources.cmake teem-1.11.0-src/src/coil/sources.cmake
--- teem-1.11.0-src.orig/src/coil/sources.cmake	2012-12-20 22:08:41.000000000 +0800
+++ teem-1.11.0-src/src/coil/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,14 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(COIL_SOURCES
-  coil.h
-  coreCoil.c
-  defaultsCoil.c
-  enumsCoil.c
-  methodsCoil.c
-  realmethods.c
-  scalarCoil.c
-  tensorCoil.c
-  )
-
-ADD_TEEM_LIBRARY(coil ${COIL_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/coil/tensorCoil.c teem-1.11.0-src/src/coil/tensorCoil.c
--- teem-1.11.0-src.orig/src/coil/tensorCoil.c	2012-12-20 22:08:41.000000000 +0800
+++ teem-1.11.0-src/src/coil/tensorCoil.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/coil/test/coiler.c teem-1.11.0-src/src/coil/test/coiler.c
--- teem-1.11.0-src.orig/src/coil/test/coiler.c	2012-12-20 22:08:39.000000000 +0800
+++ teem-1.11.0-src/src/coil/test/coiler.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../coil.h"
 
-char *info = ("Test program for coil library.");
+const char *info = ("Test program for coil library.");
 
 int
 main(int argc, const char *argv[]) {
diff --color -ruN teem-1.11.0-src.orig/src/doc/how-does-pull-work.graffle teem-1.11.0-src/src/doc/how-does-pull-work.graffle
--- teem-1.11.0-src.orig/src/doc/how-does-pull-work.graffle	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/doc/how-does-pull-work.graffle	2021-02-18 15:42:38.000000000 +0800
@@ -0,0 +1,3335 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>ActiveLayerIndex</key>
+	<integer>0</integer>
+	<key>ApplicationVersion</key>
+	<array>
+		<string>com.omnigroup.OmniGraffle</string>
+		<string>139.18.0.187838</string>
+	</array>
+	<key>AutoAdjust</key>
+	<true/>
+	<key>BackgroundGraphic</key>
+	<dict>
+		<key>Bounds</key>
+		<string>{{0, 0}, {3456, 1466}}</string>
+		<key>Class</key>
+		<string>SolidGraphic</string>
+		<key>FontInfo</key>
+		<dict>
+			<key>Font</key>
+			<string>Courier</string>
+			<key>Size</key>
+			<real>14</real>
+		</dict>
+		<key>ID</key>
+		<integer>2</integer>
+		<key>Style</key>
+		<dict>
+			<key>shadow</key>
+			<dict>
+				<key>Draws</key>
+				<string>NO</string>
+			</dict>
+			<key>stroke</key>
+			<dict>
+				<key>Draws</key>
+				<string>NO</string>
+			</dict>
+		</dict>
+	</dict>
+	<key>BaseZoom</key>
+	<integer>0</integer>
+	<key>CanvasOrigin</key>
+	<string>{0, 0}</string>
+	<key>ColumnAlign</key>
+	<integer>1</integer>
+	<key>ColumnSpacing</key>
+	<real>36</real>
+	<key>CreationDate</key>
+	<string>2013-08-30 14:48:35 +0000</string>
+	<key>Creator</key>
+	<string>Gordon L. Kindlmann</string>
+	<key>DisplayScale</key>
+	<string>1 0/72 in = 1.0000 in</string>
+	<key>GraphDocumentVersion</key>
+	<integer>8</integer>
+	<key>GraphicsList</key>
+	<array>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>150</integer>
+			</dict>
+			<key>ID</key>
+			<integer>151</integer>
+			<key>Points</key>
+			<array>
+				<string>{507, 621.33261805058851}</string>
+				<string>{622, 644.69576458940378}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>92</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{622, 631}, {343, 97}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>150</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs26 \cf0 And then depending on mode:\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f1\fs28 \cf0 _pullIterFinishDescent(pctx) 
+\fs22 (binningPull.c)\
+
+\fs28 _pullIterFinishNeighLearn(pctx) 
+\fs22 (popcntl.c)\
+
+\fs28 _pullIterFinishAdding(pctx) 
+\fs22 (popcntl.c)\
+
+\fs28 _pullIterFinishNixing(pctx) 
+\fs22 (popcntl.c)\
+}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>134</integer>
+			</dict>
+			<key>ID</key>
+			<integer>149</integer>
+			<key>Points</key>
+			<array>
+				<string>{1757, 405.07118014952539}</string>
+				<string>{2814, 284.39279833024972}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>141</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>134</integer>
+			</dict>
+			<key>ID</key>
+			<integer>148</integer>
+			<key>Points</key>
+			<array>
+				<string>{1808, 353.56239154738722}</string>
+				<string>{2814, 282.37436372821122}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>140</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>134</integer>
+			</dict>
+			<key>ID</key>
+			<integer>147</integer>
+			<key>Points</key>
+			<array>
+				<string>{1757, 306.02181255784575}</string>
+				<string>{2814, 280.21899185000126}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>142</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>ControlPoints</key>
+			<array>
+				<string>{451.66666666666669, 8.4085398950263279}</string>
+				<string>{-485, 131.27125159859725}</string>
+			</array>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>141</integer>
+			</dict>
+			<key>ID</key>
+			<integer>146</integer>
+			<key>Points</key>
+			<array>
+				<string>{366, 338.48441604220858}</string>
+				<string>{1513, 411.25936592839435}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>Bezier</key>
+					<true/>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>143</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>ControlPoints</key>
+			<array>
+				<string>{451.66666666666669, -7.5609168689539956}</string>
+				<string>{-465, 184.53084449158177}</string>
+			</array>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>140</integer>
+			</dict>
+			<key>ID</key>
+			<integer>145</integer>
+			<key>Points</key>
+			<array>
+				<string>{366, 335.71800058901323}</string>
+				<string>{1513, 360.77748393662671}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>Bezier</key>
+					<true/>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>143</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>ControlPoints</key>
+			<array>
+				<string>{451.66666666666669, -23.780204233317438}</string>
+				<string>{-442, 232.57671236267248}</string>
+			</array>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>142</integer>
+			</dict>
+			<key>ID</key>
+			<integer>144</integer>
+			<key>Points</key>
+			<array>
+				<string>{366, 333.00706650681587}</string>
+				<string>{1513, 311.30803267728112}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>Bezier</key>
+					<true/>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>143</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{233, 320.26511859893799}, {133, 28}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>12</real>
+			</dict>
+			<key>ID</key>
+			<integer>143</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs26 \cf0 _pullPointSetup()\
+
+\fs20 (pointPull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{1513, 294}, {244, 30}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>142</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 pullPointInitializePerVoxel()\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\fs22 \cf0 (pointPull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{1513, 404}, {244, 30}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>141</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 pullPointInitializeGivenPos()\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\fs22 \cf0 (pointPull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{1513, 349}, {295, 30}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>140</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 pullPointInitializeRandomOrHalton()\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\fs22 \cf0 (pointPull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>134</integer>
+			</dict>
+			<key>ID</key>
+			<integer>138</integer>
+			<key>Points</key>
+			<array>
+				<string>{2353.8882430305039, 397.167724609375}</string>
+				<string>{2814, 289.92233875461045}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>132</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>134</integer>
+			</dict>
+			<key>ID</key>
+			<integer>137</integer>
+			<key>Points</key>
+			<array>
+				<string>{2891.4088829463844, 704}</string>
+				<string>{2861.5911170536156, 294.0838623046875}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>136</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{2825, 704}, {135, 30}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>136</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 pullGammaLearn()\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\fs22 \cf0 (actionPull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>134</integer>
+			</dict>
+			<key>ID</key>
+			<integer>135</integer>
+			<key>Points</key>
+			<array>
+				<string>{2593.0733965799559, 463.8914794921875}</string>
+				<string>{2838.7941898589015, 294.0838623046875}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>127</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{2814, 264.0838623046875}, {93, 30}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>134</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 pullProbe()\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\fs22 \cf0 (pointPull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>132</integer>
+			</dict>
+			<key>ID</key>
+			<integer>133</integer>
+			<key>Points</key>
+			<array>
+				<string>{1948.3567570479838, 523.65988159179688}</string>
+				<string>{2243.6326429507089, 427.167724609375}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>119</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{2188.5341796875, 397.167724609375}, {202, 30}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>132</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 _pullConstraintSatisfy()\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\fs22 \cf0 (constraints.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>129</integer>
+			</dict>
+			<key>ID</key>
+			<integer>130</integer>
+			<key>Points</key>
+			<array>
+				<string>{2340.76708984375, 542.49571322392671}</string>
+				<string>{2478.068359375, 547.92524469608713}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>126</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{2478.068359375, 512.54193115234375}, {359.931640625, 85}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>Vertical</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>129</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fswiss\fcharset0 Helvetica;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 _pullEnergyFromPoints() 
+\fs22 (actionPull.c)\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f1\fs28 \cf0 This also has the job of learning the true point neighborhood during pullProcessModeNeighLearn,\
+as well as computing other things averaged over neighbors, like point-&gt;neighDistMean and point-&gt;stability}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>127</integer>
+			</dict>
+			<key>ID</key>
+			<integer>128</integer>
+			<key>Points</key>
+			<array>
+				<string>{2320.049225140227, 523.65988159179688}</string>
+				<string>{2537.5468941653298, 480.8914794921875}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>126</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{2454.2734375, 463.8914794921875}, {253, 17}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>127</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 _energyFromImage() 
+\fs22 (actionPull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{2146.76708984375, 523.65988159179688}, {194, 30}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>126</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 _pullPointEnergyTotal()\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\fs22 \cf0 (actionPull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{1762.345947265625, 553}, {325, 98}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>ID</key>
+			<integer>124</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 \
+_pullPointProcessNeighLearn() 
+\fs22 (popcntl.c)\
+
+\fs28 \
+_pullPointProcessAdding() 
+\fs22 (popcntl.c)\
+\
+
+\fs28 _pullPointProcessNixing() 
+\fs22 (popcntl.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>126</integer>
+			</dict>
+			<key>ID</key>
+			<integer>123</integer>
+			<key>Points</key>
+			<array>
+				<string>{2082.3458862304688, 535.39551131475457}</string>
+				<string>{2146.76708984375, 536.69828107225362}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>119</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>Group</string>
+			<key>Graphics</key>
+			<array>
+				<dict>
+					<key>Bounds</key>
+					<string>{{1729, 581.04193115234375}, {26.8992, 75.090011596679673}}</string>
+					<key>Class</key>
+					<string>ShapedGraphic</string>
+					<key>HFlip</key>
+					<string>YES</string>
+					<key>ID</key>
+					<integer>121</integer>
+					<key>Shape</key>
+					<string>Bezier</string>
+					<key>ShapeData</key>
+					<dict>
+						<key>UnitPoints</key>
+						<array>
+							<string>{-0.49940699999999999, -0.49995099999999998}</string>
+							<string>{-0.479014, -0.49995099999999998}</string>
+							<string>{0.115799, -0.50999700000000003}</string>
+							<string>{0.17077999999999999, -0.242005}</string>
+							<string>{0.22576599999999999, 0.025986100000000002}</string>
+							<string>{0.11247500000000001, 0.42752299999999999}</string>
+							<string>{0.234848, 0.46828999999999998}</string>
+							<string>{0.35722999999999999, 0.50905900000000004}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.22820199999999999, 0.50815100000000002}</string>
+							<string>{0.18604000000000001, 0.438637}</string>
+							<string>{0.143873, 0.36912699999999998}</string>
+							<string>{0.19577900000000001, -0.10635600000000001}</string>
+							<string>{0.093802899999999995, -0.30000399999999999}</string>
+							<string>{-0.0081834799999999999, -0.49365399999999998}</string>
+							<string>{-0.51980599999999999, -0.49995099999999998}</string>
+						</array>
+					</dict>
+					<key>Style</key>
+					<dict>
+						<key>fill</key>
+						<dict>
+							<key>Color</key>
+							<dict>
+								<key>b</key>
+								<string>0</string>
+								<key>g</key>
+								<string>0</string>
+								<key>r</key>
+								<string>0</string>
+							</dict>
+						</dict>
+						<key>shadow</key>
+						<dict>
+							<key>Draws</key>
+							<string>NO</string>
+						</dict>
+					</dict>
+					<key>VFlip</key>
+					<string>YES</string>
+				</dict>
+				<dict>
+					<key>Bounds</key>
+					<string>{{1729, 505.95191955566406}, {26.8992, 75.090011596679673}}</string>
+					<key>Class</key>
+					<string>ShapedGraphic</string>
+					<key>HFlip</key>
+					<string>YES</string>
+					<key>ID</key>
+					<integer>122</integer>
+					<key>Shape</key>
+					<string>Bezier</string>
+					<key>ShapeData</key>
+					<dict>
+						<key>UnitPoints</key>
+						<array>
+							<string>{-0.49940699999999999, -0.49995099999999998}</string>
+							<string>{-0.479014, -0.49995099999999998}</string>
+							<string>{0.115799, -0.50999700000000003}</string>
+							<string>{0.17077999999999999, -0.242005}</string>
+							<string>{0.22576599999999999, 0.025986100000000002}</string>
+							<string>{0.11247500000000001, 0.42752299999999999}</string>
+							<string>{0.234848, 0.46828999999999998}</string>
+							<string>{0.35722999999999999, 0.50905900000000004}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.22820199999999999, 0.50815100000000002}</string>
+							<string>{0.18604000000000001, 0.438637}</string>
+							<string>{0.143873, 0.36912699999999998}</string>
+							<string>{0.19577900000000001, -0.10635600000000001}</string>
+							<string>{0.093802899999999995, -0.30000399999999999}</string>
+							<string>{-0.0081834799999999999, -0.49365399999999998}</string>
+							<string>{-0.51980599999999999, -0.49995099999999998}</string>
+						</array>
+					</dict>
+					<key>Style</key>
+					<dict>
+						<key>fill</key>
+						<dict>
+							<key>Color</key>
+							<dict>
+								<key>b</key>
+								<string>0</string>
+								<key>g</key>
+								<string>0</string>
+								<key>r</key>
+								<string>0</string>
+							</dict>
+						</dict>
+						<key>shadow</key>
+						<dict>
+							<key>Draws</key>
+							<string>NO</string>
+						</dict>
+					</dict>
+				</dict>
+			</array>
+			<key>HFlip</key>
+			<string>YES</string>
+			<key>ID</key>
+			<integer>120</integer>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{1762.3458862304688, 523.65988159179688}, {320, 17}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>119</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 _pullPointProcessDescent() 
+\fs22 (actionPull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>117</integer>
+			</dict>
+			<key>ID</key>
+			<integer>118</integer>
+			<key>Points</key>
+			<array>
+				<string>{1256, 585.2599355778201}</string>
+				<string>{1311, 584.35195028255623}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>115</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{1311, 564.54193115234375}, {401, 33}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>Vertical</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>117</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fswiss\fcharset0 Helvetica;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 _pullPointProcess(task, bin, point) (
+\fs22 actionPull.c)\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f1\fs26 \cf0 Call a mode-process point processor}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>115</integer>
+			</dict>
+			<key>ID</key>
+			<integer>116</integer>
+			<key>Points</key>
+			<array>
+				<string>{863, 588.04991145604629}</string>
+				<string>{918, 588.04991145604629}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>114</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{918, 571.5499267578125}, {338, 33}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>115</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fswiss\fcharset0 Helvetica;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 pullBinProcess(task, binIdx) (
+\fs22 actionPull.c)\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f1\fs26 \cf0 Iterates through points in bin}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{622, 571.5499267578125}, {241, 33}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Courier</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>114</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fswiss\fcharset0 Helvetica;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 _pullProcess(task) (
+\fs22 corePull.c)\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f1\fs26 \cf0 The core of all the worker threads}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>114</integer>
+			</dict>
+			<key>ID</key>
+			<integer>113</integer>
+			<key>Points</key>
+			<array>
+				<string>{507, 591.49554353240353}</string>
+				<string>{622, 589.81297058515099}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>92</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>107</integer>
+			</dict>
+			<key>ID</key>
+			<integer>112</integer>
+			<key>Points</key>
+			<array>
+				<string>{1061.04369393058, 100}</string>
+				<string>{1109.2955276999007, 195.905029296875}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>111</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{972, 72}, {164, 28}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>ID</key>
+			<integer>111</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Color</key>
+					<dict>
+						<key>b</key>
+						<string>0.680421</string>
+						<key>g</key>
+						<string>0.90094</string>
+						<key>r</key>
+						<string>0.996411</string>
+					</dict>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs26 \cf0 pullVolumeSingleAdd()\
+
+\fs20 (volumePull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>107</integer>
+			</dict>
+			<key>ID</key>
+			<integer>110</integer>
+			<key>Points</key>
+			<array>
+				<string>{954.98111854687295, 145.9525146484375}</string>
+				<string>{1028.0585024203772, 195.905029296875}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>109</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{856, 117.9525146484375}, {157, 28}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>ID</key>
+			<integer>109</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Color</key>
+					<dict>
+						<key>b</key>
+						<string>0.680421</string>
+						<key>g</key>
+						<string>0.90094</string>
+						<key>r</key>
+						<string>0.996411</string>
+					</dict>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs26 \cf0 pullVolumeStackAdd()\
+
+\fs20 (volumePull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>107</integer>
+			</dict>
+			<key>ID</key>
+			<integer>108</integer>
+			<key>Points</key>
+			<array>
+				<string>{896, 279.96415493084879}</string>
+				<string>{999, 280.03455886494476}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>105</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{999, 195.905029296875}, {306, 170}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>Vertical</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>ID</key>
+			<integer>107</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fswiss\fcharset0 ArialMT;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs26 \cf0 _pullVolumeSet() 
+\fs20 (volumePull.c)\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f1\fs26 \cf0 This is the function that does the work of setting up the gageContext.  Via the "taskCopy" argument it controls whether this is being used as part of copying the tasks, vs being called from the public pullVolume\{Single,Stack\}Add().\
+\
+There is no real role for the gageStackBlurParm here, since pull has no role in doing or initiating the stack blurring; pull assumes that has been done by the caller (e.g. meet)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>105</integer>
+			</dict>
+			<key>ID</key>
+			<integer>106</integer>
+			<key>Points</key>
+			<array>
+				<string>{638, 279.09974163976017}</string>
+				<string>{723, 279.4006607151282}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>100</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{723, 242.405029296875}, {173, 75}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>ID</key>
+			<integer>105</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fswiss\fcharset0 ArialMT;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs26 \cf0 _pullVolumeCopy()\
+
+\fs20 (volumePull.c)\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f1\fs26 \cf0 Note that there is no public\
+pullVolumeCopy(); apparently\
+there hasn't been a need for it}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{233, 270.90504455566406}, {205, 16}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>ID</key>
+			<integer>104</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs26 \cf0 _pullTaskSetup() 
+\fs20 (taskPull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{233, 237.63500595092773}, {205, 16}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>ID</key>
+			<integer>103</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs26 \cf0 _pullInfoSetup() 
+\fs20 (infoPull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{226, 204.36496734619141}, {233, 16}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>ID</key>
+			<integer>102</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs26 \cf0 _pullVolumeSetup() 
+\fs20 (volumePull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{233, 171.09492874145508}, {149, 16}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>ID</key>
+			<integer>101</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs26 \cf0 _pullContextCheck()}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{528, 262.905029296875}, {110, 32}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>ID</key>
+			<integer>100</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs26 \cf0 _pullTaskNew()\
+(
+\fs20 taskPull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>LineGraphic</string>
+			<key>Head</key>
+			<dict>
+				<key>ID</key>
+				<integer>100</integer>
+			</dict>
+			<key>ID</key>
+			<integer>99</integer>
+			<key>Points</key>
+			<array>
+				<string>{438, 278.90504029034844}</string>
+				<string>{528, 278.90504029034844}</string>
+			</array>
+			<key>Style</key>
+			<dict>
+				<key>stroke</key>
+				<dict>
+					<key>HeadArrow</key>
+					<string>FilledArrow</string>
+					<key>Legacy</key>
+					<true/>
+					<key>LineType</key>
+					<integer>1</integer>
+					<key>TailArrow</key>
+					<string>0</string>
+				</dict>
+			</dict>
+			<key>Tail</key>
+			<dict>
+				<key>ID</key>
+				<integer>104</integer>
+			</dict>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{233, 293.08508151245115}, {149, 16}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Helvetica</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>97</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs26 \cf0 _pullBinSetup(pctx)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>Group</string>
+			<key>Graphics</key>
+			<array>
+				<dict>
+					<key>Bounds</key>
+					<string>{{194.10079956054688, 587.54993438720703}, {26.8992, 107.9099884033203}}</string>
+					<key>Class</key>
+					<string>ShapedGraphic</string>
+					<key>HFlip</key>
+					<string>YES</string>
+					<key>ID</key>
+					<integer>95</integer>
+					<key>Shape</key>
+					<string>Bezier</string>
+					<key>ShapeData</key>
+					<dict>
+						<key>UnitPoints</key>
+						<array>
+							<string>{-0.49940699999999999, -0.49995099999999998}</string>
+							<string>{-0.479014, -0.49995099999999998}</string>
+							<string>{0.115799, -0.50999700000000003}</string>
+							<string>{0.17077999999999999, -0.242005}</string>
+							<string>{0.22576599999999999, 0.025986100000000002}</string>
+							<string>{0.11247500000000001, 0.42752299999999999}</string>
+							<string>{0.234848, 0.46828999999999998}</string>
+							<string>{0.35722999999999999, 0.50905900000000004}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.22820199999999999, 0.50815100000000002}</string>
+							<string>{0.18604000000000001, 0.438637}</string>
+							<string>{0.143873, 0.36912699999999998}</string>
+							<string>{0.19577900000000001, -0.10635600000000001}</string>
+							<string>{0.093802899999999995, -0.30000399999999999}</string>
+							<string>{-0.0081834799999999999, -0.49365399999999998}</string>
+							<string>{-0.51980599999999999, -0.49995099999999998}</string>
+						</array>
+					</dict>
+					<key>Style</key>
+					<dict>
+						<key>fill</key>
+						<dict>
+							<key>Color</key>
+							<dict>
+								<key>b</key>
+								<string>0</string>
+								<key>g</key>
+								<string>0</string>
+								<key>r</key>
+								<string>0</string>
+							</dict>
+						</dict>
+						<key>shadow</key>
+						<dict>
+							<key>Draws</key>
+							<string>NO</string>
+						</dict>
+					</dict>
+					<key>VFlip</key>
+					<string>YES</string>
+				</dict>
+				<dict>
+					<key>Bounds</key>
+					<string>{{194.10079956054688, 479.63994598388672}, {26.8992, 107.9099884033203}}</string>
+					<key>Class</key>
+					<string>ShapedGraphic</string>
+					<key>HFlip</key>
+					<string>YES</string>
+					<key>ID</key>
+					<integer>96</integer>
+					<key>Shape</key>
+					<string>Bezier</string>
+					<key>ShapeData</key>
+					<dict>
+						<key>UnitPoints</key>
+						<array>
+							<string>{-0.49940699999999999, -0.49995099999999998}</string>
+							<string>{-0.479014, -0.49995099999999998}</string>
+							<string>{0.115799, -0.50999700000000003}</string>
+							<string>{0.17077999999999999, -0.242005}</string>
+							<string>{0.22576599999999999, 0.025986100000000002}</string>
+							<string>{0.11247500000000001, 0.42752299999999999}</string>
+							<string>{0.234848, 0.46828999999999998}</string>
+							<string>{0.35722999999999999, 0.50905900000000004}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.22820199999999999, 0.50815100000000002}</string>
+							<string>{0.18604000000000001, 0.438637}</string>
+							<string>{0.143873, 0.36912699999999998}</string>
+							<string>{0.19577900000000001, -0.10635600000000001}</string>
+							<string>{0.093802899999999995, -0.30000399999999999}</string>
+							<string>{-0.0081834799999999999, -0.49365399999999998}</string>
+							<string>{-0.51980599999999999, -0.49995099999999998}</string>
+						</array>
+					</dict>
+					<key>Style</key>
+					<dict>
+						<key>fill</key>
+						<dict>
+							<key>Color</key>
+							<dict>
+								<key>b</key>
+								<string>0</string>
+								<key>g</key>
+								<string>0</string>
+								<key>r</key>
+								<string>0</string>
+							</dict>
+						</dict>
+						<key>shadow</key>
+						<dict>
+							<key>Draws</key>
+							<string>NO</string>
+						</dict>
+					</dict>
+				</dict>
+			</array>
+			<key>HFlip</key>
+			<string>YES</string>
+			<key>ID</key>
+			<integer>94</integer>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{237.5, 493.45992510986326}, {413, 28}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>ID</key>
+			<integer>93</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs24 \cf0 Loops through iterations,\
+periodically doing popluation control, by iterating with different process modes}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{233, 550}, {274, 87}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Helvetica</string>
+				<key>Size</key>
+				<real>17</real>
+			</dict>
+			<key>ID</key>
+			<integer>92</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs36 \cf0 _pullIterate(pctx, mode) 
+\f1\fs22 (corePull.c)
+\fs14 \
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 "mode" is from the pullProcessMode enum:\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\fs20 \cf0 pullProcessModeDescent,\
+pullProcessModeNeighLearn,\
+pullProcessModeAdding,\
+pullProcessModeNixing}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Class</key>
+			<string>Group</string>
+			<key>Graphics</key>
+			<array>
+				<dict>
+					<key>Bounds</key>
+					<string>{{197.10079956054688, 261.72996139526367}, {26.8992, 95.270042419433565}}</string>
+					<key>Class</key>
+					<string>ShapedGraphic</string>
+					<key>HFlip</key>
+					<string>YES</string>
+					<key>ID</key>
+					<integer>90</integer>
+					<key>Shape</key>
+					<string>Bezier</string>
+					<key>ShapeData</key>
+					<dict>
+						<key>UnitPoints</key>
+						<array>
+							<string>{-0.49940699999999999, -0.49995099999999998}</string>
+							<string>{-0.479014, -0.49995099999999998}</string>
+							<string>{0.115799, -0.50999700000000003}</string>
+							<string>{0.17077999999999999, -0.242005}</string>
+							<string>{0.22576599999999999, 0.025986100000000002}</string>
+							<string>{0.11247500000000001, 0.42752299999999999}</string>
+							<string>{0.234848, 0.46828999999999998}</string>
+							<string>{0.35722999999999999, 0.50905900000000004}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.22820199999999999, 0.50815100000000002}</string>
+							<string>{0.18604000000000001, 0.438637}</string>
+							<string>{0.143873, 0.36912699999999998}</string>
+							<string>{0.19577900000000001, -0.10635600000000001}</string>
+							<string>{0.093802899999999995, -0.30000399999999999}</string>
+							<string>{-0.0081834799999999999, -0.49365399999999998}</string>
+							<string>{-0.51980599999999999, -0.49995099999999998}</string>
+						</array>
+					</dict>
+					<key>Style</key>
+					<dict>
+						<key>fill</key>
+						<dict>
+							<key>Color</key>
+							<dict>
+								<key>b</key>
+								<string>0</string>
+								<key>g</key>
+								<string>0</string>
+								<key>r</key>
+								<string>0</string>
+							</dict>
+						</dict>
+						<key>shadow</key>
+						<dict>
+							<key>Draws</key>
+							<string>NO</string>
+						</dict>
+					</dict>
+					<key>VFlip</key>
+					<string>YES</string>
+				</dict>
+				<dict>
+					<key>Bounds</key>
+					<string>{{197.10079956054688, 166.45991897583008}, {26.8992, 95.270042419433565}}</string>
+					<key>Class</key>
+					<string>ShapedGraphic</string>
+					<key>HFlip</key>
+					<string>YES</string>
+					<key>ID</key>
+					<integer>91</integer>
+					<key>Shape</key>
+					<string>Bezier</string>
+					<key>ShapeData</key>
+					<dict>
+						<key>UnitPoints</key>
+						<array>
+							<string>{-0.49940699999999999, -0.49995099999999998}</string>
+							<string>{-0.479014, -0.49995099999999998}</string>
+							<string>{0.115799, -0.50999700000000003}</string>
+							<string>{0.17077999999999999, -0.242005}</string>
+							<string>{0.22576599999999999, 0.025986100000000002}</string>
+							<string>{0.11247500000000001, 0.42752299999999999}</string>
+							<string>{0.234848, 0.46828999999999998}</string>
+							<string>{0.35722999999999999, 0.50905900000000004}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.5, 0.49886799999999998}</string>
+							<string>{0.22820199999999999, 0.50815100000000002}</string>
+							<string>{0.18604000000000001, 0.438637}</string>
+							<string>{0.143873, 0.36912699999999998}</string>
+							<string>{0.19577900000000001, -0.10635600000000001}</string>
+							<string>{0.093802899999999995, -0.30000399999999999}</string>
+							<string>{-0.0081834799999999999, -0.49365399999999998}</string>
+							<string>{-0.51980599999999999, -0.49995099999999998}</string>
+						</array>
+					</dict>
+					<key>Style</key>
+					<dict>
+						<key>fill</key>
+						<dict>
+							<key>Color</key>
+							<dict>
+								<key>b</key>
+								<string>0</string>
+								<key>g</key>
+								<string>0</string>
+								<key>r</key>
+								<string>0</string>
+							</dict>
+						</dict>
+						<key>shadow</key>
+						<dict>
+							<key>Draws</key>
+							<string>NO</string>
+						</dict>
+					</dict>
+				</dict>
+			</array>
+			<key>HFlip</key>
+			<string>YES</string>
+			<key>ID</key>
+			<integer>89</integer>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{61.5, 756.91985021972664}, {124, 35}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Helvetica</string>
+				<key>Size</key>
+				<real>17</real>
+			</dict>
+			<key>ID</key>
+			<integer>7</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Color</key>
+					<dict>
+						<key>b</key>
+						<string>0.682307</string>
+						<key>g</key>
+						<string>0.898418</string>
+						<key>r</key>
+						<string>1</string>
+					</dict>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs36 \cf0 pullOutputGet()\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f1\fs22 \cf0 (corePull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{73, 830.5}, {89, 35}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Helvetica</string>
+				<key>Size</key>
+				<real>17</real>
+			</dict>
+			<key>ID</key>
+			<integer>6</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Color</key>
+					<dict>
+						<key>b</key>
+						<string>0.680421</string>
+						<key>g</key>
+						<string>0.90094</string>
+						<key>r</key>
+						<string>0.996411</string>
+					</dict>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs36 \cf0 pullFinish()\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f1\fs22 \cf0 (corePull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{92, 562.25492327880852}, {80, 35}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Helvetica</string>
+				<key>Size</key>
+				<real>17</real>
+			</dict>
+			<key>ID</key>
+			<integer>5</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Color</key>
+					<dict>
+						<key>b</key>
+						<string>0.680421</string>
+						<key>g</key>
+						<string>0.90094</string>
+						<key>r</key>
+						<string>0.996411</string>
+					</dict>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs36 \cf0 pullRun()\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f1\fs22 \cf0 (corePull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{99, 224.04992907714842}, {80, 35}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>YES</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Helvetica</string>
+				<key>Size</key>
+				<real>17</real>
+			</dict>
+			<key>ID</key>
+			<integer>4</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Color</key>
+					<dict>
+						<key>b</key>
+						<string>0.680421</string>
+						<key>g</key>
+						<string>0.90094</string>
+						<key>r</key>
+						<string>0.996411</string>
+					</dict>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs36 \cf0 pullStart()\
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f1\fs22 \cf0 (corePull.c)}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+			<key>Wrap</key>
+			<string>NO</string>
+		</dict>
+		<dict>
+			<key>Bounds</key>
+			<string>{{20, 17}, {1039, 51}}</string>
+			<key>Class</key>
+			<string>ShapedGraphic</string>
+			<key>FitText</key>
+			<string>Vertical</string>
+			<key>Flow</key>
+			<string>Resize</string>
+			<key>FontInfo</key>
+			<dict>
+				<key>Font</key>
+				<string>Helvetica</string>
+				<key>Size</key>
+				<real>13</real>
+			</dict>
+			<key>ID</key>
+			<integer>3</integer>
+			<key>Shape</key>
+			<string>Rectangle</string>
+			<key>Style</key>
+			<dict>
+				<key>fill</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>shadow</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+				<key>stroke</key>
+				<dict>
+					<key>Draws</key>
+					<string>NO</string>
+				</dict>
+			</dict>
+			<key>Text</key>
+			<dict>
+				<key>Align</key>
+				<integer>0</integer>
+				<key>Pad</key>
+				<integer>0</integer>
+				<key>Text</key>
+				<string>{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
+\cocoascreenfonts1{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
+{\colortbl;\red255\green255\blue255;}
+\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
+
+\f0\fs28 \cf0 ???\
+Is the pullEnergyType* enum and pullEnergyType airEnum needed or used?\
+is implementation of flagScaleIsTau really complete?  is pullContext-&gt;bboxMin[3] and Max[3] really always sigma, regardless of flagScaleIsTau?}</string>
+				<key>VerticalPad</key>
+				<integer>0</integer>
+			</dict>
+		</dict>
+	</array>
+	<key>GridInfo</key>
+	<dict/>
+	<key>GuidesLocked</key>
+	<string>NO</string>
+	<key>GuidesVisible</key>
+	<string>YES</string>
+	<key>HPages</key>
+	<integer>6</integer>
+	<key>ImageCounter</key>
+	<integer>1</integer>
+	<key>KeepToScale</key>
+	<false/>
+	<key>Layers</key>
+	<array>
+		<dict>
+			<key>Lock</key>
+			<string>NO</string>
+			<key>Name</key>
+			<string>Layer 1</string>
+			<key>Print</key>
+			<string>YES</string>
+			<key>View</key>
+			<string>YES</string>
+		</dict>
+	</array>
+	<key>LayoutInfo</key>
+	<dict>
+		<key>Animate</key>
+		<string>NO</string>
+		<key>circoMinDist</key>
+		<real>18</real>
+		<key>circoSeparation</key>
+		<real>0.0</real>
+		<key>layoutEngine</key>
+		<string>dot</string>
+		<key>neatoSeparation</key>
+		<real>0.0</real>
+		<key>twopiSeparation</key>
+		<real>0.0</real>
+	</dict>
+	<key>LinksVisible</key>
+	<string>NO</string>
+	<key>MagnetsVisible</key>
+	<string>NO</string>
+	<key>MasterSheets</key>
+	<array/>
+	<key>ModificationDate</key>
+	<string>2016-04-13 17:19:40 +0000</string>
+	<key>Modifier</key>
+	<string>Gordon L. Kindlmann</string>
+	<key>NotesVisible</key>
+	<string>NO</string>
+	<key>Orientation</key>
+	<integer>2</integer>
+	<key>OriginVisible</key>
+	<string>NO</string>
+	<key>PageBreaks</key>
+	<string>NO</string>
+	<key>PrintInfo</key>
+	<dict>
+		<key>NSBottomMargin</key>
+		<array>
+			<string>float</string>
+			<string>41</string>
+		</array>
+		<key>NSHorizonalPagination</key>
+		<array>
+			<string>coded</string>
+			<string>BAtzdHJlYW10eXBlZIHoA4QBQISEhAhOU051bWJlcgCEhAdOU1ZhbHVlAISECE5TT2JqZWN0AIWEASqEhAFxlwCG</string>
+		</array>
+		<key>NSLeftMargin</key>
+		<array>
+			<string>float</string>
+			<string>18</string>
+		</array>
+		<key>NSPaperSize</key>
+		<array>
+			<string>size</string>
+			<string>{612, 792}</string>
+		</array>
+		<key>NSPrintReverseOrientation</key>
+		<array>
+			<string>int</string>
+			<string>0</string>
+		</array>
+		<key>NSRightMargin</key>
+		<array>
+			<string>float</string>
+			<string>18</string>
+		</array>
+		<key>NSTopMargin</key>
+		<array>
+			<string>float</string>
+			<string>18</string>
+		</array>
+	</dict>
+	<key>PrintOnePage</key>
+	<false/>
+	<key>ReadOnly</key>
+	<string>NO</string>
+	<key>RowAlign</key>
+	<integer>1</integer>
+	<key>RowSpacing</key>
+	<real>36</real>
+	<key>SheetTitle</key>
+	<string>Canvas 1</string>
+	<key>SmartAlignmentGuidesActive</key>
+	<string>YES</string>
+	<key>SmartDistanceGuidesActive</key>
+	<string>YES</string>
+	<key>UniqueID</key>
+	<integer>1</integer>
+	<key>UseEntirePage</key>
+	<false/>
+	<key>VPages</key>
+	<integer>2</integer>
+	<key>WindowInfo</key>
+	<dict>
+		<key>CurrentSheet</key>
+		<integer>0</integer>
+		<key>ExpandedCanvases</key>
+		<array>
+			<dict>
+				<key>name</key>
+				<string>Canvas 1</string>
+			</dict>
+		</array>
+		<key>Frame</key>
+		<string>{{1479, 520}, {1881, 873}}</string>
+		<key>ListView</key>
+		<true/>
+		<key>OutlineWidth</key>
+		<integer>142</integer>
+		<key>RightSidebar</key>
+		<false/>
+		<key>ShowRuler</key>
+		<true/>
+		<key>Sidebar</key>
+		<true/>
+		<key>SidebarWidth</key>
+		<integer>120</integer>
+		<key>VisibleRegion</key>
+		<string>{{0, 235}, {1746, 718}}</string>
+		<key>Zoom</key>
+		<real>1</real>
+		<key>ZoomValues</key>
+		<array>
+			<array>
+				<string>Canvas 1</string>
+				<real>1</real>
+				<real>1</real>
+			</array>
+		</array>
+	</dict>
+</dict>
+</plist>
Binary files teem-1.11.0-src.orig/src/doc/scale-space-computing.graffle and teem-1.11.0-src/src/doc/scale-space-computing.graffle differ
Binary files teem-1.11.0-src.orig/src/doc/scale-space-computing.pdf and teem-1.11.0-src/src/doc/scale-space-computing.pdf differ
diff --color -ruN teem-1.11.0-src.orig/src/dye/CMakeLists.txt teem-1.11.0-src/src/dye/CMakeLists.txt
--- teem-1.11.0-src.orig/src/dye/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/dye/CMakeLists.txt	2021-02-18 15:42:34.000000000 +0800
@@ -0,0 +1,11 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(DYE_SOURCES
+  convertDye.c
+  dye.h
+  methodsDye.c
+  )
+
+target_sources(teem PRIVATE ${DYE_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( dye FILES ${DYE_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/dye/convertDye.c teem-1.11.0-src/src/dye/convertDye.c
--- teem-1.11.0-src.orig/src/dye/convertDye.c	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/dye/convertDye.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -25,20 +25,31 @@
 #include "dye.h"
 
 /*
+** values in these matrices were copied from:
 ** from http://www.cs.rit.edu/~ncs/color/t_convert.html
-** each row below is really one column of the matrix
+**
+** from http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
+** these look to be specific to sRGB with D65 white
+**
+** NB: for a long time this matrices were wrong, because they
+** never got transposed at the same time that matrices in Teem
+** were switched from column-major to row-major ordering
 */
 float dyeRGBtoXYZMatx[9] = {
-  0.412453f, 0.212671f, 0.019334f,
-  0.357580f, 0.715160f, 0.119193f,
-  0.180423f, 0.072169f, 0.950227f};
+  0.412453f, 0.357580f, 0.180423f,
+  0.212671f, 0.715160f, 0.072169f,
+  0.019334f, 0.119193f, 0.950227f};
 float dyeXYZtoRGBMatx[9] = {
-  3.240479f,-0.969256f, 0.055648f,
-  -1.537150f, 1.875992f,-0.204043f,
-  -0.498535f, 0.041556f, 1.057311f};
+  3.240479f, -1.537150f, -0.498535f,
+  -0.969256f, 1.875992f, 0.041556f,
+  0.055648f, -0.204043f, 1.057311f};
 
 /* summing the rows of the RGBtoXYZ matrix to get X_n, Y_n, Z_n */
 float dyeWhiteXYZ_n[3] = {0.950456f, 1.0f, 1.088754f};
+/* so  x = X/(X+Y+Z) = 0.312731268 and
+   and y = Y/(X+Y+Z) = 0..32903287;
+   then http://en.wikipedia.org/wiki/Illuminant_D65
+   confirms that this is D65 white */
 
 /* the u'_n and v'_n which appear in the XYZ -> LUV conversion;
    u'_n = 4X_n / (X_n + 15Y_n + 3Z_n)
@@ -234,9 +245,9 @@
 
 float
 dyeLcbrt(float t) {
-  return AIR_CAST(float, (t > 0.008856
-                          ? airCbrt(t)
-                          : 7.787*t + 16.0/116.0));
+  return AIR_FLOAT(t > 0.008856
+                   ? airCbrt(t)
+                   : 7.787*t + 16.0/116.0);
 }
 
 float
@@ -276,7 +287,7 @@
   float YnormCbrt;
 
   YnormCbrt = (16 + L)/116;
-  *X = dyeWhiteXYZ_n[0]*dyeLcubed(A/500 + YnormCbrt);
+  *X = dyeWhiteXYZ_n[0]*dyeLcubed(YnormCbrt + A/500);
   *Y = dyeWhiteXYZ_n[1]*dyeLcubed(YnormCbrt);
   *Z = dyeWhiteXYZ_n[2]*dyeLcubed(YnormCbrt - B/200);
   return;
@@ -297,6 +308,39 @@
 }
 
 void
+dyeLABtoLCH(float *Lp, float *C, float *H,
+            float  L, float  A, float  B) {
+
+  *Lp = L;
+  *C = sqrtf(A*A + B*B);
+  *H = (float)(atan2f(B, A)/(2*AIR_PI) + 0.5);
+}
+
+void
+dyeLCHtoLAB(float *Lp, float *A, float *B,
+            float  L, float  C, float  H) {
+  float phi = (float)((H*2 - 1)*AIR_PI);
+  *Lp = L;
+  *A = C*cosf(phi);
+  *B = C*sinf(phi);
+}
+
+void
+dyeXYZtoLCH(float *_L, float *C, float *H,
+            float  X, float  Y, float  Z) {
+  float L, A, B;
+  dyeXYZtoLAB(&L, &A, &B, X, Y, Z);
+  dyeLABtoLCH(_L, C, H, L, A, B);
+}
+void
+dyeLCHtoXYZ(float *X, float *Y, float *Z,
+            float _L, float  C, float  H) {
+  float L, A, B;
+  dyeLCHtoLAB(&L, &A, &B, _L, C, H);
+  dyeLABtoXYZ(X, Y, Z, L, A, B);
+}
+
+void
 dyeIdentity(float *A, float *B, float *C,
             float  a, float  b, float  c) {
   *A = a;
@@ -307,13 +351,14 @@
 
 dyeConverter dyeSimpleConvert[DYE_MAX_SPACE+1][DYE_MAX_SPACE+1] =
 {
-  {NULL,          NULL,          NULL,          NULL,          NULL,          NULL,          NULL},
-  {NULL,          dyeIdentity,   NULL,          dyeHSVtoRGB,   NULL,          NULL,          NULL},
-  {NULL,          NULL,          dyeIdentity,   dyeHSLtoRGB,   NULL,          NULL,          NULL},
-  {NULL,          dyeRGBtoHSV,   dyeRGBtoHSL,   dyeIdentity,   dyeRGBtoXYZ,   NULL,          NULL},
-  {NULL,          NULL,          NULL,          dyeXYZtoRGB,   dyeIdentity,   dyeXYZtoLAB,   dyeXYZtoLUV},
-  {NULL,          NULL,          NULL,          NULL,          dyeLABtoXYZ,   dyeIdentity,   NULL},
-  {NULL,          NULL,          NULL,          NULL,          dyeLUVtoXYZ,   NULL,          dyeIdentity}
+  {NULL,          NULL,          NULL,          NULL,          NULL,          NULL,          NULL,          NULL},
+  {NULL,          dyeIdentity,   NULL,          dyeHSVtoRGB,   NULL,          NULL,          NULL,          NULL},
+  {NULL,          NULL,          dyeIdentity,   dyeHSLtoRGB,   NULL,          NULL,          NULL,          NULL},
+  {NULL,          dyeRGBtoHSV,   dyeRGBtoHSL,   dyeIdentity,   dyeRGBtoXYZ,   NULL,          NULL,          NULL},
+  {NULL,          NULL,          NULL,          dyeXYZtoRGB,   dyeIdentity,   dyeXYZtoLAB,   dyeXYZtoLUV,   dyeXYZtoLCH},
+  {NULL,          NULL,          NULL,          NULL,          dyeLABtoXYZ,   dyeIdentity,   NULL,          dyeLABtoLCH},
+  {NULL,          NULL,          NULL,          NULL,          dyeLUVtoXYZ,   NULL,          dyeIdentity,   NULL},
+  {NULL,          NULL,          NULL,          NULL,          dyeLCHtoXYZ,   dyeLCHtoLAB,   NULL,          dyeIdentity},
   };
 
 /*
@@ -356,7 +401,7 @@
       if (!E) E |= dyeConvert(col, outSpace);
     }
     else if (inSpace > dyeSpaceXYZ && outSpace > dyeSpaceXYZ) {
-      /* its an easy LAB <-- XYZ --> LUV conversion */
+      /* its an easy conversion among XYZ, LAB, LUV, LCH */
       if (!E) E |= dyeConvert(col, dyeSpaceXYZ);
       if (!E) E |= dyeConvert(col, outSpace);
     }
diff --color -ruN teem-1.11.0-src.orig/src/dye/dye.h teem-1.11.0-src/src/dye/dye.h
--- teem-1.11.0-src.orig/src/dye/dye.h	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/dye/dye.h	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -56,9 +56,10 @@
   dyeSpaceXYZ,            /* 4: perceptual primaries */
   dyeSpaceLAB,            /* 5: 1976 CIE (L*a*b*) (based on Munsell) */
   dyeSpaceLUV,            /* 6: 1976 CIE (L*u*v*) */
+  dyeSpaceLCH,            /* 7: polar coord version of L*a*b* */
   dyeSpaceLast
 };
-#define DYE_MAX_SPACE 6
+#define DYE_MAX_SPACE 7
 
 #define DYE_VALID_SPACE(spc) \
   (AIR_IN_OP(dyeSpaceUnknown, (spc), dyeSpaceLast))
@@ -66,14 +67,15 @@
 typedef struct {
   float val[2][3];        /* room for two colors: two triples of floats */
   float xWhite, yWhite;   /* chromaticity for white point */
-  signed char spc[2],     /* the spaces the two colors belong to */
+  int spc[2],             /* the spaces the two colors belong to */
     ii;                   /* which (0 or 1) of the two values is current */
 } dyeColor;
 
 /* methodsDye.c */
 DYE_EXPORT const int dyePresent;
 DYE_EXPORT const char *dyeBiffKey;
-DYE_EXPORT char dyeSpaceToStr[][AIR_STRLEN_SMALL];
+DYE_EXPORT const char *dyeSpaceToStr[DYE_MAX_SPACE+1];
+DYE_EXPORT const airEnum *const dyeSpace;
 DYE_EXPORT int dyeStrToSpace(char *str);
 DYE_EXPORT dyeColor *dyeColorInit(dyeColor *col);
 DYE_EXPORT dyeColor *dyeColorSet(dyeColor *col, int space,
@@ -109,6 +111,14 @@
                             float  L, float  A, float  B);
 DYE_EXPORT void dyeLUVtoXYZ(float *X, float *Y, float *Z,
                             float  L, float  U, float  V);
+DYE_EXPORT void dyeLABtoLCH(float*Lp, float *C, float *H,
+                            float  L, float  A, float  B);
+DYE_EXPORT void dyeLCHtoLAB(float*Lp, float *A, float *B,
+                            float  L, float  C, float  H);
+DYE_EXPORT void dyeXYZtoLCH(float *L, float *C, float *H,
+                            float  X, float  Y, float  Z);
+DYE_EXPORT void dyeLCHtoXYZ(float *X, float *Y, float *Z,
+                            float  L, float  C, float  H);
 DYE_EXPORT dyeConverter dyeSimpleConvert[DYE_MAX_SPACE+1][DYE_MAX_SPACE+1];
 DYE_EXPORT int dyeConvert(dyeColor *col, int space);
 
diff --color -ruN teem-1.11.0-src.orig/src/dye/GNUmakefile teem-1.11.0-src/src/dye/GNUmakefile
--- teem-1.11.0-src.orig/src/dye/GNUmakefile	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/dye/GNUmakefile	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -50,7 +50,7 @@
 $(L).PUBLIC_HEADERS = dye.h
 $(L).PRIVATE_HEADERS =
 $(L).OBJS = methodsDye.o convertDye.o
-$(L).TESTS = test/conv test/bow
+$(L).TESTS = test/conv test/bow test/mchist test/iconv
 
 ####
 ####
diff --color -ruN teem-1.11.0-src.orig/src/dye/methodsDye.c teem-1.11.0-src/src/dye/methodsDye.c
--- teem-1.11.0-src.orig/src/dye/methodsDye.c	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/dye/methodsDye.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -30,17 +30,50 @@
 const char *
 dyeBiffKey = "dye";
 
-char
-dyeSpaceToStr[][AIR_STRLEN_SMALL] = {
+const char *
+dyeSpaceToStr[DYE_MAX_SPACE+1] = {
   "(unknown)",
   "HSV",
   "HSL",
   "RGB",
   "XYZ",
   "LAB",
-  "LUV"
+  "LUV",
+  "LCH"
+};
+
+/* NB: the creation of dye in 2001 predates the creation of the airEnum in 2002,
+   and when this airEnum was added in 2015, bewildered why it wasn't there already,
+   GLK forgot that chronology, but that chronology explains why this airEnum isn't
+   used more widely within dye. */
+
+static const char *
+_dyeSpaceDesc[DYE_MAX_SPACE+1] = {
+  "unknown colorspace",
+  "single hexcone",
+  "double hexcone",
+  "traditional device primaries",
+  "CIE 1931 XYZ space",
+  "CIE L*a*b*",
+  "CIE 1976 L*u*v*",
+  "polar coord(L*a*b*)"
 };
 
+static const airEnum
+_dyeSpace = {
+  "colorspace",
+  DYE_MAX_SPACE,
+  dyeSpaceToStr, NULL,
+  _dyeSpaceDesc,
+  NULL, NULL,
+  AIR_FALSE
+};
+const airEnum *const
+dyeSpace = &_dyeSpace;
+
+/*
+** this function predates the dyeSpace airEnum, so we'll keep it.
+*/
 int
 dyeStrToSpace(char *_str) {
   int spc;
diff --color -ruN teem-1.11.0-src.orig/src/dye/sources.cmake teem-1.11.0-src/src/dye/sources.cmake
--- teem-1.11.0-src.orig/src/dye/sources.cmake	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/dye/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,9 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(DYE_SOURCES
-  convertDye.c
-  dye.h
-  methodsDye.c
-  )
-
-ADD_TEEM_LIBRARY(dye ${DYE_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/dye/test/bow.c teem-1.11.0-src/src/dye/test/bow.c
--- teem-1.11.0-src.orig/src/dye/test/bow.c	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/dye/test/bow.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -61,7 +62,7 @@
 
   fprintf(out, "# space: RGB\n");
   for (i=0; i<=res-1; i++) {
-    hue = AIR_AFFINE(0, i, res, 0.0, 1.0);
+    hue = (float)(AIR_AFFINE(0, i, res, 0.0, 1.0));
     dyeHSVtoRGB(&R, &G, &B, hue, 1, 1);
     fprintf(out, "%g %g %g %g\n", hue, sc*R, sc*G, sc*B);
   }
diff --color -ruN teem-1.11.0-src.orig/src/dye/test/conv.c teem-1.11.0-src/src/dye/test/conv.c
--- teem-1.11.0-src.orig/src/dye/test/conv.c	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/dye/test/conv.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/dye/test/iconv.c teem-1.11.0-src/src/dye/test/iconv.c
--- teem-1.11.0-src.orig/src/dye/test/iconv.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/dye/test/iconv.c	2021-02-18 15:42:34.000000000 +0800
@@ -0,0 +1,122 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+
+#include "../dye.h"
+
+char *me;
+
+void
+usage() {
+  /*                      0       1       2         3         4    (5) */
+  fprintf(stderr, "usage: %s <spaceIn> <imgIn> <spaceOut> <imgOut>\n", me);
+  exit(1);
+}
+
+int
+main(int argc, char *argv[]) {
+  char *inFN, *outFN, *inSpcS, *otSpcS, *err;
+  int inSpc, otSpc, hack3d;
+  airArray *mop;
+  Nrrd *nin, *nout;
+  float *id, *od;
+  unsigned int ii, nn;
+  dyeColor *col;
+
+  me = argv[0];
+  if (5 != argc)
+    usage();
+  inSpcS = argv[1];
+  inFN = argv[2];
+  otSpcS = argv[3];
+  outFN = argv[4];
+
+  inSpc = dyeStrToSpace(inSpcS);
+  if (dyeSpaceUnknown == inSpc) {
+    fprintf(stderr, "%s: couldn't parse \"%s\" as colorspace\n", me, inSpcS);
+    exit(1);
+  }
+  otSpc = dyeStrToSpace(otSpcS);
+  if (dyeSpaceUnknown == otSpc) {
+    fprintf(stderr, "%s: couldn't parse \"%s\" as colorspace\n", me, otSpcS);
+    exit(1);
+  }
+
+  mop = airMopNew();
+  nin = nrrdNew();
+  airMopAdd(mop, nin, (airMopper)nrrdNuke, airMopAlways);
+  nout = nrrdNew();
+  airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
+  if (nrrdLoad(nin, inFN, NULL)
+      || nrrdCopy(nout, nin)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: trouble:\n%s", me, err);
+    airMopError(mop);
+    exit(1);
+  }
+  if (nrrdTypeFloat != nin->type) {
+    fprintf(stderr, "%s: sorry, require type %s (not %s)\n", me,
+            airEnumStr(nrrdType, nrrdTypeFloat),
+            airEnumStr(nrrdType, nin->type));
+    airMopError(mop);
+    exit(1);
+  }
+  if (2 == nin->dim && 3 == nin->axis[0].size) {
+    /* as a big hack, promote to 3D */
+    nin->dim = 3;
+    nin->axis[2].size = 1;
+    hack3d = AIR_TRUE;
+  } else {
+    hack3d = AIR_FALSE;
+  }
+  if (!( 3 == nin->dim && 3 == nin->axis[0].size )) {
+    fprintf(stderr, "%s: sorry, need 3D 3-by-X-by-Y array (not %u-D %u-by)\n", me,
+            nin->dim, AIR_UINT(nin->axis[0].size));
+    airMopError(mop);
+    exit(1);
+  }
+  id = AIR_CAST(float *, nin->data);
+  od = AIR_CAST(float *, nout->data);
+
+  col = dyeColorNew();
+  airMopAdd(mop, col, (airMopper)dyeColorNix, airMopAlways);
+
+  nn = AIR_UINT(nin->axis[1].size * nin->axis[2].size);
+  for (ii=0; ii<nn; ii++) {
+    dyeColorSet(col, inSpc, id[0 + 3*ii], id[1 + 3*ii], id[2 + 3*ii]);
+    dyeConvert(col, otSpc);
+    dyeColorGet(od + 0 + 3*ii, od + 1 + 3*ii, od + 2 + 3*ii, col);
+  }
+
+  if (hack3d) {
+    nout->dim = 2;
+  }
+  if (nrrdSave(outFN, nout, NULL)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: trouble:\n%s", me, err);
+    airMopError(mop);
+    exit(1);
+  }
+
+  exit(0);
+}
diff --color -ruN teem-1.11.0-src.orig/src/dye/test/mchist.c teem-1.11.0-src/src/dye/test/mchist.c
--- teem-1.11.0-src.orig/src/dye/test/mchist.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/dye/test/mchist.c	2021-02-18 15:42:34.000000000 +0800
@@ -0,0 +1,293 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+
+#include "../dye.h"
+
+/*
+** hist[0]: hue vs sat
+** hist[1]: hue vs val
+*/
+void
+imageProc(Nrrd *nhproj[3], Nrrd *nhist[2], unsigned int sH,
+          float *rgb, unsigned int size0, unsigned int sXY,
+          unsigned int overSampleNum, float overSampleScale) {
+  unsigned int xyi, hi, si, vi, oi;
+  float rr, gg, bb, hh, ss, vv, *hist[2];
+  double rndA, rndB;
+
+  nrrdZeroSet(nhist[0]);
+  nrrdZeroSet(nhist[1]);
+  hist[0] = AIR_CAST(float *, nhist[0]->data);
+  hist[1] = AIR_CAST(float *, nhist[1]->data);
+  for (xyi=0; xyi<sXY; xyi++) {
+    rr = AIR_CLAMP(0, rgb[0], 255);
+    gg = AIR_CLAMP(0, rgb[1], 255);
+    bb = AIR_CLAMP(0, rgb[2], 255);
+    rr = (float)AIR_AFFINE(-1, rr, 256, 0, 1);
+    gg = (float)AIR_AFFINE(-1, gg, 256, 0, 1);
+    bb = (float)AIR_AFFINE(-1, bb, 256, 0, 1);
+    dyeRGBtoHSV(&hh, &ss, &vv, rr, gg, bb);
+    si = airIndexClamp(0, ss, 1, sH);
+    vi = airIndexClamp(0, vv, 1, sH);
+
+#define UPDATE_HIST(rnd)                                                \
+    hi = airIndexClamp(0, hh + overSampleScale*(1-ss)*(rnd), 1, sH);    \
+    hist[0][hi + sH*si] += 1.0f/overSampleNum;                           \
+    hist[1][hi + sH*vi] += 1.0f/overSampleNum
+
+    if (overSampleNum % 2 == 1) {
+      airNormalRand(&rndA, NULL);
+      UPDATE_HIST(rndA);
+      overSampleNum -= 1;
+    }
+    for (oi=0; oi<overSampleNum; oi+=2) {
+      airNormalRand(&rndA, &rndB);
+      UPDATE_HIST(rndA);
+      UPDATE_HIST(rndB);
+    }
+    rgb += size0;
+  }
+  nrrdProject(nhproj[0], nhist[0], 1, nrrdMeasureHistoMean, nrrdTypeFloat);
+  nrrdProject(nhproj[1], nhist[1], 1, nrrdMeasureHistoMean, nrrdTypeFloat);
+  nrrdProject(nhproj[2], nhist[1], 1, nrrdMeasureSum, nrrdTypeFloat);
+}
+
+const char *mchistInfo = ("Makes a color histogram of frames. ");
+
+int
+main(int argc, const char *argv[]) {
+  const char *me;
+  hestOpt *hopt;
+  hestParm *hparm;
+  airArray *mop;
+
+  char **ninStr, *err, *outS, doneStr[13];
+  Nrrd *nin0, *nin, *nrgb, *nout, *nhist[2], *npreout, *nhproj[3];
+  float *rgb;
+  float *out, *preout, *hist[2], maxSum,
+    upSample, overSampleScale;
+  unsigned int size0, sX, sY, sH, ninLen, ti, overSampleNum;
+  NrrdResampleContext *rsmc;
+  NrrdKernelSpec *ksp;
+
+  me = argv[0];
+  mop = airMopNew();
+  hopt = NULL;
+  hparm = hestParmNew();
+  airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);
+  hparm->respFileEnable = AIR_TRUE;
+  hestOptAdd(&hopt, "i", "images", airTypeString, 1, -1, &ninStr, NULL,
+             "input image sequence", &ninLen, NULL, NULL);
+  hestOptAdd(&hopt, "sh", "histo size", airTypeUInt, 1, 1, &sH, "500",
+             "histogram size");
+  hestOptAdd(&hopt, "k", "kern", airTypeOther, 1, 1, &ksp,
+             "tent", "kernel for upsampling images",
+             NULL, NULL, nrrdHestKernelSpec);
+  hestOptAdd(&hopt, "us", "upsampling", airTypeFloat, 1, 1, &upSample,
+             "1", "amount of upsampling of image");
+  hestOptAdd(&hopt, "osn", "# oversmp", airTypeUInt, 1, 1, &overSampleNum,
+             "1", "number of sample per (upsampled) pixel");
+  hestOptAdd(&hopt, "osc", "scaling", airTypeFloat, 1, 1, &overSampleScale,
+             "1", "scaling with oversampling");
+  hestOptAdd(&hopt, "ms", "max sum", airTypeFloat, 1, 1, &maxSum,
+             "10", "per-hue histogram summation is non-linearly and "
+             "asymptotically clamped to this maximum");
+  hestOptAdd(&hopt, "o", "nout", airTypeString, 1, 1, &outS, "-",
+             "output filename", NULL);
+
+  hestParseOrDie(hopt, argc-1, argv+1, hparm,
+                 me, mchistInfo, AIR_TRUE, AIR_TRUE, AIR_TRUE);
+  airMopAdd(mop, hopt, (airMopper)hestOptFree, airMopAlways);
+  airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);
+
+  if (0 == overSampleNum) {
+    fprintf(stderr, "%s: overSampleNum must be > 0\n", me);
+    airMopError(mop);
+    return 1;
+  }
+  nin0 = nrrdNew();
+  airMopAdd(mop, nin0, (airMopper)nrrdNuke, airMopAlways);
+  if (nrrdLoad(nin0, ninStr[0], NULL)) {
+    airMopAdd(mop, err=biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: couldn't load first image:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+  if (!( (3 == nin0->axis[0].size || 4 == nin0->axis[0].size)
+         && 3 == nin0->dim
+         && nrrdTypeUChar == nin0->type )) {
+    fprintf(stderr, "%s: 1st image not 3D (3-or-4)-by-X-by-Y %s array "
+            "(got %u-D %s array)\n", me,
+            airEnumStr(nrrdType, nrrdTypeUChar),
+            nin0->dim,
+            airEnumStr(nrrdType, nin0->type));
+    airMopError(mop);
+    return 1;
+  }
+  rsmc = nrrdResampleContextNew();
+  airMopAdd(mop, rsmc, (airMopper)nrrdResampleContextNix, airMopAlways);
+  size0 = AIR_UINT(nin0->axis[0].size);
+  sX = AIR_UINT(upSample*nin0->axis[1].size);
+  sY = AIR_UINT(upSample*nin0->axis[2].size);
+  nrgb = nrrdNew();
+  airMopAdd(mop, nrgb, (airMopper)nrrdNuke, airMopAlways);
+  if (nrrdResampleDefaultCenterSet(rsmc, nrrdCenterCell)
+      || nrrdResampleInputSet(rsmc, nin0)
+      || nrrdResampleKernelSet(rsmc, 1, ksp->kernel, ksp->parm)
+      || nrrdResampleKernelSet(rsmc, 2, ksp->kernel, ksp->parm)
+      || nrrdResampleSamplesSet(rsmc, 1, sX)
+      || nrrdResampleSamplesSet(rsmc, 2, sY)
+      || nrrdResampleRangeFullSet(rsmc, 1)
+      || nrrdResampleRangeFullSet(rsmc, 2)
+      || nrrdResampleTypeOutSet(rsmc, nrrdTypeFloat)
+      || nrrdResampleRenormalizeSet(rsmc, AIR_TRUE)
+      || nrrdResampleExecute(rsmc, nrgb)) {
+    airMopAdd(mop, err=biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error resampling slice:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+
+  nhist[0] = nrrdNew();
+  airMopAdd(mop, nhist[0], (airMopper)nrrdNuke, airMopAlways);
+  nhist[1] = nrrdNew();
+  airMopAdd(mop, nhist[1], (airMopper)nrrdNuke, airMopAlways);
+  if (nrrdMaybeAlloc_va(nhist[0], nrrdTypeFloat, 2,
+                        AIR_CAST(size_t, sH),
+                        AIR_CAST(size_t, sH))
+      || nrrdMaybeAlloc_va(nhist[1], nrrdTypeFloat, 2,
+                           AIR_CAST(size_t, sH),
+                           AIR_CAST(size_t, sH))) {
+    airMopAdd(mop, err=biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error allocating histos:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+  nhist[0]->axis[0].min = nhist[0]->axis[1].min = 0.0;
+  nhist[0]->axis[0].max = nhist[0]->axis[1].max = 1.0;
+  nhist[1]->axis[0].min = nhist[1]->axis[1].min = 0.0;
+  nhist[1]->axis[0].max = nhist[1]->axis[1].max = 1.0;
+  nhproj[0] = nrrdNew();
+  airMopAdd(mop, nhproj[0], (airMopper)nrrdNix, airMopAlways);
+  nhproj[1] = nrrdNew();
+  airMopAdd(mop, nhproj[1], (airMopper)nrrdNix, airMopAlways);
+  nhproj[2] = nrrdNew();
+  airMopAdd(mop, nhproj[2], (airMopper)nrrdNix, airMopAlways);
+
+  printf("working ...       ");
+  hist[0] = AIR_CAST(float *, nhist[0]->data);
+  hist[1] = AIR_CAST(float *, nhist[1]->data);
+  nin = nrrdNew();
+  airMopAdd(mop, nin, (airMopper)nrrdNuke, airMopAlways);
+  npreout = nrrdNew();
+  airMopAdd(mop, npreout, (airMopper)nrrdNuke, airMopAlways);
+  if (nrrdMaybeAlloc_va(npreout, nrrdTypeFloat, 3,
+                        AIR_CAST(size_t, 3),
+                        AIR_CAST(size_t, sH),
+                        AIR_CAST(size_t, ninLen))) {
+    airMopAdd(mop, err=biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error allocating pre-output:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+  preout = AIR_CAST(float *, npreout->data);
+  for (ti=0; ti<ninLen; ti++) {
+    printf("%s", airDoneStr(0, ti, ninLen, doneStr)); fflush(stdout);
+    if (nrrdLoad(nin, ninStr[ti], NULL)) {
+      airMopAdd(mop, err=biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: couldn't load image[%u]:\n%s", me, ti, err);
+      airMopError(mop);
+      return 1;
+    }
+    if (!nrrdSameSize(nin0, nin, AIR_TRUE)) {
+      airMopAdd(mop, err=biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: nin[%u] not like nin[0]:\n%s", me, ti, err);
+      airMopError(mop);
+      return 1;
+    }
+    if (nrrdResampleInputSet(rsmc, nin)
+        || nrrdResampleExecute(rsmc, nrgb)) {
+      airMopAdd(mop, err=biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: trouble resampling nin[%u]:\n%s", me, ti, err);
+      airMopError(mop);
+      return 1;
+    }
+    if (nrrdWrap_va(nhproj[0], preout + 0*sH, nrrdTypeFloat, 1, AIR_CAST(size_t, sH)) ||
+        nrrdWrap_va(nhproj[1], preout + 1*sH, nrrdTypeFloat, 1, AIR_CAST(size_t, sH)) ||
+        nrrdWrap_va(nhproj[2], preout + 2*sH, nrrdTypeFloat, 1, AIR_CAST(size_t, sH))) {
+      airMopAdd(mop, err=biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: trouble wrapping output[%u]:\n%s", me, ti, err);
+      airMopError(mop);
+      return 1;
+    }
+    rgb = AIR_CAST(float *, nrgb->data);
+    imageProc(nhproj, nhist, sH,
+              rgb, size0, sX*sY,
+              overSampleNum, overSampleScale);
+    preout += 3*sH;
+  }
+  printf("%s\n", airDoneStr(0, ti, ninLen, doneStr)); fflush(stdout);
+
+  nout = nrrdNew();
+  airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
+  if (nrrdMaybeAlloc_va(nout, nrrdTypeFloat, 3,
+                        AIR_CAST(size_t, 3),
+                        AIR_CAST(size_t, sH),
+                        AIR_CAST(size_t, ninLen))) {
+    airMopAdd(mop, err=biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error allocating output:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+  out = AIR_CAST(float *, nout->data);
+  preout = AIR_CAST(float *, npreout->data);
+  for (ti=0; ti<ninLen; ti++) {
+    unsigned int hi;
+    float hh, vv, ss, scl;
+    for (hi=0; hi<sH; hi++) {
+      hh = (float)AIR_AFFINE(0, hi, sH, 0, 1);
+      if (!preout[hi + 2*sH]) {
+        ELL_3V_SET(out + 3*hi, 0, 0, 0);
+      } else {
+        ss = preout[hi + 2*sH];
+        scl = ss/(maxSum + ss);
+        vv = scl*preout[hi + 1*sH];
+        dyeHSVtoRGB(out + 0 + 3*hi, out + 1 + 3*hi, out + 2 + 3*hi,
+                    hh, preout[hi + 0*sH], vv);
+      }
+    }
+    out += 3*sH;
+    preout += 3*sH;
+  }
+
+  if (nrrdSave(outS, nout, NULL)) {
+    airMopAdd(mop, err=biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error saving output:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+
+  airMopOkay(mop);
+  return 0;
+}
diff --color -ruN teem-1.11.0-src.orig/src/echo/bounds.c teem-1.11.0-src/src/echo/bounds.c
--- teem-1.11.0-src.orig/src/echo/bounds.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/bounds.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/CMakeLists.txt teem-1.11.0-src/src/echo/CMakeLists.txt
--- teem-1.11.0-src.orig/src/echo/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/echo/CMakeLists.txt	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,23 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(ECHO_SOURCES
+  bounds.c
+  color.c
+  echo.h
+  enumsEcho.c
+  intx.c
+  lightEcho.c
+  list.c
+  matter.c
+  methodsEcho.c
+  model.c
+  objmethods.c
+  privateEcho.h
+  renderEcho.c
+  set.c
+  sqd.c
+  )
+
+target_sources(teem PRIVATE ${ECHO_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( echo FILES ${ECHO_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/echo/color.c teem-1.11.0-src/src/echo/color.c
--- teem-1.11.0-src.orig/src/echo/color.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/color.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -40,12 +40,12 @@
 void
 echoTextureLookup(echoCol_t rgba[4], Nrrd *ntext,
                   echoPos_t u, echoPos_t v, echoRTParm *parm) {
-  int su, sv, ui, vi;
+  unsigned int su, sv, ui, vi;
   float uf, vf;
   unsigned char *tdata00, *tdata10, *tdata01, *tdata11;
 
-  su = ntext->axis[1].size;
-  sv = ntext->axis[2].size;
+  su = AIR_UINT(ntext->axis[1].size);
+  sv = AIR_UINT(ntext->axis[2].size);
   if (parm->textureNN) {
     ui = airIndex(0.0, u, 1.0, su);
     vi = airIndex(0.0, v, 1.0, sv);
@@ -56,8 +56,8 @@
   } else {
     u = AIR_AFFINE(0.0, u, 1.0, 0.0, su-1);  u = AIR_CLAMP(0, u, su-1);
     v = AIR_AFFINE(0.0, v, 1.0, 0.0, sv-1);  v = AIR_CLAMP(0, v, sv-1);
-    u -= (u == su-1);  ui = (int)u;  uf = AIR_CAST(float, u - ui);
-    v -= (v == sv-1);  vi = (int)v;  vf = AIR_CAST(float, v - vi);
+    u -= (u == su-1);  ui = (int)u;  uf = AIR_FLOAT(u - ui);
+    v -= (v == sv-1);  vi = (int)v;  vf = AIR_FLOAT(v - vi);
     tdata00 = (unsigned char*)(ntext->data) + 4*(ui + su*vi);
     tdata01 = tdata00 + 4;
     tdata10 = tdata00 + 4*su;
diff --color -ruN teem-1.11.0-src.orig/src/echo/echo.h teem-1.11.0-src/src/echo/echo.h
--- teem-1.11.0-src.orig/src/echo/echo.h	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/echo.h	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/enumsEcho.c teem-1.11.0-src/src/echo/enumsEcho.c
--- teem-1.11.0-src.orig/src/echo/enumsEcho.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/enumsEcho.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/GNUmakefile teem-1.11.0-src/src/echo/GNUmakefile
--- teem-1.11.0-src.orig/src/echo/GNUmakefile	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/GNUmakefile	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/echo/intx.c teem-1.11.0-src/src/echo/intx.c
--- teem-1.11.0-src.orig/src/echo/intx.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/intx.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/lightEcho.c teem-1.11.0-src/src/echo/lightEcho.c
--- teem-1.11.0-src.orig/src/echo/lightEcho.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/lightEcho.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/list.c teem-1.11.0-src/src/echo/list.c
--- teem-1.11.0-src.orig/src/echo/list.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/list.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/matter.c teem-1.11.0-src/src/echo/matter.c
--- teem-1.11.0-src.orig/src/echo/matter.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/matter.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/methodsEcho.c teem-1.11.0-src/src/echo/methodsEcho.c
--- teem-1.11.0-src.orig/src/echo/methodsEcho.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/methodsEcho.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/model.c teem-1.11.0-src/src/echo/model.c
--- teem-1.11.0-src.orig/src/echo/model.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/model.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/objmethods.c teem-1.11.0-src/src/echo/objmethods.c
--- teem-1.11.0-src.orig/src/echo/objmethods.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/objmethods.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/privateEcho.h teem-1.11.0-src/src/echo/privateEcho.h
--- teem-1.11.0-src.orig/src/echo/privateEcho.h	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/privateEcho.h	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/renderEcho.c teem-1.11.0-src/src/echo/renderEcho.c
--- teem-1.11.0-src.orig/src/echo/renderEcho.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/renderEcho.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -72,9 +72,9 @@
     return 1;
   }
 
-  airSrandMT_r(tstate->rst, AIR_CAST(unsigned int, (parm->seedRand
-                                                    ? airTime()
-                                                    : threadIdx)));
+  airSrandMT_r(tstate->rst, AIR_UINT((parm->seedRand
+                                      ? airTime()
+                                      : threadIdx)));
   tstate->returnPtr = NULL;
 
   return 0;
@@ -269,7 +269,7 @@
   if (tstate->verbose) {
     fprintf(stderr, "%s%s: hit a %d (%p) at (%g,%g,%g)\n"
             "%s    = %g along (%g,%g,%g)\n", _echoDot(tstate->depth), me,
-            intx.obj->type, AIR_CAST(void*, intx.obj),
+            intx.obj->type, AIR_VOIDP(intx.obj),
             intx.pos[0], intx.pos[1], intx.pos[2], _echoDot(tstate->depth),
             intx.t, ray->dir[0], ray->dir[1], ray->dir[2]);
   }
diff --color -ruN teem-1.11.0-src.orig/src/echo/set.c teem-1.11.0-src/src/echo/set.c
--- teem-1.11.0-src.orig/src/echo/set.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/set.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/sources.cmake teem-1.11.0-src/src/echo/sources.cmake
--- teem-1.11.0-src.orig/src/echo/sources.cmake	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,21 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(ECHO_SOURCES
-  bounds.c
-  color.c
-  echo.h
-  enumsEcho.c
-  intx.c
-  lightEcho.c
-  list.c
-  matter.c
-  methodsEcho.c
-  model.c
-  objmethods.c
-  privateEcho.h
-  renderEcho.c
-  set.c
-  sqd.c
-  )
-
-ADD_TEEM_LIBRARY(echo ${ECHO_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/echo/sqd.c teem-1.11.0-src/src/echo/sqd.c
--- teem-1.11.0-src.orig/src/echo/sqd.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/echo/sqd.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/test/glyph.c teem-1.11.0-src/src/echo/test/glyph.c
--- teem-1.11.0-src.orig/src/echo/test/glyph.c	2012-12-20 22:10:29.000000000 +0800
+++ teem-1.11.0-src/src/echo/test/glyph.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/test/test.c teem-1.11.0-src/src/echo/test/test.c
--- teem-1.11.0-src.orig/src/echo/test/test.c	2012-12-20 22:10:29.000000000 +0800
+++ teem-1.11.0-src/src/echo/test/test.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/echo/test/trend.c teem-1.11.0-src/src/echo/test/trend.c
--- teem-1.11.0-src.orig/src/echo/test/trend.c	2012-12-20 22:10:29.000000000 +0800
+++ teem-1.11.0-src/src/echo/test/trend.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/elf/ballStickElf.c teem-1.11.0-src/src/elf/ballStickElf.c
--- teem-1.11.0-src.orig/src/elf/ballStickElf.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/elf/ballStickElf.c	2021-02-18 15:42:34.000000000 +0800
@@ -48,24 +48,24 @@
   double sbd=sqrt(bd);
   double erfsbd=airErf(sbd);
   double spi=sqrt(AIR_PI);
-  kernel[0]=AIR_CAST(float, b0*AIR_PI*erfsbd/sbd);
+  kernel[0]=AIR_FLOAT(b0*AIR_PI*erfsbd/sbd);
   if (order>=2) {
-    kernel[1]=AIR_CAST(float, -b0/(4.0*bd*sbd)*embd*sqrt(5*AIR_PI)*
-                       (6*sbd+(-3+2*bd)*ebd*spi*erfsbd));
+    kernel[1]=AIR_FLOAT(-b0/(4.0*bd*sbd)*embd*sqrt(5*AIR_PI)*
+                        (6*sbd+(-3+2*bd)*ebd*spi*erfsbd));
     if (order>=4) {
-      kernel[2]=AIR_CAST(float, b0/(32.0*bd*bd*sbd)*embd*spi*
-                         (-30*sbd*(21+2*bd)+9*(35+4*bd*(-5+bd))*
+      kernel[2]=AIR_FLOAT(b0/(32.0*bd*bd*sbd)*embd*spi*
+                          (-30*sbd*(21+2*bd)+9*(35+4*bd*(-5+bd))*
                           ebd*spi*erfsbd));
       if (order>=6) { /* At order 6, noise starts to take over! */
-        kernel[3]=AIR_CAST(float, b0/(128*bd*bd*bd*sbd)*embd*sqrt(13.0)*
-                           (-42*sbd*(165+4*bd*(5+bd))*spi-
-                            5*(-693+378*bd-84*bd*bd+8*bd*bd*bd)*
-                            ebd*AIR_PI*erfsbd));
+        kernel[3]=AIR_FLOAT(b0/(128*bd*bd*bd*sbd)*embd*sqrt(13.0)*
+                            (-42*sbd*(165+4*bd*(5+bd))*spi-
+                             5*(-693+378*bd-84*bd*bd+8*bd*bd*bd)*
+                             ebd*AIR_PI*erfsbd));
         if (order>=8) {
-          kernel[4]=AIR_CAST(float, b0/(2048*bd*bd*bd*bd*sbd)*embd*sqrt(17.0)*
-                             (-6*sbd*(225225+2*bd*(15015+2*bd*(1925+62*bd)))*spi+
-                              35*(19305+8*bd*(-1287+bd*(297+2*(-18+bd)*bd)))*
-                              ebd*AIR_PI*erfsbd));
+          kernel[4]=AIR_FLOAT(b0/(2048*bd*bd*bd*bd*sbd)*embd*sqrt(17.0)*
+                              (-6*sbd*(225225+2*bd*(15015+2*bd*(1925+62*bd)))*spi+
+                               35*(19305+8*bd*(-1287+bd*(297+2*(-18+bd)*bd)))*
+                               ebd*AIR_PI*erfsbd));
           if (order>8)
             return 1;
         }
@@ -121,15 +121,15 @@
 
   /* guess d and fiso based on the data */
   for (k=0; k<dwi->dwino; k++) {
-    float thisd = AIR_CAST(float, -log(dwi->dwis[k]/dwi->b0)/dwi->b);
+    float thisd = AIR_FLOAT(-log(dwi->dwis[k]/dwi->b0)/dwi->b);
     if (dwi->dwis[k]!=0 && thisd>_d) _d=thisd;
     mean += dwi->dwis[k];
   }
   mean /= dwi->dwino;
-  isovf0 = AIR_CAST(float, 0.5*sqrt(AIR_PI/(dwi->b*_d))
-                    *airErf(sqrt(dwi->b*_d)));
-  isovf1 = AIR_CAST(float, exp(-dwi->b*_d));
-  _fiso = AIR_CAST(float, AIR_AFFINE(isovf0,mean/dwi->b0,isovf1, 0.0, 1.0));
+  isovf0 = AIR_FLOAT(0.5*sqrt(AIR_PI/(dwi->b*_d))
+                     *airErf(sqrt(dwi->b*_d)));
+  isovf1 = AIR_FLOAT(exp(-dwi->b*_d));
+  _fiso = AIR_FLOAT(AIR_AFFINE(isovf0,mean/dwi->b0,isovf1, 0.0, 1.0));
   _fiso=AIR_CLAMP(0.01f,_fiso,0.99f);
   if (fiso!=NULL) *fiso=_fiso;
   if (d!=NULL) *d=_d;
@@ -138,7 +138,7 @@
   elfKernelStick_f(kernel, order, dwi->b*_d, dwi->b0, delta);
 
   /* remove estimated isotropic part from the signal */
-  odf[0] -= AIR_CAST(float, dwi->b0 * _fiso * 2*sqrt(AIR_PI)*exp(-dwi->b*_d));
+  odf[0] -= AIR_FLOAT(dwi->b0 * _fiso * 2*sqrt(AIR_PI)*exp(-dwi->b*_d));
 
   /* deconvolve */
   tijk_esh_deconvolve_f(odf, odf, kernel, order);
diff --color -ruN teem-1.11.0-src.orig/src/elf/CMakeLists.txt teem-1.11.0-src/src/elf/CMakeLists.txt
--- teem-1.11.0-src.orig/src/elf/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/elf/CMakeLists.txt	2021-02-18 15:42:34.000000000 +0800
@@ -0,0 +1,13 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(ELF_SOURCES
+  ballStickElf.c
+  ESHEstimElf.c
+  glyphElf.c
+  maximaElf.c
+  elf.h
+  )
+
+target_sources(teem PRIVATE ${ELF_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( elf FILES ${ELF_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/elf/elf.h teem-1.11.0-src/src/elf/elf.h
--- teem-1.11.0-src.orig/src/elf/elf.h	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/elf/elf.h	2021-02-18 15:42:34.000000000 +0800
@@ -56,6 +56,10 @@
                                const unsigned char *posColor,
                                const unsigned char *negColor);
 
+ELF_EXPORT float elfGlyphKDE(limnPolyData *glyph, const char antipodal,
+                             const float *vecs, const size_t n_vecs,
+                             const float gamma, const char normalize);
+
 ELF_EXPORT int elfColorGlyphMaxima(limnPolyData *glyph, const char antipodal,
                                    const int *neighbors, unsigned int nbstride,
                                    const float *ten, const tijk_type *type,
@@ -91,12 +95,25 @@
                                elfMaximaContext *emc);
 
 /* ESHEstimElf.c */
+ELF_EXPORT void elfCart2Thetaphi_d(double *thetaphi, const double *dirs,
+                                   unsigned int ct);
 ELF_EXPORT void elfCart2Thetaphi_f(float *thetaphi, const float *dirs,
                                    unsigned int ct);
+
+ELF_EXPORT int elfESHEstimMatrix_d(double *T, double *H, unsigned int order,
+                                   const double *thetaphi,
+                                   unsigned int ct, double lambda, double *w);
 ELF_EXPORT int elfESHEstimMatrix_f(float *T, float *H, unsigned int order,
                                    const float *thetaphi,
                                    unsigned int ct, float lambda, float *w);
 
+ELF_EXPORT int elfTenEstimMatrix_d(double *T, double *H, const tijk_type *type,
+                                   const double *vecs, unsigned int ct,
+                                   double *w);
+ELF_EXPORT int elfTenEstimMatrix_f(float *T, float *H, const tijk_type *type,
+                                   const float *vecs, unsigned int ct,
+                                   float *w);
+
 /* ballStickElf.c */
 
 /* elfSingleShellDWI:
diff --color -ruN teem-1.11.0-src.orig/src/elf/ESHEstimElf.c teem-1.11.0-src/src/elf/ESHEstimElf.c
--- teem-1.11.0-src.orig/src/elf/ESHEstimElf.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/elf/ESHEstimElf.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2011, 2010, 2009, 2008 Thomas Schultz
+  Copyright (C) 2013, 2012, 2011, 2010, 2009, 2008 Thomas Schultz
 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License
@@ -21,7 +21,9 @@
 
 #include "elf.h"
 
-/* Routines for estimating even-order spherical harmonics coefficients */
+/* Routines for estimating even-order spherical harmonics or tensor
+ * coefficients.
+ */
 
 /* elfCart2Thetaphi:
  *
@@ -30,18 +32,22 @@
  * Input vectors should be non-zero, but do not need to be normalized
  * thetaphi needs to be pre-allocated to length 2*ct
  */
-void elfCart2Thetaphi_f(float *thetaphi, const float *dirs, unsigned int ct)
-{
-  unsigned int i;
-  for (i=0; i<ct; i++) {
-    float r=AIR_CAST(float, ELL_3V_LEN(dirs+3*i));
-    float z=dirs[3*i+2]/r;
-    if (z>1) thetaphi[2*i]=0;
-    else if (z<-1) thetaphi[2*i]=AIR_CAST(float, AIR_PI);
-    else thetaphi[2*i]=AIR_CAST(float, acos(z));
-    thetaphi[2*i+1]=AIR_CAST(float, atan2(dirs[3*i+1],dirs[3*i]));
-  }
-}
+#define ELFCART2THETAPHI(TYPE, SUF)                                     \
+  void elfCart2Thetaphi_##SUF(TYPE *thetaphi, const TYPE *dirs,         \
+                              unsigned int ct) {                        \
+    unsigned int i;                                                     \
+    for (i=0; i<ct; i++) {                                              \
+      TYPE r=AIR_CAST(TYPE, ELL_3V_LEN(dirs+3*i));                      \
+      TYPE z=dirs[3*i+2]/r;                                             \
+      if (z>1) thetaphi[2*i]=0;                                         \
+      else if (z<-1) thetaphi[2*i]=AIR_CAST(TYPE, AIR_PI);              \
+      else thetaphi[2*i]=AIR_CAST(TYPE, acos(z));                       \
+      thetaphi[2*i+1]=AIR_CAST(TYPE, atan2(dirs[3*i+1],dirs[3*i]));     \
+    }                                                                   \
+  }                                                                     \
+
+ELFCART2THETAPHI(double, d)
+ELFCART2THETAPHI(float, f)
 
 /* elfESHEstimMatrix:
  *
@@ -61,100 +67,233 @@
  *         1 if order is unsupported
  *         2 if len(v)<len(c) (i.e., system is underdetermined)
  */
-int elfESHEstimMatrix_f(float *T, float *H, unsigned int order,
-                        const float *thetaphi,
-                        unsigned int ct, float lambda, float *w)
-{
-  double *B, *M, *Minv;
-  unsigned int N, i, j, k;
-  Nrrd *nmat, *ninv;
-  if (order>tijk_max_esh_order || order%2!=0)
-    return 1;
-  N=tijk_esh_len[order/2];
-  if (ct<N) return 2;
-
-  /* intermediate computations are done in double precision */
-  B = (double*) malloc(sizeof(double)*N*ct);
-  M = (double*) malloc(sizeof(double)*N*N);
-
-  /* build the transformation matrix */
-  /* B has row major format -> all SHs that belong to the same
-   *                           thetaphi are stored sequentially */
-  for (i=0; i<ct; i++) {
-    tijk_eval_esh_basis_d(B+N*i, order, thetaphi[2*i], thetaphi[2*i+1]);
-  }
-  if (w!=NULL) { /* weighted fit */
-    for (i=0; i<N; ++i) /* row index */
-      for (j=0; j<N; ++j) { /* column index */
-        M[N*i+j]=0.0;
-        for (k=0; k<ct; ++k) {
-          M[N*i+j]+=B[N*k+i]*B[N*k+j]*w[k];
-        }
-      }
-  } else { /* unweighted fit */
-    for (i=0; i<N; ++i) /* row index */
-      for (j=0; j<N; ++j) { /* column index */
-        M[N*i+j]=0.0;
-        for (k=0; k<ct; ++k) {
-          M[N*i+j]+=B[N*k+i]*B[N*k+j];
-        }
-      }
-  }
-  /* if desired, perform Laplace-Beltrami regularization */
-  if (lambda>0) {
-    unsigned int idx=0, o;
-    for (o=0; o<=order; o+=2) { /* order */
-      while (idx<tijk_esh_len[o/2]) {
-        M[N*idx+idx]+=lambda*o*o*(o+1)*(o+1);
-        idx++;
-      }
-    }
-  }
-  /* invert what we have up to now */
-  nmat = nrrdNew();
-  ninv = nrrdNew();
-  nmat->dim=2;
-  nmat->type=nrrdTypeDouble;
-  nmat->axis[0].size=nmat->axis[1].size=N;
-  nmat->data=M;
-  ell_Nm_inv(ninv, nmat);
-  Minv = (double*) ninv->data;
-
-  /* create final transformation matrix */
-  if (w!=NULL) { /* weighted */
-    for (i=0; i<N; ++i) /* row index */
-      for (j=0; j<ct; ++j) {
-        unsigned int idx=ct*i+j;
-        T[idx]=0.0;
-        for (k=0; k<N; ++k) {
-          T[idx]+=AIR_CAST(float, Minv[N*i+k]*B[N*j+k]*w[j]);
-        }
-      }
-  } else { /* unweighted */
-    for (i=0; i<N; ++i) /* row index */
-      for (j=0; j<ct; ++j) {
-        unsigned int idx=ct*i+j;
-        T[idx]=0.0;
-        for (k=0; k<N; ++k) {
-          T[idx]+=AIR_CAST(float, Minv[N*i+k]*B[N*j+k]);
-        }
-      }
-  }
-  nmat = nrrdNix(nmat);
-  ninv = nrrdNuke(ninv);
-
-  if (H!=NULL) { /* H = BT */
-    for (i=0; i<ct; i++) /* row index */
-      for (j=0; j<ct; j++) {
-        unsigned int idx=ct*i+j;
-        H[idx]=0.0;
-        for (k=0; k<N; k++) { /* sum over all SH coeffs */
-          H[idx]+=AIR_CAST(float, B[N*i+k]*T[k*ct+j]);
-        }
-      }
-  }
-
-  free(M);
-  free(B);
-  return 0;
+#define ELFESHESTIMMATRIX(TYPE, SUF)                                    \
+  int elfESHEstimMatrix_##SUF(TYPE *T, TYPE *H, unsigned int order,     \
+                              const TYPE *thetaphi,                     \
+                              unsigned int ct, TYPE lambda, TYPE *w) {  \
+  double *B, *M, *Minv;                                                 \
+  unsigned int N, i, j, k;                                              \
+  Nrrd *nmat, *ninv;                                                    \
+  if (order>tijk_max_esh_order || order%2!=0)                           \
+    return 1;                                                           \
+  N=tijk_esh_len[order/2];                                              \
+  if (ct<N) return 2;                                                   \
+                                                                        \
+  /* intermediate computations are always done in double precision */   \
+  B = (double*) malloc(sizeof(double)*N*ct);                            \
+  M = (double*) malloc(sizeof(double)*N*N);                             \
+                                                                        \
+  /* build the transformation matrix */                                 \
+  /* B has row major format -> all SHs that belong to the same          \
+   *                           thetaphi are stored sequentially */      \
+  for (i=0; i<ct; i++) {                                                \
+    tijk_eval_esh_basis_d(B+N*i, order, thetaphi[2*i], thetaphi[2*i+1]); \
+  }                                                                     \
+  if (w!=NULL) { /* weighted fit */                                     \
+    for (i=0; i<N; ++i) /* row index */                                 \
+      for (j=0; j<N; ++j) { /* column index */                          \
+        M[N*i+j]=0.0;                                                   \
+        for (k=0; k<ct; ++k) {                                          \
+          M[N*i+j]+=B[N*k+i]*B[N*k+j]*w[k];                             \
+        }                                                               \
+      }                                                                 \
+  } else { /* unweighted fit */                                         \
+    for (i=0; i<N; ++i) /* row index */                                 \
+      for (j=0; j<N; ++j) { /* column index */                          \
+        M[N*i+j]=0.0;                                                   \
+        for (k=0; k<ct; ++k) {                                          \
+          M[N*i+j]+=B[N*k+i]*B[N*k+j];                                  \
+        }                                                               \
+      }                                                                 \
+  }                                                                     \
+  /* if desired, perform Laplace-Beltrami regularization */             \
+  if (lambda>0) {                                                       \
+    unsigned int idx=0, o;                                              \
+    for (o=0; o<=order; o+=2) { /* order */                             \
+      while (idx<tijk_esh_len[o/2]) {                                   \
+        M[N*idx+idx]+=lambda*o*o*(o+1)*(o+1);                           \
+        idx++;                                                          \
+      }                                                                 \
+    }                                                                   \
+  }                                                                     \
+  /* invert what we have up to now */                                   \
+  nmat = nrrdNew();                                                     \
+  ninv = nrrdNew();                                                     \
+  nmat->dim=2;                                                          \
+  nmat->type=nrrdTypeDouble;                                            \
+  nmat->axis[0].size=nmat->axis[1].size=N;                              \
+  nmat->data=M;                                                         \
+  ell_Nm_inv(ninv, nmat);                                               \
+  Minv = (double*) ninv->data;                                          \
+                                                                        \
+  /* create final transformation matrix */                              \
+  if (w!=NULL) { /* weighted */                                         \
+    for (i=0; i<N; ++i) /* row index */                                 \
+      for (j=0; j<ct; ++j) {                                            \
+        unsigned int idx=ct*i+j;                                        \
+        T[idx]=0.0;                                                     \
+        for (k=0; k<N; ++k) {                                           \
+          T[idx]+=AIR_CAST(TYPE, Minv[N*i+k]*B[N*j+k]*w[j]);            \
+        }                                                               \
+      }                                                                 \
+  } else { /* unweighted */                                             \
+    for (i=0; i<N; ++i) /* row index */                                 \
+      for (j=0; j<ct; ++j) {                                            \
+        unsigned int idx=ct*i+j;                                        \
+        T[idx]=0.0;                                                     \
+        for (k=0; k<N; ++k) {                                           \
+          T[idx]+=AIR_CAST(TYPE, Minv[N*i+k]*B[N*j+k]);                 \
+        }                                                               \
+      }                                                                 \
+  }                                                                     \
+  nmat = nrrdNix(nmat);                                                 \
+  ninv = nrrdNuke(ninv);                                                \
+                                                                        \
+  if (H!=NULL) { /* H = BT */                                           \
+    for (i=0; i<ct; i++) /* row index */                                \
+      for (j=0; j<ct; j++) {                                            \
+        unsigned int idx=ct*i+j;                                        \
+        H[idx]=0.0;                                                     \
+        for (k=0; k<N; k++) { /* sum over all SH coeffs */              \
+          H[idx]+=AIR_CAST(TYPE, B[N*i+k]*T[k*ct+j]);                   \
+        }                                                               \
+      }                                                                 \
+  }                                                                     \
+                                                                        \
+  free(M);                                                              \
+  free(B);                                                              \
+  return 0;                                                             \
 }
+
+ELFESHESTIMMATRIX(double, d)
+ELFESHESTIMMATRIX(float, f)
+
+/* elfTenEstimMatrix:
+ *
+ * Computes a matrix T that can be used to transform a measurement vector v
+ * of ct values, associated with vectors at vecs, into a vector
+ * t of symmetric tensor coefficients of the given type (t=Tv) such that the
+ * tensor approximates the given values in a least squares sense.
+ *
+ * T needs to be pre-allocated to length len(c)*ct
+ * If H is non-NULL, it should be pre-allocated to length ct*ct
+ *   In this case, the "hat" matrix will be written to H, which maps the
+ *   measurement vector v to the corresponding model predictions
+ * If w is non-NULL, it is assumed to be a weight vector with len(w)=ct
+ *
+ * Returns 0 on success
+ *         1 if tensor type is unsupported
+ *         2 if len(v)<len(c) (i.e., system is underdetermined)
+ */
+/* This is strongly modeled on elfESHEstimMatrix */
+#define ELFTENESTIMMATRIX(TYPE, SUF)                                    \
+  int elfTenEstimMatrix_##SUF(TYPE *T, TYPE *H, const tijk_type *type,  \
+                              const TYPE *vecs,                         \
+                              unsigned int ct, TYPE *w) {               \
+  double *B, *M, *Minv;                                                 \
+  unsigned int N, i, j, k;                                              \
+  Nrrd *nmat, *ninv;                                                    \
+  if (type==NULL || type->sym==NULL || (type->dim!=2 && type->dim!=3))  \
+    return 1;                                                           \
+  N=type->num;                                                          \
+  if (ct<N) return 2;                                                   \
+                                                                        \
+  /* intermediate computations are always done in double precision */   \
+  B = (double*) malloc(sizeof(double)*N*ct);                            \
+  M = (double*) malloc(sizeof(double)*N*N);                             \
+                                                                        \
+  /* build the transformation matrix */                                 \
+  /* B has row major format -> all coeffs that belong to the same       \
+   *                           vec are stored sequentially */           \
+  for (i=0; i<ct; i++) {                                                \
+    double vec[3];                                                      \
+    if (type->dim==2) {                                                 \
+      ELL_2V_COPY(vec, vecs+2*i);                                       \
+    } else {                                                            \
+      ELL_3V_COPY(vec, vecs+3*i);                                       \
+    }                                                                   \
+    (*type->sym->make_rank1_d)(B+N*i, 1.0, vec);                        \
+  }                                                                     \
+  for (j=0; j<N; j++) {                                                 \
+    /* at this point, take sqrt of multiplicities to make               \
+     * condition number for inversion rotation invariant */             \
+    double factor=sqrt(type->mult[j]);                                  \
+    for (i=0; i<ct; i++)                                                \
+      B[N*i+j]*=factor;                                                 \
+  }                                                                     \
+  if (w!=NULL) { /* weighted fit */                                     \
+    for (i=0; i<N; ++i) /* row index */                                 \
+      for (j=0; j<N; ++j) { /* column index */                          \
+        M[N*i+j]=0.0;                                                   \
+        for (k=0; k<ct; ++k) {                                          \
+          M[N*i+j]+=B[N*k+i]*B[N*k+j]*w[k];                             \
+        }                                                               \
+      }                                                                 \
+  } else { /* unweighted fit */                                         \
+    for (i=0; i<N; ++i) /* row index */                                 \
+      for (j=0; j<N; ++j) { /* column index */                          \
+        M[N*i+j]=0.0;                                                   \
+        for (k=0; k<ct; ++k) {                                          \
+          M[N*i+j]+=B[N*k+i]*B[N*k+j];                                  \
+        }                                                               \
+      }                                                                 \
+  }                                                                     \
+  /* invert what we have up to now */                                   \
+  nmat = nrrdNew();                                                     \
+  ninv = nrrdNew();                                                     \
+  nmat->dim=2;                                                          \
+  nmat->type=nrrdTypeDouble;                                            \
+  nmat->axis[0].size=nmat->axis[1].size=N;                              \
+  nmat->data=M;                                                         \
+  ell_Nm_inv(ninv, nmat);                                               \
+  Minv = (double*) ninv->data;                                          \
+                                                                        \
+  /* create final transformation matrix */                              \
+  if (w!=NULL) { /* weighted */                                         \
+    for (i=0; i<N; ++i) /* row index */                                 \
+      for (j=0; j<ct; ++j) {                                            \
+        unsigned int idx=ct*i+j;                                        \
+        T[idx]=0.0;                                                     \
+        for (k=0; k<N; ++k) {                                           \
+          T[idx]+=AIR_CAST(TYPE, Minv[N*i+k]*B[N*j+k]*w[j]);            \
+        }                                                               \
+      }                                                                 \
+  } else { /* unweighted */                                             \
+    for (i=0; i<N; ++i) /* row index */                                 \
+      for (j=0; j<ct; ++j) {                                            \
+        unsigned int idx=ct*i+j;                                        \
+        T[idx]=0.0;                                                     \
+        for (k=0; k<N; ++k) {                                           \
+          T[idx]+=AIR_CAST(TYPE, Minv[N*i+k]*B[N*j+k]);                 \
+        }                                                               \
+      }                                                                 \
+  }                                                                     \
+  nmat = nrrdNix(nmat);                                                 \
+  ninv = nrrdNuke(ninv);                                                \
+                                                                        \
+  if (H!=NULL) { /* H = BT */                                           \
+    for (i=0; i<ct; i++) /* row index */                                \
+      for (j=0; j<ct; j++) {                                            \
+        unsigned int idx=ct*i+j;                                        \
+        H[idx]=0.0;                                                     \
+        for (k=0; k<N; k++) { /* sum over all tensor coeffs */          \
+          H[idx]+=AIR_CAST(TYPE, B[N*i+k]*T[k*ct+j]);                   \
+        }                                                               \
+      }                                                                 \
+  }                                                                     \
+                                                                        \
+  /* divide sqrt(multiplicities) out of T to comply with tijk's         \
+   * (non-premultiplied) representation of tensors */                   \
+  for (i=0; i<N; i++) {                                                 \
+    double factor=1.0/sqrt(type->mult[i]);                              \
+    for (j=0; j<ct; j++)                                                \
+      T[ct*i+j]*=(TYPE)factor;                                          \
+  }                                                                     \
+                                                                        \
+  free(M);                                                              \
+  free(B);                                                              \
+  return 0;                                                             \
+}
+
+ELFTENESTIMMATRIX(double, d)
+ELFTENESTIMMATRIX(float, f)
diff --color -ruN teem-1.11.0-src.orig/src/elf/glyphElf.c teem-1.11.0-src/src/elf/glyphElf.c
--- teem-1.11.0-src.orig/src/elf/glyphElf.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/elf/glyphElf.c	2021-02-18 15:42:34.000000000 +0800
@@ -87,7 +87,7 @@
 ** clamp - if nonzero, negative values will be clamped to zero
 ** normalize - if nonzero, surface normals will be rescaled to unit length
 ** posColor[4] - RGBA color code for positive values (if desired, else NULL)
-** negColor[4] - assumed to be non-NULL if posColor is non-NULL
+** negColor[4] - RGBA color code for negative values (if desired, else NULL)
 **
 ** Output:
 ** glyph is the polar plot that corresponds to ten.
@@ -95,7 +95,7 @@
 ** shape is undefined
 ** Normals are only updated when they were allocated in the input
 ** When colors were present in the input, they are replaced by a color
-** coding of sign (if posColor!=NULL) or a pointwise XYZ-RGB map (else)
+** coding of sign (if pos/negColor!=NULL) or a pointwise XYZ-RGB map (else)
 ** When isdef!=NULL, *isdef is set to 0 if we found evidence that the given
 ** input tensor is not positive definite
 ** The return value is the radius of the glyph's bounding sphere
@@ -116,15 +116,13 @@
 
     /* if RGBA is allocated, take care of coloring */
     if (infoBitFlag & (1 << limnPolyDataInfoRGBA)) {
-      if (posColor!=NULL) {
-        /* color by sign */
-        if (val<0) {
-          ELL_4V_COPY(glyph->rgba+4*i, negColor);
-          if (antipodal) ELL_4V_COPY(glyph->rgba+4*i+4, negColor);
-        } else {
-          ELL_4V_COPY(glyph->rgba+4*i, posColor);
-          if (antipodal) ELL_4V_COPY(glyph->rgba+4*i+4, posColor);
-        }
+      /* color by sign */
+      if (val<0 && negColor!=NULL) {
+	ELL_4V_COPY(glyph->rgba+4*i, negColor);
+	if (antipodal) ELL_4V_COPY(glyph->rgba+4*i+4, negColor);
+      } else if (val>0 && posColor!=NULL) {
+	ELL_4V_COPY(glyph->rgba+4*i, posColor);
+	if (antipodal) ELL_4V_COPY(glyph->rgba+4*i+4, posColor);
       } else {
         /* RGB encode the vertex coordinates */
         ELL_4V_SET_TT(glyph->rgba+4*i, unsigned char,
@@ -207,7 +205,7 @@
     (*type->sym->v_form_f)(HOMEpos,ten,verts);
     if (ELL_3V_DOT(HOMEpos,verts)<0) def=0;
     ELL_3V_COPY(verts,HOMEpos);
-    len=AIR_CAST(float, ELL_3V_LEN(HOMEpos));
+    len=AIR_FLOAT(ELL_3V_LEN(HOMEpos));
     if (len>max) max=len;
 
     /* if RGBA is allocated, take care of coloring */
@@ -248,6 +246,87 @@
 }
 
 /*
+******** elfGlyphKDE
+**
+** Turns a unit sphere into a polar plot that depicts Kernel Density
+** Estimate (KDE) of input vectors
+**
+** Input:
+** glyph is expected to represent the unit sphere
+** antipodal can be set to a non-zero value if antipodal points on the sphere
+**           are subsequent in the input, and gamma is even. It will lead to
+**           faster processing.
+**           (this can be used together with limnPolyDataIcoSphere)
+** vecs is a set of n_vecs 3D input vectors (PDF samples)
+** KDE uses dp kernel with exponent gamma
+** normalize - if nonzero, surface normals will be rescaled to unit length
+**
+** Output:
+** glyph is the polar plot that corresponds to KDE of vecs.
+** If the input shape was anything other than a unit sphere, the output
+** shape is undefined
+**
+**  NOTE ON NORMALIZATION:
+**  Normalization is such that the maximum radius of the glyph (when all
+**  samples agree) is one. To instead normalize the KDE such that it
+**  integrates to unity, multiply by (2*gamma+1)/(4*pi)
+**
+** Normals are only updated when they were allocated in the input
+** When colors were present in the input, they are replaced by a pointwise
+** XYZ-RGB map
+** The return value is the radius of the glyph's bounding sphere
+*/
+float
+elfGlyphKDE(limnPolyData *glyph, const char antipodal,
+            const float *vecs, const size_t n_vecs,
+            const float _gamma, const char normalize) {
+  float *verts=glyph->xyzw;
+  float max=0;
+  unsigned int i, j, infoBitFlag;
+  infoBitFlag = limnPolyDataInfoBitFlag(glyph);
+  for (i=0; i<glyph->xyzwNum; i++) {
+    /* compute value by looping over all vecs */
+    double val=0;
+    for (j=0; j<n_vecs; j++) {
+      double dp = ELL_3V_DOT(verts, vecs+3*j);
+      val+=pow(dp, _gamma);
+    }
+    val/=n_vecs;
+
+    /* if RGBA is allocated, take care of coloring */
+    if (infoBitFlag & (1 << limnPolyDataInfoRGBA)) {
+      /* RGB encode the vertex coordinates */
+      ELL_4V_SET_TT(glyph->rgba+4*i, unsigned char,
+                    255*fabs(verts[0]), 255*fabs(verts[1]),
+                    255*fabs(verts[2]), 255);
+      if (antipodal) {
+        ELL_4V_COPY(glyph->rgba+4*i+4,glyph->rgba+4*i);
+      }
+    }
+
+    if (val>max) max=AIR_FLOAT(val);
+    ELL_3V_SCALE_TT(verts,float,val,verts);
+    if (antipodal) {
+      ELL_3V_SCALE(verts+4,-1.0f,verts);
+      verts+=4; i++;
+    }
+    verts+=4;
+  }
+  if (infoBitFlag & (1 << limnPolyDataInfoNorm)) {
+    /* take care of normals */
+    if (antipodal &&
+        glyph->primNum==1 &&
+        glyph->type[0]==limnPrimitiveTriangles) {
+      /* we can use our specialized, more efficient code */
+      estimateNormalsAntipodal(glyph, normalize);
+    } else { /* use standard limn routine */
+      limnPolyDataVertexNormals(glyph);
+    }
+  }
+  return max;
+}
+
+/*
 ******** elfColorGlyphMaxima
 **
 ** Maximum-based coloring of tensor glyphs, as described in Section 4 of
@@ -273,7 +352,7 @@
 elfColorGlyphMaxima(limnPolyData *glyph, const char antipodal,
                     const int *neighbors, unsigned int nbstride,
                     const float *ten, const tijk_type *type,
-                    const char modulate, const float gamma) {
+                    const char modulate, const float _gamma) {
   float *sqrdist, *verts, *newcol;
   char *processed, *id_ct, *diff_ct;
   int *path;
@@ -351,7 +430,7 @@
         float norm;
         float modfactor=1.0;
         ELL_3V_COPY(vertdir,glyph->xyzw+4*vert);
-        norm=AIR_CAST(float, ELL_3V_LEN(vertdir));
+        norm=AIR_FLOAT(ELL_3V_LEN(vertdir));
         if (norm>1e-18) {
           ELL_3V_SCALE(vertdir,1.0f/norm,vertdir);
           if (modulate) {
@@ -367,7 +446,7 @@
             } else {
               modfactor=-evals[1]/(type->order*val);
               if (modfactor>1.0) modfactor=1.0;
-              else modfactor=AIR_CAST(float, pow(modfactor,gamma));
+              else modfactor=AIR_FLOAT(pow(modfactor,_gamma));
             }
           }
         } else {
diff --color -ruN teem-1.11.0-src.orig/src/elf/GNUmakefile teem-1.11.0-src/src/elf/GNUmakefile
--- teem-1.11.0-src.orig/src/elf/GNUmakefile	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/elf/GNUmakefile	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/elf/maximaElf.c teem-1.11.0-src/src/elf/maximaElf.c
--- teem-1.11.0-src.orig/src/elf/maximaElf.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/elf/maximaElf.c	2021-02-18 15:42:34.000000000 +0800
@@ -189,7 +189,7 @@
     *ls = (float*) malloc(sizeof(float)*retval);
     *vs = (float*) malloc(sizeof(float)*3*retval);
     for (i=0; i<(unsigned int)retval; i++) {
-      (*ls)[i]=AIR_CAST(float,-airHeapFrontPop(heap, (*vs)+3*i));
+      (*ls)[i]=AIR_FLOAT(-airHeapFrontPop(heap, (*vs)+3*i));
     }
   }
   heap=airHeapNix(heap);
diff --color -ruN teem-1.11.0-src.orig/src/elf/sources.cmake teem-1.11.0-src/src/elf/sources.cmake
--- teem-1.11.0-src.orig/src/elf/sources.cmake	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/elf/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(ELF_SOURCES
-  ballStickElf.c
-  ESHEstimElf.c
-  glyphElf.c
-  maximaElf.c
-  elf.h
-  )
-
-ADD_TEEM_LIBRARY(elf ${ELF_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/ell/CMakeLists.txt teem-1.11.0-src/src/ell/CMakeLists.txt
--- teem-1.11.0-src.orig/src/ell/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/ell/CMakeLists.txt	2021-02-18 15:42:34.000000000 +0800
@@ -0,0 +1,17 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(ELL_SOURCES
+  cubicEll.c
+  eigen.c
+  ell.h
+  ellMacros.h
+  genmat.c
+  mat.c
+  miscEll.c
+  quat.c
+  vecEll.c
+  )
+
+target_sources(teem PRIVATE ${ELL_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( ell FILES ${ELL_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/ell/cubicEll.c teem-1.11.0-src/src/ell/cubicEll.c
--- teem-1.11.0-src.orig/src/ell/cubicEll.c	2012-12-20 22:10:27.000000000 +0800
+++ teem-1.11.0-src/src/ell/cubicEll.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ell/eigen.c teem-1.11.0-src/src/ell/eigen.c
--- teem-1.11.0-src.orig/src/ell/eigen.c	2012-12-20 22:10:27.000000000 +0800
+++ teem-1.11.0-src/src/ell/eigen.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -52,6 +52,168 @@
   }
   */
 
+/*
+******** ell_quadratic()
+**
+** finds real roots of A*x^2 + B*x + C.
+**
+** records the found roots in the given root array, and returns a
+** value from the ell_quadratic_root* enum:
+**
+**   ell_quadratic_root_two:
+**      two distinct roots root[0] > root[1]
+**   ell_quadratic_root_complex:
+**      two complex conjugate roots at root[0] +/- i*root[1]
+**   ell_quadratic_root_double:
+**      a repeated root root[0] == root[1]
+**
+** HEY simple as this code may seem, it has definitely numerical
+** issues that have not been explored or fixed, such as what if A is
+** near 0.  Also correctly handling the transition from double root to
+** complex roots needs to be re-thought, as well as this issue:
+** http://people.csail.mit.edu/bkph/articles/Quadratics.pdf Should
+** also understand http://www.cs.berkeley.edu/~wkahan/Qdrtcs.pdf
+**
+** This does NOT use biff
+*/
+int
+ell_quadratic(double root[2], double A, double B, double C) {
+  /* static const char me[]="ell_quadratic"; */
+  int ret;
+  double disc, rd, tmp, eps=1.0E-12;
+
+  disc = B*B - 4*A*C;
+  if (disc > 0) {
+    rd = sqrt(disc);
+    root[0] = (-B + rd)/(2*A);
+    root[1] = (-B - rd)/(2*A);
+    if (root[0] < root[1]) {
+      ELL_SWAP2(root[0], root[1], tmp);
+    }
+    ret = ell_quadratic_root_two;
+  } else if (disc < -eps) {
+    root[0] = -B/(2*A);
+    root[1] = sqrt(-disc)/(2*A);
+    ret = ell_quadratic_root_complex;
+  } else {
+    /* 0 == disc or only *very slightly* negative */
+    root[0] = root[1] = -B/(2*A);
+    ret = ell_quadratic_root_double;
+  }
+  return ret;
+}
+
+int
+ell_2m_eigenvalues_d(double eval[2], const double m[4]) {
+  double A, B, C;
+  int ret;
+
+  A = 1;
+  B = -m[0] - m[3];
+  C = m[0]*m[3] - m[1]*m[2];
+  ret = ell_quadratic(eval, A, B, C);
+  return ret;
+}
+
+void
+ell_2m_1d_nullspace_d(double ans[2], const double _n[4]) {
+  /* static const char me[]="ell_2m_1d_nullspace_d"; */
+  double n[4], dot, len, rowv[2];
+
+  ELL_4V_COPY(n, _n);
+  dot = ELL_2V_DOT(n + 2*0, n + 2*1);
+  /*
+  fprintf(stderr, "!%s: n = {{%g,%g},{%g,%g}}\n", me,
+          n[0], n[1], n[2], n[3]);
+  fprintf(stderr, "!%s: dot = %g\n", me, dot);
+  */
+  if (dot > 0) {
+    ELL_2V_ADD2(rowv, n + 2*0, n + 2*1);
+  } else {
+    ELL_2V_SUB(rowv, n + 2*0, n + 2*1);
+  }
+  /* fprintf(stderr, "!%s: rowv = %g %g\n", me, rowv[0], rowv[1]); */
+  /* have found good description of what's perpendicular nullspace,
+     so now perpendicularize it */
+  ans[0] = rowv[1];
+  ans[1] = -rowv[0];
+  ELL_2V_NORM(ans, ans, len);
+  /*
+  if (!(AIR_EXISTS(ans[0]) && AIR_EXISTS(ans[1]))) {
+    fprintf(stderr, "!%s: bad! %g %g\n", me, ans[0], ans[1]);
+  }
+  */
+  return;
+}
+
+/*
+******** ell_2m_eigensolve_d
+**
+** Eigensolve 2x2 matrix, which may be asymmetric
+*/
+int
+ell_2m_eigensolve_d(double eval[2], double evec[4], const double m[4]) {
+  /* static const char me[]="ell_2m_eigensolve_d"; */
+  double nul[4], ident[4] = {1,0,0,1};
+  int ret;
+
+  ret = ell_2m_eigenvalues_d(eval, m);
+  /*
+  fprintf(stderr, "!%s: m = {{%.17g,%.17g},{%.17g,%.17g}} -> "
+          "%s evals (%.17g,%.17g)\n", me, m[0], m[1], m[2], m[3],
+          airEnumStr(ell_quadratic_root, ret), eval[0], eval[1]);
+  */
+  switch (ret) {
+  case ell_quadratic_root_two:
+    ELL_4V_SCALE_ADD2(nul, 1.0, m, -eval[0], ident);
+    ell_2m_1d_nullspace_d(evec + 2*0, nul);
+    /*
+    fprintf(stderr, "!%s: eval=%.17g -> nul {{%.17g,%.17g},{%.17g,%.17g}} "
+            "-> evec %.17g %.17g\n", me, eval[0],
+            nul[0], nul[1], nul[2], nul[3],
+            (evec + 2*0)[0], (evec + 2*0)[1]);
+    */
+    ELL_4V_SCALE_ADD2(nul, 1.0, m, -eval[1], ident);
+    ell_2m_1d_nullspace_d(evec + 2*1, nul);
+    /*
+    fprintf(stderr, "!%s: eval=%.17g -> nul {{%.17g,%.17g},{%.17g,%.17g}} "
+            "-> evec %.17g %.17g\n", me, eval[1],
+            nul[0], nul[1], nul[2], nul[3],
+            (evec + 2*1)[0], (evec + 2*1)[1]);
+    */
+    break;
+  case ell_quadratic_root_double:
+    /* fprintf(stderr, "!%s: double eval=%.17g\n", me, eval[0]); */
+    ELL_4V_SCALE_ADD2(nul, 1.0, m, -eval[0], ident);
+    /*
+    fprintf(stderr, "!%s: nul = {{%.17g,%.17g},{%.17g,%.17g}} (len %.17g)\n",
+            me, nul[0], nul[1], nul[2], nul[3], ELL_4V_LEN(nul));
+    */
+    if (ELL_4V_DOT(nul, nul)) {
+      /* projecting out the nullspace produced non-zero matrix,
+         (possibly from an asymmetric matrix) so there is real
+         orientation to recover */
+      ell_2m_1d_nullspace_d(evec + 2*0, nul);
+      ELL_2V_COPY(evec + 2*1, evec + 2*0);
+    } else {
+      /* so this was isotropic symmetric; invent orientation */
+      ELL_2V_SET(evec + 2*0, 1, 0);
+      ELL_2V_SET(evec + 2*1, 0, 1);
+    }
+    break;
+  case ell_quadratic_root_complex:
+    /* HEY punting for now */
+    ELL_2V_SET(evec + 2*0, 0.5, 0);
+    ELL_2V_SET(evec + 2*1, 0, 0.5);
+    break;
+  default:
+    /* fprintf(stderr, "%s: unexpected solution indicator %d\n", me, ret); */
+    break;
+  }
+  return ret;
+}
+
+
 void
 _ell_align3_d(double v[9]) {
   double d0, d1, d2;
@@ -248,6 +410,10 @@
   return roots;
 }
 
+/*
+** not static because it might be useful, but it's a weird function
+** because eval is modified!
+*/
 void
 _ell_3m_evecs_d(double evec[9], double eval[3], int roots,
                 const double m[9]) {
@@ -336,10 +502,9 @@
 **
 ** finds eigenvalues and eigenvectors of given matrix m
 **
-** returns information about the roots according to ellCubeRoot enum,
-** see header for ellCubic for details.  When eval[i] is set, evec+3*i
-** is set to a corresponding eigenvector.  The eigenvectors are
-** (evec+0)[], (evec+3)[], and (evec+6)[]
+** returns information about the roots according to ell_cubic_root enum;
+** When eval[i] is set, evec+3*i is set to a corresponding eigenvector.
+** The eigenvectors are (evec+0)[], (evec+3)[], and (evec+6)[]
 **
 ** NOTE: Even in the post-Teem-1.7 switch from column-major to
 ** row-major- its still the case that the eigenvectors are at
@@ -369,6 +534,133 @@
   return roots;
 }
 
+/* ____________________________ 3m2sub ____________________________ */
+/*
+******** ell_3m2sub_eigenvalues_d
+**
+** for doing eigensolve of the upper-left 2x2 matrix sub-matrix of a
+** 3x3 matrix.  The other entries are assumed to be zero.  A 0 root is
+** put last (in eval[2]), possibly in defiance of the usual eigenvalue
+** ordering.
+*/
+int
+ell_3m2sub_eigenvalues_d(double eval[3], const double _m[9]) {
+  double A, B, m[4], D, Dsq, eps=1.0E-11;
+  int roots;
+  /* static const char me[]="ell_3m2sub_eigenvalues_d"; */
+
+  m[0] = _m[0];
+  m[1] = _m[1];
+  m[2] = _m[3];
+  m[3] = _m[4];
+
+  /* cubic characteristic equation is L^3 + A*L^2 + B*L = 0 */
+  A = -m[0] - m[3];
+  B = m[0]*m[3] - m[1]*m[2];
+  Dsq = A*A - 4*B;
+  /*
+  fprintf(stderr, "!%s: m = {{%f,%f},{%f,%f}} -> A=%f B=%f Dsq=%.17f %s 0 (%.17f)\n", me,
+          m[0], m[1], m[2], m[3], A, B, Dsq,
+          (Dsq > 0 ? ">" : (Dsq < 0 ? "<" : "==")), eps);
+  fprintf(stderr, "!%s: Dsq = \n", me);
+  airFPFprintf_d(stderr, Dsq);
+  fprintf(stderr, "!%s: eps = \n", me);
+  airFPFprintf_d(stderr, eps);
+  ell_3m_print_d(stderr, _m);
+  */
+  if (Dsq > eps) {
+    D = sqrt(Dsq);
+    eval[0] = (-A + D)/2;
+    eval[1] = (-A - D)/2;
+    eval[2] = 0;
+    roots = ell_cubic_root_three;
+  } else if (Dsq < -eps) {
+    /* no quadratic roots; only the implied zero */
+    ELL_3V_SET(eval, AIR_NAN, AIR_NAN, 0);
+    roots = ell_cubic_root_single;
+  } else {
+    /* a quadratic double root */
+    ELL_3V_SET(eval, -A/2, -A/2, 0);
+    roots = ell_cubic_root_single_double;
+  }
+  /*
+  fprintf(stderr, "!%s: Dsq=%f, roots=%d (%f %f %f)\n",
+          me, Dsq, roots, eval[0], eval[1], eval[2]);
+  */
+  return roots;
+}
+
+void
+_ell_22v_enforce_orthogonality(double uu[2], double _vv[2]) {
+  double dot, vv[2], len;
+
+  dot = ELL_2V_DOT(uu, _vv);
+  ELL_2V_SCALE_ADD2(vv, 1, _vv, -dot, uu);
+  ELL_2V_NORM(_vv, vv, len);
+  return;
+}
+
+/*
+** NOTE: assumes that eval and roots have come from
+** ell_3m2sub_eigenvalues_d(m)
+*/
+void
+_ell_3m2sub_evecs_d(double evec[9], double eval[3], int roots,
+                    const double m[9]) {
+  double n[4];
+  static const char me[]="_ell_3m2sub_evecs_d";
+
+  if (ell_cubic_root_three == roots) {
+    /* set off-diagonal entries once */
+    n[1] = m[1];
+    n[2] = m[3];
+    /* find first evec */
+    n[0] = m[0] - eval[0];
+    n[3] = m[4] - eval[0];
+    ell_2m_1d_nullspace_d(evec + 3*0, n);
+    (evec + 3*0)[2] = 0;
+    /* find second evec */
+    n[0] = m[0] - eval[1];
+    n[3] = m[4] - eval[1];
+    ell_2m_1d_nullspace_d(evec + 3*1, n);
+    (evec + 3*1)[2] = 0;
+    _ell_22v_enforce_orthogonality(evec + 3*0, evec + 3*1);
+    /* make right-handed */
+    ELL_3V_CROSS(evec + 3*2, evec + 3*0, evec + 3*1);
+  } else if (ell_cubic_root_single_double == roots) {
+    /* can pick any 2D basis */
+    ELL_3V_SET(evec + 3*0, 1, 0, 0);
+    ELL_3V_SET(evec + 3*1, 0, 1, 0);
+    ELL_3V_SET(evec + 3*2, 0, 0, 1);
+  } else {
+    /* ell_cubic_root_single == roots, if assumptions are met */
+    ELL_3V_SET(evec + 3*0, AIR_NAN, AIR_NAN, 0);
+    ELL_3V_SET(evec + 3*1, AIR_NAN, AIR_NAN, 0);
+    ELL_3V_SET(evec + 3*2, 0, 0, 1);
+  }
+  if (!ELL_3M_EXISTS(evec)) {
+    fprintf(stderr, "%s: given m = \n", me);
+    ell_3m_print_d(stderr, m);
+    fprintf(stderr, "%s: got roots = %s (%d) and evecs = \n", me,
+            airEnumStr(ell_cubic_root, roots), roots);
+    ell_3m_print_d(stderr, evec);
+  }
+  return;
+}
+
+int
+ell_3m2sub_eigensolve_d(double eval[3], double evec[9],
+                        const double m[9]) {
+  int roots;
+
+  roots = ell_3m2sub_eigenvalues_d(eval, m);
+  _ell_3m2sub_evecs_d(evec, eval, roots, m);
+
+  return roots;
+}
+
+/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 3m2sub ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */
+
 /*
 ******** ell_3m_svd_d
 **
@@ -529,15 +821,18 @@
   iter = 0;
   while (sumoff/sumon > eps) {
     double th, tt, cc, ss;
-    unsigned int P, Q;
+    const unsigned int P = maxI[0];
+    const unsigned int Q = maxI[1];
+    /* make sure that P and Q are within the bounds for mat[2][6][6] */
+    if (P >=6 || Q >= 6){
+      break;
+    }
     /*
     fprintf(stderr, "!%s(%u): sumoff/sumon = %g/%g = %g > %g\n", me, iter,
             sumoff, sumon, sumoff/sumon, eps);
     */
     cur = 1 - cur;
 
-    P = maxI[0];
-    Q = maxI[1];
     th = (mat[cur][Q][Q] - mat[cur][P][P])/(2*mat[cur][P][Q]);
     tt = (th > 0 ? +1 : -1)/(AIR_ABS(th) + sqrt(th*th + 1));
     cc = 1/sqrt(tt*tt + 1);
@@ -632,7 +927,7 @@
     if (_evec) {
       unsigned eeI;
       for (rrI=0; rrI<6; rrI++) {
-        eeI = AIR_CAST(unsigned int, evtmp[1 + 2*ccI]);
+        eeI = AIR_UINT(evtmp[1 + 2*ccI]);
         _evec[rrI + 6*ccI] = evec[1-cur][eeI][rrI];
       }
     }
diff --color -ruN teem-1.11.0-src.orig/src/ell/ell.h teem-1.11.0-src/src/ell/ell.h
--- teem-1.11.0-src.orig/src/ell/ell.h	2012-12-20 22:10:27.000000000 +0800
+++ teem-1.11.0-src/src/ell/ell.h	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -50,9 +50,25 @@
 #define ELL_EPS 1.0e-10
 
 /*
+******** ell_quadratic_root* enum
+**
+** return values for ell_quadratic, ell_2m_eigenvalues,
+** ell_2m_eigensolve, etc
+*/
+enum {
+  ell_quadratic_root_unknown,  /* 0 */
+  ell_quadratic_root_two,      /* 1 */
+  ell_quadratic_root_double,   /* 2 */
+  ell_quadratic_root_complex,  /* 3 */
+  ell_quadratic_root_last
+};
+#define ELL_QUADRATIC_ROOT_MAX    3
+
+/*
 ******** ell_cubic_root* enum
 **
-** return values for ell_cubic
+** return values for ell_cubic, ell_3m_eigenvalues,
+** ell_3m_eigensolve, etc
 */
 enum {
   ell_cubic_root_unknown,         /* 0 */
@@ -62,7 +78,6 @@
   ell_cubic_root_three,           /* 4 */
   ell_cubic_root_last
 };
-
 #define ELL_CUBIC_ROOT_MAX           4
 
 /*
@@ -94,6 +109,7 @@
 /* miscEll.c */
 ELL_EXPORT const int ellPresent;
 ELL_EXPORT const char *ell_biff_key;
+ELL_EXPORT const airEnum *const ell_quadratic_root;
 ELL_EXPORT const airEnum *const ell_cubic_root;
 ELL_EXPORT int ell_debug;
 ELL_EXPORT void ell_3m_print_f(FILE *f, const float s[9]);
@@ -117,6 +133,8 @@
                               const float m[16], const float v1[4]);
 ELL_EXPORT void ell_4mv_mul_d(double v2[4],
                               const double m[16], const double v1[4]);
+ELL_EXPORT float ell_2v_angle_f(const float u[2], const float v[2]);
+ELL_EXPORT double ell_2v_angle_d(const double u[2], const double v[2]);
 ELL_EXPORT float ell_3v_angle_f(const float u[3], const float v[3]);
 ELL_EXPORT double ell_3v_angle_d(const double u[3], const double v[3]);
 ELL_EXPORT double ell_3v_area_spherical_d(const double avec[3],
@@ -133,9 +151,11 @@
                              const float m1[9], const float m2[9]);
 ELL_EXPORT void ell_3m_mul_d(double m3[9],
                              const double m1[9], const double m2[9]);
-ELL_EXPORT void ell_3m_pre_mul_f(float m[9], const float x[9]);
-ELL_EXPORT void ell_3m_pre_mul_d(double m[9], const double x[9]);
-ELL_EXPORT void ell_3m_post_mul_f(float m[9], const float x[9]);
+/*                                     A = A * B */
+ELL_EXPORT void ell_3m_pre_mul_f(float A[9], const float B[9]);
+ELL_EXPORT void ell_3m_pre_mul_d(double A[9], const double B[9]);
+/*                                      A = B * A */
+ELL_EXPORT void ell_3m_post_mul_f(float A[9], const float B[9]);
 ELL_EXPORT void ell_3m_post_mul_d(double m[9], const double x[9]);
 ELL_EXPORT float ell_3m_det_f(float m[9]);
 ELL_EXPORT double ell_3m_det_d(double m[9]);
@@ -243,11 +263,16 @@
 ELL_EXPORT int ell_Nm_pseudo_inv(Nrrd *dest, Nrrd *src);
 ELL_EXPORT int ell_Nm_wght_pseudo_inv(Nrrd *ninv, Nrrd *nA, Nrrd *nW);
 
-/* cubic.c */
+/* cubicEll.c */
 ELL_EXPORT int ell_cubic(double root[3],
                          double A, double B, double C, int newton);
 
 /* eigen.c */
+ELL_EXPORT int ell_quadratic(double root[2], double A, double B, double C);
+ELL_EXPORT void ell_2m_1d_nullspace_d(double ans[2], const double n[4]);
+ELL_EXPORT int ell_2m_eigenvalues_d(double eval[2], const double m[4]);
+ELL_EXPORT int ell_2m_eigensolve_d(double eval[2], double evec[4],
+                                   const double m[4]);
 ELL_EXPORT void ell_3m_1d_nullspace_d(double ans[3], const double n[9]);
 ELL_EXPORT void ell_3m_2d_nullspace_d(double ans0[3],
                                       double ans1[3], const double n[9]);
@@ -255,6 +280,9 @@
                                     const double m[9], const int newton);
 ELL_EXPORT int ell_3m_eigensolve_d(double eval[3], double evec[9],
                                    const double m[9], const int newton);
+ELL_EXPORT int ell_3m2sub_eigenvalues_d(double eval[3], const double m[9]);
+ELL_EXPORT int ell_3m2sub_eigensolve_d(double eval[3], double evec[9],
+                                       const double m[9]);
 ELL_EXPORT int ell_3m_svd_d(double uu[9], double sval[3], double vv[9],
                             const double mat[9], const int newton);
 ELL_EXPORT int ell_6ms_eigensolve_d(double eval[6], double evec[36],
diff --color -ruN teem-1.11.0-src.orig/src/ell/ellMacros.h teem-1.11.0-src/src/ell/ellMacros.h
--- teem-1.11.0-src.orig/src/ell/ellMacros.h	2012-12-20 22:10:27.000000000 +0800
+++ teem-1.11.0-src/src/ell/ellMacros.h	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -92,10 +92,20 @@
       ? 2                        \
       : 1))
 
+#define ELL_2V_EQUAL(a, b) \
+  ((a)[0] == (b)[0] && (a)[1] == (b)[1])
+
+#define ELL_2V_EXISTS(v) \
+  (AIR_EXISTS((v)[0]) && AIR_EXISTS((v)[1]))
+
 #define ELL_2V_SET(v, a, b) \
   ((v)[0]=(a), (v)[1]=(b))
 
-#define ELL_2V_SET_TT(v, TT, a, b) \
+#define ELL_2V_NAN_SET(v) ( \
+  (v)[0] = AIR_NAN, \
+  (v)[1] = AIR_NAN)
+
+#define ELL_2V_SET_TT(v, TT, a, b)              \
   ((v)[0] = AIR_CAST(TT, (a)), \
    (v)[1] = AIR_CAST(TT, (b)))
 
@@ -106,6 +116,10 @@
   ((v2)[0] += (v1)[0],      \
    (v2)[1] += (v1)[1])
 
+#define ELL_2V_SCALE_INCR(v2, s0, v0) \
+  ((v2)[0] += (s0)*(v0)[0], \
+   (v2)[1] += (s0)*(v0)[1])
+
 #define ELL_2V_LERP(v3, w, v1, v2)            \
   ((v3)[0] = AIR_LERP((w), (v1)[0], (v2)[0]), \
    (v3)[1] = AIR_LERP((w), (v1)[1], (v2)[1]))
@@ -145,13 +159,32 @@
   ((v2)[0] = (a)*(v1)[0],       \
    (v2)[1] = (a)*(v1)[1])
 
+#define ELL_2V_SCALE_TT(v2, TT, a, v1)   \
+  ((v2)[0] = AIR_CAST(TT, (a)*(v1)[0]), \
+   (v2)[1] = AIR_CAST(TT, (a)*(v1)[1]))
+
 #define ELL_2V_SCALE_ADD2(v2, s0, v0, s1, v1) \
   ((v2)[0] = (s0)*(v0)[0] + (s1)*(v1)[0],     \
    (v2)[1] = (s0)*(v0)[1] + (s1)*(v1)[1])
 
+#define ELL_2V_SCALE_ADD3(vd, s0, v0, s1, v1, s2, v2)    \
+  ((vd)[0] = (s0)*(v0)[0] + (s1)*(v1)[0] + (s2)*(v2)[0], \
+   (vd)[1] = (s0)*(v0)[1] + (s1)*(v1)[1] + (s2)*(v2)[1])
+
+#define ELL_2V_SCALE_ADD4(vd, s0, v0, s1, v1, s2, v2, s3, v3)   \
+  ((vd)[0] = (s0)*(v0)[0] + (s1)*(v1)[0] + (s2)*(v2)[0] + (s3)*(v3)[0], \
+   (vd)[1] = (s0)*(v0)[1] + (s1)*(v1)[1] + (s2)*(v2)[1] + (s3)*(v3)[1])
+
 #define ELL_2V_NORM(v2, v1, length) \
   (length = ELL_2V_LEN(v1), ELL_2V_SCALE(v2, 1.0/length, v1))
 
+#define ELL_2V_NORM_TT(v2, TT, v1, length) \
+  (length = AIR_CAST(TT, ELL_2V_LEN(v1)), \
+   ELL_2V_SCALE_TT(v2, TT, 1.0/length, v1))
+
+#define ELL_2V_CROSS(v1, v2) \
+  ((v1)[0]*(v2)[1] - (v1)[1]*(v2)[0])
+
 /*
 ** the 2x2 matrix-related macros assume that the matrix indexing is:
 ** 0  1
@@ -162,6 +195,13 @@
 
 #define ELL_2M_DET(m) _ELL_2M_DET((m)[0],(m)[1],(m)[2],(m)[3])
 
+#define ELL_2M_INV(m2, m1, det) \
+  ((det) = ELL_2M_DET(m1),      \
+   (m2)[0] =  (m1)[3]/(det),    \
+   (m2)[1] = -(m1)[1]/(det),    \
+   (m2)[2] = -(m1)[2]/(det),    \
+   (m2)[3] =  (m1)[0]/(det))
+
 #define ELL_2M_TRANSPOSE(m2, m1)                \
   ((m2)[0] = (m1)[0],                           \
    (m2)[1] = (m1)[2],                           \
@@ -374,9 +414,12 @@
    (m1)[7] == (m2)[7] &&     \
    (m1)[8] == (m2)[8])
 
-#define ELL_3M_SET(m, a, b, c, d, e, f, g, h, i) \
-  (ELL_3V_SET(m + 0*3, a, b, c),                 \
-   ELL_3V_SET(m + 1*3, d, e, f),                 \
+#define ELL_3M_SET(m,            \
+                   a, b, c,      \
+                   d, e, f,      \
+                   g, h, i)      \
+  (ELL_3V_SET(m + 0*3, a, b, c), \
+   ELL_3V_SET(m + 1*3, d, e, f), \
    ELL_3V_SET(m + 2*3, g, h, i))
 
 #define ELL_3M_SCALE(m2, s, m1) \
@@ -689,6 +732,12 @@
    (v3)[2] = (v1)[2] + (v2)[2], \
    (v3)[3] = (v1)[3] + (v2)[3])
 
+#define ELL_4V_ADD3(v3, v0, v1, v2)       \
+  ((v3)[0] = (v0)[0] + (v1)[0] + (v2)[0], \
+   (v3)[1] = (v0)[1] + (v1)[1] + (v2)[1], \
+   (v3)[2] = (v0)[2] + (v1)[2] + (v2)[2], \
+   (v3)[3] = (v0)[3] + (v1)[3] + (v2)[3])
+
 #define ELL_4V_SUB(v3, v1, v2)  \
   ((v3)[0] = (v1)[0] - (v2)[0], \
    (v3)[1] = (v1)[1] - (v2)[1], \
@@ -737,6 +786,10 @@
 #define ELL_4V_NORM(v2, v1, length) \
   (length = ELL_4V_LEN(v1), ELL_4V_SCALE(v2, 1.0/length, v1))
 
+#define ELL_4V_NORM_TT(v2, TT, v1, length) \
+  (length = AIR_CAST(TT, ELL_4V_LEN(v1)), \
+   ELL_4V_SCALE_TT(v2, TT, 1.0/length, v1))
+
 #define ELL_4V_LERP(v3, w, v1, v2)            \
   ((v3)[0] = AIR_LERP((w), (v1)[0], (v2)[0]), \
    (v3)[1] = AIR_LERP((w), (v1)[1], (v2)[1]), \
@@ -771,6 +824,16 @@
    (m1)[14] == (m2)[14] &&   \
    (m1)[15] == (m2)[15])
 
+#define ELL_4M_SET(X,               \
+                   a, b, c, d,      \
+                   e, f, g, h,      \
+                   i, j, k, l,      \
+                   m, n, o, p)      \
+  (ELL_4V_SET(X + 0*4, a, b, c, d), \
+   ELL_4V_SET(X + 1*4, e, f, g, h), \
+   ELL_4V_SET(X + 2*4, i, j, k, l), \
+   ELL_4V_SET(X + 3*4, m, n, o, p))
+
 #define ELL_4M_ADD2(m3, m1, m2)            \
   (ELL_4V_ADD2((m3)+ 0, (m1)+ 0, (m2)+ 0), \
    ELL_4V_ADD2((m3)+ 4, (m1)+ 4, (m2)+ 4), \
@@ -1042,6 +1105,12 @@
    (l)[ 8] = (m)[6], (l)[ 9] = (m)[7], (l)[10] = (m)[8], (l)[11] = 0, \
    (l)[12] =   0   , (l)[13] =   0   , (l)[14] =   0   , (l)[15] = 1)
 
+#define ELL_43M_INSET_TT(l, T, m)                                      \
+  ((l)[ 0] = (T)(m)[0], (l)[ 1] = (T)(m)[1], (l)[ 2] = (T)(m)[2], (l)[ 3] = 0, \
+   (l)[ 4] = (T)(m)[3], (l)[ 5] = (T)(m)[4], (l)[ 6] = (T)(m)[5], (l)[ 7] = 0, \
+   (l)[ 8] = (T)(m)[6], (l)[ 9] = (T)(m)[7], (l)[10] = (T)(m)[8], (l)[11] = 0, \
+   (l)[12] =   0   ,    (l)[13] =   0   ,    (l)[14] =   0   ,    (l)[15] = 1)
+
 #define ELL_4M_FROB(m) \
   (sqrt(ELL_4V_DOT((m)+ 0, (m)+ 0) + \
         ELL_4V_DOT((m)+ 4, (m)+ 4) + \
diff --color -ruN teem-1.11.0-src.orig/src/ell/genmat.c teem-1.11.0-src/src/ell/genmat.c
--- teem-1.11.0-src.orig/src/ell/genmat.c	2012-12-20 22:10:27.000000000 +0800
+++ teem-1.11.0-src/src/ell/genmat.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ell/GNUmakefile teem-1.11.0-src/src/ell/GNUmakefile
--- teem-1.11.0-src.orig/src/ell/GNUmakefile	2012-12-20 22:10:27.000000000 +0800
+++ teem-1.11.0-src/src/ell/GNUmakefile	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/ell/mat.c teem-1.11.0-src/src/ell/mat.c
--- teem-1.11.0-src.orig/src/ell/mat.c	2012-12-20 22:10:27.000000000 +0800
+++ teem-1.11.0-src/src/ell/mat.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ell/miscEll.c teem-1.11.0-src/src/ell/miscEll.c
--- teem-1.11.0-src.orig/src/ell/miscEll.c	2012-12-20 22:10:27.000000000 +0800
+++ teem-1.11.0-src/src/ell/miscEll.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -45,6 +45,35 @@
 
 
 const char *
+_ell_quadratic_root_str[] = {
+  "(unknown ell_quadratic_root)",
+  "two",
+  "double",
+  "complex"
+};
+
+const char *
+_ell_quadratic_root_desc[] = {
+  "(unknown ell_quadratic_root)",
+  "two distinct roots",
+  "one double root",
+  "complex conjugate roots",
+};
+
+airEnum
+_ell_quadratic_root = {
+  "quadratic root solutions",
+  ELL_QUADRATIC_ROOT_MAX,
+  _ell_quadratic_root_str, NULL,
+  _ell_quadratic_root_desc,
+  NULL, NULL,
+  AIR_FALSE
+};
+const airEnum *const
+ell_quadratic_root = &_ell_quadratic_root;
+
+
+const char *
 _ell_cubic_root_str[] = {
   "(unknown ell_cubic_root)",
   "single",
diff --color -ruN teem-1.11.0-src.orig/src/ell/quat.c teem-1.11.0-src/src/ell/quat.c
--- teem-1.11.0-src.orig/src/ell/quat.c	2012-12-20 22:10:27.000000000 +0800
+++ teem-1.11.0-src/src/ell/quat.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -83,7 +83,7 @@
 void
 ell_3m_to_q_f(float q[4], const float m[9]) {
   _ELL_M_TO_Q( float, 0, 1, 2,    3, 4, 5,    6, 7, 8);
-  len = AIR_CAST(float, ELL_4V_LEN(q));
+  len = AIR_FLOAT(ELL_4V_LEN(q));
   ELL_4V_SCALE(q, 1.0f/len, q);
 }
 
@@ -96,7 +96,7 @@
 void
 ell_4m_to_q_f(float q[4], const float m[16]) {
   _ELL_M_TO_Q( float, 0, 1, 2,    4, 5, 6,    8, 9, 10);
-  len = AIR_CAST(float, ELL_4V_LEN(q));
+  len = AIR_FLOAT(ELL_4V_LEN(q));
   ELL_4V_SCALE(q, 1.0f/len, q);
 }
 
@@ -132,7 +132,7 @@
 void
 ell_q_to_3m_f(float m[9], const float q[4]) {
   float u[4], w=0.0, x=0.0, y=0.0, z=0.0;
-  w = AIR_CAST(float, ELL_4V_LEN(q));
+  w = AIR_FLOAT(ELL_4V_LEN(q));
   ELL_4V_SCALE(u, 1.0f/w, q);
   _ELL_Q_TO_3M(float);
 }
@@ -171,7 +171,7 @@
 void
 ell_q_to_4m_f(float m[16], const float q[4]) {
   float u[4], w=0.0, x=0.0, y=0.0, z=0.0;
-  w = AIR_CAST(float, ELL_3V_LEN(q));
+  w = AIR_FLOAT(ELL_3V_LEN(q));
   ELL_4V_SCALE(u, 1.0f/w, q);
   _ELL_Q_TO_4M(float);
 }
@@ -357,7 +357,7 @@
 ell_q_log_f(float q2[4], const float q1[4]) {
   float a, b, axis[3];
 
-  a = AIR_CAST(float, log(ELL_4V_LEN(q1)));
+  a = AIR_FLOAT(log(ELL_4V_LEN(q1)));
   b = ell_q_to_aa_f(axis, q1)/2.0f;
   ELL_4V_SET(q2, a, b*axis[0], b*axis[1], b*axis[2]);
 }
@@ -406,7 +406,7 @@
 ell_q_pow_f(float q2[4], const float q1[4], const float p) {
   float len, angle, axis[3];
 
-  len = AIR_CAST(float, pow(ELL_4V_LEN(q1), p));
+  len = AIR_FLOAT(pow(ELL_4V_LEN(q1), p));
   angle = ell_q_to_aa_f(axis, q1);
   ell_aa_to_q_f(q2, p*angle, axis);
   ELL_4V_SCALE(q2, len, q2);
diff --color -ruN teem-1.11.0-src.orig/src/ell/sources.cmake teem-1.11.0-src/src/ell/sources.cmake
--- teem-1.11.0-src.orig/src/ell/sources.cmake	2012-12-20 22:10:27.000000000 +0800
+++ teem-1.11.0-src/src/ell/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,15 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(ELL_SOURCES
-  cubicEll.c
-  eigen.c
-  ell.h
-  ellMacros.h
-  genmat.c
-  mat.c
-  miscEll.c
-  quat.c
-  vecEll.c
-  )
-
-ADD_TEEM_LIBRARY(ell ${ELL_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/ell/test/es6.c teem-1.11.0-src/src/ell/test/es6.c
--- teem-1.11.0-src.orig/src/ell/test/es6.c	2012-12-20 22:10:23.000000000 +0800
+++ teem-1.11.0-src/src/ell/test/es6.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -55,8 +56,8 @@
         && 6 == _nin->axis[1].size)) {
     fprintf(stderr, "%s: didn't get 2-D 6x6 matrix (got %u-D %ux%u)\n", me,
             _nin->dim,
-            AIR_CAST(unsigned int, _nin->axis[0].size),
-            AIR_CAST(unsigned int, _nin->axis[1].size));
+            AIR_UINT(_nin->axis[0].size),
+            AIR_UINT(_nin->axis[1].size));
     airMopError(mop); return 1;
   }
 
diff --color -ruN teem-1.11.0-src.orig/src/ell/test/inter.c teem-1.11.0-src/src/ell/test/inter.c
--- teem-1.11.0-src.orig/src/ell/test/inter.c	2012-12-20 22:10:23.000000000 +0800
+++ teem-1.11.0-src/src/ell/test/inter.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ell/test/invert.c teem-1.11.0-src/src/ell/test/invert.c
--- teem-1.11.0-src.orig/src/ell/test/invert.c	2012-12-20 22:10:23.000000000 +0800
+++ teem-1.11.0-src/src/ell/test/invert.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ell/test/mmul.c teem-1.11.0-src/src/ell/test/mmul.c
--- teem-1.11.0-src.orig/src/ell/test/mmul.c	2012-12-20 22:10:23.000000000 +0800
+++ teem-1.11.0-src/src/ell/test/mmul.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ell/test/rot2aa.c teem-1.11.0-src/src/ell/test/rot2aa.c
--- teem-1.11.0-src.orig/src/ell/test/rot2aa.c	2012-12-20 22:10:23.000000000 +0800
+++ teem-1.11.0-src/src/ell/test/rot2aa.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ell/test/sort3.c teem-1.11.0-src/src/ell/test/sort3.c
--- teem-1.11.0-src.orig/src/ell/test/sort3.c	2012-12-20 22:10:23.000000000 +0800
+++ teem-1.11.0-src/src/ell/test/sort3.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ell/test/tq.c teem-1.11.0-src/src/ell/test/tq.c
--- teem-1.11.0-src.orig/src/ell/test/tq.c	2012-12-20 22:10:23.000000000 +0800
+++ teem-1.11.0-src/src/ell/test/tq.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ell/test/wheel.c teem-1.11.0-src/src/ell/test/wheel.c
--- teem-1.11.0-src.orig/src/ell/test/wheel.c	2012-12-20 22:10:23.000000000 +0800
+++ teem-1.11.0-src/src/ell/test/wheel.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ell/vecEll.c teem-1.11.0-src/src/ell/vecEll.c
--- teem-1.11.0-src.orig/src/ell/vecEll.c	2012-12-20 22:10:27.000000000 +0800
+++ teem-1.11.0-src/src/ell/vecEll.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -28,7 +28,7 @@
 ell_4v_norm_f(float bv[4], const float av[4]) {
   float len;
 
-  len = AIR_CAST(float, ELL_4V_LEN(av));
+  len = AIR_FLOAT(ELL_4V_LEN(av));
   ELL_4V_SCALE(bv, 1.0f/len, av);
   return;
 }
@@ -119,10 +119,10 @@
   ELL_3V_NORM_TT(vv, float, _vv, len);
   if (ELL_3V_DOT(uu, vv) < 0.0) {
     ELL_3V_ADD2(tmp, uu, vv);
-    ret = AIR_CAST(float, AIR_PI - 2*asin(ELL_3V_LEN(tmp)/2.0));
+    ret = AIR_FLOAT(AIR_PI - 2*asin(ELL_3V_LEN(tmp)/2.0));
   } else {
     ELL_3V_SUB(tmp, uu, vv);
-    ret = AIR_CAST(float, 2*asin(ELL_3V_LEN(tmp)/2.0));
+    ret = AIR_FLOAT(2*asin(ELL_3V_LEN(tmp)/2.0));
   }
   return ret;
 }
@@ -143,6 +143,40 @@
   }
   return ret;
 }
+
+/* HEY: copy and paste */
+float
+ell_2v_angle_f(const float _uu[2], const float _vv[2]) {
+  float tmp[2], len, uu[2], vv[2], ret;
+
+  ELL_2V_NORM_TT(uu, float, _uu, len);
+  ELL_2V_NORM_TT(vv, float, _vv, len);
+  if (ELL_2V_DOT(uu, vv) < 0.0) {
+    ELL_2V_ADD2(tmp, uu, vv);
+    ret = AIR_FLOAT(AIR_PI - 2*asin(ELL_2V_LEN(tmp)/2.0));
+  } else {
+    ELL_2V_SUB(tmp, uu, vv);
+    ret = AIR_FLOAT(2*asin(ELL_2V_LEN(tmp)/2.0));
+  }
+  return ret;
+}
+
+/* HEY: copy and paste */
+double
+ell_2v_angle_d(const double _uu[2], const double _vv[2]) {
+  double tmp[2], len, uu[2], vv[2], ret;
+
+  ELL_2V_NORM(uu, _uu, len);
+  ELL_2V_NORM(vv, _vv, len);
+  if (ELL_2V_DOT(uu, vv) < 0.0) {
+    ELL_2V_ADD2(tmp, uu, vv);
+    ret = AIR_PI - 2*asin(ELL_2V_LEN(tmp)/2.0);
+  } else {
+    ELL_2V_SUB(tmp, uu, vv);
+    ret = 2*asin(ELL_2V_LEN(tmp)/2.0);
+  }
+  return ret;
+}
 
 /*
 ** input vectors have to be normalized!
diff --color -ruN teem-1.11.0-src.orig/src/gage/CMakeLists.txt teem-1.11.0-src/src/gage/CMakeLists.txt
--- teem-1.11.0-src.orig/src/gage/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/gage/CMakeLists.txt	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,31 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(GAGE_SOURCES
+  ctx.c
+  deconvolve.c
+  defaultsGage.c
+  filter.c
+  gage.h
+  kind.c
+  miscGage.c
+  print.c
+  privateGage.h
+  pvl.c
+  scl.c
+  sclanswer.c
+  sclfilter.c
+  sclprint.c
+  shape.c
+  st.c
+  stack.c
+  stackBlur.c
+  update.c
+  vecGage.c
+  twovecGage.c
+  vecprint.c
+  optimsig.c
+  )
+
+target_sources(teem PRIVATE ${GAGE_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( gage FILES ${GAGE_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/gage/ctx.c teem-1.11.0-src/src/gage/ctx.c
--- teem-1.11.0-src.orig/src/gage/ctx.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/ctx.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -305,13 +305,13 @@
 
   switch (which) {
   case gageParmVerbose:
-    ctx->verbose = AIR_CAST(int, val);
+    ctx->verbose = AIR_INT(val);
     if (ctx->verbose > 3) {
       fprintf(stderr, "%s(%p): ctx->verbose now %d\n", me,
-              AIR_CAST(void *, ctx), ctx->verbose);
+              AIR_VOIDP(ctx), ctx->verbose);
     }
     for (pvlIdx=0; pvlIdx<ctx->pvlNum; pvlIdx++) {
-      ctx->pvl[pvlIdx]->verbose = AIR_CAST(int, val);
+      ctx->pvl[pvlIdx]->verbose = AIR_INT(val);
       if (ctx->pvl[pvlIdx]->verbose > 3) {
         fprintf(stderr, "%s: ctx->pvl[%u]->verbose now %d\n", me, pvlIdx,
                 ctx->pvl[pvlIdx]->verbose);
@@ -339,7 +339,7 @@
     /* no flag to set, simply affects future calls to gageProbe() */
     break;
   case gageParmCurvNormalSide:
-    ctx->parm.curvNormalSide = AIR_CAST(int, val);
+    ctx->parm.curvNormalSide = AIR_INT(val);
     /* no flag to set, simply affects future calls to gageProbe() */
     break;
   case gageParmKernelIntegralNearZero:
@@ -347,12 +347,12 @@
     /* no flag to set, simply affects future calls to gageKernelSet() */
     break;
   case gageParmDefaultCenter:
-    ctx->parm.defaultCenter = AIR_CAST(int, val);
+    ctx->parm.defaultCenter = AIR_INT(val);
     /* no flag to set, I guess, although the value here effects the
        action of _gageShapeSet when called by gagePerVolumeAttach . . . */
     break;
   case gageParmStackUse:
-    ctx->parm.stackUse = AIR_CAST(int, val);
+    ctx->parm.stackUse = AIR_INT(val);
     /* no flag to set, right? simply affects future calls to gageProbe()? */
     /* HEY: no? because if you're turning on the stack behavior, you now
        should be doing the error checking to make sure that all the pvls
@@ -360,20 +360,23 @@
        supposed to be called after changing anything, prior to gageProbe() */
     break;
   case gageParmStackNormalizeRecon:
-    ctx->parm.stackNormalizeRecon = AIR_CAST(int, val);
+    ctx->parm.stackNormalizeRecon = AIR_INT(val);
     break;
   case gageParmStackNormalizeDeriv:
-    ctx->parm.stackNormalizeDeriv = AIR_CAST(int, val);
+    ctx->parm.stackNormalizeDeriv = AIR_INT(val);
     break;
   case gageParmStackNormalizeDerivBias:
     ctx->parm.stackNormalizeDerivBias = val;
     break;
   case gageParmOrientationFromSpacing:
-    ctx->parm.orientationFromSpacing = AIR_CAST(int, val);
+    ctx->parm.orientationFromSpacing = AIR_INT(val);
     /* affects future calls to _gageShapeSet */
     break;
   case gageParmGenerateErrStr:
-    ctx->parm.generateErrStr = AIR_CAST(int, val);
+    ctx->parm.generateErrStr = AIR_INT(val);
+    break;
+  case gageParmTwoDimZeroZ:
+    ctx->parm.twoDimZeroZ = AIR_INT(val);
     break;
   default:
     fprintf(stderr, "\n%s: sorry, which = %d not valid\n\n", me, which);
@@ -540,9 +543,9 @@
   }
   data = (char*)pvl->nin->data;
   if (lx >= 0 && ly >= 0 && lz >= 0
-      && hx < AIR_CAST(int, sx)
-      && hy < AIR_CAST(int, sy)
-      && hz < AIR_CAST(int, sz)) {
+      && hx < AIR_INT(sx)
+      && hy < AIR_INT(sy)
+      && hz < AIR_INT(sz)) {
     /* all the samples we need are inside the existing volume */
     dataIdx = lx + sx*(ly + sy*(lz));
     if (ctx->verbose > 1) {
@@ -559,7 +562,7 @@
               dataIdx);
       fprintf(stderr, "%s:     here = %p; iv3 = %p; off[0,1,2,3,4,5,6,7] = "
               "%d,%d,%d,%d,%d,%d,%d,%d\n",
-              me, here, AIR_CAST(void*, pvl->iv3),
+              me, AIR_VOIDP(here), AIR_VOIDP(pvl->iv3),
               ctx->off[0], ctx->off[1], ctx->off[2], ctx->off[3],
               ctx->off[4], ctx->off[5], ctx->off[6], ctx->off[7]);
     }
@@ -602,37 +605,82 @@
     }
     ctx->edgeFrac = 0;
   } else {
-    unsigned int edgeNum;
+    unsigned int edgeNum, dataStride, valLen;
     /* the query requires samples which don't actually lie
        within the volume- more care has to be taken */
+    double *iv3;
     cacheIdx = 0;
     edgeNum = 0;
-    for (_zz=lz; _zz<=hz; _zz++) {
-      zz = AIR_CLAMP(0, _zz, AIR_CAST(int, sz-1));
+    valLen = pvl->kind->valLen;
+    dataStride = AIR_UINT(valLen*nrrdTypeSize[pvl->nin->type]);
+    iv3 = pvl->iv3;
+    if (1 == sz) {
+      /* working with 2D images is now common enough that we try to make
+         simplifications for that (HEY copy and paste). We first do the
+         needed lup()s to fill first slice of iv3 ... */
       for (_yy=ly; _yy<=hy; _yy++) {
-        yy = AIR_CLAMP(0, _yy, AIR_CAST(int, sy-1));
+        yy = AIR_CLAMP(0, _yy, AIR_INT(sy-1));
         for (_xx=lx; _xx<=hx; _xx++) {
-          xx = AIR_CLAMP(0, _xx, AIR_CAST(int, sx-1));
-          edgeNum += ((AIR_CAST(int, zz) != _zz)
-                      || (AIR_CAST(int, yy) != _yy)
-                      || (AIR_CAST(int, xx) != _xx));
-          dataIdx = xx + sx*(yy + sy*zz);
-          here = data + dataIdx*pvl->kind->valLen*nrrdTypeSize[pvl->nin->type];
-          if (ctx->verbose > 2) {
-            fprintf(stderr, "%s:    (%d,%d,%d) --clamp--> (%u,%u,%u)\n", me,
-                    _xx, _yy, _zz, xx, yy, zz);
-            fprintf(stderr, "       --> dataIdx = %d; data = %p -> here = %p\n",
-                    dataIdx, data, here);
+          xx = AIR_CLAMP(0, _xx, AIR_INT(sx-1));
+          edgeNum += ((1 != sy && (AIR_INT(yy) != _yy))
+                      || (AIR_INT(xx) != _xx));
+          dataIdx = xx + sx*yy;
+          here = data+dataIdx*dataStride;
+          for (tup=0; tup<valLen; tup++) {
+            iv3[cacheIdx + fddd*tup] = pvl->lup(here, tup);
           }
-          for (tup=0; tup<pvl->kind->valLen; tup++) {
-            pvl->iv3[cacheIdx + fddd*tup] = pvl->lup(here, tup);
-            if (ctx->verbose > 3) {
-              fprintf(stderr, "%s:    iv3[%u + %u*%u=%u] = %g\n", me,
-                      cacheIdx, fddd, tup, cacheIdx + fddd*tup,
-                      pvl->iv3[cacheIdx + fddd*tup]);
+          cacheIdx++;
+        }
+      }
+      /* ... and then copy from first slice into rest of iv3 */
+      for (_zz=lz+1; _zz<=hz; _zz++) {
+        unsigned int z0ci;
+        z0ci = 0;
+        for (_yy=ly; _yy<=hy; _yy++) {
+          for (_xx=lx; _xx<=hx; _xx++) {
+            for (tup=0; tup<valLen; tup++) {
+              iv3[cacheIdx + fddd*tup] = iv3[z0ci + fddd*tup];
             }
+            cacheIdx++;
+            z0ci++;
+          }
+        }
+      }
+      /* we would have been outside for all the other z slices besides
+         z=0, but don't report this if the whole point is to pretend
+         that we're working with 2D data */
+      if (!(ctx->parm.twoDimZeroZ)) {
+        edgeNum += (2*fr - 1)*2*fr*2*fr;
+      }
+    } else {
+      /* sz > 1 */
+      for (_zz=lz; _zz<=hz; _zz++) {
+        zz = AIR_CLAMP(0, _zz, AIR_INT(sz-1));
+        for (_yy=ly; _yy<=hy; _yy++) {
+          yy = AIR_CLAMP(0, _yy, AIR_INT(sy-1));
+          for (_xx=lx; _xx<=hx; _xx++) {
+            xx = AIR_CLAMP(0, _xx, AIR_INT(sx-1));
+            edgeNum += ((AIR_INT(zz) != _zz)
+                        || (AIR_INT(yy) != _yy)
+                        || (AIR_INT(xx) != _xx));
+            dataIdx = xx + sx*(yy + sy*zz);
+            here = data+dataIdx*pvl->kind->valLen*nrrdTypeSize[pvl->nin->type];
+            if (ctx->verbose > 2) {
+              fprintf(stderr, "%s:    (%d,%d,%d) --clamp--> (%u,%u,%u)\n", me,
+                      _xx, _yy, _zz, xx, yy, zz);
+              fprintf(stderr, "    --> dataIdx = %d; data = %p -> here = %p\n",
+                      dataIdx, AIR_VOIDP(data), AIR_VOIDP(here));
+            }
+            for (tup=0; tup<pvl->kind->valLen; tup++) {
+              iv3[cacheIdx + fddd*tup] = pvl->lup(here, tup);
+              if (ctx->verbose > 3) {
+                fprintf(stderr, "%s:    iv3[%u + %u*%u=%u] = %g\n", me,
+                        cacheIdx, fddd, tup, cacheIdx + fddd*tup,
+                        iv3[cacheIdx + fddd*tup]);
+              }
+            }
+            cacheIdx++;
           }
-          cacheIdx++;
         }
       }
     }
@@ -675,6 +723,9 @@
   if (_gageLocationSet(ctx, _xi, _yi, _zi, _si)) {
     /* we're outside the volume; leave ctx->errNum and ctx->errStr set;
        as they have just been set by _gageLocationSet() */
+    /* GLK had added but not checked in the following line;
+       the logic of this has to be studied further */
+    /* ctx->edgeFrac = 0.666; */
     return 1;
   }
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/deconvolve.c teem-1.11.0-src/src/gage/deconvolve.c
--- teem-1.11.0-src.orig/src/gage/deconvolve.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/deconvolve.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/defaultsGage.c teem-1.11.0-src/src/gage/defaultsGage.c
--- teem-1.11.0-src.orig/src/gage/defaultsGage.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/defaultsGage.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -65,9 +65,6 @@
 double
 gageDefStackNormalizeDerivBias = 0.0;
 
-double
-gageDefStackBlurSigmaMax = 8.0;
-
 int
 gageDefOrientationFromSpacing = AIR_FALSE;
 /* Before teem 1.10.0, gage behaved inconsistently: Derivatives were
@@ -80,3 +77,6 @@
 /* Before Teem 1.11, error strings were always sprintf, which can easily
    become a bottleneck in some situations, but this should still stay
    the default behavior */
+
+int
+gageDefTwoDimZeroZ = AIR_FALSE; /* no way this can default to true */
diff --color -ruN teem-1.11.0-src.orig/src/gage/filter.c teem-1.11.0-src/src/gage/filter.c
--- teem-1.11.0-src.orig/src/gage/filter.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/filter.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -298,7 +298,7 @@
   /* **** computing integral and fractional sample locations **** */
   /* Thu Jan 14 19:46:53 CST 2010: detected that along the low edge
      (next to sample 0) in cell centered, the rounding behavior of
-     AIR_CAST(unsigned int, xif), namely [-0.5,0] --> 0, meant that
+     AIR_UINT(xif), namely [-0.5,0] --> 0, meant that
      the low edge was not treated symmetrically with the high edge.
      This motivated the change from using idx to store the lower
      corner of the containing voxel, to the upper corner.  So, the new
@@ -306,9 +306,9 @@
      ctx.c (since idx is saved into ctx->point.idx) has been changed
      accordingly */
   ELL_3V_SET(idx,
-             AIR_CAST(unsigned int, xif+1), /* +1: see above */
-             AIR_CAST(unsigned int, yif+1),
-             AIR_CAST(unsigned int, zif+1));
+             AIR_UINT(xif+1), /* +1: see above */
+             AIR_UINT(yif+1),
+             AIR_UINT(zif+1));
   if (ctx->verbose > 5) {
     fprintf(stderr, "%s: (%g,%g,%g,%g) -%s-> mm [%g, %g/%g/%g]\n"
             "        --> idx %u %u %u\n",
@@ -326,12 +326,12 @@
             me, idx[0], idx[1], idx[2]);
   }
   ELL_3V_SET(frac,
-             xif - (AIR_CAST(float, idx[0])-1),
-             yif - (AIR_CAST(float, idx[1])-1),
-             zif - (AIR_CAST(float, idx[2])-1));
+             xif - (AIR_FLOAT(idx[0])-1),
+             yif - (AIR_FLOAT(idx[1])-1),
+             zif - (AIR_FLOAT(idx[2])-1));
   ELL_3V_COPY(ctx->point.idx, idx);  /* not idx[3], yet */
   if (ctx->parm.stackUse) {
-    idx[3] = AIR_CAST(unsigned int, sif);
+    idx[3] = AIR_UINT(sif);
     idx[3] -= (idx[3] == ctx->pvlNum-2);
     frac[3] = sif - idx[3];
     sdiff = (ctx->point.idx[3] + ctx->point.frac[3] != sif);
diff --color -ruN teem-1.11.0-src.orig/src/gage/gage.h teem-1.11.0-src/src/gage/gage.h
--- teem-1.11.0-src.orig/src/gage/gage.h	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/gage.h	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -131,6 +131,7 @@
   gageParmStackNormalizeRecon,     /* int; does NOT imply         "        */
   gageParmOrientationFromSpacing,  /* int */
   gageParmGenerateErrStr,          /* int */
+  gageParmTwoDimZeroZ,             /* int */
   gageParmLast
 };
 
@@ -312,12 +313,14 @@
   gageSclCurvDir2,     /* 30: "cdir2", 2nd principle curv direction: [3] */
   gageSclFlowlineCurv, /* 31: "fc", curvature of normal streamline: [1] */
   gageSclMedian,       /* 32: "med", median filter */
-  gageSclHessValleyness,   /* 33: "hvalley", vallyness measure: [1] */
-  gageSclHessRidgeness,    /* 34: "hridge", ridgeness measure: [1] */
-  gageSclHessMode,     /* 35: "hmode", Hessian's mode: [1] */
+  gageSclHessValleyness,  /* 33: "hvalley", vallyness measure: [1] */
+  gageSclHessRidgeness,   /* 34: "hridge", ridgeness measure: [1] */
+  gageSclHessDotPeakness, /* 35: "hdpeak", positive blobness measure;
+                             based on simple dot-product w/ evals : [1] */
+  gageSclHessMode,     /* 36: "hmode", Hessian's mode: [1] */
   gageSclLast
 };
-#define GAGE_SCL_ITEM_MAX 35
+#define GAGE_SCL_ITEM_MAX 36
 
 /*
 ******** gageVec* enum
@@ -377,6 +380,22 @@
 };
 #define GAGE_VEC_ITEM_MAX     31
 
+/*
+******** gage2Vec* enum
+**
+** "items" that gage knows how to measure in a 2-vector volume
+*/
+enum {
+  gage2VecUnknown,        /*  0: nobody knows */
+  gage2VecVector,         /*  1: "v", component-wise-interpolated
+                                 (CWI) vec: [2] */
+  gage2VecVector0,        /*  2: "v0", vector[0]: [1] */
+  gage2VecVector1,        /*  3: "v1", vector[0]: [1] */
+  gage2VecLength,         /*  4: "l", length of 2-vector: [1] */
+  gage2VecLast
+};
+#define GAGE_2VEC_ITEM_MAX    4
+
 struct gageKind_t;       /* dumb forward declaraction, ignore */
 struct gagePerVolume_t;  /* dumb forward declaraction, ignore */
 
@@ -403,6 +422,27 @@
 #define GAGE_ITEM_PACK_PART_MAX   11
 
 /*
+******** gageSigmaSampling* enum
+**
+** The different strategies for locating samples (pre-blurred images) as part
+** of scale-space reconstruction.  It is partly arbitrary, and partly in the
+** interests of tangible familiarity, that of all the possible ways of
+** describing scale, we are using sigma (hence the specificity in the name
+** gageSigmaSampling)
+**
+** Adding this enum was motivated by the eventual plan to add a new sampling
+** density parameter "rho".
+*/
+enum {
+  gageSigmaSamplingUnknown,       /* 0 */
+  gageSigmaSamplingUniformSigma,  /* 1 */
+  gageSigmaSamplingUniformTau,    /* 2 */
+  gageSigmaSamplingOptimal3DL2L2, /* 3 */
+  gageSigmaSamplingLast
+};
+#define GAGE_SIGMA_SAMPLING_MAX      3
+
+/*
 ******** gageShape struct
 **
 ** just a container for all the information related to the "shape"
@@ -411,7 +451,7 @@
 ** Note that the utility of gageShape has extended well beyond doing
 ** convolution-based measurements in volumes- it has become the
 ** one-stop place for all of Teem to figure out a reasonable way of
-** locating a logically a volume in 3-D space, including using a
+** logically locating a volume in 3-D space, including using a
 ** nrrd's full orientation information if it is known.
 */
 typedef struct gageShape_t {
@@ -513,9 +553,21 @@
                                  had axis-aligned spaceDirection vectors, with
                                  the non-zero values determined by the given
                                  per-axis spacing. */
-    generateErrStr;           /* when errors happen, biff is never used, but
+    generateErrStr,           /* when errors happen, biff is never used, but
                                  a descriptive error is sprintf into
                                  gctx->errStr as long as this is non-zero. */
+    twoDimZeroZ;              /* a limited way of supporting queries on
+                                 two-dimensional images. If this is non-zero,
+                                 then *some* answers will only involve the 1st
+                                 ("X") and 2nd ("Y") coordinates of world
+                                 space.  Eigensystems should have only two
+                                 two elements, with the 3rd being NaN'd out.
+                                 Because gage has always been only about 3D
+                                 images; the implementation of this is likely
+                                 incomplete, since the responsibility for
+                                 correctly handling it ultimately falls to the
+                                 "answer" functions of the various
+                                 gageKinds */
 } gageParm;
 
 /*
@@ -738,7 +790,9 @@
 
   /* what fraction of the values in the kernel support had to be invented
      (by bleeding out the margin) in order to satisfy a probe that was near
-     the edge (any axis, either high or low) of the volume */
+     the edge (any axis, either high or low) of the volume. However, this
+     value is NOT meaningfully set if there is no clamping, and the probe
+     location as fallen outside the volume */
   double edgeFrac;
 } gageContext;
 
@@ -837,7 +891,7 @@
   int (*pvlDataUpdate)(const struct gageKind_t *kind,
                        const gageContext *ctx,
                        const gagePerVolume *pvl,
-                       const void *data);
+                       void *data);
   void *data;                       /* extra information about the kind of
                                        volume that's being probed.  Likely
                                        used by filter, answer, and the
@@ -877,81 +931,123 @@
 /*
 ******** gageStackBlurParm struct
 **
-** all parameters associated with blurring one volume to form a "stack"
+** All parameters associated with blurring one volume to form a "stack"
+** for the sake of scale-space analysis.
+**
+** This was reorganized August 2013 with the new attention to how
+** scale-space is handled.
 */
 typedef struct {
-  unsigned int num;      /* # of blurring scales == # volumes */
-  double *scale;         /* scale parameter for each blurred volume */
-  double sigmaMax,       /* nrrdKernelDiscreteGaussian is implemented with
-                            airBesselInExpScaled, which has numerical issues
-                            for very large kernel sizes.  Instead of doing
-                            the blurring in one step, the diffusion is done
-                            iteratively, with steps in diffusion time
-                            of sigmaMax^2 */
-    padValue;            /* padding value for nrrdBoundaryPad */
-  NrrdKernelSpec *kspec; /* NOTE: parm[0] will get over-written as part
-                            of running the resampler at each scale */
-  int dataCheck,         /* when checking given stack to see if its the
-                            blurring of a volume, actually go in and look at
-                            values of first (probably the least blurred)
-                            volume */
-    boundary,            /* passed to nrrdResampleBoundarySet */
-    renormalize,         /* passed to nrrdResampleRenormalizeSet */
-    verbose;
+  unsigned int num;      /* # of pre-computed blurring scales == allocated
+                            length of the "scale" vector below */
+  double sigmaRange[2];  /* sigma range for image blurring */
+  int sigmaSampling;     /* from gageSigmaSampling* enum: how to sample the
+                            range from sigmaRange[0] to sigmaRange[1] */
+  double *sigma;         /* when-non-NULL, the sigma parameter for each
+                            blurring level */
+  NrrdKernelSpec *kspec; /* the kernel with which we do blurring */
+  int renormalize;       /* renormalize kernel weights (associated with the
+                            kernel); passed to nrrdResampleRenormalizeSet */
+  NrrdBoundarySpec *bspec; /* what do to at image boundaries */
+  int oneDim,            /* for experimental/debugging purposes: blur *only*
+                            along the first (fastest) axis */
+    needSpatialBlur,     /* always do blurring in the spatial domain, even
+                            if frequency space blurring is possible */
+    verbose;             /* verbosity level */
+  double dgGoodSigmaMax; /* The same info as communicated by
+                            nrrdKernelDiscreteGaussianGoodSigmaMax, but
+                            allowing it to be different. With this limit on
+                            the sigma we pass to nrrdKernelDiscreteGaussian,
+                            instead of doing the blurring in one step (when
+                            doing spatial as opposed to frequency-space
+                            blurring), the diffusion is done iteratively, with
+                            steps in diffusion time of goodSigmaMax^2 */
 } gageStackBlurParm;
 
 /*
-******** gageOptimSigParm struct
+******** gageOptimSigContext struct
+**
+** The parameters and state needed to optimize (via gageOptimSigCalculate) the
+** locations for reconstructing scale-space, in the specific case of using
+** nrrdKernelDiscreteGaussian for blurring, and using the
+** nrrdKernelHermiteScaleSpaceFlag for reconstructing along scale.  The
+** "samples" are the pre-blurred correct blurrings along scale, of which there
+** are usually about a dozen or fewer.  The purpose of gageOptimSigCalculate
+** is to find where to put those samples so that the error of reconstructing
+** at any other scale is in some sense minimized.
 **
-** a fairly disorganized mess of parameters.  under construction
+** This code was re-written August 2013; one of the big changes is that there
+** is no longer a need for a big 4-D array of pre-computed blurrings.
 */
 typedef struct {
   /* INPUT ------------------------- */
-  /* these determine the allocation and (slow) computation of ntruth */
-  unsigned int dim;            /* either 1, 2, or 3 */
-  double sigmaMax,             /* highest sigma in current computation */
-    cutoff;                    /* parm[1] for discrete gaussian kernel */
-  unsigned int measrSampleNum; /* how many samples along sigma to use
-                                  for measurements of error */
-
-  /* these can be changed more often */
-  unsigned int sampleNum;      /* how many scale samples to optimize */
-  int volMeasr,                /* how to measure error at each reconstructed
-                                  scale (interpolated volume) */
-    lineMeasr,                 /* how to summarize errors across all scales */
-    plotting,                  /* we're plotting, not optimizing */
-    tentRecon;                 /* for plotting: use tent instead of hermite */
-  unsigned int maxIter;        /* allowed iterations in optimization */
-  double convEps;              /* convergence threshold */
+  /* these are set (once) at context creation time */
+  unsigned int dim,        /* what dimension of point-spread function to
+                              optimize based on; either 1, 2, or 3 */
+    sampleNumMax,          /* max number of samples to optimize */
+    trueImgNum;            /* how many samples along scale to use for the
+                              correct reference blurrings; this discretization
+                              determines the accuracy of the error measurement
+                              integrated across scales. For allMeasr *other*
+                              than nrrdMeasureLinf, this determines the number
+                              of error values summarized with allMeasr. With
+                              the re-write of this code, setting this is not
+                              as consequential as it used to be; now it only
+                              controls the allocation of nerr.  One could
+                              imagine another tweak that shifted truImgNum
+                              to the gageOptimSigCalculate or similar call */
+  double sigmaRange[2];    /* range of sigma values that should be studied */
+  double cutoff;           /* second parm to nrrdKernelDiscreteGaussian */
+  /* NOTE: the image blurring to sample a particular scale is always by
+     nrrdKernelDiscreteGaussian; this code is not built for other kinds
+     blurring kernels, even though that would be interesting to pursue */
+
+  /* these are set with calls to gageOptimSigCalculate or gageOptimSigPlot */
+  NrrdKernelSpec *kssSpec; /* how to interpolate across scale; should be
+                              nrrdKernelHermiteScaleSpaceFlag for
+                              kspec->kernel; the main purpose of the sigma
+                              optimization that this code does */
+  unsigned int sampleNum,  /* how many scale samples to optimize */
+    maxIter;               /* allowed iterations in optimization */
+  int imgMeasr,            /* how to measure error at each reconstructed
+                              scale (in the scale-interpolated image) */
+    allMeasr;              /* how to summarize errors across all scales */
+  double convEps;          /* convergence threshold */
 
   /* INTERNAL ------------------------- */
-  /* these related to the allocation and (slow) computation of ntruth */
-  unsigned int sx, sy, sz;     /* volume size for testing */
-  double *sigmatru,            /* sigmas for all lines of ntruth, allocated
-                                  for measrSampleNum */
-    *truth;                    /* data pointer of ntruth */
-  Nrrd *ntruth,                /* big array of all truth volumes, logically
-                                  a sx x sy x sz x measrSampleNum array */
-    *nerr,                     /* line of all errors, across scale */
-    *ntruline,                 /* *wrapper* around some scanline of ntruth */
-    *ninterp,                  /* last recon result */
-    *ndiff;                    /* diff between recon and truth, single vol */
-  /* most of these allocated according sampleNumMax */
-  unsigned int sampleNumMax;   /* largest number of SS samples to look at;
-                                  this is set at parm creation time and can't
-                                  be changed safely during parm lifetime */
-  double *scalePos,            /* current SS sample locations, allocated
-                                  for sampleNumMax */
-    *step;                     /* per-point stepsize for descent */
-  Nrrd **nsampvol;             /* current set of SS samples, allocated for
-                                  sampleNumMax */
-  gagePerVolume *pvl, **pvlSS; /* for gage; pvlSS allocation different than
-                                  scalePos or nsampvol */
-  gageContext *gctx;           /* context around nsamplevol */
+  /* NOTE: all internal computations are parameterized by a tau-like
+     quantity termed rho, rather than sigma */
+  unsigned int sx, sy, sz; /* image size for testing; determined by
+                              dim, sigmaRange[1], and cutoff */
+  Nrrd *nerr,              /* 1D array of all errors, across scale, with
+                              length trueImgNum */
+    *ninterp,              /* last scale interpolation result */
+    *ndiff;                /* diff between truth and the single recon last
+                              computed in ninterp */
+  double rhoRange[2],      /* rho(sigmaRange) */
+    *kloc,                 /* allocated for length sx to evaluation locations
+                              of nrrdKernelDiscreteGaussian */
+    *kern, *ktmp1, *ktmp2, /* allocated for length sx to store a high-quality
+                              nrrdKernelDiscreteGaussian evaluation, or
+                              buffers related to that */
+    kone[1];               /* stores 1.0 */
+  gageContext *gctx;       /* context around pvlBase, pvlSS, and nsampleImg */
+  /* buffers for kernel evaluation */
+  /* except for pvlBase, these are allocated for sampleNumMax */
+  gagePerVolume *pvlBase,  /* the base pvl for getting answers */
+    **pvlSS;               /* for gage; pvlSS is the stack pervolume,
+                              for the sampleNum volumes in nsampvol */
+  Nrrd **nsampleImg;       /* current set of scale-interpolated samples */
+  double *sampleSigma,     /* current locations of nsampleImg in sigma
+                              (this array is for the gageStack) */
+    *sampleRho,            /* current locations of nsampleImg in rho */
+    *sampleTmp,            /* buffer for sample location info */
+    *sampleErrMax,         /* for tracking per-sample-pair errors in Linf */
+    *step;                 /* per-point stepsize for gradient descent */
 
   /* OUTPUT ------------------------- */
-  double finalErr;             /* error of converged points */
-} gageOptimSigParm;
+  double finalErr;         /* error of converged points */
+} gageOptimSigContext;
 
 /* defaultsGage.c */
 GAGE_EXPORT const char *gageBiffKey;
@@ -967,9 +1063,9 @@
 GAGE_EXPORT int gageDefStackNormalizeRecon;
 GAGE_EXPORT int gageDefStackNormalizeDeriv;
 GAGE_EXPORT double gageDefStackNormalizeDerivBias;
-GAGE_EXPORT double gageDefStackBlurSigmaMax;
 GAGE_EXPORT int gageDefOrientationFromSpacing;
 GAGE_EXPORT int gageDefGenerateErrStr;
+GAGE_EXPORT int gageDefTwoDimZeroZ;
 
 /* miscGage.c */
 GAGE_EXPORT const int gagePresent;
@@ -1025,6 +1121,10 @@
 GAGE_EXPORT const airEnum *const gageVec;
 GAGE_EXPORT gageKind *const gageKindVec;
 
+/* twovecGage.c */
+GAGE_EXPORT const airEnum *const gage2Vec;
+GAGE_EXPORT gageKind *const gageKind2Vec;
+
 /* shape.c */
 GAGE_EXPORT void gageShapeReset(gageShape *shp);
 GAGE_EXPORT gageShape *gageShapeNew(void);
@@ -1067,26 +1167,40 @@
 /* optimsig.c */
 GAGE_EXPORT int gageOptimSigSet(double *scale, unsigned int num,
                                 unsigned int sigmaMax);
-GAGE_EXPORT gageOptimSigParm *gageOptimSigParmNew(unsigned int sampleMaxNum);
-GAGE_EXPORT gageOptimSigParm *gageOptimSigParmNix(gageOptimSigParm *parm);
-GAGE_EXPORT int gageOptimSigTruthSet(gageOptimSigParm *parm,
-                                     unsigned int dim,
-                                     double sigmaMax, double cutoff,
-                                     unsigned int measrSampleNum);
-GAGE_EXPORT int gageOptimSigCalculate(gageOptimSigParm *parm,
-                                      double *scalePos, unsigned int num,
-                                      int volMeasr, int lineMeasr,
-                                      double convEps, unsigned int maxIter);
-GAGE_EXPORT int gageOptimSigPlot(gageOptimSigParm *parm, Nrrd *nout,
-                                 const double *plotpos,
-                                 unsigned int plotPosNum,
-                                 int volMeasr, int tentRecon);
+GAGE_EXPORT gageOptimSigContext *
+  gageOptimSigContextNew(unsigned int dim,
+                         unsigned int sampleNumMax,
+                         unsigned int trueImgNum,
+                         double sigmaMin, double sigmaMax,
+                         double cutoff);
+GAGE_EXPORT gageOptimSigContext *gageOptimSigContextNix(gageOptimSigContext
+                                                        *oscx);
+GAGE_EXPORT int gageOptimSigCalculate(gageOptimSigContext *oscx,
+                                      /* output */ double *sigma,
+                                      unsigned int sigmaNum,
+                                      const NrrdKernelSpec *kssSpec,
+                                      int imgMeasr, int allMeasr,
+                                      unsigned int maxIter, double convEps);
+GAGE_EXPORT int gageOptimSigErrorPlot(gageOptimSigContext *oscx,
+                                      Nrrd *nout,
+                                      const double *sigma,
+                                      unsigned int sigmaNum,
+                                      const NrrdKernelSpec *kssSpec,
+                                      int imgMeasr);
+GAGE_EXPORT int gageOptimSigErrorPlotSliding(gageOptimSigContext *oscx,
+                                             Nrrd *nout,
+                                             double windowRho,
+                                             unsigned int sampleNum,
+                                             const NrrdKernelSpec *kssSpec,
+                                             int imgMeasr);
 
 /* stack.c */
-GAGE_EXPORT double gageTauOfTee(double tee);
-GAGE_EXPORT double gageTeeOfTau(double tau);
-GAGE_EXPORT double gageSigOfTau(double tau);
-GAGE_EXPORT double gageTauOfSig(double sig);
+/* moved the tau conversion functions to air, so that they can be
+   called from unu */
+#define gageTauOfTee(TEE) airTauOfTime(TEE)
+#define gageTeeOfTau(TAU) airTimeOfTau(TAU)
+#define gageSigOfTau(TAU) airSigmaOfTau(TAU)
+#define gageTauOfSig(SIG) airTauOfSigma(SIG)
 GAGE_EXPORT double gageStackWtoI(gageContext *ctx, double swrl,
                                  int *outside);
 GAGE_EXPORT double gageStackItoW(gageContext *ctx, double si,
@@ -1108,20 +1222,54 @@
                                     int indexSpace, int clamp);
 
 /* stackBlur.c */
+GAGE_EXPORT const airEnum *const gageSigmaSampling;
 GAGE_EXPORT gageStackBlurParm *gageStackBlurParmNew(void);
+GAGE_EXPORT int gageStackBlurParmCopy(gageStackBlurParm *sbpDst,
+                                      const gageStackBlurParm *sbpSrc);
+GAGE_EXPORT void gageStackBlurParmInit(gageStackBlurParm *parm);
 GAGE_EXPORT gageStackBlurParm *gageStackBlurParmNix(gageStackBlurParm *sbp);
+GAGE_EXPORT int gageStackBlurParmCompare(const gageStackBlurParm *sbpA,
+                                         const char *nameA,
+                                         const gageStackBlurParm *sbpB,
+                                         const char *nameB,
+                                         int *differ,
+                                         char explain[AIR_STRLEN_LARGE]);
 GAGE_EXPORT int gageStackBlurParmScaleSet(gageStackBlurParm *sbp,
                                           unsigned int num,
-                                          double scaleMin, double scaleMax,
-                                          int uniform, int optim);
+                                          double sigmaMin,
+                                          double sigmaMax,
+                                          int uniformSigma, int optimalL2L2);
+GAGE_EXPORT int gageStackBlurParmSigmaSet(gageStackBlurParm *sbp,
+                                          unsigned int num,
+                                          double sigmaMin,
+                                          double sigmaMax,
+                                          int sigmaSampling);
 GAGE_EXPORT int gageStackBlurParmKernelSet(gageStackBlurParm *sbp,
-                                           const NrrdKernelSpec *kspec,
-                                           int renormalize);
+                                           const NrrdKernelSpec *kspec);
+GAGE_EXPORT int gageStackBlurParmRenormalizeSet(gageStackBlurParm *sbp,
+                                                int renormalize);
+GAGE_EXPORT int gageStackBlurParmDgGoodSigmaMaxSet(gageStackBlurParm *sbp,
+                                                   double dgGoodSigmaMax);
 GAGE_EXPORT int gageStackBlurParmBoundarySet(gageStackBlurParm *sbp,
                                              int boundary, double padValue);
+GAGE_EXPORT int gageStackBlurParmBoundarySpecSet(gageStackBlurParm *sbp,
+                                                 const NrrdBoundarySpec *bsp);
+GAGE_EXPORT int gageStackBlurParmNeedSpatialBlurSet(gageStackBlurParm *sbp,
+                                                    int sblur);
 GAGE_EXPORT int gageStackBlurParmVerboseSet(gageStackBlurParm *sbp,
                                             int verbose);
-GAGE_EXPORT int gageStackBlurParmCheck(gageStackBlurParm *sbp);
+GAGE_EXPORT int gageStackBlurParmOneDimSet(gageStackBlurParm *sbp,
+                                           int oneDim);
+GAGE_EXPORT int gageStackBlurParmCheck(const gageStackBlurParm *sbp);
+GAGE_EXPORT int gageStackBlurParmParse(gageStackBlurParm *sbp,
+                                       int extraFlags[256],
+                                       char **extraParmsP,
+                                       const char *str);
+GAGE_EXPORT hestCB *gageHestStackBlurParm;
+GAGE_EXPORT int gageStackBlurParmSprint(char str[AIR_STRLEN_LARGE],
+                                        const gageStackBlurParm *sbp,
+                                        int extraFlag[256],
+                                        char *extraParm);
 GAGE_EXPORT int gageStackBlur(Nrrd *const nblur[], gageStackBlurParm *sbp,
                               const Nrrd *nin, const gageKind *kind);
 GAGE_EXPORT int gageStackBlurCheck(const Nrrd *const nblur[],
diff --color -ruN teem-1.11.0-src.orig/src/gage/GNUmakefile teem-1.11.0-src/src/gage/GNUmakefile
--- teem-1.11.0-src.orig/src/gage/GNUmakefile	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/GNUmakefile	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -52,10 +52,10 @@
 $(L).OBJS = defaultsGage.o miscGage.o scl.o kind.o \
         shape.o pvl.o update.o deconvolve.o \
 	print.o sclanswer.o sclprint.o sclfilter.o \
-	vecGage.o vecprint.o st.o filter.o ctx.o \
+	vecGage.o vecprint.o twovecGage.o st.o filter.o ctx.o \
 	stack.o stackBlur.o optimsig.o
 $(L).TESTS = test/ctfix test/demo test/vh test/aalias test/indx \
-        test/genoptsig test/ssc
+        test/genoptsig test/ssc test/maxes test/tplot
 ####
 ####
 ####
diff --color -ruN teem-1.11.0-src.orig/src/gage/INFO.txt teem-1.11.0-src/src/gage/INFO.txt
--- teem-1.11.0-src.orig/src/gage/INFO.txt	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/INFO.txt	2021-02-18 15:42:32.000000000 +0800
@@ -19,13 +19,13 @@
    set up the context with the answers to get, the kernels to use, and
    any other parameters to set.  There is no need in gage to directly
    set or read the members of a struct except:
-   
+
    and the kernels to use.  Use gageSet() to set other int flags.
    These calls can be made in any order.  Calls with int return should
    be checked for erroneous (non-zero) return, and then biffGetDone(GAGE)
    to see the error messages.
 6) Call gageUpdate() and check the return to make sure everything is okay.
-7) Start probing away with gageProbe().  
+7) Start probing away with gageProbe().
 8) When all done, gageContextNix() will clean up all the attached pervolumes
    and any memory they allocated.
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/kind.c teem-1.11.0-src/src/gage/kind.c
--- teem-1.11.0-src.orig/src/gage/kind.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/kind.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/miscGage.c teem-1.11.0-src/src/gage/miscGage.c
--- teem-1.11.0-src.orig/src/gage/miscGage.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/miscGage.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -122,6 +122,7 @@
     parm->stackNormalizeDerivBias = gageDefStackNormalizeDerivBias;
     parm->orientationFromSpacing = gageDefOrientationFromSpacing;
     parm->generateErrStr = gageDefGenerateErrStr;
+    parm->twoDimZeroZ = gageDefTwoDimZeroZ;
   }
   return;
 }
@@ -137,7 +138,7 @@
        is handled correctly */
     ELL_4V_SET(point->frac,
                AIR_POS_INF, AIR_POS_INF, AIR_POS_INF, AIR_POS_INF);
-    big = AIR_CAST(unsigned int, -1);
+    big = AIR_UINT(-1);
     ELL_4V_SET(point->idx, big, big, big, big);
     point->stackFwNonZeroNum = 0;
   }
diff --color -ruN teem-1.11.0-src.orig/src/gage/multiGage.c teem-1.11.0-src/src/gage/multiGage.c
--- teem-1.11.0-src.orig/src/gage/multiGage.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/multiGage.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/optimsig.c teem-1.11.0-src/src/gage/optimsig.c
--- teem-1.11.0-src.orig/src/gage/optimsig.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/optimsig.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -24,6 +24,41 @@
 #include "gage.h"
 #include "privateGage.h"
 
+/*
+static int debugging = 0;
+static int debugii;
+*/
+
+static airArray *debugReconErrArr = NULL;
+static double *debugReconErr = NULL;
+static char *debugReconErrName = NULL;
+
+/*
+** learned:
+**
+** -- debug high/discontinuous errors at the low sigmas: was because
+** cut-off was insufficient to prevent some discontinuous change in
+** kernel values: increased minimum support in the kernel itself, and
+** now using larger cut-offs.
+**
+** -- also, separately from this problem, you can have minima in the
+** inf error (in imgMeasr) *not* at sample points, apparently simply
+** because of how the hermite interpolation works (but this is
+** troubling)
+**
+** -- do now have a different minimization scheme for allMeasr=Linf,
+** but this may still be a work in progress.  Recognizing that this is
+** essentially seeking to find a uniform re-parameterization of
+** something with a hidden non-uniform parameterization, we could
+** probably implement a simple global warping of control points within
+** the implied non-uniform domain.
+*/
+
+/* this limits how big the kernel can get with a single evaluation
+   of nrrdKernelDiscreteGaussian; there are some numerical issues
+   with large kernels that need ironing out */
+#define GOOD_SIGMA_MAX 5
+
 #define N -1
 
 /*
@@ -175,6 +210,9 @@
   }
 };
 
+/*
+** this is only for retreiving part of the table above
+*/
 int
 gageOptimSigSet(double *scale, unsigned int num, unsigned int sigmaMax) {
   static const char me[]="gageOptimSigSet";
@@ -202,309 +240,576 @@
   return 0;
 }
 
-gageOptimSigParm *
-gageOptimSigParmNew(unsigned int sampleNumMax) {
-  gageOptimSigParm *parm;
+/* ------- from here down is the stuff for computing the table ------ */
 
-  parm = AIR_CAST(gageOptimSigParm *, calloc(1, sizeof(gageOptimSigParm)));
-  if (parm) {
-    unsigned int si;
-    parm->dim = 0;
-    parm->sampleNumMax = sampleNumMax;
-    parm->plotting = AIR_FALSE;
-    parm->tentRecon = AIR_FALSE;
-    parm->sigmatru = NULL;
-    parm->truth = NULL;
-    parm->ntruth = nrrdNew();
-    parm->nerr = nrrdNew();
-    parm->ntruline = nrrdNew();
-    parm->ninterp = nrrdNew();
-    parm->ndiff = nrrdNew();
-    parm->scalePos = AIR_CAST(double *, calloc(sampleNumMax, sizeof(double)));
-    parm->step = AIR_CAST(double *, calloc(sampleNumMax, sizeof(double)));
-    parm->nsampvol = AIR_CAST(Nrrd **, calloc(sampleNumMax, sizeof(Nrrd *)));
-    for (si=0; si<sampleNumMax; si++) {
-      parm->nsampvol[si] = nrrdNew();
-    }
-    parm->pvl = NULL;
-    parm->pvlSS = AIR_CAST(gagePerVolume **,
-                           calloc(sampleNumMax, sizeof(gagePerVolume *)));
-    parm->gctx = gageContextNew();
+/* rho is a stand-in for tau - and something that will likely change
+   based on the findings from using this code; the idea is that it
+   reflects the needed density of samples for optimal scale-space
+   reconstruction. In order to be used for the internal workings of
+   the sigma optimization, its important that the conversion between
+   sigma and rho be accurately invertible. */
+
+/*
+**
+** This is a decent approximation of tau(sigma), made of a slightly
+** scaled version of the taylor expansion of tau(sigma=0) which meets
+** up with the large-scale approximation of tau from Lindeberg.
+** However, because its so flat at sigma=0, its not really invertible
+** there, so its a poor basis for computations that are parameterized
+** by rho.  Keeping it around for reference.
+
+static double
+_RhoOfSig(double sig) {
+  double rho;
+
+  if (sig < 1.05189095) {
+    rho = sig*sig*(0.2775733212544225 + 0.13078298856958057*sig*sig);
+  } else {
+    double tee;
+    tee = sig*sig;
+    rho = 0.53653222368715360118 + log(tee)/2.0 + log(1.0 - 1.0/(8.0*tee));
   }
-  return parm;
+  return rho;
 }
 
-gageOptimSigParm *
-gageOptimSigParmNix(gageOptimSigParm *parm) {
+static double
+_SigOfRho(double rho) {
+  double sig;
 
-  if (parm) {
-    unsigned int si;
-    airFree(parm->sigmatru);
-    nrrdNuke(parm->ntruth);
-    nrrdNuke(parm->nerr);
-    nrrdNix(parm->ntruline);
-    nrrdNuke(parm->ninterp);
-    nrrdNuke(parm->ndiff);
-    airFree(parm->scalePos);
-    airFree(parm->step);
-    for (si=0; si<parm->sampleNumMax; si++) {
-      nrrdNuke(parm->nsampvol[si]);
-    }
-    airFree(parm->nsampvol);
-    airFree(parm->pvlSS);
-    gageContextNix(parm->gctx);
-    airFree(parm);
+  if (rho < 0.46724360022171363) {
+    sig = 0.00033978812426865065 *
+      sqrt(-9.191366355042886e6 + 245.3752559286824 *
+           sqrt(1.403132301e9 + 9.526961876920057e9*rho));
+  } else {
+    double ee, tee;
+    ee = exp(2.0*rho);
+    tee = 0.0063325739776461107152*(27.0*ee + 2*AIR_PI*AIR_PI
+                                    + 3.0*sqrt(81.0*ee*ee
+                                               + 12*ee*AIR_PI*AIR_PI));
+    sig = sqrt(tee);
   }
-  return NULL;
+  return sig;
 }
+*/
 
-static void
-_volTrueBlur(Nrrd *nvol, double sigma, gageOptimSigParm *parm) {
-  double *vol, xv, yv, zv;
-  unsigned int xi, yi, zi;
-  NrrdKernel *dg;
-  double kparm[NRRD_KERNEL_PARMS_NUM], xrad, yrad, zrad;
+static double
+_RhoOfSig(double sig) {
 
-  vol = AIR_CAST(double *, nvol->data);
-  xrad = (nvol->axis[0].size + 1)/2 - 1;
-  yrad = (nvol->axis[1].size + 1)/2 - 1;
-  zrad = (nvol->axis[2].size + 1)/2 - 1;
-  dg = nrrdKernelDiscreteGaussian;
-  kparm[0] = sigma;
-  kparm[1] = parm->cutoff;
-  for (zi=0; zi<parm->sz; zi++) {
-    zv = (parm->dim >= 2
-          ? dg->eval1_d(AIR_CAST(double, zi) - zrad, kparm)
-          : 1);
-    for (yi=0; yi<parm->sy; yi++) {
-      yv = (parm->dim >= 3
-            ? dg->eval1_d(AIR_CAST(double, yi) - yrad, kparm)
-            : 1);
-      for (xi=0; xi<parm->sx; xi++) {
-        xv = dg->eval1_d(AIR_CAST(double, xi) - xrad, kparm);
-        vol[xi + parm->sx*(yi + parm->sy*zi)] = xv*yv*zv;
-      }
-    }
-  }
-  return;
+  return log(sig + 1);
 }
 
-int
-gageOptimSigTruthSet(gageOptimSigParm *parm,
-                     unsigned int dim,
-                     double sigmaMax, double cutoff,
-                     unsigned int measrSampleNum) {
-  static const char me[]="gageOptimSigTruthSet";
-  char doneStr[AIR_STRLEN_SMALL];
-  double kparm[NRRD_KERNEL_PARMS_NUM], tauMax;
+static double
+_SigOfRho(double rho) {
+
+  return exp(rho)-1;
+}
+
+
+/*
+** allocates context, with error checking
+** does use biff
+*/
+gageOptimSigContext *gageOptimSigContextNew(unsigned int dim,
+                                            unsigned int sampleNumMax,
+                                            unsigned int trueImgNum,
+                                            double sigmaMin, double sigmaMax,
+                                            double cutoff) {
+  static const char me[]="gageOptimSigContextNew";
+  gageOptimSigContext *oscx;
   unsigned int support, ii;
+  double kparm[2];
 
-  if (!parm) {
-    biffAddf(GAGE, "%s: got NULL pointer", me);
-    return 1;
+  oscx = AIR_CALLOC(1, gageOptimSigContext);
+  if (!oscx) {
+    biffAddf(GAGE, "%s: couldn't allocate context", me);
+    return NULL;
   }
   if (!AIR_IN_CL(1, dim, 3)) {
     biffAddf(GAGE, "%s: dim %u not 1, 2, or 3", me, dim);
-    return 1;
+    return NULL;
   }
-  if (!(sigmaMax > 0 && cutoff > 0)) {
-    biffAddf(GAGE, "%s: sigmaMax %g, cutoff %g not both > 0", me,
-             sigmaMax, cutoff);
-    return 1;
-  }
-  if (!(measrSampleNum >= 3)) {
-    biffAddf(GAGE, "%s: measrSampleNum %u not >= 3", me, measrSampleNum);
-    return 1;
-  }
-
-  parm->dim = dim;
-  kparm[0] = parm->sigmaMax = sigmaMax;
-  kparm[1] = parm->cutoff = cutoff;
-  parm->measrSampleNum = measrSampleNum;
+  if (!(sampleNumMax >= 3)) {
+    biffAddf(GAGE, "%s: sampleNumMax %u not >= 3", me, sampleNumMax);
+    return NULL;
+  }
+  if (!(trueImgNum >= 3)) {
+    biffAddf(GAGE, "%s: trueImgNum %u not >= 3", me, trueImgNum);
+    return NULL;
+  }
+  if (!(sigmaMin >= 0 && sigmaMax > sigmaMin && cutoff > 0)) {
+    biffAddf(GAGE, "%s: sigmaMin %g, sigmaMax %g, cutoff %g not valid", me,
+             sigmaMin, sigmaMax, cutoff);
+    return NULL;
+  }
+
+  oscx->dim = dim;
+  oscx->sampleNumMax = sampleNumMax;
+  oscx->trueImgNum = trueImgNum;
+  oscx->sigmaRange[0] = sigmaMin;
+  oscx->sigmaRange[1] = sigmaMax;
+  oscx->cutoff = cutoff;
+
+  /* will be set later */
+  oscx->kssSpec = NULL;
+  oscx->sampleNum = 0;
+  oscx->maxIter = 0;
+  oscx->imgMeasr = nrrdMeasureUnknown;
+  oscx->allMeasr = nrrdMeasureUnknown;
+  oscx->convEps = AIR_NAN;
+
+  /* allocate internal buffers based on arguments */
+  kparm[0] = oscx->sigmaRange[1];
+  kparm[1] = oscx->cutoff;
   support = AIR_ROUNDUP(nrrdKernelDiscreteGaussian->support(kparm));
-  /* may later allow different shaped volumes */
-  parm->sx = parm->sy = parm->sz = 2*support - 1;
-  fprintf(stderr, "!%s: support = %u, vol size = %u\n", me, support, parm->sx);
-  airFree(parm->sigmatru);
-  parm->sigmatru = AIR_CAST(double *, calloc(measrSampleNum, sizeof(double)));
-  if (!parm->sigmatru) {
-    biffAddf(GAGE, "%s: couldn't alloc sigmatru buffer", me);
-    return 1;
-  }
-  if (nrrdMaybeAlloc_va(parm->ntruth, nrrdTypeDouble, 4,
-                        AIR_CAST(size_t, parm->sx),
-                        AIR_CAST(size_t, parm->sy),
-                        AIR_CAST(size_t, parm->sz),
-                        AIR_CAST(size_t, measrSampleNum))
-      || nrrdMaybeAlloc_va(parm->nerr, nrrdTypeDouble, 1,
-                           AIR_CAST(size_t, measrSampleNum))
-      /* ntruline->data will be re-set willy-nilly */
-      || nrrdWrap_va(parm->ntruline, parm->ntruth->data,
-                     parm->ntruth->type, 3,
-                     AIR_CAST(size_t, parm->sx),
-                     AIR_CAST(size_t, parm->sy),
-                     AIR_CAST(size_t, parm->sz))
-      || nrrdMaybeAlloc_va(parm->ninterp, nrrdTypeDouble, 3,
-                           AIR_CAST(size_t, parm->sx),
-                           AIR_CAST(size_t, parm->sy),
-                           AIR_CAST(size_t, parm->sz))
-      || nrrdMaybeAlloc_va(parm->ndiff, nrrdTypeDouble, 3,
-                           AIR_CAST(size_t, parm->sx),
-                           AIR_CAST(size_t, parm->sy),
-                           AIR_CAST(size_t, parm->sz))) {
-    biffMovef(GAGE, NRRD, "%s: couldn't allocate truth", me);
-    return 1;
-  }
-  parm->truth = AIR_CAST(double *, parm->ntruth->data);
-  nrrdAxisInfoSet_va(parm->ntruth, nrrdAxisInfoSpacing,
-                     1.0, 1.0, 1.0, AIR_NAN);
-  nrrdAxisInfoSet_va(parm->ntruline, nrrdAxisInfoSpacing,
-                     1.0, 1.0, 1.0);
-  nrrdAxisInfoSet_va(parm->ninterp, nrrdAxisInfoSpacing,
+  oscx->sx = 2*support - 1;
+  oscx->sy = dim >= 2 ? 2*support - 1 : 1;
+  oscx->sz = dim >= 3 ? 2*support - 1 : 1;
+  /*
+  fprintf(stderr, "%s: max sigma = %g, cutoff %g ==> support=%u, "
+          "3D vol size=%u x %u x %u\n", me,
+          sigmaMax, cutoff, support, oscx->sx, oscx->sy, oscx->sz);
+  */
+  oscx->nerr = nrrdNew();
+  oscx->ninterp = nrrdNew();
+  oscx->ndiff = nrrdNew();
+  if (nrrdMaybeAlloc_va(oscx->nerr, nrrdTypeDouble, 1,
+                        AIR_CAST(size_t, oscx->trueImgNum))
+      || nrrdMaybeAlloc_va(oscx->ninterp, nrrdTypeDouble, 3,
+                           AIR_CAST(size_t, oscx->sx),
+                           AIR_CAST(size_t, oscx->sy),
+                           AIR_CAST(size_t, oscx->sz))
+      || nrrdMaybeAlloc_va(oscx->ndiff, nrrdTypeDouble, 3,
+                           AIR_CAST(size_t, oscx->sx),
+                           AIR_CAST(size_t, oscx->sy),
+                           AIR_CAST(size_t, oscx->sz))) {
+    biffMovef(GAGE, NRRD, "%s: couldn't allocate buffers", me);
+    return NULL;
+  }
+  nrrdAxisInfoSet_va(oscx->ninterp, nrrdAxisInfoSpacing,
                      1.0, 1.0, 1.0);
-  nrrdAxisInfoSet_va(parm->ndiff, nrrdAxisInfoSpacing,
+  nrrdAxisInfoSet_va(oscx->ndiff, nrrdAxisInfoSpacing,
                      1.0, 1.0, 1.0);
-  for (ii=0; ii<parm->sampleNumMax; ii++) {
-    if (nrrdMaybeAlloc_va(parm->nsampvol[ii], nrrdTypeDouble, 3,
-                          AIR_CAST(size_t, parm->sx),
-                          AIR_CAST(size_t, parm->sy),
-                          AIR_CAST(size_t, parm->sz))) {
+  oscx->rhoRange[0] = _RhoOfSig(oscx->sigmaRange[0]);
+  oscx->rhoRange[1] = _RhoOfSig(oscx->sigmaRange[1]);
+  nrrdAxisInfoSet_va(oscx->nerr, nrrdAxisInfoMin,
+                     oscx->rhoRange[0]);
+  nrrdAxisInfoSet_va(oscx->nerr, nrrdAxisInfoMax,
+                     oscx->rhoRange[1]);
+
+  fprintf(stderr, "!%s: sigma [%g,%g] -> rho [%g,%g]\n", me,
+          oscx->sigmaRange[0], oscx->sigmaRange[1],
+          oscx->rhoRange[0], oscx->rhoRange[1]);
+  fprintf(stderr, "!%s: rho %g -- %g\n", me,
+          oscx->rhoRange[0], oscx->rhoRange[1]);
+  for (ii=0; ii<oscx->trueImgNum; ii++) {
+    double rr, ss, rc, eps=1e-13;
+    rr = AIR_AFFINE(0, ii, oscx->trueImgNum-1,
+                    oscx->rhoRange[0], oscx->rhoRange[1]);
+    ss = _SigOfRho(rr);
+    rc = _RhoOfSig(ss);
+    /*
+    fprintf(stderr, "!%s: (%u) rho %.17g -> sig %.17g -> rho %.17g (%.17g)\n",
+            me, ii, rr, ss, rc, AIR_ABS(rr - rc)/(rr + eps/2));
+    */
+    if ( AIR_ABS(rr - rc)/(rr + eps) > eps ) {
+      biffAddf(GAGE, "%s: rho %g -> sig %g -> rho %g has error %g > %g; "
+               "_SigOfRho() and _RhoOfSig() not invertible",
+               me, rr, ss, rc, AIR_ABS(rr - rc)/(rr + eps/2), eps);
+      return NULL;
+    }
+  }
+
+  oscx->kloc = AIR_CALLOC(oscx->sx, double);
+  oscx->kern = AIR_CALLOC(oscx->sx, double);
+  oscx->ktmp1 = AIR_CALLOC(oscx->sx, double);
+  oscx->ktmp2 = AIR_CALLOC(oscx->sx, double);
+  if (!(oscx->kloc && oscx->kern && oscx->ktmp1 && oscx->ktmp2)) {
+    biffAddf(GAGE, "%s: couldn't allocate kernel buffers", me);
+    return NULL;
+  }
+  for (ii=0; ii<oscx->sx; ii++) {
+    oscx->kloc[ii] = AIR_CAST(double, ii) - ((oscx->sx + 1)/2 - 1);
+  }
+  oscx->kone[0] = 1.0;
+
+  oscx->gctx = NULL;
+  oscx->pvlBase = NULL;
+  oscx->pvlSS = AIR_CALLOC(oscx->sampleNumMax, gagePerVolume *);
+  oscx->nsampleImg = AIR_CALLOC(oscx->sampleNumMax, Nrrd *);
+  oscx->sampleSigma = AIR_CALLOC(oscx->sampleNumMax, double);
+  oscx->sampleRho = AIR_CALLOC(oscx->sampleNumMax, double);
+  oscx->sampleTmp = AIR_CALLOC(oscx->sampleNumMax, double);
+  oscx->sampleErrMax = AIR_CALLOC(oscx->sampleNumMax, double);
+  oscx->step = AIR_CALLOC(oscx->sampleNumMax, double);
+  if (!(oscx->pvlSS && oscx->nsampleImg
+        && oscx->sampleSigma && oscx->sampleRho
+        && oscx->sampleTmp && oscx->sampleErrMax && oscx->step)) {
+    biffAddf(GAGE, "%s: couldn't allocate per-sample arrays", me);
+    return NULL;
+  }
+  for (ii=0; ii<oscx->sampleNumMax; ii++) {
+    oscx->nsampleImg[ii] = nrrdNew();
+    if (nrrdMaybeAlloc_va(oscx->nsampleImg[ii], nrrdTypeDouble, 3,
+                          AIR_CAST(size_t, oscx->sx),
+                          AIR_CAST(size_t, oscx->sy),
+                          AIR_CAST(size_t, oscx->sz))) {
       biffMovef(GAGE, NRRD, "%s: couldn't allocate vol[%u]", me, ii);
-      return 1;
+      return NULL;
     }
-    nrrdAxisInfoSet_va(parm->nsampvol[ii], nrrdAxisInfoSpacing,
+    nrrdAxisInfoSet_va(oscx->nsampleImg[ii], nrrdAxisInfoSpacing,
                        1.0, 1.0, 1.0);
   }
-  fprintf(stderr, "%s: computing reference blurrings ...       ", me);
-  tauMax =  gageTauOfSig(parm->sigmaMax);
-  for (ii=0; ii<parm->measrSampleNum; ii++) {
-    double sigma;
-    if (!(ii % 10)) {
-      fprintf(stderr, "%s", airDoneStr(0, ii, parm->measrSampleNum, doneStr));
-      fflush(stderr);
-    }
-    parm->ntruline->data = parm->truth + ii*parm->sx*parm->sy*parm->sz;
-    if (parm->plotting) {
-      sigma = AIR_AFFINE(0, ii, parm->measrSampleNum-1, 0.0, parm->sigmaMax);
-    } else {
-      double tau;
-      tau = AIR_AFFINE(0, ii, parm->measrSampleNum-1, 0.0, tauMax);
-      sigma = gageSigOfTau(tau);
+
+  /* implementation not started
+  oscx->nsampleHist = nrrdNew();
+  */
+
+  return oscx;
+}
+
+gageOptimSigContext *
+gageOptimSigContextNix(gageOptimSigContext *oscx) {
+
+  if (oscx) {
+    unsigned int si;
+    nrrdKernelSpecNix(oscx->kssSpec);
+    nrrdNuke(oscx->nerr);
+    nrrdNuke(oscx->ninterp);
+    nrrdNuke(oscx->ndiff);
+    airFree(oscx->kloc);
+    airFree(oscx->kern);
+    airFree(oscx->ktmp1);
+    airFree(oscx->ktmp2);
+    gageContextNix(oscx->gctx);
+    /* airFree(oscx->pvlSS); needed? */
+    for (si=0; si<oscx->sampleNumMax; si++) {
+      nrrdNuke(oscx->nsampleImg[si]);
     }
-    parm->sigmatru[ii] = sigma;
-    _volTrueBlur(parm->ntruline, sigma, parm);
+    airFree(oscx->nsampleImg);
+    airFree(oscx->sampleSigma);
+    airFree(oscx->sampleRho);
+    airFree(oscx->sampleTmp);
+    airFree(oscx->sampleErrMax);
+    airFree(oscx->step);
+    /* nrrdNuke(oscx->nsampleHist); */
+    airFree(oscx);
   }
-  fprintf(stderr, "%s\n", airDoneStr(0, ii, parm->measrSampleNum, doneStr));
-  return 0;
+  return NULL;
 }
 
-static void
-_volInterp(Nrrd *ninterp, double scale, gageOptimSigParm *parm) {
-  double *interp, scaleIdx;
+static int
+_volInterp(Nrrd *ninterp, double rho, gageOptimSigContext *oscx) {
+  static const char me[]="_volInterp";
+  double *interp, scaleIdx, sigma;
   const double *answer;
   unsigned int xi, yi, zi;
   int outside;
 
-  scaleIdx = gageStackWtoI(parm->gctx, scale, &outside);
-  answer = gageAnswerPointer(parm->gctx, parm->pvl, gageSclValue);
+  /*
+  debugging = rho > 1.197;
+  gageParmSet(oscx->gctx, gageParmVerbose, 2*debugging);
+  */
+  sigma = _SigOfRho(rho);
+  scaleIdx = gageStackWtoI(oscx->gctx, sigma, &outside);
+  /* Because of limited numerical precision, _SigOfRho(rhoRange[1])
+     can end up "outside" stack, which should really be a bug.
+     However, since the use of gage is pretty straight-forward here,
+     we're okay with ignoring the "outside" here, and also clamping
+     the probe below */
+  answer = gageAnswerPointer(oscx->gctx, oscx->pvlBase, gageSclValue);
   interp = AIR_CAST(double *, ninterp->data);
-  for (zi=0; zi<parm->sz; zi++) {
-    for (yi=0; yi<parm->sy; yi++) {
-      for (xi=0; xi<parm->sx; xi++) {
-        gageStackProbe(parm->gctx, xi, yi, zi, scaleIdx);
-        interp[xi + parm->sx*(yi + parm->sy*zi)] = answer[0];
+  for (zi=0; zi<oscx->sz; zi++) {
+    for (yi=0; yi<oscx->sy; yi++) {
+      for (xi=0; xi<oscx->sx; xi++) {
+        if (gageStackProbeSpace(oscx->gctx, xi, yi, zi, scaleIdx,
+                                AIR_TRUE /* index space */,
+                                AIR_TRUE /* clamping */)) {
+          biffAddf(GAGE, "%s: probe error at (%u,%u,%u,%.17g): %s (%d)", me,
+                   xi, yi, zi, scaleIdx,
+                   oscx->gctx->errStr, oscx->gctx->errNum);
+          return 1;
+        }
+        interp[xi + oscx->sx*(yi + oscx->sy*zi)] = answer[0];
       }
     }
   }
+  /*
+  gageParmSet(oscx->gctx, gageParmVerbose, 0);
+  */
+  /*
+  if (debugging) {
+    char fname[AIR_STRLEN_SMALL];
+    sprintf(fname, "interp-%04u.nrrd", debugii);
+    nrrdSave(fname, ninterp, NULL);
+  }
+  */
+  return 0;
+}
+
+static void
+_kernset(double **kzP, double **kyP, double **kxP,
+         gageOptimSigContext *oscx,
+         double rho) {
+  NrrdKernel *dg;
+  double sig, kparm[NRRD_KERNEL_PARMS_NUM],
+    *kloc, *kern, *ktmp1, *ktmp2;
+  unsigned int ki, kj, kk, sx;
+
+  kern = oscx->kern;
+  kloc = oscx->kloc;
+  ktmp1 = oscx->ktmp1;
+  ktmp2 = oscx->ktmp2;
+  sx = oscx->sx;
+  sig = _SigOfRho(rho);
+  dg = nrrdKernelDiscreteGaussian;
+  kparm[1] = oscx->cutoff;
+  if (sig < GOOD_SIGMA_MAX) {
+    /* for small sigma, can evaluate directly into kern */
+    kparm[0] = sig;
+    dg->evalN_d(kern, kloc, sx, kparm);
+  } else {
+    double timeleft, tdelta;
+    unsigned int rx;
+    rx = (sx + 1)/2 - 1;
+    /* we have to iteratively blur */
+    kparm[0] = GOOD_SIGMA_MAX;
+    dg->evalN_d(kern, kloc, sx, kparm);
+    timeleft = sig*sig - GOOD_SIGMA_MAX*GOOD_SIGMA_MAX;
+    do {
+      tdelta = AIR_MIN( GOOD_SIGMA_MAX*GOOD_SIGMA_MAX, timeleft );
+      kparm[0] = sqrt(tdelta);
+      dg->evalN_d(ktmp1, kloc, sx, kparm);
+      for (ki=0; ki<sx; ki++) {
+        double csum = 0.0;
+        for (kj=0; kj<sx; kj++) {
+          kk = ki - kj + rx;
+          if (kk < sx) {
+            csum += kern[kk]*ktmp1[kj];
+          }
+        }
+        ktmp2[ki] = csum;
+      }
+      for (ki=0; ki<sx; ki++) {
+        kern[ki] = ktmp2[ki];
+      }
+      timeleft -= tdelta;
+    } while (timeleft);
+  }
+  *kzP = oscx->dim >= 3 ? kern : oscx->kone;
+  *kyP = oscx->dim >= 2 ? kern : oscx->kone;
+  *kxP = kern;
   return;
 }
 
-static double
-_errSingle(gageOptimSigParm *parm, unsigned int sigmaIdx) {
-  double *interp, *truline, *diff, ret;
-  size_t ii, nn;
-
-  _volInterp(parm->ninterp, parm->sigmatru[sigmaIdx], parm);
-  interp = AIR_CAST(double *, parm->ninterp->data);
-  nn = parm->sx*parm->sy*parm->sz;
-  truline = parm->truth + sigmaIdx*nn;
-  diff = AIR_CAST(double *, parm->ndiff->data);
-  for (ii=0; ii<nn; ii++) {
-    diff[ii] = truline[ii] - interp[ii];
+/*
+** sets one of the sampleImg, to be used as a sample in scale-space interp
+*/
+static void
+_sampleSet(gageOptimSigContext *oscx, unsigned int si, double rho) {
+  double *vol, *kz, *ky, *kx;
+  unsigned int ii, xi, yi, zi;
+
+  oscx->sampleSigma[si] = _SigOfRho(rho);
+  oscx->sampleRho[si] = rho;
+  vol = AIR_CAST(double *, oscx->nsampleImg[si]->data);
+  _kernset(&kz, &ky, &kx, oscx, rho);
+  ii = 0;
+  for (zi=0; zi<oscx->sz; zi++) {
+    for (yi=0; yi<oscx->sy; yi++) {
+      for (xi=0; xi<oscx->sx; xi++) {
+        vol[ii] = kz[zi]*ky[yi]*kx[xi];
+        ii++;
+      }
+    }
   }
-  if (0) {
+  if (oscx->gctx) {
+    /* the gage stack needs to know new scale pos */
+    oscx->gctx->stackPos[si] = oscx->sampleSigma[si];
+    /* HEY: GLK forgets why this is needed,
+       but remembers it was a tricky bug to find */
+    gagePointReset(&(oscx->gctx->point));
+  }
+  return;
+}
+
+static int
+_errSingle(double *retP, gageOptimSigContext *oscx, double rho) {
+  static const char me[]="_errSingle";
+  double *diff, *kx, *ky, *kz;
+  const double *interp;
+  unsigned int ii, xi, yi, zi;
+
+  if (_volInterp(oscx->ninterp, rho, oscx)) {
+    biffAddf(GAGE, "%s: trouble at rho %.17g\n", me, rho);
+    return 1;
+  }
+  /*
+  if (debugging) {
     char fname[AIR_STRLEN_SMALL];
-    sprintf(fname, "interp-%03u.nrrd", sigmaIdx);
-    nrrdSave(fname, parm->ninterp, NULL);
+    sprintf(fname, "interp-%04u.nrrd", debugii);
+    nrrdSave(fname, oscx->ninterp, NULL);
+  }
+  */
+  interp = AIR_CAST(const double *, oscx->ninterp->data);
+  diff = AIR_CAST(double *, oscx->ndiff->data);
+  _kernset(&kz, &ky, &kx, oscx, rho);
+  ii = 0;
+  for (zi=0; zi<oscx->sz; zi++) {
+    for (yi=0; yi<oscx->sy; yi++) {
+      for (xi=0; xi<oscx->sx; xi++) {
+        double tru;
+        tru = kz[zi]*ky[yi]*kx[xi];
+        diff[ii] = interp[ii] - tru;
+        if (debugReconErrArr) {
+          unsigned int idx = airArrayLenIncr(debugReconErrArr, 2);
+          debugReconErr[idx + 0] = tru;
+          debugReconErr[idx + 1] = interp[ii];
+        }
+        ii++;
+      }
+    }
   }
-  nrrdMeasureLine[parm->volMeasr](&ret, nrrdTypeDouble,
+  nrrdMeasureLine[oscx->imgMeasr](retP, nrrdTypeDouble,
                                   diff, nrrdTypeDouble,
-                                  nn, AIR_NAN, AIR_NAN);
-  return ret;
+                                  ii /* HEY: cleverness */,
+                                  AIR_NAN, AIR_NAN);
+  return 0;
 }
 
-static double
-_errTotal(gageOptimSigParm *parm) {
+static int
+_errTotal(double *retP, gageOptimSigContext *oscx) {
+  static const char me[]="_errTotal";
   unsigned int ii;
-  double *err, ret;
+  double *err;
 
-  for (ii=0; ii<parm->sampleNum; ii++) {
-    parm->gctx->stackPos[ii] = parm->scalePos[ii];
+  err = AIR_CAST(double *, oscx->nerr->data);
+  for (ii=0; ii<oscx->trueImgNum; ii++) {
+    /* debugii = ii; */
+    if (_errSingle(err + ii, oscx, AIR_AFFINE(0, ii, oscx->trueImgNum-1,
+                                              oscx->rhoRange[0],
+                                              oscx->rhoRange[1]))) {
+      biffAddf(GAGE, "%s: trouble at ii %u", me, ii);
+      return 1;
+    }
+  }
+  nrrdMeasureLine[oscx->allMeasr](retP, nrrdTypeDouble,
+                                  err, nrrdTypeDouble,
+                                  oscx->trueImgNum,
+                                  AIR_NAN, AIR_NAN);
+  /*
+  if (debugging) {
+    char fname[AIR_STRLEN_SMALL];
+    unsigned int ni;
+    for (ni=0; ni<oscx->sampleNum; ni++) {
+      sprintf(fname, "sample-%04u.nrrd", ni);
+      nrrdSave(fname, oscx->nsampleImg[ni], NULL);
+    }
+  }
+  */
+  if (0) {
+    static unsigned int call=0;
+    char fname[AIR_STRLEN_SMALL];
+    sprintf(fname, "err-%04u.nrrd", call);
+    nrrdSave(fname, oscx->nerr, NULL);
+    call++;
+  }
+  return 0;
+}
+
+static int
+_errTotalLinf(double *retP, gageOptimSigContext *oscx,
+              unsigned int mmIdx[2], double mmErr[2]) {
+  static const char me[]="_errTotalLinf";
+  unsigned int ii, pi;
+  double *err, *sem, *rr, rho, sig, pid;
+  int outside;
+
+  err = AIR_CAST(double *, oscx->nerr->data);
+  sem = oscx->sampleErrMax;
+  rr = oscx->rhoRange;
+  for (pi=0; pi<=oscx->sampleNum-2; pi++) {
+    sem[pi] = 0;
+  }
+  /* NOTE: we don't bother with last "true image": it will always be a
+     low error, and not meaningfully associated with a gap */
+  for (ii=0; ii<oscx->trueImgNum-1; ii++) {
+    /* debugii = ii; */
+    rho = AIR_AFFINE(0, ii, oscx->trueImgNum-1, rr[0], rr[1]);
+    if (_errSingle(err + ii, oscx, rho)) {
+      biffAddf(GAGE, "%s: trouble at ii %u", me, ii);
+      return 1;
+    }
+    sig = _SigOfRho(rho);
+    pid = gageStackWtoI(oscx->gctx, sig, &outside);
+    pi = AIR_UINT(pid);
+    if (outside || !(pi <= oscx->sampleNum-2)) {
+      biffAddf(GAGE, "%s: ii %u -> rho %g -> sig %g -> pi %u-> OUTSIDE",
+               me, ii, rho, sig, pi);
+      return 1;
+    }
+    sem[pi] = AIR_MAX(sem[pi], err[ii]);
+  }
+  mmIdx[0] = mmIdx[1] = 0;
+  mmErr[0] = mmErr[1] = sem[0];
+  for (pi=1; pi<=oscx->sampleNum-2; pi++) {
+    if (sem[pi] < mmErr[0]) {
+      mmIdx[0] = pi;
+      mmErr[0] = sem[pi];
+    }
+    if (sem[pi] > mmErr[1]) {
+      mmIdx[1] = pi;
+      mmErr[1] = sem[pi];
+    }
   }
-  err = AIR_CAST(double *, parm->nerr->data);
-  for (ii=0; ii<parm->measrSampleNum; ii++) {
-    err[ii] = _errSingle(parm, ii);
-  }
-  nrrdMeasureLine[parm->lineMeasr](&ret, nrrdTypeDouble,
-                                   err, nrrdTypeDouble,
-                                   parm->measrSampleNum,
-                                   AIR_NAN, AIR_NAN);
+  /* returned error invented, not really Linf, but minimizing this
+     does the right thing */
+  *retP = 1000*oscx->sampleNum*(mmErr[1] - mmErr[0])/(rr[1] - rr[0]);
   if (0) {
-    static unsigned int call;
+    static unsigned int call=0;
     char fname[AIR_STRLEN_SMALL];
     sprintf(fname, "err-%04u.nrrd", call);
-    nrrdSave(fname, parm->nerr, NULL);
+    nrrdSave(fname, oscx->nerr, NULL);
     call++;
   }
-  return ret;
+  return 0;
 }
 
+/*
+** this can be called repeatedly
+*/
 static int
-_gageSetup(gageOptimSigParm *parm) {
+_gageSetup(gageOptimSigContext *oscx) {
   static const char me[]="_gageSetup";
   double kparm[NRRD_KERNEL_PARMS_NUM];
   int E;
 
-  if (parm->gctx) {
-    gageContextNix(parm->gctx);
+  if (oscx->gctx) {
+    gageContextNix(oscx->gctx);
   }
-  parm->gctx = gageContextNew();
-  gageParmSet(parm->gctx, gageParmVerbose, 0);
-  gageParmSet(parm->gctx, gageParmRenormalize, AIR_FALSE);
-  gageParmSet(parm->gctx, gageParmCheckIntegrals, AIR_FALSE);
-  gageParmSet(parm->gctx, gageParmOrientationFromSpacing, AIR_TRUE);
-  gageParmSet(parm->gctx, gageParmStackUse, AIR_TRUE);
+  oscx->gctx = gageContextNew();
+  gageParmSet(oscx->gctx, gageParmVerbose, 0);
+  gageParmSet(oscx->gctx, gageParmRenormalize, AIR_FALSE);
+  gageParmSet(oscx->gctx, gageParmCheckIntegrals, AIR_FALSE);
+  gageParmSet(oscx->gctx, gageParmOrientationFromSpacing, AIR_TRUE);
+  gageParmSet(oscx->gctx, gageParmStackUse, AIR_TRUE);
   E = 0;
-  if (!E) E |= !(parm->pvl = gagePerVolumeNew(parm->gctx, parm->nsampvol[0],
-                                              gageKindScl));
-  if (!E) E |= gageStackPerVolumeNew(parm->gctx, parm->pvlSS,
+  if (!E) E |= !(oscx->pvlBase = gagePerVolumeNew(oscx->gctx,
+                                                  oscx->nsampleImg[0],
+                                                  gageKindScl));
+  if (!E) E |= gageStackPerVolumeNew(oscx->gctx, oscx->pvlSS,
                                      AIR_CAST(const Nrrd*const*,
-                                              parm->nsampvol),
-                                     parm->sampleNum, gageKindScl);
-  if (!E) E |= gageStackPerVolumeAttach(parm->gctx, parm->pvl, parm->pvlSS,
-                                        parm->scalePos, parm->sampleNum);
+                                              oscx->nsampleImg),
+                                     oscx->sampleNum, gageKindScl);
+  if (!E) E |= gageStackPerVolumeAttach(oscx->gctx,
+                                        oscx->pvlBase, oscx->pvlSS,
+                                        oscx->sampleSigma, oscx->sampleNum);
   kparm[0] = 1;
-  if (!E) E |= gageKernelSet(parm->gctx, gageKernel00,
-                             nrrdKernelTent, kparm);
-  if (parm->tentRecon) {
-    if (!E) E |= gageKernelSet(parm->gctx, gageKernelStack,
-                               nrrdKernelTent, kparm);
-  } else {
-    if (!E) E |= gageKernelSet(parm->gctx, gageKernelStack,
-                               nrrdKernelHermiteScaleSpaceFlag, kparm);
-  }
-  if (!E) E |= gageQueryItemOn(parm->gctx, parm->pvl, gageSclValue);
-  if (!E) E |= gageUpdate(parm->gctx);
+  if (!E) E |= gageKernelSet(oscx->gctx, gageKernel00,
+                             nrrdKernelBox, kparm);
+  if (!E) E |= gageKernelSet(oscx->gctx, gageKernelStack,
+                             oscx->kssSpec->kernel, oscx->kssSpec->parm);
+  if (!E) E |= gageQueryItemOn(oscx->gctx, oscx->pvlBase, gageSclValue);
+  if (!E) E |= gageUpdate(oscx->gctx);
   if (E) {
     biffAddf(GAGE, "%s: problem setting up gage", me);
     return 1;
@@ -512,14 +817,6 @@
   return 0;
 }
 
-static void
-_scalePosSet(gageOptimSigParm *parm, unsigned int ii, double sigma) {
-
-  parm->scalePos[ii] = sigma;
-  _volTrueBlur(parm->nsampvol[ii], parm->scalePos[ii], parm);
-  gagePointReset(&(parm->gctx->point));
-}
-
 static char *
 _timefmt(char tstr[AIR_STRLEN_MED], double deltim) {
 
@@ -548,65 +845,85 @@
 }
 
 static int
-_optsigrun(gageOptimSigParm *parm) {
+_optsigrun(gageOptimSigContext *oscx) {
   static const char me[]="_optsigrun";
   char tstr[AIR_STRLEN_MED];
   unsigned int iter, pnt;
-  double lastErr, newErr, sigeps, oppor, lastPos, backoff, decavg, time0;
+  double lastErr, newErr, rhoeps, oppor, lastPos, backoff, decavg, time0;
   int badStep;
 
+  /* used to debug failure to measure error meaningfully
+  {
+    unsigned int hi, hn=200;
+    double rr;
+    for (hi=0; hi<hn; hi++) {
+      rr = AIR_AFFINE(-20, hi, hn+20, oscx->rhoRange[0], oscx->rhoRange[1]);
+      _sampleSet(oscx, 1, rr);
+      _errTotal(oscx);
+    }
+  }
+  */
+
   time0 = airTime();
-  lastErr = _errTotal(parm);
+  if (_errTotal(&lastErr, oscx)) {
+    biffAddf(GAGE, "%s: first error measurement", me);
+    return 1;
+  }
   fprintf(stderr, "%s: (%s for initial error measr)\n", me,
           _timefmt(tstr, airTime() - time0));
   newErr = AIR_NAN;
-  decavg = parm->sampleNum; /* hack */
+  decavg = oscx->sampleNum; /* hack */
   /* meaningful discrete difference for looking at error gradient is
      bounded by the resolution of the sampling we're doing along scale */
-  sigeps = parm->sigmatru[1]/10;
+  rhoeps = 0.1*(oscx->rhoRange[1]-oscx->rhoRange[0])/oscx->trueImgNum;
   oppor = 1.3333;
   backoff = 0.25;
-  for (pnt=1; pnt<parm->sampleNum-1; pnt++) {
-    parm->step[pnt] = 10;
+  /* initialize step for the moving samples: 1 through oscx->sampleNum-2 */
+  for (pnt=1; pnt<oscx->sampleNum-1; pnt++) {
+    oscx->step[pnt] = 10;
   }
-  for (iter=0; iter<parm->maxIter; iter++) {
+  for (iter=0; iter<oscx->maxIter; iter++) {
     double limit, err1, grad, delta;
     unsigned int tryi;
     int zerodelta, esgn;
-    esgn = 2*AIR_CAST(int, airRandInt(2)) - 1;
-    pnt = 1 + (iter % (parm->sampleNum-2));
-    lastPos = parm->scalePos[pnt];
+    esgn = 2*AIR_INT(airRandInt(2)) - 1;
+    pnt = 1 + (iter % (oscx->sampleNum-2));
+    lastPos = oscx->sampleRho[pnt];
     fprintf(stderr, "%s: ***** iter %u; [[ err %g ]] %s\n",
             me, iter, lastErr, _timefmt(tstr, airTime() - time0));
-    limit = AIR_MIN((parm->scalePos[pnt] - parm->scalePos[pnt-1])/3,
-                    (parm->scalePos[pnt+1] - parm->scalePos[pnt])/3);
+    limit = AIR_MIN((oscx->sampleRho[pnt] - oscx->sampleRho[pnt-1])/3,
+                    (oscx->sampleRho[pnt+1] - oscx->sampleRho[pnt])/3);
     fprintf(stderr, ". pnt %u: pos %g, step %g\n",
-            pnt, lastPos, parm->step[pnt]);
+            pnt, lastPos, oscx->step[pnt]);
     fprintf(stderr, ". limit = min((%g-%g)/3,(%g-%g)/3) = %g\n",
-            parm->scalePos[pnt], parm->scalePos[pnt-1],
-            parm->scalePos[pnt+1], parm->scalePos[pnt], limit);
-    _scalePosSet(parm, pnt, lastPos + esgn*sigeps);
-    err1 = _errTotal(parm);
-    _scalePosSet(parm, pnt, lastPos);
-    grad = (err1 - lastErr)/(esgn*sigeps);
+            oscx->sampleRho[pnt], oscx->sampleRho[pnt-1],
+            oscx->sampleRho[pnt+1], oscx->sampleRho[pnt], limit);
+    _sampleSet(oscx, pnt, lastPos + esgn*rhoeps);
+    if (_errTotal(&err1, oscx)) {
+      biffAddf(GAGE, "%s: for err1 (%u -> %.17g)",
+               me, pnt, lastPos + esgn*rhoeps);
+      return 1;
+    }
+    _sampleSet(oscx, pnt, lastPos);
+    grad = (err1 - lastErr)/(esgn*rhoeps);
     fprintf(stderr, ". grad = %g\n", grad);
-    delta = -grad*parm->step[pnt];
+    delta = -grad*oscx->step[pnt];
     if (!AIR_EXISTS(delta)) {
       biffAddf(GAGE, "%s: got non-exist delta %g on iter %u (pnt %u) err %g",
                me, delta, iter, pnt, lastErr);
       return 1;
     }
     if (AIR_ABS(delta) > limit) {
-      parm->step[pnt] *= limit/AIR_ABS(delta);
+      oscx->step[pnt] *= limit/AIR_ABS(delta);
       fprintf(stderr, ". step *= %g/%g -> %g\n",
-              limit, AIR_ABS(delta), parm->step[pnt]);
-      delta = -grad*parm->step[pnt];
+              limit, AIR_ABS(delta), oscx->step[pnt]);
+      delta = -grad*oscx->step[pnt];
     }
     fprintf(stderr, ". delta = %g\n", delta);
     tryi = 0;
     badStep = AIR_FALSE;
     do {
-      if (tryi == parm->maxIter) {
+      if (tryi == oscx->maxIter) {
         biffAddf(GAGE, "%s: confusion (tryi %u) on iter %u (pnt %u) err %g",
                  me, tryi, iter, pnt, lastErr);
         return 1;
@@ -617,26 +934,30 @@
         zerodelta = AIR_TRUE;
       } else {
         zerodelta = AIR_FALSE;
-        _scalePosSet(parm, pnt, lastPos + delta);
-        newErr = _errTotal(parm);
+        _sampleSet(oscx, pnt, lastPos + delta);
+        if (_errTotal(&newErr, oscx)) {
+          biffAddf(GAGE, "%s: for newErr (%u -> %.17g)", me,
+                   pnt, lastPos + delta);
+          return 1;
+        }
         badStep = newErr > lastErr;
         fprintf(stderr, "... try %u: pos[%u] %g + %g = %g;\n"
                 "%s: err %g %s %g\n",
                 tryi, pnt, lastPos, delta,
-                parm->scalePos[pnt],
+                oscx->sampleRho[pnt],
                badStep ? "*BAD*" : "good",
                newErr, newErr > lastErr ? ">" : "<=", lastErr);
         if (badStep) {
-          parm->step[pnt] *= backoff;
-          if (parm->step[pnt] < sigeps/1000) {
+          oscx->step[pnt] *= backoff;
+          if (oscx->step[pnt] < rhoeps/1000) {
             /* step got so small its stupid to be moving this point */
             fprintf(stderr, "... !! step %g < %g pointlessly small, "
-                    "moving on\n", parm->step[pnt], sigeps/1000);
-            _scalePosSet(parm, pnt, lastPos);
+                    "moving on\n", oscx->step[pnt], rhoeps/1000);
+            _sampleSet(oscx, pnt, lastPos);
             newErr = lastErr;
             badStep = AIR_FALSE;
           } else {
-            delta = -grad*parm->step[pnt];
+            delta = -grad*oscx->step[pnt];
           }
         }
       }
@@ -644,151 +965,430 @@
     } while (badStep);
     if (!zerodelta) {
       /* don't update decavg if we moved on because slope was EXACTLY zero */
-      decavg = AIR_AFFINE(0, 1, parm->sampleNum,
+      decavg = AIR_AFFINE(0, 1, oscx->sampleNum,
                           decavg, (lastErr - newErr)/lastErr);
-      parm->step[pnt] *= oppor;
+      oscx->step[pnt] *= oppor;
     }
-    if (decavg <= parm->convEps) {
+    if (decavg <= oscx->convEps) {
       fprintf(stderr, "%s: converged (%g <= %g) after %u iters\n", me,
-              decavg, parm->convEps, iter);
+              decavg, oscx->convEps, iter);
       break;
     } else {
-      fprintf(stderr, "%s: _____ iter %u done; decavg = %g > %g\n", me,
-              iter, decavg, parm->convEps);
+      fprintf(stderr, "%s: _____ iter %u done; decavg = %g > eps %g\n", me,
+              iter, decavg, oscx->convEps);
     }
     lastErr = newErr;
   }
-  if (iter == parm->maxIter) {
+  if (iter == oscx->maxIter && decavg > oscx->convEps) {
+    biffAddf(GAGE, "%s: failed to converge (%g > %g) after %u iters\n", me,
+             decavg, oscx->convEps, iter);
+    return 1;
+  }
+  oscx->finalErr = lastErr;
+
+  return 0;
+}
+
+static int
+_optsigrunLinf(gageOptimSigContext *oscx) {
+  static const char me[]="_optsigrunLinf";
+  char tstr[AIR_STRLEN_MED];
+  double *srho, *stmp, time0, lastErr, newErr, decavg,
+    step, oppor, backoff, ceps, mmErr[2];
+  unsigned int iter, si, sn, mmIdx[2];
+  int shrink;
+
+  time0 = airTime();
+  if (_errTotalLinf(&lastErr, oscx, mmIdx, mmErr)) {
+    biffAddf(GAGE, "%s: first error measurement", me);
+    return 1;
+  }
+  fprintf(stderr, "%s: (init)  min %u %g          max %u %g\n", me,
+          mmIdx[0], mmErr[0], mmIdx[1], mmErr[1]);
+  fprintf(stderr, "%s: (%s for initial error measr)\n", me,
+          _timefmt(tstr, airTime() - time0));
+  newErr = AIR_NAN;
+
+  /* shorcuts */
+  sn = oscx->sampleNum;
+  srho = oscx->sampleRho;
+  stmp = oscx->sampleTmp;
+
+  /* Linf uses a single scalar step istead of oscx->step array */
+  step = 0.1;
+  oppor = 1.1;
+  backoff = 0.5;
+
+  /* more demanding for more points */
+  ceps = oscx->convEps/sn;
+
+  decavg = 2*ceps;
+  for (iter=0; iter<oscx->maxIter; iter++) {
+    double midp, wlo, whi, glo, ghi, gerr;
+    unsigned int gap, tryi;
+    int badStep;
+
+    if (iter % 2) {
+      /* we will grow gap around smallest peak */
+      gap = mmIdx[0];
+      gerr = mmErr[0];
+      shrink = AIR_FALSE;
+    } else {
+      /* we will shrink gap around tallest peak */
+      gap = mmIdx[1];
+      gerr = mmErr[1];
+      shrink = AIR_TRUE;
+    }
+    midp = (srho[gap] + srho[gap+1])/2;
+    fprintf(stderr, "%s: ---- iter %u (step %g): gap [%u]/%g (%s)\n",
+            me, iter, step, gap, gerr,
+            shrink ? "shrinking tallest" : "growing lowest");
+    /* save last set of positions to restore after bad step */
+    for (si=1; si<sn-1; si++) {
+      stmp[si] = srho[si];
+    }
+    tryi = 0;
+    badStep = AIR_FALSE;
+    do {
+      if (tryi == oscx->maxIter) {
+        biffAddf(GAGE, "%s: confusion (tryi %u) on iter %u err %g",
+                 me, tryi, iter, lastErr);
+        return 1;
+      }
+      if (shrink) {
+        wlo = AIR_AFFINE(0, step, 1, srho[gap], midp);
+        whi = AIR_AFFINE(0, step, 1, srho[gap+1], midp);
+      } else {
+        wlo = AIR_AFFINE(0, step, -2, srho[gap], midp);
+        whi = AIR_AFFINE(0, step, -2, srho[gap+1], midp);
+      }
+      glo = srho[gap];
+      ghi = srho[gap+1];
+      fprintf(stderr, "%s:     rho[%u] %g | %g  -- rho[%u] %g | %g\n", me,
+              gap, srho[gap], wlo, gap+1, srho[gap+1], whi);
+      for (si=1; si<sn-1; si++) {
+        _sampleSet(oscx, si, (si <= gap
+                              ? AIR_AFFINE(srho[0], srho[si], glo,
+                                           srho[0], wlo)
+                              : AIR_AFFINE(ghi, srho[si], srho[sn-1],
+                                           whi, srho[sn-1])));
+      }
+      if (_errTotalLinf(&newErr,
+                        oscx, mmIdx, mmErr)) {
+        biffAddf(GAGE, "%s: iter %u", me, iter);
+        return 1;
+      }
+      fprintf(stderr, "%s:        min %u %g          max %u %g\n", me,
+              mmIdx[0], mmErr[0], mmIdx[1], mmErr[1]);
+      if (iter % 3) {
+        badStep = newErr > lastErr;
+        fprintf(stderr, "... try %u [%u] step %g -> newErr %g %s "
+                "lastErr %g %s\n",
+                tryi, gap, step, newErr,
+                badStep ? ">" : "<=",
+                lastErr,
+                badStep ? "*BAD*" : "good");
+        if (badStep) {
+          step *= backoff;
+          for (si=1; si<sn-1; si++) {
+            srho[si] = stmp[si];
+          }
+        }
+        tryi++;
+      }
+    } while (badStep);
+    step *= oppor;
+    decavg = (decavg + (lastErr - newErr))/2;
+    if (AIR_IN_OP(0, decavg, ceps)) {
+      fprintf(stderr, "%s: converged (%g <= %g) after %u iters\n", me,
+              decavg, ceps, iter);
+      break;
+    } else {
+      fprintf(stderr, "%s:      iter %u done; decavg = %g > eps %g\n", me,
+              iter, decavg, ceps);
+    }
+    lastErr = newErr;
+  } /* for iter */
+  if (oscx->maxIter
+      && iter == oscx->maxIter
+      && decavg > ceps) {
     biffAddf(GAGE, "%s: failed to converge (%g > %g) after %u iters\n", me,
-             decavg, parm->convEps, iter);
+             decavg, ceps, iter);
     return 1;
   }
-  parm->finalErr = lastErr;
+  oscx->finalErr = lastErr;
+
   return 0;
 }
 
 int
-gageOptimSigCalculate(gageOptimSigParm *parm,
-                      double *scalePos, unsigned int num,
-                      int volMeasr, int lineMeasr,
-                      double convEps, unsigned int maxIter) {
+gageOptimSigCalculate(gageOptimSigContext *oscx,
+                      /* output */ double *sigma,
+                      unsigned int sigmaNum,
+                      const NrrdKernelSpec *kssSpec,
+                      int imgMeasr, int allMeasr,
+                      unsigned int maxIter, double convEps) {
   static const char me[]="gageOptimSigCalculate";
   unsigned int ii;
-  double tauMax;
 
-  if (!( parm && scalePos && num )) {
+  if (!( oscx && sigma && kssSpec )) {
     biffAddf(GAGE, "%s: got NULL pointer", me);
     return 1;
   }
-  if (!( AIR_IN_CL(1, parm->dim, 3)
-         && parm->ntruth->data )) {
-    biffAddf(GAGE, "%s: incomplete parm setup?", me);
-    return 1;
-  }
-  if (num > parm->sampleNumMax) {
-    biffAddf(GAGE, "%s: parm setup for max %u samples, not %u", me,
-             parm->sampleNumMax, num);
+  if (sigmaNum > oscx->sampleNumMax) {
+    biffAddf(GAGE, "%s: initialized for max %u samples, not %u", me,
+             oscx->sampleNumMax, sigmaNum);
     return 1;
   }
-  /* copy remaining input parms */
-  parm->sampleNum = num;
-  parm->volMeasr = volMeasr;
-  parm->lineMeasr = lineMeasr;
-  parm->maxIter = maxIter;
-  parm->convEps = convEps;
-
-  /* initialize the scalePos[] array to uniform samples in tau */
-  fprintf(stderr, "%s: initializing samples ... ", me); fflush(stderr);
-  tauMax = gageTauOfSig(parm->sigmaMax);
-  for (ii=0; ii<parm->sampleNum; ii++) {
-    double tau;
-    tau = AIR_AFFINE(0, ii, parm->sampleNum-1, 0, tauMax);
-    _scalePosSet(parm, ii, gageSigOfTau(tau));
+
+  /* initialize to uniform samples in rho */
+  oscx->sampleNum = sigmaNum;
+  fprintf(stderr, "%s: initializing %u samples ... ", me, oscx->sampleNum);
+  fflush(stderr);
+  for (ii=0; ii<oscx->sampleNum; ii++) {
+    _sampleSet(oscx, ii, AIR_AFFINE(0, ii, oscx->sampleNum-1,
+                                    oscx->rhoRange[0], oscx->rhoRange[1]));
   }
   fprintf(stderr, "done.\n");
 
+  /* copy remaining input parameters */
+  nrrdKernelSpecNix(oscx->kssSpec);
+  oscx->kssSpec = nrrdKernelSpecCopy(kssSpec);
+  oscx->imgMeasr = imgMeasr;
+  oscx->allMeasr = allMeasr;
+  oscx->convEps = convEps;
+  oscx->maxIter = maxIter;
+  oscx->convEps = convEps;
+
   /* set up gage */
   fprintf(stderr, "%s: setting up gage ... \n", me);
-  if (_gageSetup(parm)) {
+  if (_gageSetup(oscx)) {
     biffAddf(GAGE, "%s: problem setting up gage", me);
     return 1;
   }
-  fprintf(stderr, "%s: gage setup done.\n", me);
+  fprintf(stderr, "%s: ... gage setup done.\n", me);
 
   /* run the optimization */
-  if (num > 2) {
-    if (_optsigrun(parm)) {
+  if (oscx->sampleNum > 2) {
+    int EE;
+    EE = (nrrdMeasureLinf == oscx->allMeasr
+          ? _optsigrunLinf(oscx)
+          : _optsigrun(oscx));
+    if (EE) {
       biffAddf(GAGE, "%s: trouble", me);
       return 1;
     }
   } else {
     fprintf(stderr, "%s: num == 2, no optimization, finding error ... ", me);
     fflush(stderr);
-    parm->finalErr = _errTotal(parm);
+    if (_errTotal(&(oscx->finalErr), oscx)) {
+      biffAddf(GAGE, "%s: for finalErr", me);
+      return 1;
+    }
     fprintf(stderr, "done.\n");
   }
 
   /* save output */
-  for (ii=0; ii<num; ii++) {
-    scalePos[ii] = parm->scalePos[ii];
+  for (ii=0; ii<oscx->sampleNum; ii++) {
+    sigma[ii] = oscx->sampleSigma[ii];
   }
 
   return 0;
 }
 
 int
-gageOptimSigPlot(gageOptimSigParm *parm, Nrrd *nout,
-                 const double *plotPos, unsigned int plotPosNum,
-                 int volMeasr, int tentRecon) {
-  char me[]="gageOptimSigPlot", doneStr[AIR_STRLEN_SMALL];
-  unsigned int ii;
+gageOptimSigErrorPlot(gageOptimSigContext *oscx, Nrrd *nout,
+                      const double *sigma,
+                      unsigned int sigmaNum,
+                      const NrrdKernelSpec *kssSpec,
+                      int imgMeasr) {
+  static const char me[]="gageOptimSigErrorPlot";
+  char doneStr[AIR_STRLEN_SMALL];
   double *out;
+  unsigned int ii;
 
-  if (!(parm && nout && plotPos)) {
+  if (!(oscx && nout && sigma)) {
     biffAddf(GAGE, "%s: got NULL pointer", me);
     return 1;
   }
-  if (!( plotPosNum >= 2 )) {
-    biffAddf(GAGE, "%s: need plotPosNum >= 2 (not %u)", me, plotPosNum);
+  if (!( sigmaNum >= 2 )) {
+    biffAddf(GAGE, "%s: need sigmaNum >= 2 (not %u)", me, sigmaNum);
     return 1;
   }
-  /* HEY: copy and paste from above */
-  if (!( AIR_IN_CL(1, parm->dim, 3)
-         && parm->ntruth->data )) {
-    biffAddf(GAGE, "%s: incomplete parm setup?", me);
-    return 1;
-  }
-  if (plotPosNum > parm->sampleNumMax) {
-    biffAddf(GAGE, "%s: parm setup for max %u samples, not %u", me,
-             parm->sampleNumMax, plotPosNum);
+  if (sigmaNum > oscx->sampleNumMax) {
+    biffAddf(GAGE, "%s: initialized for max %u samples, not %u", me,
+             oscx->sampleNumMax, sigmaNum);
     return 1;
   }
+
   /* copy remaining input parms */
-  parm->sampleNum = plotPosNum;
-  parm->volMeasr = volMeasr;
-  parm->tentRecon = tentRecon;
-  if (nrrdMaybeAlloc_va(nout, nrrdTypeDouble, 1,
-                        AIR_CAST(size_t, parm->measrSampleNum))) {
+  nrrdKernelSpecNix(oscx->kssSpec);
+  oscx->kssSpec = nrrdKernelSpecCopy(kssSpec);
+  oscx->sampleNum = sigmaNum;
+  oscx->maxIter = 0;
+  oscx->imgMeasr = imgMeasr;
+  oscx->allMeasr = nrrdMeasureUnknown;
+  oscx->convEps = AIR_NAN;
+  if (nrrdMaybeAlloc_va(nout, nrrdTypeDouble, 2,
+                        AIR_CAST(size_t, 2),
+                        AIR_CAST(size_t, oscx->trueImgNum))) {
     biffMovef(GAGE, NRRD, "%s: trouble allocating output", me);
     return 1;
   }
   out = AIR_CAST(double *, nout->data);
 
   /* set up requested samples */
-  for (ii=0; ii<parm->sampleNum; ii++) {
-    _scalePosSet(parm, ii, plotPos[ii]);
+  for (ii=0; ii<oscx->sampleNum; ii++) {
+    _sampleSet(oscx, ii, _RhoOfSig(sigma[ii]));
   }
-  if (_gageSetup(parm)) {
+  if (_gageSetup(oscx)) {
     biffAddf(GAGE, "%s: problem setting up gage", me);
     return 1;
   }
-  fprintf(stderr, "%s: working ...       ", me);
-  for (ii=0; ii<parm->measrSampleNum; ii++) {
-    printf("%s", airDoneStr(0, ii, parm->measrSampleNum, doneStr));
+  fprintf(stderr, "%s: plotting ...       ", me); fflush(stderr);
+  for (ii=0; ii<oscx->trueImgNum; ii++) {
+    double rho, err;
+    fprintf(stderr, "%s", airDoneStr(0, ii, oscx->trueImgNum, doneStr));
     fflush(stderr);
-    out[ii] = _errSingle(parm, ii);
+    rho = AIR_AFFINE(0, ii, oscx->trueImgNum-1,
+                     oscx->rhoRange[0], oscx->rhoRange[1]);
+    out[0 + 2*ii] = rho;
+    /* debugii = ii; */
+    if (_errSingle(&err, oscx, rho)) {
+      biffAddf(GAGE, "%s: plotting %u", me, ii);
+      return 1;
+    }
+    out[1 + 2*ii] = err;
+    /*
+    if (AIR_IN_CL(69,ii,71)) {
+      fprintf(stderr, "!%s: ----- %u : %g\n", me, ii, err);
+    }
+    */
+  }
+  fprintf(stderr, "%s\n", airDoneStr(0, ii, oscx->trueImgNum, doneStr));
+
+  /*
+  if (0) {
+    static unsigned int call=0;
+    char fname[AIR_STRLEN_SMALL];
+    unsigned int ni;
+    if (0) {
+      sprintf(fname, "err-%04u.nrrd", call);
+      nrrdSave(fname, oscx->nerr, NULL);
+    }
+    if (debugging) {
+      for (ni=0; ni<oscx->sampleNum; ni++) {
+        sprintf(fname, "sample-%04u.nrrd", ni);
+        nrrdSave(fname, oscx->nsampleImg[ni], NULL);
+      }
+    }
+    call++;
+    debugging = (2 == call);
   }
-  fprintf(stderr, "%s\n", airDoneStr(0, ii, parm->measrSampleNum, doneStr));
+  */
 
   return 0;
 }
+
+int
+gageOptimSigErrorPlotSliding(gageOptimSigContext *oscx, Nrrd *nout,
+                             double windowRho,
+                             unsigned int sampleNum,
+                             const NrrdKernelSpec *kssSpec,
+                             int imgMeasr) {
+  static const char me[]="gageOptimSigRecondErrorPlotSliding";
+  char doneStr[AIR_STRLEN_SMALL];
+  unsigned int ii;
+  double *out;
+  char hackKeyStr[]="TEEM_OPTSIG_RECONERR";
+
+  if (!( oscx && nout && kssSpec )) {
+    biffAddf(GAGE, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (windowRho <= 0) {
+    biffAddf(GAGE, "%s: need positive windowRho (not %g)", me, windowRho);
+    return 1;
+  }
+  if (windowRho > oscx->rhoRange[1] - oscx->rhoRange[0]) {
+    biffAddf(GAGE, "%s: window %g > rhorange %g-%g=%g", me,
+             windowRho, oscx->rhoRange[1], oscx->rhoRange[0],
+             oscx->rhoRange[1] - oscx->rhoRange[0]);
+    return 1;
+  }
+
+  if (nrrdGetenvString(&debugReconErrName, hackKeyStr)) {
+    fprintf(stderr, "%s: %s hack on: will save recon results to %s\n",
+            me, hackKeyStr, debugReconErrName);
+    debugReconErrArr = airArrayNew(AIR_CAST(void **, &(debugReconErr)), NULL,
+                                   sizeof(double), 1000);
+  }
+
+  /* copy remaining input parms */
+  nrrdKernelSpecNix(oscx->kssSpec);
+  oscx->kssSpec = nrrdKernelSpecCopy(kssSpec);
+  oscx->sampleNum = 3; /* hacky */
+  oscx->maxIter = 0;
+  oscx->imgMeasr = imgMeasr;
+  oscx->allMeasr = nrrdMeasureUnknown;
+  oscx->convEps = AIR_NAN;
+  oscx->sampleSigma[0] = oscx->sigmaRange[0]; /* just for gage setup */
+  oscx->sampleSigma[1] = oscx->sigmaRange[1]; /* just for gage setup */
+  oscx->sampleSigma[2] = oscx->sigmaRange[1]+1;
+  if (_gageSetup(oscx)) {
+    biffAddf(GAGE, "%s: problem setting up gage", me);
+    return 1;
+  }
+  if (nrrdMaybeAlloc_va(nout, nrrdTypeDouble, 2,
+                        AIR_CAST(size_t, 2),
+                        AIR_CAST(size_t, sampleNum))) {
+    biffMovef(GAGE, NRRD, "%s: trouble allocating output", me);
+    return 1;
+  }
+  out = AIR_CAST(double *, nout->data);
+  fprintf(stderr, "%s: plotting ...       ", me); fflush(stderr);
+  for (ii=0; ii<sampleNum; ii++) {
+    double rho, rlo, rhi, err;
+    fprintf(stderr, "%s", airDoneStr(0, ii, oscx->trueImgNum, doneStr));
+    fflush(stderr);
+    rho = AIR_AFFINE(0, ii, sampleNum,
+                     oscx->rhoRange[0], oscx->rhoRange[1]);
+    rlo = rho - windowRho/2;
+    rhi = rho + windowRho/2;
+    if (rlo < oscx->rhoRange[0]
+        || rhi > oscx->rhoRange[1]) {
+      if (debugReconErrArr) {
+        /* we have to simulate the updates to debugReconErrArr
+           that would happen with a call to _errSingle */
+        airArrayLenIncr(debugReconErrArr, 2*oscx->sz*oscx->sy*oscx->sx);
+      }
+      out[0 + 2*ii] = _SigOfRho(rho);
+      out[1 + 2*ii] = AIR_NAN;
+      continue;
+    }
+    /* required samples will slide along with plotting */
+    _sampleSet(oscx, 0, rlo);
+    _sampleSet(oscx, 1, rhi);
+    if (_errSingle(&err, oscx, rho)) {
+      biffAddf(GAGE, "%s: plotting/sliding %u", me, ii);
+      return 1;
+    }
+    out[0 + 2*ii] = _SigOfRho(rho);
+    out[1 + 2*ii] = err;
+  }
+  fprintf(stderr, "%s\n", airDoneStr(0, ii, oscx->trueImgNum, doneStr));
+
+  if (debugReconErrArr) {
+    Nrrd *nre = nrrdNew();
+    nrrdWrap_va(nre, debugReconErr, nrrdTypeDouble, 3,
+                AIR_CAST(size_t, 2),
+                AIR_CAST(size_t, oscx->sz*oscx->sy*oscx->sx),
+                AIR_CAST(size_t, sampleNum));
+    nrrdSave(debugReconErrName, nre, NULL);
+    nrrdNix(nre);
+  }
+
+
+  return 0;
+}
+
diff --color -ruN teem-1.11.0-src.orig/src/gage/print.c teem-1.11.0-src/src/gage/print.c
--- teem-1.11.0-src.orig/src/gage/print.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/print.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/privateGage.h teem-1.11.0-src/src/gage/privateGage.h
--- teem-1.11.0-src.orig/src/gage/privateGage.h	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/privateGage.h	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/pvl.c teem-1.11.0-src/src/gage/pvl.c
--- teem-1.11.0-src.orig/src/gage/pvl.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/pvl.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/scl3pfilterbody.c teem-1.11.0-src/src/gage/scl3pfilterbody.c
--- teem-1.11.0-src.orig/src/gage/scl3pfilterbody.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/scl3pfilterbody.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/sclanswer.c teem-1.11.0-src/src/gage/sclanswer.c
--- teem-1.11.0-src.orig/src/gage/sclanswer.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/sclanswer.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -50,7 +50,7 @@
   double len, gp1[3], gp2[3], *nPerp, ncTen[9], nProj[9]={0,0,0,0,0,0,0,0,0};
   double alpha = 0.5;
   double beta = 0.5;
-  double gamma = 5;
+  double _gamma = 5;
   double cc = 1e-6;
 #define FD_MEDIAN_MAX 16
   int fd, nidx, xi, yi, zi;
@@ -134,8 +134,12 @@
     pvl->directAnswer[gageSclHessFrob][0] = ELL_3M_FROB(hess);
   }
   if (GAGE_QUERY_ITEM_TEST(pvl->query, gageSclHessEval)) {
-    /* HEY: look at the return value for root multiplicity? */
-    ell_3m_eigensolve_d(heval, hevec, hess, AIR_TRUE);
+    if (ctx->parm.twoDimZeroZ) {
+      ell_3m2sub_eigensolve_d(heval, hevec, hess);
+    } else {
+      /* HEY: look at the return value for root multiplicity? */
+      ell_3m_eigensolve_d(heval, hevec, hess, AIR_TRUE);
+    }
     ELL_3V_COPY(pvl->directAnswer[gageSclHessEval], heval);
   }
   if (GAGE_QUERY_ITEM_TEST(pvl->query, gageSclHessEvec)) {
@@ -158,7 +162,7 @@
       ans = pvl->directAnswer[gageSclHessRidgeness];
       ans[0] = (1-exp(-A*A/(2*alpha*alpha))) *
         exp(-B*B/(2*beta*beta)) *
-        (1-exp(-S*S/(2*gamma*gamma))) *
+        (1-exp(-S*S/(2*_gamma*_gamma))) *
         exp(-2*cc*cc/(AIR_ABS(heval[1])*heval[2]*heval[2]));
     }
   }
@@ -209,10 +213,24 @@
       ans = pvl->directAnswer[gageSclHessValleyness];
       ans[0] = (1-exp(-A*A/(2*alpha*alpha))) *
         exp(-B*B/(2*beta*beta)) *
-        (1-exp(-S*S/(2*gamma*gamma))) *
+        (1-exp(-S*S/(2*_gamma*_gamma))) *
         exp(-2*cc*cc/(AIR_ABS(heval[1])*heval[0]*heval[0]));
     }
   }
+  if (GAGE_QUERY_ITEM_TEST(pvl->query, gageSclHessDotPeakness)) {
+#define OSQT 0.57735026918962576451
+    double neval[3], hlen, pness,
+      peak[3] = {-OSQT, -OSQT, -OSQT};
+    ELL_3V_NORM(neval, heval, hlen);
+    if (!hlen) {
+      pness = 0;
+    } else {
+      pness = ELL_3V_DOT(peak, neval);
+      pness = AIR_AFFINE(-1, pness, 1, 0, 1);
+      pvl->directAnswer[gageSclHessDotPeakness][0] = pness;
+    }
+#undef OSQT
+  }
   if (GAGE_QUERY_ITEM_TEST(pvl->query, gageSclHessMode)) {
     pvl->directAnswer[gageSclHessMode][0] = airMode3_d(heval);
   }
diff --color -ruN teem-1.11.0-src.orig/src/gage/scl.c teem-1.11.0-src/src/gage/scl.c
--- teem-1.11.0-src.orig/src/gage/scl.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/scl.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -67,6 +67,7 @@
   {gageSclMedian,        1,  0,  {0},                                            0,               0,   AIR_FALSE},
   {gageSclHessValleyness,1,  2,  {gageSclHessEval},                              0,               0,   AIR_FALSE},
   {gageSclHessRidgeness, 1,  2,  {gageSclHessEval},                              0,               0,   AIR_FALSE},
+  {gageSclHessDotPeakness,1,  2,  {gageSclHessEval},                              0,               0,   AIR_FALSE},
   {gageSclHessMode,      1,  2,  {gageSclHessEval},                              0,               0,   AIR_FALSE}
 };
 
@@ -107,6 +108,7 @@
   "median",
   "Hessian valleyness",
   "Hessian ridgeness",
+  "Hessian peakness",
   "Hessian mode"
 };
 
@@ -147,6 +149,7 @@
   "median of iv3 cache (not weighted by any filter (yet))",
   "measure of valleyness of Hessian",
   "measure of ridgeness of Hessian",
+  "measure of peakness of Hessian",
   "mode of Hessian eigenvalues"
 };
 
@@ -187,6 +190,7 @@
   gageSclMedian,
   gageSclHessValleyness,
   gageSclHessRidgeness,
+  gageSclHessDotPeakness,
   gageSclHessMode
 };
 
@@ -224,6 +228,7 @@
 #define GS_MD  gageSclMedian
 #define GS_HV  gageSclHessValleyness
 #define GS_HR  gageSclHessRidgeness
+#define GS_PK  gageSclHessDotPeakness
 #define GS_HM  gageSclHessMode
 
 const char *
@@ -263,6 +268,7 @@
   "med", "median",
   "hvalley", "hessvalley", "hessian valleyness",
   "hridge", "hessridge", "hessian ridgeness",
+  "hdpeak", "hessian peakness",
   "hmode", "hessmode", "hessian mode",
   ""
 };
@@ -303,6 +309,7 @@
   GS_MD, GS_MD,
   GS_HV, GS_HV, GS_HV,
   GS_HR, GS_HR, GS_HR,
+  GS_PK, GS_PK,
   GS_HM, GS_HM, GS_HM
 };
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/sclfilter.c teem-1.11.0-src/src/gage/sclfilter.c
--- teem-1.11.0-src.orig/src/gage/sclfilter.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/sclfilter.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/sclprint.c teem-1.11.0-src/src/gage/sclprint.c
--- teem-1.11.0-src.orig/src/gage/sclprint.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/sclprint.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/shape.c teem-1.11.0-src/src/gage/shape.c
--- teem-1.11.0-src.orig/src/gage/shape.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/shape.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -261,9 +261,9 @@
                       : shape->defaultCenter));
 
   /* ------ find sizes (set shape->size[0,1,2]) */
-  shape->size[0] = ax[0]->size;
-  shape->size[1] = ax[1]->size;
-  shape->size[2] = ax[2]->size;
+  shape->size[0] = AIR_UINT(ax[0]->size);
+  shape->size[1] = AIR_UINT(ax[1]->size);
+  shape->size[2] = AIR_UINT(ax[2]->size);
   minsize = (nrrdCenterCell == shape->center ? 1 : 2);
   /* this can't be relaxed in the face of having full orientation info,
      because even then, you can't have a non-zero probe-able volume if
diff --color -ruN teem-1.11.0-src.orig/src/gage/sources.cmake teem-1.11.0-src/src/gage/sources.cmake
--- teem-1.11.0-src.orig/src/gage/sources.cmake	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(GAGE_SOURCES
-  ctx.c
-  deconvolve.c
-  defaultsGage.c
-  filter.c
-  gage.h
-  kind.c
-  miscGage.c
-  print.c
-  privateGage.h
-  pvl.c
-  scl.c
-  sclanswer.c
-  sclfilter.c
-  sclprint.c
-  shape.c
-  st.c
-  stack.c
-  stackBlur.c
-  update.c
-  vecGage.c
-  vecprint.c
-  optimsig.c
-  )
-
-ADD_TEEM_LIBRARY(gage ${GAGE_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/gage/stackBlur.c teem-1.11.0-src/src/gage/stackBlur.c
--- teem-1.11.0-src.orig/src/gage/stackBlur.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/stackBlur.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -24,6 +24,77 @@
 #include "gage.h"
 #include "privateGage.h"
 
+const char *
+_gageSigmaSamplingStr[] = {
+  "(unknown_sampling)",
+  "unisig", /* "uniform-sigma", */
+  "unitau", /* "uniform-tau", */
+  "optil2" /* "optimal-3d-l2l2" */
+};
+
+const char *
+_gageSigmaSamplingDesc[] = {
+  "unknown sampling",
+  "uniform samples along sigma",
+  "uniform samples along Lindeberg's tau",
+  "optimal sampling (3D L2 image error and L2 error across scales)"
+};
+
+const char *
+_gageSigmaSamplingStrEqv[] = {
+  "uniform-sigma", "unisigma", "unisig",
+  "uniform-tau", "unitau",
+  "optimal-3d-l2l2", "optimal-l2l2", "optil2",
+  ""
+};
+
+const int
+_gageSigmaSamplingValEqv[] = {
+  gageSigmaSamplingUniformSigma, gageSigmaSamplingUniformSigma,
+  /* */ gageSigmaSamplingUniformSigma,
+  gageSigmaSamplingUniformTau, gageSigmaSamplingUniformTau,
+  gageSigmaSamplingOptimal3DL2L2, gageSigmaSamplingOptimal3DL2L2,
+  /* */ gageSigmaSamplingOptimal3DL2L2
+};
+
+const airEnum
+_gageSigmaSampling_enum = {
+  "sigma sampling strategy",
+  GAGE_SIGMA_SAMPLING_MAX,
+  _gageSigmaSamplingStr, NULL,
+  _gageSigmaSamplingDesc,
+  _gageSigmaSamplingStrEqv, _gageSigmaSamplingValEqv,
+  AIR_FALSE
+};
+const airEnum *const
+gageSigmaSampling = &_gageSigmaSampling_enum;
+
+
+void
+gageStackBlurParmInit(gageStackBlurParm *parm) {
+
+  if (parm) {
+    parm->num = 0;
+    parm->sigmaRange[0] = AIR_NAN;
+    parm->sigmaRange[1] = AIR_NAN;
+    parm->sigmaSampling = gageSigmaSamplingUnknown;
+    parm->sigma = airFree(parm->sigma);
+    parm->kspec = nrrdKernelSpecNix(parm->kspec);
+    /* this will be effectively moot when nrrdKernelDiscreteGaussian is used
+       with a bit cut-off, and will only help with smaller cut-offs and with
+       any other kernel, and will be moot for FFT-based blurring */
+    parm->renormalize = AIR_TRUE;
+    parm->bspec = nrrdBoundarySpecNix(parm->bspec);
+    parm->oneDim = AIR_FALSE;
+    /* the cautious application of the FFT--based blurring justifies enables
+       it by default */
+    parm->needSpatialBlur = AIR_FALSE;
+    parm->verbose = 1; /* HEY: this may be revisited */
+    parm->dgGoodSigmaMax = nrrdKernelDiscreteGaussianGoodSigmaMax;
+  }
+  return;
+}
+
 /*
 ** does not use biff
 */
@@ -32,16 +103,7 @@
   gageStackBlurParm *parm;
 
   parm = AIR_CALLOC(1, gageStackBlurParm);
-  if (parm) {
-    parm->scale = NULL;
-    parm->sigmaMax = gageDefStackBlurSigmaMax;
-    parm->padValue = AIR_NAN;
-    parm->kspec = NULL;
-    parm->dataCheck = AIR_TRUE;
-    parm->boundary = nrrdBoundaryUnknown;
-    parm->renormalize = AIR_FALSE;
-    parm->verbose = 0;
-  }
+  gageStackBlurParmInit(parm);
   return parm;
 }
 
@@ -49,71 +111,289 @@
 gageStackBlurParmNix(gageStackBlurParm *sbp) {
 
   if (sbp) {
-    airFree(sbp->scale);
+    airFree(sbp->sigma);
     nrrdKernelSpecNix(sbp->kspec);
+    nrrdBoundarySpecNix(sbp->bspec);
     free(sbp);
   }
   return NULL;
 }
 
+/*
+** *differ is set to 0 or 1; not useful for sorting
+*/
 int
-gageStackBlurParmScaleSet(gageStackBlurParm *sbp, unsigned int num,
-                          double scaleMin, double scaleMax,
-                          int uniform, int optim) {
-  static const char me[]="gageStackBlurParmScaleSet";
+gageStackBlurParmCompare(const gageStackBlurParm *aa, const char *_nameA,
+                         const gageStackBlurParm *bb, const char *_nameB,
+                         int *differ, char explain[AIR_STRLEN_LARGE]) {
+  static const char me[]="gageStackBlurParmCompare",
+    baseA[]="A", baseB[]="B";
+  const char *nameA, *nameB;
+  unsigned int si, warnLen = AIR_STRLEN_LARGE/4;
+  char stmp[2][AIR_STRLEN_LARGE], subexplain[AIR_STRLEN_LARGE];
+
+  if (!(aa && bb && differ)) {
+    biffAddf(GAGE, "%s: got NULL pointer (%p %p %p)", me,
+             AIR_CVOIDP(aa), AIR_CVOIDP(bb), AIR_VOIDP(differ));
+    return 1;
+  }
+  nameA = _nameA ? _nameA : baseA;
+  nameB = _nameB ? _nameB : baseB;
+  if (strlen(nameA) + strlen(nameB) > warnLen) {
+    biffAddf(GAGE, "%s: names (len %s, %s) might lead to overflow", me,
+             airSprintSize_t(stmp[0], strlen(nameA)),
+             airSprintSize_t(stmp[1], strlen(nameB)));
+    return 1;
+  }
+  /*
+  ** HEY: really ambivalent about not doing this check:
+  ** its unusual in Teem to not take an opportunity to do this kind
+  ** of sanity check when its available, but we don't really know the
+  ** circumstances of when this will be called, and if that includes
+  ** some interaction with hest, there may not yet have been the chance
+  ** to complete the sbp.
+  if (gageStackBlurParmCheck(aa)) {
+    biffAddf(GAGE, "%s: problem with sbp %s", me, nameA);
+    return 1;
+  }
+  if (gageStackBlurParmCheck(bb)) {
+    biffAddf(GAGE, "%s: problem with sbp %s", me, nameB);
+    return 1;
+  }
+  */
+#define CHECK(VAR, FMT)                                                 \
+  if (aa->VAR != bb->VAR) {                                             \
+    if (explain) {                                                      \
+      sprintf(explain, "%s->" #VAR "=" #FMT " != %s->" #VAR "=" #FMT,   \
+              nameA, aa->VAR, nameB,  bb->VAR);                         \
+    }                                                                   \
+    *differ = 1;                                                        \
+    return 0;                                                           \
+  }
+  CHECK(num, %u);
+  CHECK(sigmaRange[0], %.17g);
+  CHECK(sigmaRange[1], %.17g);
+  CHECK(renormalize, %d);
+  CHECK(oneDim, %d);
+  CHECK(needSpatialBlur, %d);
+  /* This is sketchy: the apparent point of the function is to see if two
+     sbp's are different.  But a big role of the function is to enable
+     leeching in meet.  And for leeching, a difference in verbose is moot */
+  /* CHECK(verbose, %d); */
+  CHECK(dgGoodSigmaMax, %.17g);
+#undef CHECK
+  if (aa->sigmaSampling != bb->sigmaSampling) {
+    if (explain) {
+      sprintf(explain, "%s->sigmaSampling=%s != %s->sigmaSampling=%s",
+              nameA, airEnumStr(gageSigmaSampling, aa->sigmaSampling),
+              nameB, airEnumStr(gageSigmaSampling, bb->sigmaSampling));
+    }
+    *differ = 1; return 0;
+  }
+  for (si=0; si<aa->num; si++) {
+    if (aa->sigma[si] != bb->sigma[si]) {
+      if (explain) {
+        sprintf(explain, "%s->sigma[%u]=%.17g != %s->sigma[%u]=%.17g",
+                nameA, si, aa->sigma[si], nameB, si, bb->sigma[si]);
+      }
+      *differ = 1; return 0;
+    }
+  }
+  if (nrrdKernelSpecCompare(aa->kspec, bb->kspec,
+                            differ, subexplain)) {
+    biffMovef(GAGE, NRRD, "%s: trouble comparing kernel specs", me);
+    return 1;
+  }
+  if (*differ) {
+    if (explain) {
+      sprintf(explain, "kernel specs different: %s", subexplain);
+    }
+    *differ = 1; return 0;
+  }
+  if (nrrdBoundarySpecCompare(aa->bspec, bb->bspec,
+                              differ, subexplain)) {
+    biffMovef(GAGE, NRRD, "%s: trouble comparing boundary specs", me);
+    return 1;
+  }
+  if (*differ) {
+    if (explain) {
+      sprintf(explain, "boundary specs different: %s", subexplain);
+    }
+    *differ = 1; return 0;
+  }
+  /* no differences so far */
+  *differ = 0;
+  return 0;
+}
+
+int
+gageStackBlurParmCopy(gageStackBlurParm *dst,
+                      const gageStackBlurParm *src) {
+  static const char me[]="gageStackBlurParmCopy";
+  int differ;
+  char explain[AIR_STRLEN_LARGE];
+
+  if (!(dst && src)) {
+    biffAddf(GAGE, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (gageStackBlurParmCheck(src)) {
+    biffAddf(GAGE, "%s: given src parm has problems", me);
+    return 1;
+  }
+  if (gageStackBlurParmSigmaSet(dst, src->num,
+                                src->sigmaRange[0], src->sigmaRange[1],
+                                src->sigmaSampling)
+      || gageStackBlurParmKernelSet(dst, src->kspec)
+      || gageStackBlurParmRenormalizeSet(dst, src->renormalize)
+      || gageStackBlurParmDgGoodSigmaMaxSet(dst, src->dgGoodSigmaMax)
+      || gageStackBlurParmBoundarySpecSet(dst, src->bspec)
+      || gageStackBlurParmNeedSpatialBlurSet(dst, src->needSpatialBlur)
+      || gageStackBlurParmVerboseSet(dst, src->verbose)
+      || gageStackBlurParmOneDimSet(dst, src->oneDim)) {
+    biffAddf(GAGE, "%s: problem setting dst parm", me);
+    return 1;
+  }
+  if (gageStackBlurParmCompare(dst, "copy", src, "original",
+                               &differ, explain)) {
+    biffAddf(GAGE, "%s: trouble assessing correctness of copy", me);
+    return 1;
+  }
+  if (differ) {
+    biffAddf(GAGE, "%s: problem: copy not equal: %s", me, explain);
+    return 1;
+  }
+  return 0;
+}
+
+int
+gageStackBlurParmSigmaSet(gageStackBlurParm *sbp, unsigned int num,
+                          double sigmaMin, double sigmaMax,
+                          int sigmaSampling) {
+  static const char me[]="gageStackBlurParmSigmaSet";
   unsigned int ii;
 
   if (!( sbp )) {
     biffAddf(GAGE, "%s: got NULL pointer", me);
     return 1;
   }
-  airFree(sbp->scale);
-  sbp->scale = NULL;
-  if (!( scaleMin < scaleMax )) {
-    biffAddf(GAGE, "%s: scaleMin %g not < scaleMax %g", me,
-             scaleMin, scaleMax);
+  airFree(sbp->sigma);
+  sbp->sigma = NULL;
+  if (!( 0 <= sigmaMin )) {
+    biffAddf(GAGE, "%s: need sigmaMin >= 0 (not %g)", me, sigmaMin);
+    return 1;
+  }
+  if (!( sigmaMin < sigmaMax )) {
+    biffAddf(GAGE, "%s: need sigmaMax %g > sigmaMin %g",
+             me, sigmaMax, sigmaMin);
+    return 1;
+  }
+  if (airEnumValCheck(gageSigmaSampling, sigmaSampling)) {
+    biffAddf(GAGE, "%s: %d is not a valid %s", me,
+             sigmaSampling, gageSigmaSampling->name);
+    return 1;
+  }
+  if (!( num >= 2 )) {
+    biffAddf(GAGE, "%s: need # scale samples >= 2 (not %u)", me, num);
     return 1;
   }
-  sbp->scale = AIR_CALLOC(num, double);
-  if (!sbp->scale) {
+  sbp->sigma = AIR_CALLOC(num, double);
+  if (!sbp->sigma) {
     biffAddf(GAGE, "%s: couldn't alloc scale for %u", me, num);
     return 1;
   }
   sbp->num = num;
+  sbp->sigmaRange[0] = sigmaMin;
+  sbp->sigmaRange[1] = sigmaMax;
+  sbp->sigmaSampling = sigmaSampling;
 
-  if (uniform) {
+  switch (sigmaSampling) {
+    double tau0, tau1, tau;
+    unsigned int sigmax;
+  case gageSigmaSamplingUniformSigma:
     for (ii=0; ii<num; ii++) {
-      sbp->scale[ii] = AIR_AFFINE(0, ii, num-1, scaleMin, scaleMax);
+      sbp->sigma[ii] = AIR_AFFINE(0, ii, num-1, sigmaMin, sigmaMax);
     }
-  } else if (!optim) {
-    double tau0, tau1, tau;
-    tau0 = gageTauOfSig(scaleMin);
-    tau1 = gageTauOfSig(scaleMax);
+    break;
+  case gageSigmaSamplingUniformTau:
+    tau0 = gageTauOfSig(sigmaMin);
+    tau1 = gageTauOfSig(sigmaMax);
     for (ii=0; ii<num; ii++) {
       tau = AIR_AFFINE(0, ii, num-1, tau0, tau1);
-      sbp->scale[ii] = gageSigOfTau(tau);
+      sbp->sigma[ii] = gageSigOfTau(tau);
     }
-  } else {
-    unsigned int sigmax;
-    sigmax = AIR_CAST(unsigned int, scaleMax);
-    if (!( 0 == scaleMin && sigmax == scaleMax )) {
-      biffAddf(GAGE, "%s: range [%g,%g] not [0,N] w/ integral N", me,
-               scaleMin, scaleMax);
+    break;
+  case gageSigmaSamplingOptimal3DL2L2:
+    sigmax = AIR_UINT(sigmaMax);
+    if (0 != sigmaMin) {
+      biffAddf(GAGE, "%s: sigmaMin %g != 0", me, sigmaMin);
       return 1;
     }
-    if (gageOptimSigSet(sbp->scale, num, sigmax)) {
-      biffAddf(GAGE, "%s: trouble w/ optimal sigmas", me);
+    if (sigmax != sigmaMax) {
+      biffAddf(GAGE, "%s: sigmaMax %g not an integer", me, sigmaMax);
       return 1;
     }
+    if (gageOptimSigSet(sbp->sigma, num, sigmax)) {
+      biffAddf(GAGE, "%s: trouble setting optimal sigmas", me);
+      return 1;
+    }
+    break;
+  default:
+    biffAddf(GAGE, "%s: sorry, sigmaSampling %s (%d) not implemented", me,
+             airEnumStr(gageSigmaSampling, sigmaSampling), sigmaSampling);
+    return 1;
+  }
+  if (sbp->verbose > 1) {
+    fprintf(stderr, "%s: %u samples in [%g,%g] via %s:\n", me,
+            num, sigmaMin, sigmaMax,
+            airEnumStr(gageSigmaSampling, sigmaSampling));
+    for (ii=0; ii<num; ii++) {
+      if (ii) {
+        fprintf(stderr, "%s:           "
+                "| deltas: %g\t               %g\n", me,
+                sbp->sigma[ii] - sbp->sigma[ii-1],
+                gageTauOfSig(sbp->sigma[ii])
+                - gageTauOfSig(sbp->sigma[ii-1]));
+      }
+      fprintf(stderr, "%s: sigma[%02u]=%g%s\t         tau=%g\n", me, ii,
+              sbp->sigma[ii], !sbp->sigma[ii] ? "     " : "",
+              gageTauOfSig(sbp->sigma[ii]));
+    }
   }
 
   return 0;
 }
 
 int
+gageStackBlurParmScaleSet(gageStackBlurParm *sbp,
+                          unsigned int num,
+                          double smin, double smax,
+                          int uniform, int optimal) {
+  static const char me[]="gageStackBlurParmScaleSet";
+  int sampling;
+
+  fprintf(stderr, "\n%s: !!! This function is deprecated; use "
+          "gageStackBlurParmSigmaSet instead !!!\n\n", me);
+  if (uniform && optimal) {
+    biffAddf(GAGE, "%s: can't have both uniform and optimal sigma sampling",
+             me);
+    return 1;
+  }
+  sampling = (uniform
+              ? gageSigmaSamplingUniformSigma
+              : (optimal
+                 ? gageSigmaSamplingOptimal3DL2L2
+                 : gageSigmaSamplingUniformTau));
+  if (gageStackBlurParmSigmaSet(sbp, num, smin, smax, sampling)) {
+    biffAddf(GAGE, "%s: trouble", me);
+    return 1;
+  }
+  return 0;
+}
+
+int
 gageStackBlurParmKernelSet(gageStackBlurParm *sbp,
-                           const NrrdKernelSpec *kspec,
-                           int renormalize) {
+                           const NrrdKernelSpec *kspec) {
   static const char me[]="gageStackBlurParmKernelSet";
 
   if (!( sbp && kspec )) {
@@ -122,6 +402,18 @@
   }
   nrrdKernelSpecNix(sbp->kspec);
   sbp->kspec = nrrdKernelSpecCopy(kspec);
+  return 0;
+}
+
+int
+gageStackBlurParmRenormalizeSet(gageStackBlurParm *sbp,
+                                int renormalize) {
+  static const char me[]="gageStackBlurParmRenormalizeSet";
+
+  if (!sbp) {
+    biffAddf(GAGE, "%s: got NULL pointer", me);
+    return 1;
+  }
   sbp->renormalize = renormalize;
   return 0;
 }
@@ -135,18 +427,57 @@
     biffAddf(GAGE, "%s: got NULL pointer", me);
     return 1;
   }
-  if (airEnumValCheck(nrrdBoundary, boundary)) {
-    biffAddf(GAGE, "%s: %d not a known %s", me,
-             boundary, nrrdBoundary->name);
+  nrrdBoundarySpecNix(sbp->bspec);
+  sbp->bspec = nrrdBoundarySpecNew();
+  sbp->bspec->boundary = boundary;
+  sbp->bspec->padValue = padValue;
+  if (nrrdBoundarySpecCheck(sbp->bspec)) {
+    biffMovef(GAGE, NRRD, "%s: problem", me);
     return 1;
   }
-  if (nrrdBoundaryPad == boundary && !AIR_EXISTS(padValue)) {
-    biffAddf(GAGE, "%s: want boundary %s but padValue %g doesn't exist", me,
-             airEnumStr(nrrdBoundary, boundary), padValue);
+  return 0;
+}
+
+int
+gageStackBlurParmBoundarySpecSet(gageStackBlurParm *sbp,
+                                 const NrrdBoundarySpec *bspec) {
+  static const char me[]="gageStackBlurParmBoundarySet";
+
+  if (!sbp) {
+    biffAddf(GAGE, "%s: got NULL pointer", me);
+    return 1;
+  }
+  nrrdBoundarySpecNix(sbp->bspec);
+  sbp->bspec = nrrdBoundarySpecCopy(bspec);
+  if (nrrdBoundarySpecCheck(sbp->bspec)) {
+    biffMovef(GAGE, NRRD, "%s: problem", me);
+    return 1;
+  }
+  return 0;
+}
+
+int
+gageStackBlurParmOneDimSet(gageStackBlurParm *sbp, int oneDim) {
+  static const char me[]="gageStackBlurParmOneDimSet";
+
+  if (!sbp) {
+    biffAddf(GAGE, "%s: got NULL pointer", me);
+    return 1;
+  }
+  sbp->oneDim = oneDim;
+  return 0;
+}
+
+int
+gageStackBlurParmNeedSpatialBlurSet(gageStackBlurParm *sbp,
+                                    int needSpatialBlur) {
+  static const char me[]="gageStackBlurParmNeedSpatialBlurSet";
+
+  if (!sbp) {
+    biffAddf(GAGE, "%s: got NULL pointer", me);
     return 1;
   }
-  sbp->boundary = boundary;
-  sbp->padValue = padValue;
+  sbp->needSpatialBlur = needSpatialBlur;
   return 0;
 }
 
@@ -163,44 +494,442 @@
 }
 
 int
-gageStackBlurParmCheck(gageStackBlurParm *sbp) {
-  static const char me[]="gageStackBlurParmCheck";
-  unsigned int ii;
+gageStackBlurParmDgGoodSigmaMaxSet(gageStackBlurParm *sbp,
+                                 double dgGoodSigmaMax) {
+  static const char me[]="gageStackBlurParmDgGoodSigmaMaxSet";
 
   if (!sbp) {
     biffAddf(GAGE, "%s: got NULL pointer", me);
     return 1;
   }
-  if (!( sbp->scale && sbp->kspec )) {
-    biffAddf(GAGE, "%s: scale and kernel aren't set", me);
+  if (!(dgGoodSigmaMax > 0)) {
+    biffAddf(GAGE, "%s: given dgGoodSigmaMax %g not > 0", me, dgGoodSigmaMax);
+    return 1;
+  }
+  sbp->dgGoodSigmaMax = dgGoodSigmaMax;
+  return 0;
+}
+
+int
+gageStackBlurParmCheck(const gageStackBlurParm *sbp) {
+  static const char me[]="gageStackBlurParmCheck";
+  unsigned int ii;
+
+  if (!sbp) {
+    biffAddf(GAGE, "%s: got NULL pointer", me);
     return 1;
   }
   if (!( sbp->num >= 2)) {
     biffAddf(GAGE, "%s: need num >= 2, not %u", me, sbp->num);
     return 1;
   }
+  if (!sbp->sigma) {
+    biffAddf(GAGE, "%s: sigma vector not allocated", me);
+    return 1;
+  }
+  if (!sbp->kspec) {
+    biffAddf(GAGE, "%s: blurring kernel not set", me);
+    return 1;
+  }
+  if (!sbp->bspec) {
+    biffAddf(GAGE, "%s: boundary specification not set", me);
+    return 1;
+  }
   for (ii=0; ii<sbp->num; ii++) {
-    if (!AIR_EXISTS(sbp->scale[ii])) {
-      biffAddf(GAGE, "%s: scale[%u] = %g doesn't exist", me, ii,
-               sbp->scale[ii]);
+    if (!AIR_EXISTS(sbp->sigma[ii])) {
+      biffAddf(GAGE, "%s: sigma[%u] = %g doesn't exist", me, ii,
+               sbp->sigma[ii]);
       return 1;
     }
     if (ii) {
-      if (!( sbp->scale[ii-1] < sbp->scale[ii] )) {
-        biffAddf(GAGE, "%s: scale[%u] = %g not < scale[%u] = %g", me,
-                 ii, sbp->scale[ii-1], ii+1, sbp->scale[ii]);
+      if (!( sbp->sigma[ii-1] < sbp->sigma[ii] )) {
+        biffAddf(GAGE, "%s: sigma[%u] = %g not < sigma[%u] = %g", me,
+                 ii, sbp->sigma[ii-1], ii+1, sbp->sigma[ii]);
         return 1;
       }
     }
   }
-  if (airEnumValCheck(nrrdBoundary, sbp->boundary)) {
-    biffAddf(GAGE, "%s: %d not a known %s", me,
-             sbp->boundary, nrrdBoundary->name);
+  /* HEY: no sanity check on kernel because there is no
+     nrrdKernelSpecCheck(), but there should be! */
+  if (nrrdBoundarySpecCheck(sbp->bspec)) {
+    biffMovef(GAGE, NRRD, "%s: problem with boundary", me);
+    return 1;
+  }
+  return 0;
+}
+
+int
+gageStackBlurParmParse(gageStackBlurParm *sbp,
+                       int extraFlags[256],
+                       char **extraParmsP,
+                       const char *_str) {
+  static const char me[]="gageStackBlurParmParse";
+  char *str, *mnmfS, *stok, *slast=NULL, *parmS, *eps;
+  int flagSeen[256];
+  double sigmaMin, sigmaMax, dggsm;
+  unsigned int sigmaNum, parmNum;
+  int haveFlags, verbose, verboseGot=AIR_FALSE, dggsmGot=AIR_FALSE,
+    sampling = AIR_FALSE, samplingGot=AIR_FALSE, E;
+  airArray *mop, *epsArr;
+  NrrdKernelSpec *kspec=NULL;
+  NrrdBoundarySpec *bspec=NULL;
+
+  if (!( sbp && _str )) {
+    biffAddf(GAGE, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (!( str = airStrdup(_str) )) {
+    biffAddf(GAGE, "%s: couldn't copy input", me);
+    return 1;
+  }
+  mop = airMopNew();
+  airMopAdd(mop, str, airFree, airMopAlways);
+  if (extraParmsP) {
+    /* start with empty string */
+    epsArr = airArrayNew(AIR_CAST(void **, &eps), NULL, sizeof(char), 42);
+    airMopAdd(mop, epsArr, (airMopper)airArrayNuke, airMopAlways);
+    airArrayLenIncr(epsArr, 1);
+    *eps = '\0';
+  } else {
+    epsArr = NULL;
+  }
+
+  /* working with assumption that '/' does not appear
+     in mnmfS <minScl>-<#smp>-<maxScl>[-<flags>] */
+  if ( (parmS = strchr(str, '/')) ) {
+    /* there are in fact parms */
+    *parmS = '\0';
+    parmS++;
+  } else {
+    parmS = NULL;
+  }
+  mnmfS = str;
+  if (!( 3 == airStrntok(mnmfS, "-") || 4 == airStrntok(mnmfS, "-") )) {
+    biffAddf(GAGE, "%s: didn't get 3 or 4 \"-\"-separated tokens in \"%s\"",
+             me, mnmfS);
+    airMopError(mop); return 1;
+  }
+  haveFlags = (4 == airStrntok(mnmfS, "-"));
+  stok = airStrtok(mnmfS, "-", &slast);
+  if (1 != sscanf(stok, "%lg", &sigmaMin)) {
+    biffAddf(GAGE, "%s: couldn't parse \"%s\" as max sigma", me, stok);
+    airMopError(mop); return 1;
+  }
+  stok = airStrtok(NULL, "-", &slast);
+  if (1 != sscanf(stok, "%u", &sigmaNum)) {
+    biffAddf(GAGE, "%s: couldn't parse \"%s\" as # scale samples", me, stok);
+    airMopError(mop); return 1;
+  }
+  stok = airStrtok(NULL, "-", &slast);
+  if (1 != sscanf(stok, "%lg", &sigmaMax)) {
+    biffAddf(GAGE, "%s: couldn't parse \"%s\" as max scale", me, stok);
+    airMopError(mop); return 1;
+  }
+  memset(flagSeen, 0, sizeof(flagSeen));
+  if (extraFlags) {
+    /* not sizeof(extraFlags) == sizeof(int*) */
+    memset(extraFlags, 0, sizeof(flagSeen));
+  }
+  if (haveFlags) {
+    char *flags, *ff;
+    /* look for various things in flags */
+    flags = airToLower(airStrdup(airStrtok(NULL, "-", &slast)));
+    airMopAdd(mop, flags, airFree, airMopAlways);
+    ff = flags;
+    while (*ff && '+' != *ff) {
+      /* '1': oneDim
+         'r': turn OFF spatial kernel renormalize
+         'u': uniform (in sigma) sampling
+         'o': optimized (3d l2l2) sampling
+         'p': need spatial blur
+      */
+      if (strchr("1ruop", *ff)) {
+        flagSeen[AIR_UCHAR(*ff)] = AIR_TRUE;
+      } else {
+        if (extraFlags) {
+          extraFlags[AIR_UCHAR(*ff)] = AIR_TRUE;
+        } else {
+          biffAddf(GAGE, "%s: got extra flag '%c' but NULL extraFlag",
+                   me, *ff);
+          airMopError(mop); return 1;
+        }
+      }
+      ff++;
+    }
+    if (flagSeen['u'] && flagSeen['o']) {
+      biffAddf(GAGE, "%s: can't have both optimal ('o') and uniform ('u') "
+               "flags set in \"%s\"", me, flags);
+      airMopError(mop); return 1;
+    }
+    if (ff && '+' == *ff) {
+      biffAddf(GAGE, "%s: sorry, can no longer indicate a derivative "
+               "normalization bias via '+' in \"%s\" in flags \"%s\"; "
+               "use \"dnbias=\" parm instead", me, ff, flags);
+      airMopError(mop); return 1;
+    }
+  }
+  if (parmS) {
+    unsigned int parmIdx;
+    char *pval, xeq[AIR_STRLEN_SMALL];
+    parmNum = airStrntok(parmS, "/");
+    for (parmIdx=0; parmIdx<parmNum; parmIdx++) {
+      if (!parmIdx) {
+        stok = airStrtok(parmS, "/", &slast);
+      } else {
+        stok = airStrtok(NULL, "/", &slast);
+      }
+      if (strcpy(xeq, "k=") && stok == strstr(stok, xeq)) {
+        pval = stok + strlen(xeq);
+        kspec = nrrdKernelSpecNew();
+        airMopAdd(mop, kspec, (airMopper)nrrdKernelSpecNix, airMopAlways);
+        if (nrrdKernelSpecParse(kspec, pval)) {
+          biffMovef(GAGE, NRRD, "%s: couldn't parse \"%s\" as blurring kernel",
+                    me, pval);
+          airMopError(mop); return 1;
+        }
+      } else if (strcpy(xeq, "b=") && strstr(stok, xeq) == stok) {
+        pval = stok + strlen(xeq);
+        bspec = nrrdBoundarySpecNew();
+        airMopAdd(mop, bspec, (airMopper)nrrdBoundarySpecNix, airMopAlways);
+        if (nrrdBoundarySpecParse(bspec, pval)) {
+          biffMovef(GAGE, NRRD, "%s: couldn't parse \"%s\" as boundary",
+                    me, pval);
+          airMopError(mop); return 1;
+        }
+      } else if (strcpy(xeq, "v=") && strstr(stok, xeq) == stok) {
+        pval = stok + strlen(xeq);
+        if (1 != sscanf(pval, "%d", &verbose)) {
+          biffAddf(GAGE, "%s: couldn't parse \"%s\" as verbose int", me, pval);
+          airMopError(mop); return 1;
+        }
+        verboseGot = AIR_TRUE;
+      } else if (strcpy(xeq, "s=") && strstr(stok, xeq) == stok) {
+        pval = stok + strlen(xeq);
+        sampling = airEnumVal(gageSigmaSampling, pval);
+        if (gageSigmaSamplingUnknown == sampling) {
+          biffAddf(GAGE, "%s: couldn't parse \"%s\" as %s", me, pval,
+                   gageSigmaSampling->name);
+          airMopError(mop); return 1;
+        }
+        samplingGot = AIR_TRUE;
+      } else if (strcpy(xeq, "dggsm=") && strstr(stok, xeq) == stok) {
+        pval = stok + strlen(xeq);
+        if (1 != sscanf(pval, "%lg", &dggsm)) {
+          biffAddf(GAGE, "%s: couldn't parse \"%s\" as dgGoodSigmaMax double",
+                   me, pval);
+          airMopError(mop); return 1;
+        }
+        dggsmGot = AIR_TRUE;
+      } else {
+        /* doesn't match any of the parms we know how to parse */
+        if (extraParmsP) {
+          airArrayLenIncr(epsArr, AIR_INT(2 + strlen(stok)));
+          if (strlen(eps)) {
+            strcat(eps, "/");
+          }
+          strcat(eps, stok);
+        } else {
+          biffAddf(GAGE, "%s: got extra parm \"%s\" but NULL extraParmsP",
+                   me, stok);
+          airMopError(mop); return 1;
+        }
+      }
+    }
+  }
+  /* have parsed everything, now error checking and making sense */
+  if (flagSeen['u'] && flagSeen['o']) {
+    biffAddf(GAGE, "%s: can't use flags 'u' and 'o' at same time", me);
+    airMopError(mop); return 1;
+  }
+  if ((flagSeen['u'] || flagSeen['o']) && samplingGot) {
+    biffAddf(GAGE, "%s: can't use both 'u','o' flags and parms to "
+             "specify sigma sampling", me);
+    airMopError(mop); return 1;
+  }
+  if (!samplingGot) {
+    /* have to set sampling from flags */
+    if (flagSeen['u']) {
+      sampling = gageSigmaSamplingUniformSigma;
+    } else if (flagSeen['o']) {
+      sampling = gageSigmaSamplingOptimal3DL2L2;
+    } else {
+      sampling = gageSigmaSamplingUniformTau;
+    }
+  }
+  /* setting sbp fields */
+  E = 0;
+  if (!E) E |= gageStackBlurParmSigmaSet(sbp, sigmaNum,
+                                         sigmaMin, sigmaMax, sampling);
+  if (kspec) {
+    if (!E) E |= gageStackBlurParmKernelSet(sbp, kspec);
+  }
+  if (flagSeen['r']) {
+    if (!E) E |= gageStackBlurParmRenormalizeSet(sbp, AIR_FALSE);
+  }
+  if (dggsmGot) {
+    if (!E) E |= gageStackBlurParmDgGoodSigmaMaxSet(sbp, dggsm);
+  }
+  if (bspec) {
+    if (!E) E |= gageStackBlurParmBoundarySpecSet(sbp, bspec);
+  }
+  if (flagSeen['p']) {
+    if (!E) E |= gageStackBlurParmNeedSpatialBlurSet(sbp, AIR_TRUE);
+  }
+  if (verboseGot) {
+    if (!E) E |= gageStackBlurParmVerboseSet(sbp, verbose);
+  }
+  if (flagSeen['1']) {
+    if (!E) E |= gageStackBlurParmOneDimSet(sbp, AIR_TRUE);
+  }
+  /* NOT doing the final check, because if this is being called from
+     hest, the caller won't have had time to set the default info in
+     the sbp (like the default kernel), so it will probably look
+     incomplete.
+     if (!E) E |= gageStackBlurParmCheck(sbp); */
+  if (E) {
+    biffAddf(GAGE, "%s: problem with blur parm specification", me);
+    airMopError(mop); return 1;
+  }
+  if (extraParmsP) {
+    if (airStrlen(eps)) {
+      *extraParmsP = airStrdup(eps);
+    } else {
+      *extraParmsP = NULL;
+    }
+  }
+  airMopOkay(mop);
+  return 0;
+}
+
+int
+gageStackBlurParmSprint(char str[AIR_STRLEN_LARGE],
+                        const gageStackBlurParm *sbp,
+                        int extraFlag[256],
+                        char *extraParm) {
+  static const char me[]="gageStackBlurParmSprint";
+  char *out, stmp[AIR_STRLEN_LARGE];
+  int needFlags, hef;
+  unsigned int fi;
+
+  if (!(str && sbp)) {
+    biffAddf(GAGE, "%s: got NULL pointer", me);
+    return 1;
+  }
+
+  out = str;
+  sprintf(out, "%.17g-%u-%.17g",
+          sbp->sigmaRange[0], sbp->num, sbp->sigmaRange[1]);
+  out += strlen(out);
+  hef = AIR_FALSE;
+  if (extraFlag) {
+    for (fi=0; fi<256; fi++) {
+      hef |= extraFlag[fi];
+    }
+  }
+  needFlags = (sbp->oneDim
+               || sbp->renormalize
+               || sbp->needSpatialBlur
+               || hef);
+  if (needFlags) {
+    strcat(out, "-");
+    if (sbp->oneDim)          { strcat(out, "1"); }
+    if (sbp->renormalize)     { strcat(out, "r"); }
+    if (sbp->needSpatialBlur) { strcat(out, "p"); }
+    if (hef) {
+      for (fi=0; fi<256; fi++) {
+        if (extraFlag[fi]) {
+          sprintf(stmp, "%c", AIR_CAST(char, fi));
+          strcat(out, stmp);
+        }
+      }
+    }
+  }
+
+  if (sbp->kspec) {
+    strcat(out, "/");
+    if (nrrdKernelSpecSprint(stmp, sbp->kspec)) {
+      biffMovef(GAGE, NRRD, "%s: problem with kernel", me);
+      return 1;
+    }
+    strcat(out, "k="); strcat(out, stmp);
+  }
+
+  if (sbp->bspec) {
+    strcat(out, "/");
+    if (nrrdBoundarySpecSprint(stmp, sbp->bspec)) {
+      biffMovef(GAGE, NRRD, "%s: problem with boundary", me);
+      return 1;
+    }
+    strcat(out, "b="); strcat(out, stmp);
+  }
+
+  if (!airEnumValCheck(gageSigmaSampling, sbp->sigmaSampling)) {
+    strcat(out, "/s=");
+    strcat(out, airEnumStr(gageSigmaSampling, sbp->sigmaSampling));
+  }
+
+  if (sbp->verbose) {
+    sprintf(stmp, "/v=%d", sbp->verbose);
+    strcat(out, stmp);
+  }
+
+  if (sbp->kspec
+      && nrrdKernelDiscreteGaussian == sbp->kspec->kernel
+      && nrrdKernelDiscreteGaussianGoodSigmaMax != sbp->dgGoodSigmaMax) {
+    sprintf(stmp, "/dggsm=%.17g", sbp->dgGoodSigmaMax);
+    strcat(out, stmp);
+  }
+
+  if (extraParm) {
+    strcat(out, "/");
+    strcat(out, extraParm);
+  }
+
+  return 0;
+}
+
+int
+_gageHestStackBlurParmParse(void *ptr, const char *str,
+                            char err[AIR_STRLEN_HUGE]) {
+  gageStackBlurParm **sbp;
+  char me[]="_gageHestStackBlurParmParse", *nerr;
+
+  if (!(ptr && str)) {
+    sprintf(err, "%s: got NULL pointer", me);
     return 1;
   }
+  sbp = (gageStackBlurParm **)ptr;
+  if (!strlen(str)) {
+    /* got an empty string; we trying to emulate an "optional"
+       command-line option, in a program that likely still has
+       the older -ssn, -ssr, -kssb, and which may or may not
+       need any scale-space functionality */
+    *sbp = NULL;
+  } else {
+    *sbp = gageStackBlurParmNew();
+    /* NOTE: no way to retrieve extraFlags or extraParms from hest */
+    if (gageStackBlurParmParse(*sbp, NULL, NULL, str)) {
+      nerr = biffGetDone(GAGE);
+      airStrcpy(err, AIR_STRLEN_HUGE, nerr);
+      gageStackBlurParmNix(*sbp);
+      free(nerr);
+      return 1;
+    }
+  }
   return 0;
 }
 
+hestCB
+_gageHestStackBlurParm = {
+  sizeof(gageStackBlurParm*),
+  "stack blur specification",
+  _gageHestStackBlurParmParse,
+  (airMopper)gageStackBlurParmNix
+};
+
+hestCB *
+gageHestStackBlurParm = &_gageHestStackBlurParm;
+
 static int
 _checkNrrd(Nrrd *const nblur[], const Nrrd *const ncheck[],
            unsigned int blNum, int checking,
@@ -229,77 +958,280 @@
   return 0;
 }
 
-#define KVP_NUM 5
+#define KVP_NUM 9
 
-static const char                      /*    0             1         2          3            4     */
-_blurKey[KVP_NUM][AIR_STRLEN_LARGE] = {"gageStackBlur", "scale", "kernel", "boundary", "renormalize"};
+static const char
+_blurKey[KVP_NUM][AIR_STRLEN_LARGE] = {/*  0  */ "gageStackBlur",
+                                       /*  1 */  "cksum",
+                                       /*  2  */ "scale",
+                                       /*  3  */ "kernel",
+                                       /*  4  */ "renormalize",
+                                       /*  5  */ "boundary",
+                                       /*  6  */ "onedim",
+                                       /*  7  */ "spatialblurred",
+#define KVP_SBLUR_IDX                      7
+                                       /*  8  */ "dgGoodSigmaMax"
+#define KVP_DGGSM_IDX                      8
+                                       /* (9 == KVP_NUM, above) */};
 
 typedef struct {
   char val[KVP_NUM][AIR_STRLEN_LARGE];
 } blurVal_t;
 
 static blurVal_t *
-_blurValAlloc(airArray *mop, gageStackBlurParm *sbp) {
+_blurValAlloc(airArray *mop, gageStackBlurParm *sbp, NrrdKernelSpec *kssb,
+              const Nrrd *nin, int spatialBlurred) {
   static const char me[]="_blurValAlloc";
   blurVal_t *blurVal;
-  unsigned int blIdx;
+  unsigned int blIdx, cksum;
 
   blurVal = AIR_CAST(blurVal_t *, calloc(sbp->num, sizeof(blurVal_t)));
   if (!blurVal) {
     biffAddf(GAGE, "%s: couldn't alloc blurVal for %u", me, sbp->num);
     return NULL;
   }
+  cksum = nrrdCRC32(nin, airEndianLittle);
+
   for (blIdx=0; blIdx<sbp->num; blIdx++) {
-    sbp->kspec->parm[0] = sbp->scale[blIdx];
+    kssb->parm[0] = sbp->sigma[blIdx];
     sprintf(blurVal[blIdx].val[0], "true");
-    sprintf(blurVal[blIdx].val[1], "%g", sbp->scale[blIdx]);
-    nrrdKernelSpecSprint(blurVal[blIdx].val[2], sbp->kspec);
-    sprintf(blurVal[blIdx].val[3], "%s", sbp->renormalize ? "true" : "false");
-    sprintf(blurVal[blIdx].val[4], "%s",
-            airEnumStr(nrrdBoundary, sbp->boundary));
+    sprintf(blurVal[blIdx].val[1], "%u", cksum);
+    sprintf(blurVal[blIdx].val[2], "%.17g", sbp->sigma[blIdx]);
+    nrrdKernelSpecSprint(blurVal[blIdx].val[3], kssb);
+    sprintf(blurVal[blIdx].val[4], "%s", sbp->renormalize ? "true" : "false");
+    nrrdBoundarySpecSprint(blurVal[blIdx].val[5], sbp->bspec);
+    sprintf(blurVal[blIdx].val[6], "%s",
+            sbp->oneDim ? "true" : "false");
+    sprintf(blurVal[blIdx].val[7], "%s",
+            spatialBlurred ? "true" : "false");
+    sprintf(blurVal[blIdx].val[8], "%.17g", sbp->dgGoodSigmaMax);
   }
   airMopAdd(mop, blurVal, airFree, airMopAlways);
   return blurVal;
 }
 
 /*
-** little helper function to do pre-blurring of a given nrrd
-** of the sort that might be useful for scale-space gage use
-**
-** nblur has to already be allocated for "blNum" Nrrd*s, AND, they all
-** have to point to valid (possibly empty) Nrrds, so they can hold the
-** results of blurring
+** some spot checks suggest that where the PSF of lindeberg-gaussian blurring
+** should be significantly non-zero, this is more accurate than the current
+** "discrete gauss" kernel, but for small values near zero, the spatial
+** blurring is more accurate.  This is due to how with limited numerical
+** precision, the FFT can produce very low amplitude noise.
 */
-int
-gageStackBlur(Nrrd *const nblur[], gageStackBlurParm *sbp,
-              const Nrrd *nin, const gageKind *kind) {
-  static const char me[]="gageStackBlur";
-  unsigned int blIdx, axi;
-  NrrdResampleContext *rsmc;
-  blurVal_t *blurVal;
+static int
+_stackBlurDiscreteGaussFFT(Nrrd *const nblur[], gageStackBlurParm *sbp,
+                           const Nrrd *nin, const gageKind *kind) {
+  static const char me[]="_stackBlurDiscreteGaussFFT";
+  size_t sizeAll[NRRD_DIM_MAX], *size, ii, xi, yi, zi, nn;
+  Nrrd *ninC, /* complex version of input, same as input type */
+    *ninFT,   /* FT of input, type double */
+    *noutFT,  /* FT of output, values set manually from ninFT, as double */
+    *noutCd,  /* complex version of output, still as double */
+    *noutC;   /* complex version of output, as input type;
+                 will convert/clamp this to get nblur[i] */
+  double (*lup)(const void *, size_t), (*ins)(void *, size_t, double),
+    *ww[3], tblur, theta, *inFT, *outFT;
+  unsigned int blIdx, axi, ftaxes[3] = {1,2,3};
   airArray *mop;
-  int E;
-  Nrrd *ntmp;
+  int axmap[NRRD_DIM_MAX];
 
-  if (!(nblur && sbp && nin && kind)) {
-    biffAddf(GAGE, "%s: got NULL pointer", me);
-    return 1;
-  }
   mop = airMopNew();
-  if (gageStackBlurParmCheck(sbp)
-      || _checkNrrd(nblur, NULL, sbp->num, AIR_FALSE, nin, kind)
-      || (!( blurVal = _blurValAlloc(mop, sbp) )) ) {
-    biffAddf(GAGE, "%s: problem", me);
+  ninC = nrrdNew();
+  airMopAdd(mop, ninC, (airMopper)nrrdNuke, airMopAlways);
+  ninFT = nrrdNew();
+  airMopAdd(mop, ninFT, (airMopper)nrrdNuke, airMopAlways);
+  noutFT = nrrdNew();
+  airMopAdd(mop, noutFT, (airMopper)nrrdNuke, airMopAlways);
+  noutCd = nrrdNew();
+  airMopAdd(mop, noutCd, (airMopper)nrrdNuke, airMopAlways);
+  noutC = nrrdNew();
+  airMopAdd(mop, noutC, (airMopper)nrrdNuke, airMopAlways);
+
+  if (gageKindScl != kind) {
+    biffAddf(GAGE, "%s: sorry, non-scalar kind not yet implemented", me);
+    /* but it really wouldn't be that hard ... */
+    airMopError(mop); return 1;
+  }
+  if (3 != nin->dim) {
+    biffAddf(GAGE, "%s: sanity check fail: nin->dim %u != 3", me, nin->dim);
     airMopError(mop); return 1;
   }
+  lup = nrrdDLookup[nin->type];
+  ins = nrrdDInsert[nin->type];
+  /* unurrdu/fft.c handles real input by doing an axis insert and then
+     padding, but that is overkill; this is a more direct way, which perhaps
+     should be migrated to unurrdu/fft.c */
+  sizeAll[0] = 2;
+  size = sizeAll + 1;
+  nrrdAxisInfoGet_nva(nin, nrrdAxisInfoSize, size);
+  if (nrrdMaybeAlloc_nva(ninC, nin->type, nin->dim+1, sizeAll)) {
+    biffMovef(GAGE, NRRD, "%s: couldn't allocate complex-valued input", me);
+    airMopError(mop); return 1;
+  }
+  for (axi=0; axi<3; axi++) {
+    if (!( ww[axi] = AIR_CALLOC(size[axi], double) )) {
+      biffAddf(GAGE, "%s: couldn't allocate axis %u buffer", me, axi);
+      airMopError(mop); return 1;
+    }
+    airMopAdd(mop, ww[axi], airFree, airMopAlways);
+  }
+  nn = size[0]*size[1]*size[2];
+  for (ii=0; ii<nn; ii++) {
+    ins(ninC->data, 0 + 2*ii, lup(nin->data, ii));
+    ins(ninC->data, 1 + 2*ii, 0.0);
+  }
+  for (axi=0; axi<4; axi++) {
+    if (!axi) {
+      axmap[axi] = -1;
+    } else {
+      axmap[axi] = axi-1;
+    }
+  }
+  if (nrrdAxisInfoCopy(ninC, nin, axmap, NRRD_AXIS_INFO_NONE)
+      || nrrdBasicInfoCopy(ninC, nin,
+                           (NRRD_BASIC_INFO_DATA_BIT |
+                            NRRD_BASIC_INFO_DIMENSION_BIT |
+                            NRRD_BASIC_INFO_CONTENT_BIT |
+                            NRRD_BASIC_INFO_COMMENTS_BIT |
+                            NRRD_BASIC_INFO_KEYVALUEPAIRS_BIT))) {
+    biffMovef(GAGE, NRRD, "%s: couldn't set complex-valued axinfo", me);
+    airMopError(mop); return 1;
+  }
+  ninC->axis[0].kind = nrrdKindComplex; /* should use API */
+  /*
+  nrrdSave("ninC.nrrd", ninC, NULL);
+  */
+  /* the copy to noutFT is just to allocate it; the values
+     there will be re-written over and over in the loop below */
+  if (nrrdFFT(ninFT, ninC, ftaxes, 3,
+              +1 /* forward */,
+              AIR_TRUE /* rescale */,
+              nrrdFFTWPlanRigorEstimate /* should generalize! */)
+      || nrrdCopy(noutFT, ninFT)) {
+    biffMovef(GAGE, NRRD, "%s: trouble with initial transforms", me);
+    airMopError(mop); return 1;
+  }
+  /*
+  nrrdSave("ninFT.nrrd", ninFT, NULL);
+  */
+  inFT = AIR_CAST(double *, ninFT->data);
+  outFT = AIR_CAST(double *, noutFT->data);
+  for (blIdx=0; blIdx<sbp->num; blIdx++) {
+    if (sbp->verbose) {
+      fprintf(stderr, "%s: . . . %u/%u (scale %g, tau %g) . . . ", me,
+              blIdx, sbp->num, sbp->sigma[blIdx],
+              gageTauOfSig(sbp->sigma[blIdx]));
+      fflush(stderr);
+    }
+    tblur = sbp->sigma[blIdx]*sbp->sigma[blIdx];
+    for (axi=0; axi<3; axi++) {
+      for (ii=0; ii<size[axi]; ii++) {
+        theta = AIR_AFFINE(0, ii, size[axi], 0.0, 2*AIR_PI);
+        /* from eq (22) of T. Lindeberg "Scale-Space for Discrete
+           Signals", IEEE PAMI 12(234-254); 1990 */
+        ww[axi][ii] = exp(tblur*(cos(theta)-1.0));
+        /*
+        fprintf(stderr, "!%s: ww[%u][%u] = %g\n", me, axi,
+                AIR_UINT(ii), ww[axi][ii]);
+        */
+      }
+    }
+    ii=0;
+    /*
+    for (axi=0; axi<3; axi++) {
+      fprintf(stderr, "!%s: size[%u] = %u\n", me, axi,
+              AIR_UINT(size[axi]));
+    }
+    */
+    for (zi=0; zi<size[2]; zi++) {
+      for (yi=0; yi<size[1]; yi++) {
+        for (xi=0; xi<size[0]; xi++) {
+          double wght;
+          wght = sbp->oneDim ? 1.0 : ww[1][yi]*ww[2][zi];
+          wght *= ww[0][xi];
+          outFT[0 + 2*ii] = wght*inFT[0 + 2*ii];
+          outFT[1 + 2*ii] = wght*inFT[1 + 2*ii];
+          /*
+          fprintf(stderr, "!%s: out[%u] = (%g,%g) = %g * (%g,%g)\n", me,
+                  AIR_UINT(ii),
+                  outFT[0 + 2*ii], outFT[1 + 2*ii],
+                  wght,
+                  inFT[0 + 2*ii], inFT[1 + 2*ii]);
+          */
+          ii++;
+        }
+      }
+    }
+    if (nrrdFFT(noutCd, noutFT, ftaxes, 3,
+                -1 /* backward */,
+                AIR_TRUE /* rescale */,
+                nrrdFFTWPlanRigorEstimate /* should generalize! */)
+        || (nrrdTypeDouble == nin->type
+            ? nrrdCopy(noutC, noutCd)
+            : nrrdCastClampRound(noutC, noutCd, nin->type,
+                                 AIR_TRUE /* clamp */,
+                                 +1 /* roundDir, when needed */))
+        || nrrdSlice(nblur[blIdx], noutC, 0, 0)
+        || nrrdContentSet_va(nblur[blIdx], "blur", nin, "")) {
+      biffMovef(GAGE, NRRD, "%s: trouble with back transform %u", me, blIdx);
+      airMopError(mop); return 1;
+    }
+    if (sbp->verbose) {
+      fprintf(stderr, "done\n");
+    }
+    /*
+    if (0) {
+      char fname[AIR_STRLEN_SMALL];
+      sprintf(fname, "noutFT-%03u.nrrd", blIdx);
+      nrrdSave(fname, noutFT, NULL);
+      sprintf(fname, "noutCd-%03u.nrrd", blIdx);
+      nrrdSave(fname, noutCd, NULL);
+      sprintf(fname, "noutC-%03u.nrrd", blIdx);
+      nrrdSave(fname, noutC, NULL);
+      sprintf(fname, "nblur-%03u.nrrd", blIdx);
+      nrrdSave(fname, nblur[blIdx], NULL);
+    }
+    */
+  }
+
+  airMopOkay(mop);
+  return 0;
+}
+
+static int
+_stackBlurSpatial(Nrrd *const nblur[], gageStackBlurParm *sbp,
+                  NrrdKernelSpec *kssb,
+                  const Nrrd *nin, const gageKind *kind) {
+  static const char me[]="_stackBlurSpatial";
+  NrrdResampleContext *rsmc;
+  Nrrd *niter;
+  unsigned int axi, blIdx;
+  int E, iterative, rsmpType;
+  double timeStepMax, /* max length of diffusion time allowed per blur,
+                         as determined by sbp->dgGoodSigmaMax */
+    timeDone,         /* amount of diffusion time just applied */
+    timeLeft;         /* amount of diffusion time left to do */
+  airArray *mop;
+
+  mop = airMopNew();
   rsmc = nrrdResampleContextNew();
   airMopAdd(mop, rsmc, (airMopper)nrrdResampleContextNix, airMopAlways);
-  /* may or may not be needed for iterative diffusion */
-  ntmp = nrrdNew();
-  airMopAdd(mop, ntmp, (airMopper)nrrdNuke, airMopAlways);
+  if (nrrdKernelDiscreteGaussian == kssb->kernel) {
+    iterative = AIR_TRUE;
+    /* we don't want to lose precision when iterating */
+    rsmpType = nrrdResample_nt;
+    /* may be used with iterative diffusion */
+    niter = nrrdNew();
+    airMopAdd(mop, niter, (airMopper)nrrdNuke, airMopAlways);
+  } else {
+    iterative = AIR_FALSE;
+    rsmpType = nrrdTypeDefault;
+    niter = NULL;
+  }
 
   E = 0;
   if (!E) E |= nrrdResampleDefaultCenterSet(rsmc, nrrdDefaultCenter);
+  /* the input for the first scale is indeed nin, regardless
+     of iterative */
   if (!E) E |= nrrdResampleInputSet(rsmc, nin);
   if (kind->baseDim) {
     unsigned int bai;
@@ -312,68 +1244,117 @@
                                         nin->axis[kind->baseDim + axi].size);
     if (!E) E |= nrrdResampleRangeFullSet(rsmc, kind->baseDim + axi);
   }
-  if (!E) E |= nrrdResampleBoundarySet(rsmc, sbp->boundary);
-  if (!E) E |= nrrdResampleTypeOutSet(rsmc, nrrdTypeDefault);
+  if (!E) E |= nrrdResampleBoundarySpecSet(rsmc, sbp->bspec);
+  if (!E) E |= nrrdResampleTypeOutSet(rsmc, rsmpType);
+  if (!E) E |= nrrdResampleClampSet(rsmc, AIR_TRUE); /* probably moot */
   if (!E) E |= nrrdResampleRenormalizeSet(rsmc, sbp->renormalize);
   if (E) {
     biffAddf(GAGE, "%s: trouble setting up resampling", me);
     airMopError(mop); return 1;
   }
 
+  timeDone = 0;
+  timeStepMax = (sbp->dgGoodSigmaMax)*(sbp->dgGoodSigmaMax);
   for (blIdx=0; blIdx<sbp->num; blIdx++) {
-    unsigned int kvpIdx;
     if (sbp->verbose) {
-      fprintf(stderr, "%s: blurring %u / %u (scale %g) ... ", me, blIdx,
-              sbp->num, sbp->scale[blIdx]);
+      fprintf(stderr, "%s: . . . blurring %u / %u (scale %g) . . . ",
+              me, blIdx, sbp->num, sbp->sigma[blIdx]);
       fflush(stderr);
     }
-    if (nrrdKernelDiscreteGaussian == sbp->kspec->kernel
-        && sbp->scale[blIdx] > sbp->sigmaMax) {
-      double timeLeft, /* amount of diffusion time left to do */
-        timeStep,      /* length of diffusion time per blur */
-        timeDo;        /* amount of diffusion time just applied */
+    if (iterative) {
+      double timeNow = sbp->sigma[blIdx]*sbp->sigma[blIdx];
       unsigned int passIdx = 0;
-      timeLeft = sbp->scale[blIdx]*sbp->scale[blIdx];
-      timeStep = (sbp->sigmaMax)*(sbp->sigmaMax);
+      timeLeft = timeNow - timeDone;
       if (sbp->verbose) {
         fprintf(stderr, "\n");
-        fprintf(stderr, "%s: scale %g > sigmaMax %g\n", me,
-                sbp->scale[blIdx], sbp->sigmaMax);
-        fprintf(stderr, "%s: diffusing for time %g in steps of %g\n", me,
-                timeLeft, timeStep);
+        fprintf(stderr, "%s: scale %g == time %g (tau %g);\n"
+                "               timeLeft %g = %g - %g\n",
+                me, sbp->sigma[blIdx], timeNow, gageTauOfTee(timeNow),
+                timeLeft, timeNow, timeDone);
+        if (timeLeft > timeStepMax) {
+          fprintf(stderr, "%s: diffusing for time %g in steps of %g\n", me,
+                  timeLeft, timeStepMax);
+        }
         fflush(stderr);
       }
       do {
-        if (!passIdx) {
-          if (!E) E |= nrrdResampleInputSet(rsmc, nin);
-        } else {
-          if (!E) E |= nrrdResampleInputSet(rsmc, ntmp);
+        double timeDo;
+        if (blIdx || passIdx) {
+          /* either we're past the first scale (blIdx >= 1), or
+             (unlikely) we're on the first scale but after the first
+             pass of a multi-pass blurring, so we have to feed the
+             previous result back in as input.
+             AND: the way that niter is being used is very sneaky,
+             and probably too clever: the resampling happens in
+             multiple passes, among buffers internal to nrrdResample;
+             so its okay have the output and input nrrds be the same:
+             they're never used at the same time. */
+          if (!E) E |= nrrdResampleInputSet(rsmc, niter);
         }
-        timeDo = (timeLeft > timeStep
-                  ? timeStep
+        timeDo = (timeLeft > timeStepMax
+                  ? timeStepMax
                   : timeLeft);
-        sbp->kspec->parm[0] = sqrt(timeDo);
+        /* it is the repeated re-setting of this parm[0] which motivated
+           copying to our own kernel spec, so that the given one in the
+           gageStackBlurParm can stay untouched */
+        kssb->parm[0] = sqrt(timeDo);
         for (axi=0; axi<3; axi++) {
-          if (!E) E |= nrrdResampleKernelSet(rsmc, kind->baseDim + axi,
-                                             sbp->kspec->kernel,
-                                             sbp->kspec->parm);
+          if (!sbp->oneDim || !axi) {
+            /* we set the blurring kernel on this axis if
+               we are NOT doing oneDim, or, we are,
+               but this is axi == 0 */
+            if (!E) E |= nrrdResampleKernelSet(rsmc, kind->baseDim + axi,
+                                               kssb->kernel,
+                                               kssb->parm);
+          } else {
+            /* what to do with oneDom on axi 1, 2 */
+            /* you might think that we should just do no resampling at all
+               on this axis, but that would undermine the in==out==niter
+               trick described above; and produce the mysterious behavior
+               that the second scale-space volume is all 0.0 */
+            double boxparm[NRRD_KERNEL_PARMS_NUM] = {1.0};
+            if (!E) E |= nrrdResampleKernelSet(rsmc, kind->baseDim + axi,
+                                               nrrdKernelBox, boxparm);
+          }
         }
         if (sbp->verbose) {
-          fprintf(stderr, "  pass %u (timeLeft=%g => time=%g, sigma=%g) ...\n",
-                  passIdx, timeLeft, timeDo, sbp->kspec->parm[0]);
+          fprintf(stderr, "  pass %u (timeLeft=%g => "
+                  "time=%g, sigma=%g) ...\n",
+                  passIdx, timeLeft, timeDo, kssb->parm[0]);
         }
-        if (!E) E |= nrrdResampleExecute(rsmc, ntmp);
+        if (!E) E |= nrrdResampleExecute(rsmc, niter);
+        /* for debugging problem with getting zero output
+        if (!E) {
+          NrrdRange *nrange;
+          nrange = nrrdRangeNewSet(niter, AIR_FALSE);
+          fprintf(stderr, "%s: min/max = %g/%g\n", me,
+                  nrange->min, nrange->max);
+          if (!nrange->min || !nrange->max) {
+            fprintf(stderr, "%s: what? zero zero\n", me);
+            biffAddf(GAGE, "%s: no good", me);
+            airMopError(mop); return 1;
+          }
+        }
+        */
         timeLeft -= timeDo;
         passIdx++;
       } while (!E && timeLeft > 0.0);
-      if (!E) E |= nrrdCopy(nblur[blIdx], ntmp);
-    } else {
-      /* do blurring in one shot as usual */
-      sbp->kspec->parm[0] = sbp->scale[blIdx];
-      for (axi=0; axi<3; axi++) {
+      /* at this point we have to replicate the behavior of the
+         last stage of resampling (e.g. _nrrdResampleOutputUpdate
+         in nrrd/resampleContext.c), since we've gently hijacked
+         the resampling to access the nrrdResample_t blurring
+         result (for further blurring) */
+      if (!E) E |= nrrdCastClampRound(nblur[blIdx], niter, nin->type,
+                                      AIR_TRUE,
+                                      nrrdTypeIsIntegral[nin->type]);
+      if (!E) E |= nrrdContentSet_va(nblur[blIdx], "blur", nin, "");
+      timeDone = timeNow;
+    } else { /* do blurring in one shot */
+      kssb->parm[0] = sbp->sigma[blIdx];
+      for (axi=0; axi<(sbp->oneDim ? 1u : 3u); axi++) {
         if (!E) E |= nrrdResampleKernelSet(rsmc, kind->baseDim + axi,
-                                           sbp->kspec->kernel,
-                                           sbp->kspec->parm);
+                                           kssb->kernel,
+                                           kssb->parm);
       }
       if (!E) E |= nrrdResampleExecute(rsmc, nblur[blIdx]);
     }
@@ -381,19 +1362,112 @@
       if (sbp->verbose) {
         fprintf(stderr, "problem!\n");
       }
-      biffAddf(GAGE, "%s: trouble w/ %u of %u (scale %g)",
-               me, blIdx, sbp->num, sbp->scale[blIdx]);
+      biffMovef(GAGE, NRRD, "%s: trouble w/ %u of %u (scale %g)",
+                me, blIdx, sbp->num, sbp->sigma[blIdx]);
       airMopError(mop); return 1;
     }
     if (sbp->verbose) {
-      fprintf(stderr, "done.\n");
+      fprintf(stderr, "  done.\n");
+    }
+  } /* for blIdx */
+
+  airMopOkay(mop);
+  return 0;
+}
+
+/*
+** little helper function to do pre-blurring of a given nrrd
+** of the sort that might be useful for scale-space gage use
+**
+** nblur has to already be allocated for "blNum" Nrrd*s, AND, they all
+** have to point to valid (possibly empty) Nrrds, so they can hold the
+** results of blurring
+*/
+int
+gageStackBlur(Nrrd *const nblur[], gageStackBlurParm *sbp,
+              const Nrrd *nin, const gageKind *kind) {
+  static const char me[]="gageStackBlur";
+  unsigned int blIdx, kvpIdx;
+  NrrdKernelSpec *kssb;
+  blurVal_t *blurVal;
+  airArray *mop;
+  int E, fftable, spatialBlurred;
+
+  if (!(nblur && sbp && nin && kind)) {
+    biffAddf(GAGE, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (gageStackBlurParmCheck(sbp)) {
+    biffAddf(GAGE, "%s: problem with parms", me);
+    return 1;
+  }
+  if (_checkNrrd(nblur, NULL, sbp->num, AIR_FALSE, nin, kind)) {
+    biffAddf(GAGE, "%s: problem with input ", me);
+    return 1;
+  }
+  mop = airMopNew();
+  kssb = nrrdKernelSpecCopy(sbp->kspec);
+  airMopAdd(mop, kssb, (airMopper)nrrdKernelSpecNix, airMopAlways);
+  /* see if we can use FFT-based implementation */
+  fftable = (!sbp->needSpatialBlur
+             && nrrdBoundaryWrap == sbp->bspec->boundary
+             && nrrdKernelDiscreteGaussian == sbp->kspec->kernel);
+  if (fftable && nrrdFFTWEnabled) {
+    /* go directly to FFT-based blurring */
+    if (_stackBlurDiscreteGaussFFT(nblur, sbp, nin, kind)) {
+      biffAddf(GAGE, "%s: trouble with frequency-space blurring", me);
+      airMopError(mop); return 1;
+    }
+    spatialBlurred = AIR_FALSE;
+  } else { /* else either not fft-able, or not it was, but not available;
+              in either case we have to do spatial blurring */
+    if (fftable && !nrrdFFTWEnabled) {
+      if (sbp->verbose) {
+        fprintf(stderr, "%s: NOTE: FFT-based blurring applicable but not "
+                "available in this Teem build (not built with FFTW)\n", me);
+      }
+    } else {
+      if (sbp->verbose) {
+        char kstr[AIR_STRLEN_LARGE], bstr[AIR_STRLEN_LARGE];
+        nrrdKernelSpecSprint(kstr, kssb);
+        nrrdBoundarySpecSprint(bstr, sbp->bspec);
+        fprintf(stderr, "%s: (FFT-based blurring not applicable: "
+                "need spatial blur=%s, boundary=%s, kernel=%s)\n", me,
+                sbp->needSpatialBlur ? "yes" : "no", bstr, kstr);
+      }
     }
-    /* add the KVPs to document how these were blurred */
+    if (_stackBlurSpatial(nblur, sbp, kssb, nin, kind)) {
+      biffAddf(GAGE, "%s: trouble with spatial-domain blurring", me);
+      airMopError(mop); return 1;
+    }
+    spatialBlurred = AIR_TRUE;
+  }
+  /* add the KVPs to document how these were blurred */
+  if (!( blurVal = _blurValAlloc(mop, sbp, kssb, nin, spatialBlurred) )) {
+    biffAddf(GAGE, "%s: problem getting KVP buffer", me);
+    airMopError(mop); return 1;
+  }
+  E = 0;
+  for (blIdx=0; blIdx<sbp->num; blIdx++) {
     for (kvpIdx=0; kvpIdx<KVP_NUM; kvpIdx++) {
-      if (!E) E |= nrrdKeyValueAdd(nblur[blIdx], _blurKey[kvpIdx],
-                                   blurVal[blIdx].val[kvpIdx]);
+      if (KVP_DGGSM_IDX != kvpIdx) {
+        if (!E) E |= nrrdKeyValueAdd(nblur[blIdx], _blurKey[kvpIdx],
+                                     blurVal[blIdx].val[kvpIdx]);
+      } else {
+        /* only need to save dgGoodSigmaMax if it was spatially blurred
+           with the discrete gaussian kernel */
+        if (spatialBlurred
+            && nrrdKernelDiscreteGaussian == kssb->kernel) {
+          if (!E) E |= nrrdKeyValueAdd(nblur[blIdx], _blurKey[kvpIdx],
+                                       blurVal[blIdx].val[kvpIdx]);
+        }
+      }
     }
   }
+  if (E) {
+    biffMovef(GAGE, NRRD, "%s: trouble adding KVPs", me);
+    airMopError(mop); return 1;
+  }
 
   airMopOkay(mop);
   return 0;
@@ -404,11 +1478,6 @@
 **
 ** (docs)
 **
-** on why sbp->dataCheck should be non-zero: really need to check that
-** the data values themselves are correct; its too dangerous to have
-** this unchecked, because it means that experimental changes in
-** volumes could mysteriously have no effect, because the cached
-** pre-blurred volumes from the old data are being re-used
 */
 int
 gageStackBlurCheck(const Nrrd *const nblur[],
@@ -419,15 +1488,21 @@
   blurVal_t *blurVal;
   airArray *mop;
   unsigned int blIdx, kvpIdx;
+  NrrdKernelSpec *kssb;
 
   if (!(nblur && sbp && nin && kind)) {
     biffAddf(GAGE, "%s: got NULL pointer", me);
     return 1;
   }
   mop = airMopNew();
+  kssb = nrrdKernelSpecCopy(sbp->kspec);
+  airMopAdd(mop, kssb, (airMopper)nrrdKernelSpecNix, airMopAlways);
   if (gageStackBlurParmCheck(sbp)
       || _checkNrrd(NULL, nblur, sbp->num, AIR_TRUE, nin, kind)
-      || (!( blurVal = _blurValAlloc(mop, sbp) )) ) {
+      || (!( blurVal = _blurValAlloc(mop, sbp, kssb, nin,
+                                     (sbp->needSpatialBlur
+                                      ? AIR_TRUE
+                                      : AIR_FALSE)) )) ) {
     biffAddf(GAGE, "%s: problem", me);
     airMopError(mop); return 1;
   }
@@ -455,43 +1530,52 @@
                me, blIdx);
       airMopError(mop); return 1;
     }
-    /* see if the KVPs are already there */
+    /* see if the KVPs are there with the required values */
     for (kvpIdx=0; kvpIdx<KVP_NUM; kvpIdx++) {
       char *tmpval;
       tmpval = nrrdKeyValueGet(nblur[blIdx], _blurKey[kvpIdx]);
-      if (!tmpval) {
-        biffAddf(GAGE, "%s: didn't see key \"%s\" in nblur[%u]", me,
-                 _blurKey[kvpIdx], blIdx);
-        airMopError(mop); return 1;
-      }
       airMopAdd(mop, tmpval, airFree, airMopAlways);
-      if (strcmp(tmpval, blurVal[blIdx].val[kvpIdx])) {
-        biffAddf(GAGE, "%s: found key[%s] \"%s\" != wanted \"%s\"", me,
-                 _blurKey[kvpIdx], tmpval, blurVal[blIdx].val[kvpIdx]);
-        airMopError(mop); return 1;
-      }
-    }
-  }
-  if (sbp->dataCheck) {
-    double (*lup)(const void *, size_t), vin, vbl;
-    size_t II, NN;
-    if (!(0.0 == sbp->scale[0])) {
-      biffAddf(GAGE, "%s: sorry, dataCheck w/ scale[0] %g "
-               "!= 0.0 not implemented", me, sbp->scale[0]);
-      airMopError(mop); return 1;
-      /* so the non-zero return here will be acted upon as though there
-         was a difference between the desired and the current stack,
-         so things will be recomputed, which is conservative but costly */
-    }
-    lup = nrrdDLookup[nin->type];
-    NN = nrrdElementNumber(nin);
-    for (II=0; II<NN; II++) {
-      vin = lup(nin->data, II);
-      vbl = lup(nblur[0]->data, II);
-      if (vin != vbl) {
-        biffAddf(GAGE, "%s: value[%u] in nin %g != in nblur[0] %g\n", me,
-                 AIR_CAST(unsigned int, II), vin, vbl);
-        airMopError(mop); return 1;
+      if (KVP_DGGSM_IDX != kvpIdx) {
+        if (!tmpval) {
+          biffAddf(GAGE, "%s: didn't see key \"%s\" in nblur[%u]", me,
+                   _blurKey[kvpIdx], blIdx);
+          airMopError(mop); return 1;
+        }
+        if (KVP_SBLUR_IDX == kvpIdx) {
+          /* this KVP is handled differently */
+          if (!sbp->needSpatialBlur) {
+            /* we don't care if it was frequency-domain or spatial-domain
+               blurring, so there's no right answer */
+            continue;
+          }
+          /* else we do need spatial domain blurring; so do the check below */
+        }
+        if (strcmp(tmpval, blurVal[blIdx].val[kvpIdx])) {
+          biffAddf(GAGE, "%s: found key[%s] \"%s\" != wanted \"%s\"", me,
+                   _blurKey[kvpIdx], tmpval, blurVal[blIdx].val[kvpIdx]);
+          airMopError(mop); return 1;
+        }
+      } else {
+        /* KVP_DGGSM_IDX == kvpIdx; handled differently since KVP isn't saved
+           when not needed */
+        if (!sbp->needSpatialBlur) {
+          /* if you don't care about needing spatial blurring, you
+             lose the right to care about a difference in dggsm */
+          continue;
+        }
+        if (tmpval) {
+          /* therefore it was spatially blurred, so there's a saved DGGSM,
+             and we do need spatial blurring, so we compare them */
+          if (strcmp(tmpval, blurVal[blIdx].val[kvpIdx])) {
+            biffAddf(GAGE, "%s: found key[%s] \"%s\" != wanted \"%s\"", me,
+                     _blurKey[kvpIdx], tmpval, blurVal[blIdx].val[kvpIdx]);
+            /* HEY: a change in the discrete Gaussian cut-off will result
+               in a recomputation of the blurrings, even with FFT-based
+               blurring, though cut-off is completely moot then */
+            airMopError(mop); return 1;
+          }
+        }
+        continue;
       }
     }
   }
@@ -510,6 +1594,7 @@
   int recompute;
   unsigned int ii;
 
+
   if (!( nblur && sbp && nin && kind )) {
     biffAddf(GAGE, "%s: got NULL pointer", me);
     return 1;
diff --color -ruN teem-1.11.0-src.orig/src/gage/stack.c teem-1.11.0-src/src/gage/stack.c
--- teem-1.11.0-src.orig/src/gage/stack.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/stack.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -24,103 +24,6 @@
 #include "gage.h"
 #include "privateGage.h"
 
-/*
-** based on: T. Lindeberg. "Effective Scale: A Natural Unit For
-** Measuring Scale-Space Lifetime" IEEE PAMI, 15:1068-1074 (1993)
-**
-** which includes tau(tee) as equation (29),
-** here taking A'' == 0 and B'' == 1, with
-** a0 and a1 as defined by eqs (22) and (23)
-**
-** Used MiniMaxApproximation[] from Mathematica to get functions, but
-** the specific functions and their domains could certainly be
-** improved upon.  Also, the absence of conversions directly between
-** tau and sigma is quite unfortunate: going through tee loses
-** precision and takes more time.
-*/
-double
-gageTauOfTee(double tee) {
-  double tau;
-
-  if (tee < 0) {
-    tau = 0;
-  } else if (tee < 1.49807) {
-    /* mmtau0tweaked */
-    tau = (tee*(0.2756644487429131 + tee*(0.10594329088466668 + tee*(0.05514331911165778 + (0.021449249669475232 + 0.004417835440932558*tee)*tee))))/
-      (1.0 + tee*(-0.08684532328108877 + tee*(0.1792830876099199 + tee*(0.07468999631784223 + (0.012123550696192354 + 0.0021535864222409365*tee)*tee))));
-  } else if (tee < 4.96757) {
-    /* mmtau1 */
-    tau = (0.0076145275813930356 + tee*(0.24811886965997867 + tee*(0.048329025380584194 +
-                                                                   tee*(0.04227260554167517 + (0.0084221516844712 + 0.0092075782656669*tee)*tee))))/
-      (1.0 + tee*(-0.43596678272093764 + tee*(0.38077975530585234 + tee*(-0.049133766853683175 + (0.030319379462443567 + 0.0034126333151669654*tee)*tee))));
-  } else if (tee < 15.4583) {
-    /* mmtau2 */
-    tau = (-0.2897145176074084 + tee*(1.3527948686285203 + tee*(-0.47099157589904095 +
-           tee*(-0.16031981786376195 + (-0.004820970155881798 - 4.149777202275125e-6*tee)*tee))))/
-      (1.0 + tee*(0.3662508612514773 + tee*(-0.5357849572367938 + (-0.0805122462310566 - 0.0015558889784971902*tee)*tee)));
-  } else if (tee < 420.787) {
-    /* mmtau3 */
-    tau = (-4.2037874383990445e9 + tee*(2.838805157541766e9 + tee*(4.032410315406513e8 + tee*(5.392017876788518e6 + tee*(9135.49750298428 + tee)))))/
-      (tee*(2.326563899563907e9 + tee*(1.6920560224321905e8 + tee*(1.613645012626063e6 + (2049.748257887103 + 0.1617034516398788*tee)*tee))));
-  } else {
-    /* lindtau = eq (33) in paper */
-    tau = 0.53653222368715360118 + log(tee)/2.0 + log(1.0 - 1.0/(8.0*tee));
-  }
-  return tau;
-}
-
-double
-gageTeeOfTau(double tau) {
-  double tee;
-
-  /* the number of branches here is not good; needs re-working */
-  if (tau < 0) {
-    tee = 0;
-  } else if (tau < 0.611262) {
-    /* mmtee0tweaked */
-    tee = (tau*(3.6275987317285265 + tau*(11.774700160760132 + tau*(4.52406587856803 + tau*(-14.125688866786549 + tau*(-0.725387283317479 + 3.5113122862478865*tau))))))/
-      (1.0 + tau*(4.955066250765395 + tau*(4.6850073321973404 + tau*(-6.407987550661679 + tau*(-6.398430668865182 + 5.213709282093169*tau)))));
-  } else if (tau < 1.31281) {
-    /* mmtee1 */
-    tee = (1.9887378739371435e49 + tau*(-2.681749984485673e50 + tau*(-4.23360463718195e50 + tau*(2.09694591123974e51 + tau*(-2.7561518523389087e51 + (1.661629137055526e51 - 4.471073383223687e50*tau)*tau)))))/
-      (1.0 + tau*(-5.920734745050949e50 + tau*(1.580953446553531e51 + tau*(-1.799463907469813e51 + tau*(1.0766702953985062e51 + tau*(-3.57278667155516e50 + 5.008335824520649e49*tau))))));
-  } else if (tau < 1.64767) {
-    /* mmtee2 */
-    tee = (7.929177830383403 + tau*(-26.12773195115971 + tau*(40.13296225515305 + tau*(-25.041659428733585 + 11.357596970027744*tau))))/
-      (1.0 + tau*(-2.3694595653302377 + tau*(7.324354882915464 + (-3.5335141717471314 + 0.4916661013041915*tau)*tau)));
-  } else if (tau < 1.88714) {
-    /* mmtee3 */
-    tee = (0.8334252264680793 + tau*(-0.2388940380698891 + (0.6057616935583752 - 0.01610044688317929*tau)*tau))/(1.0 + tau*(-0.7723301124908083 + (0.21283962841683607 - 0.020834957466407206*tau)*tau));
-  } else if (tau < 2.23845) {
-    /* mmtee4 */
-    tee = (0.6376900379835665 + tau*(0.3177131886056259 + (0.1844114646774132 + 0.2001613331260136*tau)*tau))/(1.0 + tau*(-0.6685635461372561 + (0.15860524381878136 - 0.013304300252332686*tau)*tau));
-  } else if (tau < 2.6065) {
-    /* mmtee5 */
-    tee = (1.3420027677612982 + (-0.939215712453483 + 0.9586140009249253*tau)*tau)/(1.0 + tau*(-0.6923014141351673 + (0.16834190074776287 - 0.014312833444962668*tau)*tau));
-  } else if (tau < 3.14419) {
-    /* mmtee6 */
-    tee = (tau*(190.2181493338235 + tau*(-120.16652155353106 + 60.*tau)))/(76.13355144582292 + tau*(-42.019121363472614 + (8.023304636521623 - 0.5281725039404653*tau)*tau));
-  } else {
-    /* lindtee = lindtau^{-1} */
-    double ee;
-    ee = exp(2.0*tau);
-    tee = 0.0063325739776461107152*(27.0*ee + 2*AIR_PI*AIR_PI + 3.0*sqrt(81.0*ee*ee + 12*ee*AIR_PI*AIR_PI));
-  }
-  return tee;
-}
-
-double
-gageSigOfTau(double tau) {
-
-  return sqrt(gageTeeOfTau(tau));
-}
-
-double
-gageTauOfSig(double sig) {
-
-  return gageTauOfTee(sig*sig);
-}
-
 double
 gageStackWtoI(gageContext *ctx, double swrl, int *outside) {
   double si;
@@ -172,7 +75,7 @@
       sidx = ctx->pvlNum-3;
       *outside = AIR_TRUE;
     } else {
-      sidx = AIR_CAST(unsigned int, si);
+      sidx = AIR_UINT(si);
       *outside = AIR_FALSE;
     }
     sfrac = si - sidx;
@@ -284,9 +187,9 @@
   ctx->stackFw = AIR_CALLOC(blNum, double);
   if (!( ctx->stackPos && ctx->stackFsl && ctx->stackFw )) {
     biffAddf(GAGE, "%s: couldn't allocate stack buffers (%p %p %p)", me,
-             AIR_CAST(void *, ctx->stackPos),
-             AIR_CAST(void *, ctx->stackFsl),
-             AIR_CAST(void *, ctx->stackFw));
+             AIR_VOIDP(ctx->stackPos),
+             AIR_VOIDP(ctx->stackFsl),
+             AIR_VOIDP(ctx->stackFw));
     return 1;
   }
   for (blIdx=0; blIdx<blNum; blIdx++) {
@@ -316,8 +219,9 @@
     fprintf(stderr, "%s: cacheLen = %u\n", me, cacheLen);
   }
   if (nrrdKernelHermiteScaleSpaceFlag  == ctx->ksp[gageKernelStack]->kernel) {
-    unsigned int xi, yi, zi, blurIdx, valIdx, fdd;
-    double xx, *iv30, *iv31, sigma0, sigma1;
+    unsigned int iii, xi, yi, zi, blurIdx, valIdx, fdd, sz, sy;
+    double xx, *iv3, *iv30, *iv31, sigma0, sigma1,
+      val0, val1, drv0, drv1, lapl0, lapl1;
 
     fdd = fd*fd;
     /* initialize the output iv3 to all zeros, since we won't be
@@ -327,8 +231,9 @@
        non-existent values creeping in.  We shouldn't need to do any
        kind of nrrdBoundaryBleed thing here, because the kernel
        weights really should be zero on the boundary. */
+    iv3 = ctx->pvl[baseIdx]->iv3;
     for (cacheIdx=0; cacheIdx<cacheLen; cacheIdx++) {
-      ctx->pvl[baseIdx]->iv3[cacheIdx] = 0;
+      iv3[cacheIdx] = 0;
     }
 
     /* find the interval in the pre-blurred volumes containing the
@@ -359,33 +264,108 @@
     sigma0 = ctx->stackPos[blurIdx];
     sigma1 = ctx->stackPos[blurIdx+1];
     valLen = ctx->pvl[baseIdx]->kind->valLen;
-    for (valIdx=0; valIdx<valLen; valIdx++) {
-      unsigned iii;
-      double val0, val1, drv0, drv1, lapl0, lapl1, aa, bb, cc, dd;
-      for (zi=1; zi<fd-1; zi++) {
-        for (yi=1; yi<fd-1; yi++) {
+    sy = ctx->shape->size[1];
+    sz = ctx->shape->size[2];
+    if (1 == sz) {
+      if (1 == sy) {
+        /* (1-D data: HEY copy and paste; see 2D case below) */
+        for (valIdx=0; valIdx<valLen; valIdx++) {
+          /* nixed "for zi" and "for yi" loop; zi==yi==1 */
           for (xi=1; xi<fd-1; xi++) {
-            /* note that iv3 axis ordering is x, y, z, tuple */
-            iii = xi + fd*(yi + fd*(zi + fd*valIdx));
+            iii = xi + fd*(1 /* yi */ + fd*(1 /* zi */ + fd*valIdx));
             val0 = iv30[iii];
+            /* can do a 1D instead of 2D discrete laplacian */
+            lapl0 = (iv30[iii+1] + iv30[iii-1] - 2*val0);
             val1 = iv31[iii];
-            lapl0 = (iv30[iii + 1]   + iv30[iii - 1] +
-                     iv30[iii + fd]  + iv30[iii - fd] +
-                     iv30[iii + fdd] + iv30[iii - fdd] - 6*val0);
-            lapl1 = (iv31[iii + 1]   + iv31[iii - 1] +
-                     iv31[iii + fd]  + iv31[iii - fd] +
-                     iv31[iii + fdd] + iv31[iii - fdd] - 6*val1);
-            /* the (sigma1 - sigma0) factor is needed to convert the
-               derivative with respect to sigma (sigma*lapl) into the
-               derivative with respect to xx */
+            lapl1 = (iv31[iii+1] + iv31[iii-1] - 2*val1);
             drv0 = sigma0*lapl0*(sigma1 - sigma0);
             drv1 = sigma1*lapl1*(sigma1 - sigma0);
-            /* Hermite spline coefficients, thanks Mathematica */
-            aa = drv0 + drv1 + 2*val0 - 2*val1;
-            bb = -2*drv0 - drv1 - 3*val0 + 3*val1;
-            cc = drv0;
-            dd = val0;
-            ctx->pvl[baseIdx]->iv3[iii] = dd + xx*(cc + xx*(bb + aa*xx));
+            iv3[iii] = val0 + xx*(drv0 + xx*(drv0*(-2 + xx) + drv1*(-1 + xx)
+                                             + (val0 - val1)*(-3 + 2*xx)));
+            /*
+            fprintf(stderr, "!%s: (%u): val %g %g, lapl %g %g, sigma %g %g, drv %g %g --> iv3[%u] = %g\n", me,
+                    xi, val0, val1, lapl0, lapl1, sigma0, sigma1, drv0, drv1, iii, iv3[iii]);
+            fprintf(stderr, "!%s: lapl0 %g = %g + %g + %g + %g - 4*%g\n", me, lapl0,
+                    iv30[iii+1] , iv30[iii-1] , iv30[iii+fd] , iv30[iii-fd] , val0);
+            fprintf(stderr, "!%s: lapl1 %g = %g + %g + %g + %g - 4*%g\n", me, lapl1,
+                    iv31[iii+1] , iv31[iii-1] , iv31[iii+fd] , iv31[iii-fd] , val1);
+            */
+          }
+          for (zi=  2  ; zi<fd-1; zi++) {
+            for (yi=  2  ; yi<fd-1; yi++) {
+              for (xi=1; xi<fd-1; xi++) {
+                iii =          xi + fd*(yi + fd*(zi + fd*valIdx));
+                iv3[iii] = iv3[xi + fd*(1  + fd*(1  + fd*valIdx))];
+              }
+            }
+          }
+        }
+      } else {
+        /* as in gageIv3Fill; we do some special-case-ing for 2-D images;
+           (HEY copy and paste; see sz > 1 below for explanatory comments) */
+        for (valIdx=0; valIdx<valLen; valIdx++) {
+          /* nixed "for zi" loop; zi==1 */
+          for (yi=1; yi<fd-1; yi++) {
+            for (xi=1; xi<fd-1; xi++) {
+              iii = xi + fd*(yi + fd*(1 /* zi */ + fd*valIdx));
+              val0 = iv30[iii];
+              /* can do a 2D instead of 3D discrete laplacian */
+              lapl0 = (iv30[iii+1]   + iv30[iii-1] +
+                       iv30[iii+fd]  + iv30[iii-fd] - 4*val0);
+              val1 = iv31[iii];
+              lapl1 = (iv31[iii+1]   + iv31[iii-1] +
+                       iv31[iii+fd]  + iv31[iii-fd] - 4*val1);
+              drv0 = sigma0*lapl0*(sigma1 - sigma0);
+              drv1 = sigma1*lapl1*(sigma1 - sigma0);
+              iv3[iii] = val0 + xx*(drv0 + xx*(drv0*(-2 + xx) + drv1*(-1 + xx)
+                                               + (val0 - val1)*(-3 + 2*xx)));
+              /*
+              fprintf(stderr, "!%s: (%u,%u): val %g %g, lapl %g %g, sigma %g %g, drv %g %g --> iv3[%u] = %g\n", me,
+                      xi, yi, val0, val1, lapl0, lapl1, sigma0, sigma1, drv0, drv1, iii, iv3[iii]);
+              fprintf(stderr, "!%s: lapl0 %g = %g + %g + %g + %g - 4*%g\n", me, lapl0,
+                      iv30[iii+1] , iv30[iii-1] , iv30[iii+fd] , iv30[iii-fd] , val0);
+              fprintf(stderr, "!%s: lapl1 %g = %g + %g + %g + %g - 4*%g\n", me, lapl1,
+                      iv31[iii+1] , iv31[iii-1] , iv31[iii+fd] , iv31[iii-fd] , val1);
+              */
+            }
+          }
+          for (zi=  2  ; zi<fd-1; zi++) {
+            for (yi=1; yi<fd-1; yi++) {
+              for (xi=1; xi<fd-1; xi++) {
+                iii =          xi + fd*(yi + fd*(zi + fd*valIdx));
+                iv3[iii] = iv3[xi + fd*(yi + fd*(1  + fd*valIdx))];
+              }
+            }
+          }
+        }
+      }
+    } else {
+      /* sz > 1 */
+      for (valIdx=0; valIdx<valLen; valIdx++) {
+        for (zi=1; zi<fd-1; zi++) {
+          for (yi=1; yi<fd-1; yi++) {
+            for (xi=1; xi<fd-1; xi++) {
+              /* note that iv3 axis ordering is x, y, z, tuple */
+              iii = xi + fd*(yi + fd*(zi + fd*valIdx));
+              val0 = iv30[iii];
+              lapl0 = (iv30[iii+1]   + iv30[iii-1] +
+                       iv30[iii+fd]  + iv30[iii-fd] +
+                       iv30[iii+fdd] + iv30[iii-fdd] - 6*val0);
+              val1 = iv31[iii];
+              lapl1 = (iv31[iii+1]   + iv31[iii-1] +
+                       iv31[iii+fd]  + iv31[iii-fd] +
+                       iv31[iii+fdd] + iv31[iii-fdd] - 6*val1);
+              /* the (sigma1 - sigma0) factor is needed to convert the
+                 derivative with respect to sigma (sigma*lapl) into the
+                 derivative with respect to xx (ranges from 0 to 1) */
+              drv0 = sigma0*lapl0*(sigma1 - sigma0);
+              drv1 = sigma1*lapl1*(sigma1 - sigma0);
+              /* This inner loop is the bottleneck for some uses of
+                 scale-space; a re-arrangement of the Hermite spline
+                 evaluation (thanks Mathematica) does save a little time */
+              iv3[iii] = val0 + xx*(drv0 + xx*(drv0*(-2 + xx) + drv1*(-1 + xx)
+                                               + (val0 - val1)*(-3 + 2*xx)));
+            }
           }
         }
       }
@@ -436,7 +416,14 @@
                     double xx, double yy, double zz, double ss,
                     int indexSpace, int clamp) {
   static const char me[]="gageStackProbeSpace";
-
+  int ret;
+  /*
+  fprintf(stderr, "!%s(%g,%g,%g,%g, %d,%d): hello\n", me,
+          xx, yy, zz, ss, indexSpace, clamp);
+  if (AIR_ABS(-98.2539 - xx) < 0.1 && AIR_ABS(yy) < 0.1 && AIR_ABS(zz) < 0.1 && AIR_ABS(495.853 - ss)) {
+    ctx->verbose += 10;
+  }
+  */
   if (!ctx) {
     return 1;
   }
@@ -449,6 +436,8 @@
     ctx->errNum = gageErrStackUnused;
     return 1;
   }
-  return _gageProbeSpace(ctx, xx, yy, zz, ss, indexSpace, clamp);
+  ret = _gageProbeSpace(ctx, xx, yy, zz, ss, indexSpace, clamp);
+  /* fprintf(stderr, "!%s: returning %d\n", me, ret); */
+  return ret;
 }
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/st.c teem-1.11.0-src/src/gage/st.c
--- teem-1.11.0-src.orig/src/gage/st.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/st.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -217,9 +217,9 @@
             wi, wi/xs, wi/ys, wi/zs, ixw[wi+rad], iyw[wi+rad], izw[wi+rad]);
   }
 
-  osx = (nin->axis[0].size)/dsmp;
-  osy = (nin->axis[1].size)/dsmp;
-  osz = (nin->axis[2].size)/dsmp;
+  osx = AIR_INT((nin->axis[0].size)/dsmp);
+  osy = AIR_INT((nin->axis[1].size)/dsmp);
+  osz = AIR_INT((nin->axis[2].size)/dsmp);
   if (nrrdMaybeAlloc_va(nout, nrrdTypeDouble, 4,
                         AIR_CAST(size_t, 7),
                         AIR_CAST(size_t, osx),
diff --color -ruN teem-1.11.0-src.orig/src/gage/test/aalias.c teem-1.11.0-src/src/gage/test/aalias.c
--- teem-1.11.0-src.orig/src/gage/test/aalias.c	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/gage/test/aalias.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/test/ctfix.c teem-1.11.0-src/src/gage/test/ctfix.c
--- teem-1.11.0-src.orig/src/gage/test/ctfix.c	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/gage/test/ctfix.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -129,7 +130,7 @@
   fprintf(stderr, "%s: processing streaks ... \n", me);
   for (si=0; si<nsinfo->axis[1].size; si++) {
     fprintf(stderr, "%s: streak %d of %d       ",
-            me, si+1, AIR_CAST(int, nsinfo->axis[1].size));
+            me, si+1, AIR_INT(nsinfo->axis[1].size));
     fflush(stderr);
     zi = (int)(sinfo[0 + 5*si]);
     if (!( zi < sz )) {
diff --color -ruN teem-1.11.0-src.orig/src/gage/test/demo.c teem-1.11.0-src/src/gage/test/demo.c
--- teem-1.11.0-src.orig/src/gage/test/demo.c	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/gage/test/demo.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/test/genoptsig.c teem-1.11.0-src/src/gage/test/genoptsig.c
--- teem-1.11.0-src.orig/src/gage/test/genoptsig.c	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/gage/test/genoptsig.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -33,12 +34,13 @@
   airArray *mop;
 
   char *err, *outS;
-  double sigmaMax, convEps, cutoff;
+  double sigma[2], convEps, cutoff;
   int measr[2], tentRecon;
-  unsigned int sampleNumMax, dim, measrSampleNum, maxIter, num, ii;
-  gageOptimSigParm *osparm;
+  unsigned int sampleNum[2], dim, measrSampleNum, maxIter, num, ii;
+  gageOptimSigContext *osctx;
   double *scalePos, *out, info[512];
   Nrrd *nout;
+  NrrdKernelSpec *kss;
   double *plotPos; unsigned int plotPosNum;
 
   me = argv[0];
@@ -46,15 +48,16 @@
   hparm = hestParmNew();
   hopt = NULL;
   airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);
-  hestOptAdd(&hopt, "num", "# samp", airTypeUInt, 1, 1, &sampleNumMax, NULL,
-             "maximum number of samples to optimize");
+  hestOptAdd(&hopt, "num", "# samp", airTypeUInt, 2, 2, sampleNum, NULL,
+             "min and max number of samples to optimize");
   hestOptAdd(&hopt, "dim", "dimension", airTypeUInt, 1, 1, &dim, "3",
              "dimension of image to work with");
-  hestOptAdd(&hopt, "max", "sigma", airTypeDouble, 1, 1, &sigmaMax, NULL,
-             "sigma to use for top sample (using 0 for bottom sample)");
+  hestOptAdd(&hopt, "sig", "min max", airTypeDouble, 2, 2, sigma, NULL,
+             "sigmas to use for bottom and top sample; normal use "
+             "should have 0 for bottom scale");
   hestOptAdd(&hopt, "cut", "cut", airTypeDouble, 1, 1, &cutoff, "4",
              "at how many sigmas to cut-off discrete gaussian");
-  hestOptAdd(&hopt, "mi", "max", airTypeUInt, 1, 1, &maxIter, "1000",
+  hestOptAdd(&hopt, "maxi", "max", airTypeUInt, 1, 1, &maxIter, "1000",
              "maximum # iterations");
   hestOptAdd(&hopt, "N", "# samp", airTypeUInt, 1, 1, &measrSampleNum, "300",
              "number of samples in the measurement of error across scales");
@@ -63,9 +66,15 @@
   hestOptAdd(&hopt, "m", "m1 m2", airTypeEnum, 2, 2, measr, "l2 l2",
              "how to measure error across image, and across scales",
              NULL, nrrdMeasure);
-  hestOptAdd(&hopt, "p", "s0 s1", airTypeDouble, 2, -1, &plotPos, "nan nan",
-             "hack: dont do optimization; just plot the recon error given "
-             "these samples along scale", &plotPosNum);
+  hestOptAdd(&hopt, "p", "s0 s1", airTypeDouble, 1, -1, &plotPos, "nan nan",
+             "hack: don't do optimization; just plot the recon error given "
+             "these (two or more) samples along scale.  OR, hackier hack: "
+             "if there is only one value given here, do a different "
+             "plot: of the recon error within a small window (with the width "
+             "given here) in rho, as rho moves through its range",
+             &plotPosNum);
+  hestOptAdd(&hopt, "kss", "kern", airTypeOther, 1, 1, &kss, "hermite",
+             "kernel for gageKernelStack", NULL, NULL, nrrdHestKernelSpec);
   hestOptAdd(&hopt, "tent", NULL, airTypeInt, 0, 0, &tentRecon, NULL,
              "same hack: plot error with tent recon, not hermite");
   hestOptAdd(&hopt, "o", "nout", airTypeString, 1, 1, &outS, NULL,
@@ -78,22 +87,37 @@
   nout = nrrdNew();
   airMopAdd(mop, nout, AIR_CAST(airMopper, nrrdNuke), airMopAlways);
 
-  osparm = gageOptimSigParmNew(sampleNumMax);
-  airMopAdd(mop, osparm, AIR_CAST(airMopper, gageOptimSigParmNix),
-            airMopAlways);
-  scalePos = AIR_CAST(double *, calloc(sampleNumMax, sizeof(double)));
-  airMopAdd(mop, scalePos, airFree, airMopAlways);
-
-  osparm->plotting = (AIR_EXISTS(plotPos[0]) && AIR_EXISTS(plotPos[1]));
-  if (gageOptimSigTruthSet(osparm, dim, sigmaMax, cutoff, measrSampleNum)) {
+  osctx = gageOptimSigContextNew(dim, sampleNum[1],
+                                 measrSampleNum,
+                                 sigma[0], sigma[1],
+                                 cutoff);
+  if (!osctx) {
     airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
     fprintf(stderr, "%s: trouble:\n%s", me, err);
     airMopError(mop); return 1;
   }
+  airMopAdd(mop, osctx, AIR_CAST(airMopper, gageOptimSigContextNix),
+            airMopAlways);
+
+  scalePos = AIR_CALLOC(sampleNum[1], double);
+  airMopAdd(mop, scalePos, airFree, airMopAlways);
 
-  if (osparm->plotting) {
-    if (gageOptimSigPlot(osparm, nout, plotPos, plotPosNum,
-                         measr[0], tentRecon)) {
+  if (1 == plotPosNum && AIR_EXISTS(plotPos[0])) {
+    /* hackity hack: a different kind of plotting requested */
+    if (gageOptimSigErrorPlotSliding(osctx, nout,
+                                     plotPos[0],
+                                     measrSampleNum,
+                                     kss, measr[0])) {
+      airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
+      fprintf(stderr, "%s: trouble:\n%s", me, err);
+      airMopError(mop); return 1;
+    }
+  } else if (AIR_EXISTS(plotPos[0]) && AIR_EXISTS(plotPos[1])) {
+    /* hack: plotting requested */
+    if (gageOptimSigErrorPlot(osctx, nout,
+                              plotPos, plotPosNum,
+                              kss,
+                              measr[0])) {
       airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
       fprintf(stderr, "%s: trouble:\n%s", me, err);
       airMopError(mop); return 1;
@@ -101,37 +125,38 @@
   } else {
     /* do sample position optimization */
     if (nrrdMaybeAlloc_va(nout, nrrdTypeDouble, 2,
-                          AIR_CAST(size_t, sampleNumMax+1),
-                          AIR_CAST(size_t, sampleNumMax+1))) {
+                          AIR_CAST(size_t, sampleNum[1]+1),
+                          AIR_CAST(size_t, sampleNum[1]+1))) {
       airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
       fprintf(stderr, "%s: trouble allocating output:\n%s", me, err);
       airMopError(mop); return 1;
     }
     out = AIR_CAST(double *, nout->data);
     /* hacky way of saving some of the computation information */
+    /* HEY: this is what KVPs are for */
     info[0] = cutoff;
     info[1] = measrSampleNum;
     info[2] = measr[0];
     info[3] = measr[1];
     info[4] = convEps;
     info[5] = maxIter;
-    for (ii=0; ii<sampleNumMax+1; ii++) {
+    for (ii=0; ii<sampleNum[1]+1; ii++) {
       out[ii] = info[ii];
     }
-    for (num=2; num<=sampleNumMax; num++) {
-      printf("\n%s: ======= optimizing %u/%u samples (sigmaMax %g) \n\n",
-             me, num, sampleNumMax, sigmaMax);
-      if (gageOptimSigCalculate(osparm, scalePos, num,
-                                measr[0], measr[1],
-                                convEps, maxIter)) {
+    for (num=sampleNum[0]; num<=sampleNum[1]; num++) {
+      printf("\n%s: ======= optimizing %u/%u samples (sigma %g--%g) \n\n",
+             me, num, sampleNum[1]+1, sigma[0], sigma[1]);
+      if (gageOptimSigCalculate(osctx, scalePos, num,
+                                kss, measr[0], measr[1],
+                                maxIter, convEps)) {
         airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
         fprintf(stderr, "%s: trouble:\n%s", me, err);
         airMopError(mop); return 1;
       }
-      out[sampleNumMax + (sampleNumMax+1)*num] = osparm->finalErr;
       for (ii=0; ii<num; ii++) {
-        out[ii + (sampleNumMax+1)*num] = scalePos[ii];
+        out[ii + (sampleNum[1]+1)*num] = scalePos[ii];
       }
+      out[sampleNum[1] + (sampleNum[1]+1)*num] = osctx->finalErr;
     }
   }
   if (nrrdSave(outS, nout, NULL)) {
diff --color -ruN teem-1.11.0-src.orig/src/gage/test/indx.c teem-1.11.0-src/src/gage/test/indx.c
--- teem-1.11.0-src.orig/src/gage/test/indx.c	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/gage/test/indx.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -71,9 +72,9 @@
       fprintf(stderr, "OUTSIDE\n");
     } else {
       if (0 && nrrdCenterCell == center) {
-        xi = AIR_CAST(unsigned int, _xi+1) - 1;
+        xi = AIR_UINT(_xi+1) - 1;
       } else {
-        xi = AIR_CAST(unsigned int, _xi);
+        xi = AIR_UINT(_xi);
       }
       xi -= (xi == max);
       xf = _xi - xi;
diff --color -ruN teem-1.11.0-src.orig/src/gage/test/maxes.c teem-1.11.0-src/src/gage/test/maxes.c
--- teem-1.11.0-src.orig/src/gage/test/maxes.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/gage/test/maxes.c	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,170 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "../gage.h"
+
+void
+maxes1(Nrrd *nout, const Nrrd *nin) {
+  unsigned int sx, xi, xd;
+  int xo, ismax;
+  double val, (*lup)(const void *, size_t),
+    (*ins)(void *, size_t, double);
+
+  lup = nrrdDLookup[nin->type];
+  ins = nrrdDInsert[nin->type];
+  sx = AIR_UINT(nin->axis[0].size);
+  for (xi=0; xi<sx; xi++) {
+    ismax = AIR_TRUE;
+    val = lup(nin->data, xi);
+    for (xo=-1; xo<=1; xo+=2) {
+      xd = !xi && xo < 0 ? sx-1 : AIR_MOD(xi+xo, sx);
+      ismax &= lup(nin->data, xd) < val;
+      if (!ismax) break;
+    }
+    ins(nout->data, xi, ismax);
+  }
+  return;
+}
+
+void
+maxes2(Nrrd *nout, const Nrrd *nin) {
+  unsigned int sx, sy, xi, yi, xd, yd;
+  int xo, yo, ismax;
+  double val, (*lup)(const void *, size_t),
+    (*ins)(void *, size_t, double);
+
+  lup = nrrdDLookup[nin->type];
+  ins = nrrdDInsert[nin->type];
+  sx = AIR_UINT(nin->axis[0].size);
+  sy = AIR_UINT(nin->axis[1].size);
+  for (yi=0; yi<sy; yi++) {
+    for (xi=0; xi<sx; xi++) {
+      ismax = AIR_TRUE;
+      val = lup(nin->data, xi + sx*yi);
+      for (yo=-1; yo<=1; yo++) {
+        yd = !yi && yo < 0 ? sy-1 : AIR_MOD(yi+yo, sy);
+        for (xo=-1; xo<=1; xo++) {
+          if (!xo && !yo) continue;
+          xd = !xi && xo < 0 ? sx-1 : AIR_MOD(xi+xo, sx);
+          ismax &= lup(nin->data, xd + sx*yd) < val;
+        }
+      }
+      ins(nout->data, xi + sx*yi, ismax);
+    }
+  }
+  return;
+}
+
+void
+maxes3(Nrrd *nout, const Nrrd *nin) {
+  unsigned int sx, sy, sz, xi, yi, zi, xd, yd, zd;
+  int xo, yo, zo, ismax;
+  double val, (*lup)(const void *, size_t),
+    (*ins)(void *, size_t, double);
+
+  lup = nrrdDLookup[nin->type];
+  ins = nrrdDInsert[nin->type];
+  sx = AIR_UINT(nin->axis[0].size);
+  sy = AIR_UINT(nin->axis[1].size);
+  sz = AIR_UINT(nin->axis[2].size);
+  for (zi=0; zi<sz; zi++) {
+    for (yi=0; yi<sy; yi++) {
+      for (xi=0; xi<sx; xi++) {
+        ismax = AIR_TRUE;
+        val = lup(nin->data, xi + sx*(yi + sy*zi));
+        for (zo=-1; zo<=1; zo++) {
+          zd = !zi && zo < 0 ? sz-1 : AIR_MOD(zi+zo, sz);
+          for (yo=-1; yo<=1; yo++) {
+            yd = !yi && yo < 0 ? sy-1 : AIR_MOD(yi+yo, sy);
+            for (xo=-1; xo<=1; xo++) {
+              if (!xo && !yo && !zo) continue;
+              xd = !xi && xo < 0 ? sx-1 : AIR_MOD(xi+xo, sx);
+              ismax &= lup(nin->data, xd + sx*(yd + sy*zd)) < val;
+            }
+          }
+        }
+        ins(nout->data, xi + sx*(yi + sy*zi), ismax);
+      }
+    }
+  }
+  return;
+}
+
+char *maxesInfo = ("sets maxima to 1, else 0");
+
+int
+main(int argc, const char *argv[]) {
+  const char *me;
+  char *outS;
+  hestOpt *hopt;
+  hestParm *hparm;
+  airArray *mop;
+
+  char *err;
+  Nrrd *nin, *nout;
+
+  me = argv[0];
+  mop = airMopNew();
+  hparm = hestParmNew();
+  hopt = NULL;
+  airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);
+  hestOptAdd(&hopt, "i", "nin", airTypeOther, 1, 1, &nin, NULL,
+             "input image", NULL, NULL, nrrdHestNrrd);
+  hestOptAdd(&hopt, "o", "filename", airTypeString, 1, 1, &outS, NULL,
+             "output volume");
+  hestParseOrDie(hopt, argc-1, argv+1, hparm,
+                 me, maxesInfo, AIR_TRUE, AIR_TRUE, AIR_TRUE);
+  airMopAdd(mop, hopt, (airMopper)hestOptFree, airMopAlways);
+  airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);
+
+  if (!AIR_IN_CL(1, nin->dim, 3)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: nin->dim %u not 1, 2, or 3", me, nin->dim);
+    airMopError(mop); return 1;
+  }
+
+  nout = nrrdNew();
+  airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
+  if (nrrdCopy(nout, nin)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: couldn't allocate output:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+
+  if (1 == nin->dim) {
+    maxes1(nout, nin);
+  } else if (2 == nin->dim) {
+    maxes2(nout, nin);
+  } else {
+    maxes3(nout, nin);
+  }
+
+  if (nrrdSave(outS, nout, NULL)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: couldn't save output:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+
+  airMopOkay(mop);
+  exit(0);
+}
diff --color -ruN teem-1.11.0-src.orig/src/gage/test/ssc.c teem-1.11.0-src/src/gage/test/ssc.c
--- teem-1.11.0-src.orig/src/gage/test/ssc.c	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/gage/test/ssc.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2011, 2010, 2009, 2008  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/test/tplot.c teem-1.11.0-src/src/gage/test/tplot.c
--- teem-1.11.0-src.orig/src/gage/test/tplot.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/gage/test/tplot.c	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,88 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "../gage.h"
+
+char *tplotInfo = ("for plotting tau");
+
+int
+main(int argc, const char *argv[]) {
+  const char *me;
+  hestOpt *hopt;
+  hestParm *hparm;
+  airArray *mop;
+
+  double dommm[2];
+  unsigned int num;
+  char *err;
+  char *outS;
+
+  Nrrd *nout;
+  double *out, dd;
+  unsigned int ii;
+  int tee;
+
+  me = argv[0];
+  mop = airMopNew();
+  hparm = hestParmNew();
+  hopt = NULL;
+  airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);
+  hestOptAdd(&hopt, "tee", NULL, airTypeInt, 0, 0, &tee, NULL,
+             "domain of plot is t, not sigma");
+  hestOptAdd(&hopt, "mm", "min max", airTypeDouble, 2, 2, dommm, NULL,
+             "range of domain to plot");
+  hestOptAdd(&hopt, "n", "# samp", airTypeUInt, 1, 1, &num, NULL,
+             "number of samples");
+  hestOptAdd(&hopt, "o", "filename", airTypeString, 1, 1, &outS, NULL,
+             "output volume");
+  hestParseOrDie(hopt, argc-1, argv+1, hparm,
+                 me, tplotInfo, AIR_TRUE, AIR_TRUE, AIR_TRUE);
+  airMopAdd(mop, hopt, (airMopper)hestOptFree, airMopAlways);
+  airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);
+
+  nout = nrrdNew();
+  airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
+  if (nrrdMaybeAlloc_va(nout, nrrdTypeDouble, 1,
+                        AIR_CAST(size_t, num))) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: couldn't allocate output:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+  out = AIR_CAST(double *, nout->data);
+  nout->axis[0].min = dommm[0];
+  nout->axis[0].max = dommm[1];
+  nout->axis[0].center = nrrdCenterNode;
+  for (ii=0; ii<num; ii++) {
+    dd = AIR_AFFINE(0, ii, num-1, dommm[0], dommm[1]);
+    out[ii] = tee ? gageTauOfTee(dd) : gageTauOfSig(dd);
+  }
+
+  if (nrrdSave(outS, nout, NULL)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: couldn't save output:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+
+  airMopOkay(mop);
+  exit(0);
+}
diff --color -ruN teem-1.11.0-src.orig/src/gage/test/vh.c teem-1.11.0-src/src/gage/test/vh.c
--- teem-1.11.0-src.orig/src/gage/test/vh.c	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/gage/test/vh.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/twovecGage.c teem-1.11.0-src/src/gage/twovecGage.c
--- teem-1.11.0-src.orig/src/gage/twovecGage.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/gage/twovecGage.c	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,195 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "gage.h"
+#include "privateGage.h"
+
+const char *
+_gage2VecStr[] = {
+  "(unknown gage2Vec)",
+  "vector",
+  "vector0",
+  "vector1",
+  "length",
+};
+
+const char *
+_gage2VecDesc[] = {
+  "unknown gage2Vec query",
+  "component-wise-interpolated vector",
+  "vector[0]",
+  "vector[1]",
+  "length of vector",
+};
+
+const int
+_gage2VecVal[] = {
+  gage2VecUnknown,
+  gage2VecVector,
+  gage2VecVector0,
+  gage2VecVector1,
+  gage2VecLength,
+};
+
+#define GV_V   gage2VecVector
+#define GV_V0  gage2VecVector0
+#define GV_V1  gage2VecVector1
+#define GV_L   gage2VecLength
+
+const char *
+_gage2VecStrEqv[] = {
+  "v", "vector", "vec",
+  "v0", "vector0", "vec0",
+  "v1", "vector1", "vec1",
+  "l", "length", "len",
+  ""
+};
+
+const int
+_gage2VecValEqv[] = {
+  GV_V, GV_V, GV_V,
+  GV_V0, GV_V0, GV_V0,
+  GV_V1, GV_V1, GV_V1,
+  GV_L, GV_L, GV_L,
+};
+
+const airEnum
+_gage2Vec = {
+  "gage2Vec",
+  GAGE_2VEC_ITEM_MAX,
+  _gage2VecStr, _gage2VecVal,
+  _gage2VecDesc,
+  _gage2VecStrEqv, _gage2VecValEqv,
+  AIR_FALSE
+};
+const airEnum *const
+gage2Vec = &_gage2Vec;
+
+
+
+gageItemEntry
+_gage2VecTable[GAGE_2VEC_ITEM_MAX+1] = {
+  /* enum value         len, deriv, prereqs,                                                  parent item, parent index, needData */
+  {gage2VecUnknown,        0,  0,   {0},                                                                0,      0,       AIR_FALSE},
+  {gage2VecVector,         2,  0,   {0},                                                                0,      0,       AIR_FALSE},
+  {gage2VecVector0,        1,  0,   {gage2VecVector},                                      gage2VecVector,      0,       AIR_FALSE},
+  {gage2VecVector1,        1,  0,   {gage2VecVector},                                      gage2VecVector,      1,       AIR_FALSE},
+  {gage2VecLength,         1,  0,   {gage2VecVector},                                                   0,      0,       AIR_FALSE},
+};
+
+void
+_gage2VecFilter(gageContext *ctx, gagePerVolume *pvl) {
+  static const char me[]="_gage2VecFilter";
+  double *fw00, *fw11, *fw22, *vec;
+  int fd;
+  gageScl3PFilter_t *filter[5] = {NULL, gageScl3PFilter2, gageScl3PFilter4,
+                                  gageScl3PFilter6, gageScl3PFilter8};
+  unsigned int valIdx;
+
+  fd = 2*ctx->radius;
+  vec  = pvl->directAnswer[gage2VecVector];
+  if (!ctx->parm.k3pack) {
+    fprintf(stderr, "!%s: sorry, 6pack filtering not implemented\n", me);
+    return;
+  }
+  fw00 = ctx->fw + fd*3*gageKernel00;
+  fw11 = ctx->fw + fd*3*gageKernel11;
+  fw22 = ctx->fw + fd*3*gageKernel22;
+  /* perform the filtering */
+  if (fd <= 8) {
+    for (valIdx=0; valIdx<2; valIdx++) {
+      filter[ctx->radius](ctx->shape,
+                          pvl->iv3 + valIdx*fd*fd*fd,
+                          pvl->iv2 + valIdx*fd*fd,
+                          pvl->iv1 + valIdx*fd,
+                          fw00, fw11, fw22,
+                          vec + valIdx, NULL, NULL, /* jac + valIdx*2, hes + valIdx*4, */
+                          pvl->needD);
+    }
+  } else {
+    for (valIdx=0; valIdx<2; valIdx++) {
+      gageScl3PFilterN(ctx->shape, fd,
+                       pvl->iv3 + valIdx*fd*fd*fd,
+                       pvl->iv2 + valIdx*fd*fd,
+                       pvl->iv1 + valIdx*fd,
+                       fw00, fw11, fw22,
+                       vec + valIdx, NULL, NULL, /* jac + valIdx*2, hes + valIdx*4, */
+                       pvl->needD);
+    }
+  }
+
+  return;
+}
+
+void
+_gage2VecAnswer(gageContext *ctx, gagePerVolume *pvl) {
+  /* static const char me[]="_gage2VecAnswer"; */
+  double *vecAns;
+  /* int asw; */
+
+  AIR_UNUSED(ctx);
+  vecAns          = pvl->directAnswer[gage2VecVector];
+
+  if (GAGE_QUERY_ITEM_TEST(pvl->query, gage2VecVector)) {
+    /* done if doV */
+    /*
+    if (ctx->verbose) {
+      fprintf(stderr, "vec = %f %f", vecAns[0], vecAns[1]);
+    }
+    */
+  }
+  /* done if doV
+  if (GAGE_QUERY_ITEM_TEST(pvl->query, gage2VecVector{0,1})) {
+  }
+  */
+  if (GAGE_QUERY_ITEM_TEST(pvl->query, gage2VecLength)) {
+    pvl->directAnswer[gage2VecLength][0] = ELL_2V_LEN(vecAns);
+  }
+  return;
+}
+
+void
+_gage2VecIv3Print (FILE *file, gageContext *ctx, gagePerVolume *pvl) {
+
+  AIR_UNUSED(ctx);
+  AIR_UNUSED(pvl);
+  fprintf(file, "_gage2VecIv3Print() not implemented\n");
+}
+
+gageKind
+_gageKind2Vec = {
+  AIR_FALSE, /* statically allocated */
+  "2vector",
+  &_gage2Vec,
+  1, /* baseDim */
+  2, /* valLen */
+  GAGE_2VEC_ITEM_MAX,
+  _gage2VecTable,
+  _gage2VecIv3Print,
+  _gage2VecFilter,
+  _gage2VecAnswer,
+  NULL, NULL, NULL, NULL,
+  NULL
+};
+gageKind *const
+gageKind2Vec = &_gageKind2Vec;
diff --color -ruN teem-1.11.0-src.orig/src/gage/update.c teem-1.11.0-src/src/gage/update.c
--- teem-1.11.0-src.orig/src/gage/update.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/update.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/vecGage.c teem-1.11.0-src/src/gage/vecGage.c
--- teem-1.11.0-src.orig/src/gage/vecGage.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/vecGage.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -31,7 +31,7 @@
 double
 gage_imaginary_part_eigenvalues(double *M ) {
     double A, B, C, scale, frob, m[9], _eval[3];
-    double beta, gamma;
+    double beta, _gamma;
     int roots;
 
     frob = ELL_3M_FROB(M);
@@ -55,8 +55,8 @@
 
     /* 2 complex conjuguate eigenvalues */
     beta = A + _eval[0];
-    gamma = -C/_eval[0];
-    return sqrt( 4.*gamma - beta*beta );
+    _gamma = -C/_eval[0];
+    return sqrt( 4.*_gamma - beta*beta );
 }
 
 
diff --color -ruN teem-1.11.0-src.orig/src/gage/vecprint.c teem-1.11.0-src/src/gage/vecprint.c
--- teem-1.11.0-src.orig/src/gage/vecprint.c	2012-12-20 22:07:57.000000000 +0800
+++ teem-1.11.0-src/src/gage/vecprint.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/GNUmakefile teem-1.11.0-src/src/GNUmakefile
--- teem-1.11.0-src.orig/src/GNUmakefile	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/GNUmakefile	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2020  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -177,7 +177,7 @@
 ## By giving a list of library extensions we care about, LIBEXTS determines
 ## what kinds of libraries are built (just static, or both static and
 ## shared)
-## 
+##
 ifdef TEEM_SHEXT
   LIBEXTS = $(TEEM_SHEXT)
 endif
@@ -187,16 +187,22 @@
 ## Flags
 ##
 ifneq (undefined,$(origin TEEM_LINK_SHARED))
-  # If we ever have absolutify-this-path working, then having an 
+  # If we ever have absolutify-this-path working, then having an
   # absolute TEEM_DEST path is no longer a pre-requisite
   BIN_CFLAGS += $(SHARED_CFLAG) $(if $(TEEM_DEST),$(if $(SHARED_RPATH),$(SHARED_RPATH)$(LDEST),),)
 else
   BIN_CFLAGS += $(STATIC_CFLAG)
 endif
 
-## The -DTEEM_BUILD_EXPERIMENTAL_LIBS mimics something that 
-## would otherwise come from CMake files
-CFLAGS += -DTEEM_BUILD_EXPERIMENTAL_LIBS $(OPT_CFLAG) $(ARCH_CFLAG)
+## CMake is how most people will compile Teem, but these GNUMakefiles are
+## still what GLK uses day-to-day when working with Teem, with their finer
+## per-library granularity. Some additions to CFLAGS are adaptions help these
+## GNUMakfiles adapt to the CMake world around them.  -DTEEM_NON_CMAKE says
+## that this isn't being build by cmake (so, e.g. don't look for
+## teem/airExistsConf.h), and -DTEEM_BUILD_EXPERIMENTAL_LIBS mimics something
+## that would otherwise come from CMake files only when *all* the libraries
+## are being compiled
+CFLAGS += -DTEEM_NON_CMAKE -DTEEM_BUILD_EXPERIMENTAL_LIBS $(OPT_CFLAG) $(ARCH_CFLAG)
 LDFLAGS += $(ARCH_LDFLAG) $(SHARED_LDFLAG)
 
 ## SGI's C pre-processor errors aren't fatal by default
@@ -209,7 +215,7 @@
 
 ## Each of these can be $(call)ed with a library name, as the one
 ## and only argument, in order to get a list of files or flags related to
-## library.  
+## library.
 ##
 ## {libs,hdrs}.inst(L): installed libs and headers for library L
 ## hdrs.dev(L): the local (original) copies of public and private headers
@@ -235,7 +241,7 @@
 ## (discover more needed libs).  The number of levels is more than
 ## enough for the current teem; and adding more levels later is
 ## trivial.
-## 
+##
 ## Since we rely on $(sort) to remove redundancies, we need a way of
 ## putting the libraries back in dependency order (!= lexical order).
 ## So, we prefix the needed library names with [0..D] (via $(join)) to
@@ -243,7 +249,7 @@
 ## with $(notdir).  This is done by "deporder". On the link line,
 ## however, the ordering needs to be reversed, this is done by
 ## "linkorder".
-## 
+##
 dmnl = $(sort $(foreach LIB,$(1),$(LIB) $($(LIB).NEED)))
 deporder = $(notdir $(sort $(foreach LIB,$(1),\
   $(filter %/$(LIB),$(NUM/LIBS)))))
@@ -323,7 +329,7 @@
 #######################################
 
 ## Read in the makefiles for all the libraries, and the bins.  Run-away
-## recursive inclusion is prevented by having set DEF_TARGETS. 
+## recursive inclusion is prevented by having set DEF_TARGETS.
 ## Note: "include" is a directive, not a function, which eliminates
 ## the possibility of iterating through the libraries, reading the
 ## make file, and then setting variables based on what was just read.
diff --color -ruN teem-1.11.0-src.orig/src/HELP.txt teem-1.11.0-src/src/HELP.txt
--- teem-1.11.0-src.orig/src/HELP.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/HELP.txt	2021-02-18 15:42:38.000000000 +0800
@@ -0,0 +1,124 @@
+** Below are some non-trivial coding tasks that would help Teem a lot,
+** starting with the most important.  Compared to things in TODO.txt,
+** these are more generally useful, and can be done prior to working
+** on Teem 2.0 because they don't involve API changes.
+
+
+Update NrrdIO's CMakeLists.txt file.  While Teem has a good working
+CMakeLists.txt file:
+<http://sourceforge.net/p/teem/code/HEAD/tree/teem/trunk/CMakeLists.txt#l86>
+NrrdIO has a fairly meagre one:
+<http://sourceforge.net/p/teem/code/HEAD/tree/NrrdIO/trunk/CMakeLists.txt>
+Note how NrrdIO's CMakeLists.txt file doesn't really have proper handling
+of qnanhibit; it says "The QNANHIBIT variable is configured by the root
+level CMakeLists.txt".  But that's bogus- it's a copy-and-paste from the
+CMakeLists.txt from ITK's NrrdIO, whereas this NrrdIO is entirely
+stand-alone. What is required to teach NrrdIO's CMakeLists.txt about how to
+learn qnanhitbit at configure-time?  What other best practices are in
+Teem's CMakeLists.txt that should be copied in NrrdIO's (or introduced
+there if Teem's is out dated)?  You can get a copy of NrrdIO via:
+svn co http://svn.code.sf.net/p/teem/code/NrrdIO/trunk/ NrrdIO
+The source files here are largely extracted automatically by Teem code,
+via running:
+make -f pre-GNUmakefile
+clean make -f pre-GNUmakefile
+But the CMakeLists.txt file there is specific to NrrdIO; it isn't copied
+or updated based on anything in the rest of Teem.
+
+
+Create and host a new Teem CDash dashboard. The old one at
+<http://my.cdash.org/index.php?project=Teem> stopped working when
+Sourceforge changed the URL for code repo, and, whomever at Kitware created
+that dashboard no longer works there, and, they don't want to be bothered
+with fixing something that isn't making them money.  Also, enlist more
+machines for testing.
+
+
+Generate and commit some examples for using Doxygen to document Teem code,
+with "for dummies"-level intructions on how to run doxygen to generate a
+set of documentation web pages. One or two of these have been floated, but
+nothing was committed to the repo so they haven't stuck as examples to
+build upon.  Also, figure out a way to streamline the propogation of
+newly-generated documentation (from doxygen) to sourceforge-hosted web
+pages.  It seems like changes at sourceforge have made it increasingly
+annoying to update those web pages, so something scripted (or at least
+documented in gory detail) will help.
+
+
+Scrutinize all uses of sizeof(), especially with memcpy or memset.  When
+possible, sizeof() should be passed something involving the variable name
+itself, rather than referring to specific type (e.g. "float").  This has
+caused at least one tricky memory bug, when the variable type changed.
+
+
+Scrutinize all use strncpy. Why not use airStrcpy?
+
+
+All of the code in teem/src/nrrd/apply1D.c is ancient, and has not
+been brought into the modern world of using unsigned int and size_t.
+Also its very confusing. Needs to be walked through and tested
+thoroughly (with new tests in teem/Testing/nrrd)
+
+
+airArray's are used through-out Teem whenever a dynamically resized array
+is needed.  The current scheme for reallocation is very dumb: an "incr" is
+set at creation time, and then the array allocates itself for some multiple
+of incr (0, incr, 2*incr, 3*incr, etc).  The scaling should be
+multiplicative, not linear, with some adjustable factor:
+<http://en.wikipedia.org/wiki/Dynamic_array>
+<http://hg.python.org/cpython/file/e3be2941c834/Objects/listobject.c> The
+new thing should be called the "airList", and otherwise have an API closely
+matching that of airArray, including the callback mechanisms. Bit by bit
+things inside Teem can be switched over from using airArray to airList,
+starting with uses that have no public visibility.  Teem 2.0 can start
+changing things that are public, like the implementation of the airMop
+functions with airArrays (airMopNew() would then return an airList).
+
+
+There should be something called airBuff which can be generally used
+for reading and writing data, from/to strings or files, raw or compressed.
+Desirable features:
+* unify sprint'ing into string, or fwrite'ing to file
+* unify reading from string, or from file
+* string dynamically reallocated on write, with optional cap on
+  allowed size, maybe allowing control of whether reaching that size
+  is an error
+* when reading from a file, allow the file to be gzip'd, so that
+  all the subsequent IO can be blind to whether the file was
+  compressed or not
+* when reading from stdin, buffer it as you go to make it effectively
+  fseek-able. This would allow Nrrd IO functions to more experimentally
+  delegate to the different possible format readers. Right now Nrrd IO
+  function presume the file starts with some "magic", but NIFTI thwarts
+  this.
+* when writing to string, should be remembering where last output is,
+  to avoid needless repeated calls to strlen
+* could use one of these as wrapper around stderr for normal output of
+  unrrduCmds, but allowing it to be saved to string in case the command
+  is being invoked from C
+* remember comment from nrrd/formatPNG.c:
+     /* Reading PNGs teaches Gordon that his scheme for parsing nrrd header
+        information is inappropriately specific to reading PNMs and NRRDs,
+        since in this case the text from which we parse a nrrd field
+        descriptor did NOT come from a line of text as read by
+        _nrrdOneLine */
+     nio->line = (char *)airFree(nio->line);
+     nio->line = airStrdup(txt[i].text);
+Once airBuff is stable and working, nrrd IO things can be moved to that.
+
+
+Run Clang's static analyzer:
+<http://clang-analyzer.llvm.org/scan-build.html> Right now this reports
+"217 bugs found".  The "Value ... is never read" bugs seem mostly
+innocuous, all the other ones are actually concerning.  Any questions that
+arise in fixing the bugs should be posted to the teem-users list:
+http://sourceforge.net/p/teem/mailman/teem-users/
+
+
+Hest would benefit from some way of accepting comments (which are removed
+prior to doing the real work of command-line parsing). What should the
+syntax for this be?  Ignoring anything after a "#"?  Is there a way to
+delimit a comment string (as with /* ... */).  Implementing this would
+likely involve revisiting the cryptic innards of hest, which haven't
+changed a lot since they were first written during the 2002 winter
+olympics.  This is all do-able without any API changes.
diff --color -ruN teem-1.11.0-src.orig/src/hest/CMakeLists.txt teem-1.11.0-src/src/hest/CMakeLists.txt
--- teem-1.11.0-src.orig/src/hest/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/hest/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -0,0 +1,14 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(HEST_SOURCES
+  defaultsHest.c
+  hest.h
+  methodsHest.c
+  parseHest.c
+  privateHest.h
+  usage.c
+  )
+
+target_sources(teem PRIVATE ${HEST_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( hest FILES ${HEST_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/hest/defaultsHest.c teem-1.11.0-src/src/hest/defaultsHest.c
--- teem-1.11.0-src.orig/src/hest/defaultsHest.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/defaultsHest.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hest/GNUmakefile teem-1.11.0-src/src/hest/GNUmakefile
--- teem-1.11.0-src.orig/src/hest/GNUmakefile	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/GNUmakefile	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/hest/hest.h teem-1.11.0-src/src/hest/hest.h
--- teem-1.11.0-src.orig/src/hest/hest.h	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/hest.h	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -46,6 +46,21 @@
 #endif
 
 /*
+******** hestSource* enum
+**
+** records whether the info to satisfy a particular option came
+** from the default or from the user (command-line or response file).
+** Distinguishing command-line from response file would take a
+** much more significant code restructuring
+*/
+enum {
+  hestSourceUnknown,       /* 0 */
+  hestSourceDefault,       /* 1 */
+  hestSourceUser,          /* 2 */
+  hestSourceLast
+};
+
+/*
 ******** hestCB struct
 **
 ** for when the thing you want to parse from the command-line is not a
@@ -60,7 +75,7 @@
 typedef struct {
   size_t size;          /* sizeof() one thing */
   const char *type;     /* used by hestGlossary() to describe the type */
-  int (*parse)(void *ptr, char *str, char err[AIR_STRLEN_HUGE]);
+  int (*parse)(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]);
                         /* how to parse one thing from a string.  This will
                            be called multiple times for multiple parameter
                            options.  A non-zero return value is considered
@@ -93,7 +108,9 @@
   airEnum *enm;         /* used ONLY for airTypeEnum options */
   hestCB *CB;           /* used ONLY for airTypeOther options */
 
-  /* --------------------- end of user-defined fields */
+  /* --------------------- end of user-defined fields; the following fields
+     must be set by hestParse() as part of its operation. This does prevent
+     adding const to much usage of the hestOpt */
 
   int kind,             /* what kind of option is this, based on min and max,
                            set by hestParse() (actually _hestPanic()),
@@ -120,6 +137,12 @@
                               of a fixed-length array of strings
                            3: free((*valueP)[i]) and free(*valueP), because
                               it is a dynamically allocated array of strings */
+
+  /* --------------------- Output */
+
+  int source;           /* from the hestSource* enum; from whence was this
+                           information set, else hestSourceUnknown if not */
+
 } hestOpt;
 
 /*
@@ -155,10 +178,14 @@
                            "show me usage info"). */
     greedySingleString, /* when parsing a single string, whether or not
                            to be greedy (as per airParseStrS) */
-    cleverPluralizeOtherY; /* when printing the type for airTypeOther, when
+    cleverPluralizeOtherY, /* when printing the type for airTypeOther, when
                               the min number of items is > 1, and the type
                               string ends with "y", then pluralize with
                               "ies" instead of "ys" */
+    dieLessVerbose,     /* on parse failure, hestParseOrDie prints less
+                           than it otherwise might: only print info and
+                           glossary when they "ask for it" */
+    noBlankLineBeforeUsage; /* like it says */
   unsigned int columns; /* number of printable columns in output */
   char respFileFlag,    /* the character at the beginning of an argument
                            indicating that this is a response file name */
@@ -197,17 +224,20 @@
 HEST_EXPORT const int hestPresent;
 HEST_EXPORT hestParm *hestParmNew(void);
 HEST_EXPORT hestParm *hestParmFree(hestParm *parm);
-HEST_EXPORT void hestOptAdd(hestOpt **optP,
-                            const char *flag, const char *name,
-                            int type, int min, int max,
-                            void *valueP, const char *dflt, const char *info,
-                            ... /* int *sawP, airEnum *enm , hestCB *CB */);
+HEST_EXPORT unsigned int hestOptAdd(hestOpt **optP,
+                                    const char *flag, const char *name,
+                                    int type, int min, int max,
+                                    void *valueP, const char *dflt,
+                                    const char *info,
+                                    ... /* unsigned int *sawP,
+                                           airEnum *enm,
+                                           hestCB *CB */);
 HEST_EXPORT hestOpt *hestOptFree(hestOpt *opt);
 HEST_EXPORT int hestOptCheck(hestOpt *opt, char **errP);
 
 /* parseHest.c */
 HEST_EXPORT int hestParse(hestOpt *opt, int argc, const char **argv,
-                          char **errP, hestParm *parm);
+                          char **errP, const hestParm *parm);
 HEST_EXPORT void *hestParseFree(hestOpt *opt);
 HEST_EXPORT void hestParseOrDie(hestOpt *opt, int argc, const char **argv,
                                 hestParm *parm,
@@ -220,10 +250,11 @@
                                const char *_str, int bslash);
 HEST_EXPORT int hestMinNumArgs(hestOpt *opt);
 HEST_EXPORT void hestUsage(FILE *file, hestOpt *opt, const char *argv0,
-                           hestParm *parm);
-HEST_EXPORT void hestGlossary(FILE *file, hestOpt *opt, hestParm *parm);
+                           const hestParm *parm);
+HEST_EXPORT void hestGlossary(FILE *file, hestOpt *opt,
+                              const hestParm *parm);
 HEST_EXPORT void hestInfo(FILE *file, const char *argv0, const char *info,
-                          hestParm *parm);
+                          const hestParm *parm);
 
 #ifdef __cplusplus
 }
diff --color -ruN teem-1.11.0-src.orig/src/hest/methodsHest.c teem-1.11.0-src/src/hest/methodsHest.c
--- teem-1.11.0-src.orig/src/hest/methodsHest.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/methodsHest.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -54,6 +54,10 @@
     parm->respFileComment = hestRespFileComment;
     parm->varParamStopFlag = hestVarParamStopFlag;
     parm->multiFlagSep = hestMultiFlagSep;
+    /* for these most recent addition to the hestParm,
+       abstaining from added yet another default globals */
+    parm->dieLessVerbose = AIR_FALSE;
+    parm->noBlankLineBeforeUsage = AIR_FALSE;
   }
   return parm;
 }
@@ -77,6 +81,7 @@
   opt->CB = NULL;
   opt->sawP = NULL;
   opt->kind = opt->alloc = 0;
+  opt->source = hestSourceUnknown;
 }
 
 /*
@@ -93,7 +98,11 @@
 }
 */
 
-void
+/*
+** as of Sept 2013 this returns information: the index of the
+** option just added.  Returns UINT_MAX in case of error.
+*/
+unsigned int
 hestOptAdd(hestOpt **optP,
            const char *flag, const char *name,
            int type, int min, int max,
@@ -101,17 +110,18 @@
   hestOpt *ret = NULL;
   int num;
   va_list ap;
-  void *dummy = NULL;
+  unsigned int retIdx;
 
   if (!optP)
-    return;
+    return UINT_MAX;
 
   num = *optP ? _hestNumOpts(*optP) : 0;
   if (!( ret = AIR_CALLOC(num+2, hestOpt) )) {
-    return;
+    return UINT_MAX;
   }
   if (num)
     memcpy(ret, *optP, num*sizeof(hestOpt));
+  retIdx = AIR_UINT(num);
   ret[num].flag = airStrdup(flag);
   ret[num].name = airStrdup(name);
   ret[num].type = type;
@@ -124,6 +134,8 @@
   ret[num].sawP = NULL;
   ret[num].enm = NULL;
   ret[num].CB = NULL;
+  /* seems to be redundant with above _hestOptInit() */
+  ret[num].source = hestSourceUnknown;
   /* deal with var args */
   if (5 == _hestKind(&(ret[num]))) {
     va_start(ap, info);
@@ -132,14 +144,14 @@
   }
   if (airTypeEnum == type) {
     va_start(ap, info);
-    dummy = (void *)(va_arg(ap, unsigned int*));  /* skip sawP */
+    va_arg(ap, unsigned int*);  /* skip sawP */
     ret[num].enm = va_arg(ap, airEnum*);
     va_end(ap);
   }
   if (airTypeOther == type) {
     va_start(ap, info);
-    dummy = (void *)(va_arg(ap, unsigned int*));      /* skip sawP */
-    dummy = (void *)(va_arg(ap, airEnum*));  /* skip enm */
+    va_arg(ap, unsigned int*);  /* skip sawP */
+    va_arg(ap, airEnum*);       /* skip enm */
     ret[num].CB = va_arg(ap, hestCB*);
     va_end(ap);
   }
@@ -148,8 +160,7 @@
   if (*optP)
     free(*optP);
   *optP = ret;
-  AIR_UNUSED(dummy);
-  return;
+  return retIdx;
 }
 
 void
@@ -223,7 +234,7 @@
 ** how to identify an option in error and usage messages
 */
 char *
-_hestIdent(char *ident, hestOpt *opt, hestParm *parm, int brief) {
+_hestIdent(char *ident, hestOpt *opt, const hestParm *parm, int brief) {
   char copy[AIR_STRLEN_HUGE], *sep;
 
   if (opt->flag && (sep = strchr(opt->flag, parm->multiFlagSep))) {
@@ -254,7 +265,7 @@
 }
 
 int
-_hestKind(hestOpt *opt) {
+_hestKind(const hestOpt *opt) {
   int max;
 
   max = _hestMax(opt->max);
@@ -308,7 +319,7 @@
 ** marker (according to parm->varParamStopFlag)
 */
 int
-_hestWhichFlag(hestOpt *opt, char *flag, hestParm *parm) {
+_hestWhichFlag(hestOpt *opt, char *flag, const hestParm *parm) {
   char buff[AIR_STRLEN_HUGE], copy[AIR_STRLEN_HUGE], *sep;
   int op, numOpts;
 
@@ -430,7 +441,7 @@
 }
 
 int
-_hestNumOpts(hestOpt *opt) {
+_hestNumOpts(const hestOpt *opt) {
   int num = 0;
 
   while (opt[num].flag || opt[num].name || opt[num].type) {
diff --color -ruN teem-1.11.0-src.orig/src/hest/parseHest.c teem-1.11.0-src/src/hest/parseHest.c
--- teem-1.11.0-src.orig/src/hest/parseHest.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/parseHest.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -46,7 +46,8 @@
 */
 int
 _hestArgsInResponseFiles(int *argcP, int *nrfP,
-                         const char **argv, char *err, hestParm *parm) {
+                         const char **argv, char *err,
+                         const hestParm *parm) {
   FILE *file;
   char me[]="_hestArgsInResponseFiles: ", line[AIR_STRLEN_HUGE], *pound;
   int ai, len;
@@ -61,6 +62,10 @@
   ai = 0;
   while (argv[ai]) {
     if (parm->respFileFlag == argv[ai][0]) {
+      /* NOTE: despite the repeated temptation: "-" aka stdin cannot
+         be a response file, because it is going to be read in twice:
+         once by _hestArgsInResponseFiles, and then again by
+         _hestResponseFiles */
       if (!(file = fopen(argv[ai]+1, "rb"))) {
         /* can't open the indicated response file for reading */
         sprintf(err, "%scouldn't open \"%s\" for reading as response file",
@@ -77,7 +82,9 @@
         *argcP += airStrntok(line, AIR_WHITESPACE);
         len = airOneLine(file, line, AIR_STRLEN_HUGE);
       }
-      fclose(file);
+      if (stdin != file) {
+        fclose(file);
+      }
       (*nrfP)++;
     }
     ai++;
@@ -94,7 +101,7 @@
 */
 int
 _hestResponseFiles(char **newArgv, const char **oldArgv,
-                   hestParm *parm, airArray *pmop) {
+                   const hestParm *parm, airArray *pmop) {
   char line[AIR_STRLEN_HUGE], *pound;
   int len, newArgc, oldArgc, incr, ai;
   FILE *file;
@@ -161,7 +168,7 @@
 ** the opt struct
 */
 int
-_hestPanic(hestOpt *opt, char *err, hestParm *parm) {
+_hestPanic(hestOpt *opt, char *err, const hestParm *parm) {
   char me[]="_hestPanic: ", tbuff[AIR_STRLEN_HUGE], *sep;
   int numvar, op, numOpts;
 
@@ -348,7 +355,7 @@
 }
 
 int
-_hestErrStrlen(hestOpt *opt, int argc, const char **argv) {
+_hestErrStrlen(const hestOpt *opt, int argc, const char **argv) {
   int a, numOpts, ret, other;
 
   ret = 0;
@@ -393,7 +400,7 @@
 _hestExtractFlagged(char **prms, unsigned int *nprm, int *appr,
                      int *argcP, char **argv,
                      hestOpt *opt,
-                     char *err, hestParm *parm, airArray *pmop) {
+                     char *err, const hestParm *parm, airArray *pmop) {
   char me[]="_hestExtractFlagged: ", ident1[AIR_STRLEN_HUGE],
     ident2[AIR_STRLEN_HUGE];
   int a, np, flag, endflag, numOpts, op;
@@ -501,7 +508,7 @@
 _hestExtractUnflagged(char **prms, unsigned int *nprm,
                       int *argcP, char **argv,
                       hestOpt *opt,
-                      char *err, hestParm *parm, airArray *pmop) {
+                      char *err, const hestParm *parm, airArray *pmop) {
   char me[]="_hestExtractUnflagged: ", ident[AIR_STRLEN_HUGE];
   int nvp, np, op, unflag1st, unflagVar, numOpts;
 
@@ -604,7 +611,7 @@
 int
 _hestDefaults(char **prms, int *udflt, unsigned int *nprm, int *appr,
               hestOpt *opt,
-              char *err, hestParm *parm, airArray *mop) {
+              char *err, const hestParm *parm, airArray *mop) {
   char *tmpS, me[]="_hestDefaults: ", ident[AIR_STRLEN_HUGE];
   int op, numOpts;
 
@@ -617,8 +624,11 @@
     switch(opt[op].kind) {
     case 1:
       /* -------- (no-parameter) boolean flags -------- */
-      /* default is always ignored */
-      udflt[op] = 0;
+      /* default is indeed always ignored for the sake of setting the
+         option's value, but udflt is used downstream to set
+         the option's source. The info came from the user if
+         the flag appears, otherwise it is from the default. */
+      udflt[op] = !appr[op];
       break;
     case 2:
     case 3:
@@ -657,7 +667,7 @@
       airOneLinify(prms[op]);
       tmpS = airStrdup(prms[op]);
       nprm[op] = airStrntok(tmpS, " ");
-      tmpS = (char *)airFree(tmpS);
+      airFree(tmpS);
       /* printf("!%s: nprm[%d] in default = %u\n", me, op, nprm[op]); */
       if ((int)opt[op].min < _hestMax(opt[op].max)) { /* HEY scrutinize casts */
         if (!( AIR_IN_CL((int)opt[op].min, (int)nprm[op], _hestMax(opt[op].max)) /* HEY scrutinize casts */
@@ -721,7 +731,7 @@
 int
 _hestSetValues(char **prms, int *udflt, unsigned int *nprm, int *appr,
                hestOpt *opt,
-               char *err, hestParm *parm, airArray *pmop) {
+               char *err, const hestParm *parm, airArray *pmop) {
   char ident[AIR_STRLEN_HUGE], me[]="_hestSetValues: ",
     cberr[AIR_STRLEN_HUGE], *tok, *last, *prmsCopy;
   double tmpD;
@@ -733,6 +743,7 @@
   numOpts = _hestNumOpts(opt);
   for (op=0; op<numOpts; op++) {
     _hestIdent(ident, opt+op, parm, AIR_TRUE);
+    opt[op].source = udflt[op] ? hestSourceDefault : hestSourceUser;
     type = opt[op].type;
     size = (airTypeEnum == type
             ? (int)sizeof(int)             /* HEY scrutinize casts */
@@ -962,7 +973,8 @@
       break;
     case 5:
       /* -------- multiple optional parameters -------- */
-      /* hammerhead problems in this case */
+      /* hammerhead problems in this case;
+         may have been from calloc(0), fixed below */
       if (prms[op] && vP) {
         if (1 == _hestCase(opt, udflt, nprm, appr, op)) {
           *((void**)vP) = NULL;
@@ -973,13 +985,21 @@
                the resulting char** is, like argv, NULL-terminated */
             *((void**)vP) = calloc(nprm[op]+1, size);
           } else {
-            *((void**)vP) = calloc(nprm[op], size);
+            if (nprm[op]) {
+              /* only allocate if there's something to allocate */
+              *((void**)vP) = calloc(nprm[op], size);
+            } else {
+              *((void**)vP) = NULL;
+            }
           }
           if (parm->verbosity) {
             printf("!%s: nprm[%d] = %u\n", me, op, nprm[op]);
-            printf("!%s: new array is at 0x%p\n", me, *((void**)vP));
+            printf("!%s: new array (size %u*%u) is at 0x%p\n", me,
+                   nprm[op], (unsigned int)size, *((void**)vP));
+          }
+          if (*((void**)vP)) {
+            airMopMem(pmop, vP, airMopOnError);
           }
-          airMopMem(pmop, vP, airMopOnError);
           *(opt[op].sawP) = nprm[op];
           /* so far everything we've done is regardless of type */
           switch (type) {
@@ -1080,7 +1100,7 @@
 */
 int
 hestParse(hestOpt *opt, int _argc, const char **_argv,
-          char **_errP, hestParm *_parm) {
+          char **_errP, const hestParm *_parm) {
   char me[]="hestParse: ";
   char *param, *param_copy;
   char **argv, **prms, *err;
@@ -1097,12 +1117,14 @@
 
   /* -------- either copy given _parm, or allocate one */
   if (_parm) {
-    parm = _parm;
+    parm = NULL;
   }
   else {
     parm = hestParmNew();
     airMopAdd(mop, parm, (airMopper)hestParmFree, airMopAlways);
   }
+  /* how to const-correctly use parm or _parm in an expression */
+#define PARM (_parm ? _parm : parm)
 
   /* -------- allocate the err string.  To determine its size with total
      ridiculous safety we have to find the biggest things which can appear
@@ -1127,7 +1149,7 @@
   }
 
   /* -------- check on validity of the hestOpt array */
-  if (_hestPanic(opt, err, parm)) {
+  if (_hestPanic(opt, err, PARM)) {
     airMopError(mop); return 1;
   }
 
@@ -1149,12 +1171,12 @@
      by seeing how many args are in the response files, and then adding
      on the args from the actual argv (getting this right the first time
      greatly simplifies the problem of eliminating memory leaks) */
-  if (_hestArgsInResponseFiles(&argr, &nrf, _argv, err, parm)) {
+  if (_hestArgsInResponseFiles(&argr, &nrf, _argv, err, PARM)) {
     airMopError(mop); return 1;
   }
   argc = argr + _argc - nrf;
 
-  if (parm->verbosity) {
+  if (PARM->verbosity) {
     printf("!%s: nrf = %d; argr = %d; _argc = %d --> argc = %d\n",
            me, nrf, argr, _argc, argc);
   }
@@ -1163,37 +1185,37 @@
 
   /* -------- process response files (if any) and set the remaining
      elements of argv */
-  if (parm->verbosity) printf("%s: #### calling hestResponseFiles\n", me);
-  if (_hestResponseFiles(argv, _argv, parm, mop)) {
+  if (PARM->verbosity) printf("%s: #### calling hestResponseFiles\n", me);
+  if (_hestResponseFiles(argv, _argv, PARM, mop)) {
     airMopError(mop); return 1;
   }
-  if (parm->verbosity) printf("%s: #### hestResponseFiles done!\n", me);
+  if (PARM->verbosity) printf("%s: #### hestResponseFiles done!\n", me);
   /*
   _hestPrintArgv(argc, argv);
   */
 
   /* -------- extract flags and their associated parameters from argv */
-  if (parm->verbosity) printf("%s: #### calling hestExtractFlagged\n", me);
+  if (PARM->verbosity) printf("%s: #### calling hestExtractFlagged\n", me);
   if (_hestExtractFlagged(prms, nprm, appr,
                            &argc, argv,
                            opt,
-                           err, parm, mop)) {
+                           err, PARM, mop)) {
     airMopError(mop); return 1;
   }
-  if (parm->verbosity) printf("%s: #### hestExtractFlagged done!\n", me);
+  if (PARM->verbosity) printf("%s: #### hestExtractFlagged done!\n", me);
   /*
   _hestPrintArgv(argc, argv);
   */
 
   /* -------- extract args for unflagged options */
-  if (parm->verbosity) printf("%s: #### calling hestExtractUnflagged\n", me);
+  if (PARM->verbosity) printf("%s: #### calling hestExtractUnflagged\n", me);
   if (_hestExtractUnflagged(prms, nprm,
                             &argc, argv,
                             opt,
-                            err, parm, mop)) {
+                            err, PARM, mop)) {
     airMopError(mop); return 1;
   }
-  if (parm->verbosity) printf("%s: #### hestExtractUnflagged done!\n", me);
+  if (PARM->verbosity) printf("%s: #### hestExtractUnflagged done!\n", me);
 
   /* currently, any left over arguments indicate error */
   if (argc) {
@@ -1205,18 +1227,18 @@
   }
 
   /* -------- learn defaults */
-  if (parm->verbosity) printf("%s: #### calling hestDefaults\n", me);
+  if (PARM->verbosity) printf("%s: #### calling hestDefaults\n", me);
   if (_hestDefaults(prms, udflt, nprm, appr,
                     opt,
-                    err, parm, mop)) {
+                    err, PARM, mop)) {
     airMopError(mop); return 1;
   }
-  if (parm->verbosity) printf("%s: #### hestDefaults done!\n", me);
+  if (PARM->verbosity) printf("%s: #### hestDefaults done!\n", me);
 
   /* remove quotes from strings
          if greedy wasn't turned on for strings, then we have no hope
          of capturing filenames with spaces. */
-  if ( parm->greedySingleString ) {
+  if ( PARM->greedySingleString ) {
     for (i=0; i<numOpts; i++) {
       param = prms[i];
       param_copy = NULL;
@@ -1238,15 +1260,16 @@
 
   /* -------- now, the actual parsing of values */
   /* hammerhead problems in _hestSetValues */
-  if (parm->verbosity) printf("%s: #### calling hestSetValues\n", me);
+  if (PARM->verbosity) printf("%s: #### calling hestSetValues\n", me);
   ret = _hestSetValues(prms, udflt, nprm, appr,
                        opt,
-                       err, parm, mop);
+                       err, PARM, mop);
   if (ret) {
     airMopError(mop); return ret;
   }
 
-  if (parm->verbosity) printf("%s: #### hestSetValues done!\n", me);
+  if (PARM->verbosity) printf("%s: #### hestSetValues done!\n", me);
+#undef PARM
 
   airMopOkay(mop);
   return 0;
@@ -1346,8 +1369,7 @@
                hestParm *parm,
                const char *me, const char *info,
                int doInfo, int doUsage, int doGlossary) {
-  int E;
-  int argcBad;
+  int E, argcBad, wantHelp=AIR_FALSE;
   char *errS;
 
   if (opt) {
@@ -1363,25 +1385,39 @@
       if (E) {
         if (argv[0] && !strcmp(argv[0], "--version")) {
           /* print version info and bail */
-          printf("Teem version %s (%s)\n",
-                 airTeemVersion, airTeemReleaseDate);
+          char vbuff[AIR_STRLEN_LARGE];
+          airTeemVersionSprint(vbuff);
+          printf("%s\n", vbuff);
           hestParmFree(parm);
           hestOptFree(opt);
           exit(0);
         } else if (argv[0] && !strcmp(argv[0], "--help")) {
           /* actually, not an error, they were asking for help */
+          wantHelp=AIR_TRUE;
           E = 0;
         } else {
           fprintf(stderr, "ERROR: %s\n", errS);
         }
         free(errS);
       }
-      if (!E) {
-        /* no error, just !argc */
-        if (doInfo && info) hestInfo(stdout, me?me:"", info, parm);
+      if (parm && parm->dieLessVerbose) {
+        /* newer logic for when to print which things */
+        if (wantHelp && info) hestInfo(stdout, me?me:"", info, parm);
+        if (doUsage) hestUsage(E ? stderr : stdout, opt, me?me:"", parm);
+        if (wantHelp && doGlossary) {
+          hestGlossary(E ? stderr : stdout, opt, parm);
+        } else if ((!argc || E) && me) {
+          printf("\"%s --help\" for more information\n", me);
+        }
+      } else {
+        /* leave older (pre-dieLessVerbose) logic as is */
+        if (!E) {
+          /* no error, just !argc */
+          if (doInfo && info) hestInfo(stdout, me?me:"", info, parm);
+        }
+        if (doUsage) hestUsage(E ? stderr : stdout, opt, me?me:"", parm);
+        if (doGlossary) hestGlossary(E ? stderr : stdout, opt, parm);
       }
-      if (doUsage) hestUsage(E ? stderr : stdout, opt, me?me:"", parm);
-      if (doGlossary) hestGlossary(E ? stderr : stdout, opt, parm);
       hestParmFree(parm);
       hestOptFree(opt);
       exit(1);
diff --color -ruN teem-1.11.0-src.orig/src/hest/privateHest.h teem-1.11.0-src/src/hest/privateHest.h
--- teem-1.11.0-src.orig/src/hest/privateHest.h	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/privateHest.h	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -29,19 +29,20 @@
 #endif
 
 /* methodsHest.c */
-extern char *_hestIdent(char *ident, hestOpt *opt, hestParm *parm, int brief);
-extern int _hestKind(hestOpt *opt);
+extern char *_hestIdent(char *ident, hestOpt *opt,
+                        const hestParm *parm, int brief);
+extern int _hestKind(const hestOpt *opt);
 extern void _hestPrintArgv(int argc, char **argv);
-extern int _hestWhichFlag(hestOpt *opt, char *flag, hestParm *parm);
+extern int _hestWhichFlag(hestOpt *opt, char *flag, const hestParm *parm);
 extern int _hestCase(hestOpt *opt, int *udflt, unsigned int *nprm, int *appr, int op);
 extern char *_hestExtract(int *argcP, char **argv,
                           unsigned int base, unsigned int pnum);
-extern int _hestNumOpts(hestOpt *opt);
+extern int _hestNumOpts(const hestOpt *opt);
 extern int _hestMax(int max);
 
 /* parseHest.c */
-extern int _hestPanic(hestOpt *opt, char *err, hestParm *parm);
-extern int _hestErrStrlen(hestOpt *opt, int argc, const char **argv);
+extern int _hestPanic(hestOpt *opt, char *err, const hestParm *parm);
+extern int _hestErrStrlen(const hestOpt *opt, int argc, const char **argv);
 
 #ifdef __cplusplus
 }
diff --color -ruN teem-1.11.0-src.orig/src/hest/sources.cmake teem-1.11.0-src/src/hest/sources.cmake
--- teem-1.11.0-src.orig/src/hest/sources.cmake	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,12 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(HEST_SOURCES
-  defaultsHest.c
-  hest.h
-  methodsHest.c
-  parseHest.c
-  privateHest.h
-  usage.c
-  )
-
-ADD_TEEM_LIBRARY(hest ${HEST_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/hest/test/bday.c teem-1.11.0-src/src/hest/test/bday.c
--- teem-1.11.0-src.orig/src/hest/test/bday.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/test/bday.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hest/test/ex0.c teem-1.11.0-src/src/hest/test/ex0.c
--- teem-1.11.0-src.orig/src/hest/test/ex0.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/test/ex0.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hest/test/ex1.c teem-1.11.0-src/src/hest/test/ex1.c
--- teem-1.11.0-src.orig/src/hest/test/ex1.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/test/ex1.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hest/test/ex2.c teem-1.11.0-src/src/hest/test/ex2.c
--- teem-1.11.0-src.orig/src/hest/test/ex2.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/test/ex2.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hest/test/ex3.c teem-1.11.0-src/src/hest/test/ex3.c
--- teem-1.11.0-src.orig/src/hest/test/ex3.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/test/ex3.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hest/test/ex4.c teem-1.11.0-src/src/hest/test/ex4.c
--- teem-1.11.0-src.orig/src/hest/test/ex4.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/test/ex4.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hest/test/ex5.c teem-1.11.0-src/src/hest/test/ex5.c
--- teem-1.11.0-src.orig/src/hest/test/ex5.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/test/ex5.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -50,17 +51,21 @@
   int howMany, i, N;
   hestOpt *opt = NULL;
   char *err = NULL;
+  unsigned int copi, opi, opn;
 
   hestOptAdd(&opt, "A",      "token",           airTypeOther, 1,  1, &single,
              "alpha",        "testing A",       NULL,  NULL,  &cbinfo);
   hestOptAdd(&opt, "B",      "tok1 tok2 tok3",  airTypeOther, 3,  3, triple,
              "beta psi rho", "testing B",       NULL,  NULL,  &cbinfo);
-  hestOptAdd(&opt, "C",      "mtok",            airTypeOther, 0,  1, &maybe,
-             "gamma",        "testing C",       NULL,  NULL,  &cbinfo);
+  copi =
+    hestOptAdd(&opt,"C",     "mtok",            airTypeOther, 0,  1, &maybe,
+               "gamma",        "testing C",       NULL,  NULL,  &cbinfo);
   hestOptAdd(&opt, "D",      "tok",             airTypeOther, 1, -1, &many,
              "kappa omega",  "testing D",       &howMany, NULL, &cbinfo);
-  hestOptAdd(&opt, "int",    "N",               airTypeInt,   1,  1, &N,
-             NULL,           "an integer");
+  opn =
+    hestOptAdd(&opt, "int",  "N",               airTypeInt,   1,  1, &N,
+               NULL,           "an integer");
+  opn++;
 
   if (hestParse(opt, argc-1, argv+1, &err, NULL)) {
     fprintf(stderr, "ERROR: %s\n", err); free(err);
@@ -78,6 +83,11 @@
   }
   printf("\n");
 
+  printf("source(%s) = %d\n\n", opt[copi].flag, opt[copi].source);
+  for (opi=0; opi<opn; opi++) {
+    printf("source(opt[%u]) = %d\n", opi, opt[opi].source);
+  }
+
   hestParseFree(opt);
   exit(0);
 }
diff --color -ruN teem-1.11.0-src.orig/src/hest/test/strings.c teem-1.11.0-src/src/hest/test/strings.c
--- teem-1.11.0-src.orig/src/hest/test/strings.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/test/strings.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hest/test/tmpl.c teem-1.11.0-src/src/hest/test/tmpl.c
--- teem-1.11.0-src.orig/src/hest/test/tmpl.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/test/tmpl.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hest/TODO.txt teem-1.11.0-src/src/hest/TODO.txt
--- teem-1.11.0-src.orig/src/hest/TODO.txt	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/TODO.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,5 +1,10 @@
-make new calls for setting the different kinds of options, so that
-reliance on var-args is minimized
+How is it that, once the command-line has been parsed, there isn't an
+easy way to see (or print, for an error message) the parameter (or
+concatenation of parameters) that was passed for a given option?
+Want to be able to have error messages like "you passed %s to the -i
+option but that has a problem: ..."
+Should add a new output field in hestOpt, alongside "source",
+to store this new single string.
 
 for super long things like "tend glyph", it would be nice to have
 seperator lines between the long versions of options, to visually
@@ -8,27 +13,3 @@
 currently the "input nrrd" option to unu comes last as a way of allowing
 hest to do error checking on all other (more error prone) options.  But
 it would be nice to indicate a parsing order seperate from the option order.
-
-basic problems with hest:
-
-- there's no such thing as a trully optional parameter: data is needed
-for all options, whether it comes from the default string or the
-command line, and its an error if no data is found.  Not having
-optional parameters is getting in the way of things like allowing "unu
-make" taking centerings.
-
-- there's no way to tell whether the information for any given option 
-came from the default string, or from the command line
-
-- there's no way to access the string that was parsed to get the
-information for an option (could be from default, or command-line,
-or response file)
-
-- (from tendGlyph.c): learned: a huge problem with hest and its
-var-arg-based hestOptAdd is that it can't tell when you've based
-multiple strings for the detailed usage information by accident.  I
-had accidentally inserted a comma into my multi-line string for the
-"info" arg, relying on the automatic string concatenation, and ended
-up passing total garbage to hestOptAdd for the airEnum pointer,
-causing me to think that the tenGlyphType airEnum was malformed, when
-it was in fact fine ... 
diff --color -ruN teem-1.11.0-src.orig/src/hest/usage.c teem-1.11.0-src/src/hest/usage.c
--- teem-1.11.0-src.orig/src/hest/usage.c	2012-12-20 22:07:59.000000000 +0800
+++ teem-1.11.0-src/src/hest/usage.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -28,7 +28,8 @@
 ** don't ask
 */
 void
-_hestSetBuff(char *B, hestOpt *O, hestParm *P, int showshort, int showlong) {
+_hestSetBuff(char *B, const hestOpt *O, const hestParm *P,
+             int showshort, int showlong) {
   char copy[AIR_STRLEN_HUGE], *sep;
   int max; unsigned int len;
 
@@ -185,7 +186,7 @@
 
   parm = hestParmNew();
   if (_hestPanic(opt, NULL, parm)) {
-    parm = hestParmFree(parm);
+    hestParmFree(parm);
     return _hestMax(-1);
   }
   count = 0;
@@ -198,76 +199,94 @@
       }
     }
   }
-  parm = hestParmFree(parm);
+  hestParmFree(parm);
   return count;
 }
 
 void
-hestInfo(FILE *file, const char *argv0, const char *info, hestParm *_parm) {
+hestInfo(FILE *file, const char *argv0, const char *info,
+         const hestParm *_parm) {
   hestParm *parm;
 
-  parm = !_parm ? hestParmNew() : _parm;
+  parm = _parm ? NULL : hestParmNew();
+  /* how to const-correctly use parm or _parm in an expression */
+#define PARM (_parm ? _parm : parm)
+
   if (info) {
     if (argv0) {
       fprintf(file, "\n%s: ", argv0);
       _hestPrintStr(file, 0, AIR_UINT(strlen(argv0)) + 2,
-                    parm->columns, info, AIR_FALSE);
+                    PARM->columns, info, AIR_FALSE);
+      if (PARM->noBlankLineBeforeUsage) {
+        /* we still want a blank line to separate info and usage */
+        fprintf(file, "\n");
+      }
     } else {
       fprintf(file, "ERROR: hestInfo got NULL argv0\n");
     }
   }
-  parm = !_parm ? hestParmFree(parm) : NULL;
+  if (parm) {
+    hestParmFree(parm);
+  }
 }
 
 void
-hestUsage(FILE *f, hestOpt *opt, const char *argv0, hestParm *_parm) {
+hestUsage(FILE *f, hestOpt *opt, const char *argv0,
+          const hestParm *_parm) {
   int i, numOpts;
   char buff[2*AIR_STRLEN_HUGE], tmpS[AIR_STRLEN_HUGE];
   hestParm *parm;
 
-  parm = !_parm ? hestParmNew() : _parm;
+  parm = _parm ? NULL : hestParmNew();
 
-  if (_hestPanic(opt, NULL, parm)) {
+  if (_hestPanic(opt, NULL, PARM)) {
     /* we can't continue; the opt array is botched */
-    parm = !_parm ? hestParmFree(parm) : NULL;
+    if (parm) {
+      hestParmFree(parm);
+    }
     return;
   }
 
   numOpts = _hestNumOpts(opt);
-  fprintf(f, "\n");
+  if (!(PARM->noBlankLineBeforeUsage)) {
+    fprintf(f, "\n");
+  }
   strcpy(buff, "Usage: ");
   strcat(buff, argv0 ? argv0 : "");
-  if (parm && parm->respFileEnable) {
-    sprintf(tmpS, " [%cfile\t...]", parm->respFileFlag);
+  if (PARM->respFileEnable) {
+    sprintf(tmpS, " [%cfile\t...]", PARM->respFileFlag);
     strcat(buff, tmpS);
   }
   for (i=0; i<numOpts; i++) {
     strcat(buff, " ");
     if (1 == opt[i].kind || (opt[i].flag && opt[i].dflt))
       strcat(buff, "[");
-    _hestSetBuff(buff, opt + i, parm, AIR_TRUE, AIR_TRUE);
+    _hestSetBuff(buff, opt + i, PARM, AIR_TRUE, AIR_TRUE);
     if (1 == opt[i].kind || (opt[i].flag && opt[i].dflt))
       strcat(buff, "]");
   }
 
   _hestPrintStr(f, AIR_UINT(strlen("Usage: ")), 0,
-                parm->columns, buff, AIR_TRUE);
-
-  parm = !_parm ? hestParmFree(parm) : NULL;
+                PARM->columns, buff, AIR_TRUE);
+  if (parm) {
+    hestParmFree(parm);
+  }
   return;
 }
 
 void
-hestGlossary(FILE *f, hestOpt *opt, hestParm *_parm) {
+hestGlossary(FILE *f, hestOpt *opt, const hestParm *_parm) {
   int i, j, maxlen, numOpts; unsigned int len;
   char buff[2*AIR_STRLEN_HUGE], tmpS[AIR_STRLEN_HUGE];
   hestParm *parm;
 
-  parm = !_parm ? hestParmNew() : _parm;
+  parm = _parm ? NULL : hestParmNew();
 
-  if (_hestPanic(opt, NULL, parm)) {
+  if (_hestPanic(opt, NULL, PARM)) {
     /* we can't continue; the opt array is botched */
-    parm = !_parm ? hestParmFree(parm) : NULL;
+    if (parm) {
+      hestParmFree(parm);
+    }
     return;
   }
 
@@ -279,22 +298,22 @@
   }
   for (i=0; i<numOpts; i++) {
     strcpy(buff, "");
-    _hestSetBuff(buff, opt + i, parm, AIR_TRUE, AIR_FALSE);
+    _hestSetBuff(buff, opt + i, PARM, AIR_TRUE, AIR_FALSE);
     maxlen = AIR_MAX((int)strlen(buff), maxlen);
   }
-  if (parm && parm->respFileEnable) {
-    sprintf(buff, "%cfile ...", parm->respFileFlag);
+  if (PARM->respFileEnable) {
+    sprintf(buff, "%cfile ...", PARM->respFileFlag);
     len = AIR_UINT(strlen(buff));
     for (j=len; j<maxlen; j++) {
       fprintf(f, " ");
     }
     fprintf(f, "%s = ", buff);
     strcpy(buff, "response file(s) containing command-line arguments");
-    _hestPrintStr(f, maxlen + 3, maxlen + 3, parm->columns, buff, AIR_FALSE);
+    _hestPrintStr(f, maxlen + 3, maxlen + 3, PARM->columns, buff, AIR_FALSE);
   }
   for (i=0; i<numOpts; i++) {
     strcpy(buff, "");
-    _hestSetBuff(buff, opt + i, parm, AIR_TRUE, AIR_FALSE);
+    _hestSetBuff(buff, opt + i, PARM, AIR_TRUE, AIR_FALSE);
     airOneLinify(buff);
     len = AIR_UINT(strlen(buff));
     for (j=len; j<maxlen; j++) {
@@ -303,9 +322,9 @@
     fprintf(f, "%s", buff);
     strcpy(buff, "");
 #if 1
-    if (opt[i].flag && strchr(opt[i].flag, parm->multiFlagSep)) {
+    if (opt[i].flag && strchr(opt[i].flag, PARM->multiFlagSep)) {
       /* there is a long-form flag as well as short */
-      _hestSetBuff(buff, opt + i, parm, AIR_FALSE, AIR_TRUE);
+      _hestSetBuff(buff, opt + i, PARM, AIR_FALSE, AIR_TRUE);
       strcat(buff, " = ");
       fprintf(f, " , ");
     } else {
@@ -321,10 +340,10 @@
     if ((opt[i].min || _hestMax(opt[i].max))
         && (!( 2 == opt[i].kind
                && airTypeEnum == opt[i].type
-               && parm->elideSingleEnumType ))
+               && PARM->elideSingleEnumType ))
         && (!( 2 == opt[i].kind
                && airTypeOther == opt[i].type
-               && parm->elideSingleOtherType ))
+               && PARM->elideSingleOtherType ))
         ) {
       /* if there are newlines in the info, then we want to clarify the
          type by printing it on its own line */
@@ -362,7 +381,7 @@
               (_hestMax(opt[i].max) > 1
                ? (airTypeOther == opt[i].type
                   && 'y' == opt[i].CB->type[airStrlen(opt[i].CB->type)-1]
-                  && parm->cleverPluralizeOtherY
+                  && PARM->cleverPluralizeOtherY
                   ? "\bies"
                   : "s")
                : ""));
@@ -370,29 +389,29 @@
       strcat(buff, ")");
     }
     /*
-    fprintf(stderr, "!%s: parm->elideSingleOtherDefault = %d\n",
-            "hestGlossary", parm->elideSingleOtherDefault);
+    fprintf(stderr, "!%s: PARM->elideSingleOtherDefault = %d\n",
+            "hestGlossary", PARM->elideSingleOtherDefault);
     */
     if (opt[i].dflt
         && (opt[i].min || _hestMax(opt[i].max))
         && (!( 2 == opt[i].kind
                && (airTypeFloat == opt[i].type || airTypeDouble == opt[i].type)
                && !AIR_EXISTS(airAtod(opt[i].dflt))
-               && parm->elideSingleNonExistFloatDefault ))
+               && PARM->elideSingleNonExistFloatDefault ))
         && (!( (3 == opt[i].kind || 5 == opt[i].kind)
                && (airTypeFloat == opt[i].type || airTypeDouble == opt[i].type)
                && !AIR_EXISTS(airAtod(opt[i].dflt))
-               && parm->elideMultipleNonExistFloatDefault ))
+               && PARM->elideMultipleNonExistFloatDefault ))
         && (!( 2 == opt[i].kind
                && airTypeOther == opt[i].type
-               && parm->elideSingleOtherDefault ))
+               && PARM->elideSingleOtherDefault ))
         && (!( 2 == opt[i].kind
                && airTypeString == opt[i].type
-               && parm->elideSingleEmptyStringDefault
+               && PARM->elideSingleEmptyStringDefault
                && 0 == airStrlen(opt[i].dflt) ))
         && (!( (3 == opt[i].kind || 5 == opt[i].kind)
                && airTypeString == opt[i].type
-               && parm->elideMultipleEmptyStringDefault
+               && PARM->elideMultipleEmptyStringDefault
                && 0 == airStrlen(opt[i].dflt) ))
         ) {
       /* if there are newlines in the info, then we want to clarify the
@@ -410,10 +429,14 @@
       strcat(buff, tmpS);
       strcat(buff, "\"");
     }
-    _hestPrintStr(f, maxlen + 3, maxlen + 3, parm->columns, buff, AIR_FALSE);
+    _hestPrintStr(f, maxlen + 3, maxlen + 3, PARM->columns, buff, AIR_FALSE);
+  }
+  if (parm) {
+    hestParmFree(parm);
   }
-  parm = !_parm ? hestParmFree(parm) : NULL;
 
   return;
 }
 
+#undef PARM
+
diff --color -ruN teem-1.11.0-src.orig/src/hex/CMakeLists.txt teem-1.11.0-src/src/hex/CMakeLists.txt
--- teem-1.11.0-src.orig/src/hex/CMakeLists.txt	2012-12-20 22:08:39.000000000 +0800
+++ teem-1.11.0-src/src/hex/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
-# Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Teem: Tools to process and visualize scientific data and images
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -21,10 +21,10 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-ADD_EXECUTABLE(dehex
+add_executable(dehex
  dehex.c
 )
-ADD_EXECUTABLE(enhex
+add_executable(enhex
   enhex.c
-)  
+)
 
diff --color -ruN teem-1.11.0-src.orig/src/hex/dehex.c teem-1.11.0-src/src/hex/dehex.c
--- teem-1.11.0-src.orig/src/hex/dehex.c	2012-12-20 22:08:39.000000000 +0800
+++ teem-1.11.0-src/src/hex/dehex.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hex/enhex.c teem-1.11.0-src/src/hex/enhex.c
--- teem-1.11.0-src.orig/src/hex/enhex.c	2012-12-20 22:08:39.000000000 +0800
+++ teem-1.11.0-src/src/hex/enhex.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hex/README.txt teem-1.11.0-src/src/hex/README.txt
--- teem-1.11.0-src.orig/src/hex/README.txt	2012-12-20 22:08:39.000000000 +0800
+++ teem-1.11.0-src/src/hex/README.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
-# Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Teem: Tools to process and visualize scientific data and images
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -27,7 +27,7 @@
 
 enhex and dehex are a stand-alone hex encoder/decoder pair.
 They convert between data in raw form (paying no regard to the
-endianness), and convert it to hexadecimal form.  
+endianness), and convert it to hexadecimal form.
 
 To compile:
 
diff --color -ruN teem-1.11.0-src.orig/src/hoover/CMakeLists.txt teem-1.11.0-src/src/hoover/CMakeLists.txt
--- teem-1.11.0-src.orig/src/hoover/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/hoover/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -0,0 +1,13 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(HOOVER_SOURCES
+  defaultsHoover.c
+  hoover.h
+  methodsHoover.c
+  rays.c
+  stub.c
+  )
+
+target_sources(teem PRIVATE ${HOOVER_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( hoover FILES ${HOOVER_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/hoover/defaultsHoover.c teem-1.11.0-src/src/hoover/defaultsHoover.c
--- teem-1.11.0-src.orig/src/hoover/defaultsHoover.c	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/hoover/defaultsHoover.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hoover/GNUmakefile teem-1.11.0-src/src/hoover/GNUmakefile
--- teem-1.11.0-src.orig/src/hoover/GNUmakefile	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/hoover/GNUmakefile	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/hoover/hoover.h teem-1.11.0-src/src/hoover/hoover.h
--- teem-1.11.0-src.orig/src/hoover/hoover.h	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/hoover/hoover.h	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hoover/methodsHoover.c teem-1.11.0-src/src/hoover/methodsHoover.c
--- teem-1.11.0-src.orig/src/hoover/methodsHoover.c	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/hoover/methodsHoover.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hoover/rays.c teem-1.11.0-src/src/hoover/rays.c
--- teem-1.11.0-src.orig/src/hoover/rays.c	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/hoover/rays.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/hoover/sources.cmake teem-1.11.0-src/src/hoover/sources.cmake
--- teem-1.11.0-src.orig/src/hoover/sources.cmake	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/hoover/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(HOOVER_SOURCES
-  defaultsHoover.c
-  hoover.h
-  methodsHoover.c
-  rays.c
-  stub.c
-  )
-
-ADD_TEEM_LIBRARY(hoover ${HOOVER_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/hoover/stub.c teem-1.11.0-src/src/hoover/stub.c
--- teem-1.11.0-src.orig/src/hoover/stub.c	2012-12-20 22:07:43.000000000 +0800
+++ teem-1.11.0-src/src/hoover/stub.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/cam.c teem-1.11.0-src/src/limn/cam.c
--- teem-1.11.0-src.orig/src/limn/cam.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/cam.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/CMakeLists.txt teem-1.11.0-src/src/limn/CMakeLists.txt
--- teem-1.11.0-src.orig/src/limn/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/limn/CMakeLists.txt	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,32 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+# NOTE that the lpu_*.c files are not included (no lpu from a CMake build)
+set(LIMN_SOURCES
+  cam.c
+  defaultsLimn.c
+  enumsLimn.c
+  envmap.c
+  hestLimn.c
+  io.c
+  light.c
+  limn.h
+  methodsLimn.c
+  obj.c
+  polydata.c
+  polyfilter.c
+  polymod.c
+  polyshapes.c
+  privateLimn.h
+  qn.c
+  renderLimn.c
+  shapes.c
+  splineEval.c
+  splineMethods.c
+  splineMisc.c
+  splineFit.c
+  transform.c
+  )
+
+target_sources(teem PRIVATE ${LIMN_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( limn FILES ${LIMN_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/limn/defaultsLimn.c teem-1.11.0-src/src/limn/defaultsLimn.c
--- teem-1.11.0-src.orig/src/limn/defaultsLimn.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/defaultsLimn.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/enumsLimn.c teem-1.11.0-src/src/limn/enumsLimn.c
--- teem-1.11.0-src.orig/src/limn/enumsLimn.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/enumsLimn.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/envmap.c teem-1.11.0-src/src/limn/envmap.c
--- teem-1.11.0-src.orig/src/limn/envmap.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/envmap.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/GNUmakefile teem-1.11.0-src/src/limn/GNUmakefile
--- teem-1.11.0-src.orig/src/limn/GNUmakefile	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/GNUmakefile	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2020  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -46,15 +46,15 @@
 #### Describe library here
 ####
 ####
-$(L).NEED = gage ell unrrdu nrrd biff hest air 
+$(L).NEED = gage ell unrrdu nrrd biff hest air
 $(L).PUBLIC_HEADERS = limn.h
 $(L).PRIVATE_HEADERS = privateLimn.h
 $(L).OBJS = defaultsLimn.o qn.o light.o envmap.o cam.o methodsLimn.o \
         obj.o transform.o shapes.o renderLimn.o io.o hestLimn.o \
 	splineMisc.o splineMethods.o splineEval.o enumsLimn.o \
-	polydata.o polyshapes.o polymod.o polyfilter.o \
+	splineFit.o polydata.o polyshapes.o polymod.o polyfilter.o \
 	lpuFlotsam.o lpu_about.o lpu_ccfind.o lpu_psel.o lpu_rast.o \
-	lpu_verts.o lpu_meas.o lpu_sort.o
+	lpu_verts.o lpu_meas.o lpu_sort.o lpu_cbfit.o
 $(L).TESTS = test/map test/light test/tcam test/tps test/tspline test/tbc \
 	test/tcamanim test/soid test/off2eps test/triimg test/plot test/intx \
 	test/tio test/clip test/lpu test/tqn
diff --color -ruN teem-1.11.0-src.orig/src/limn/hestLimn.c teem-1.11.0-src/src/limn/hestLimn.c
--- teem-1.11.0-src.orig/src/limn/hestLimn.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/hestLimn.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/io.c teem-1.11.0-src/src/limn/io.c
--- teem-1.11.0-src.orig/src/limn/io.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/io.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -64,8 +64,9 @@
           fprintf(file, ",");
         }
       }
-      fprintf(file, "]; wn = (%g,%g,%g)", face->worldNormal[0],
-              face->worldNormal[1], face->worldNormal[2]);
+      fprintf(file, "]; wn = (%g,%g,%g) |%g|", face->worldNormal[0],
+              face->worldNormal[1], face->worldNormal[2],
+              ELL_3V_LEN(face->worldNormal));
       look = obj->look + face->lookIdx;
       fprintf(file, "; RGB=(%g,%g,%g)",
               look->rgba[0], look->rgba[1], look->rgba[2]);
@@ -350,9 +351,9 @@
       if (-1 == lastLook || !ELL_3V_EQUAL(lastRGB, vert+3)) {
         lookIdx = limnObjectLookAdd(obj);
         ELL_4V_SET(obj->look[lookIdx].rgba,
-                   AIR_CAST(float, vert[3]),
-                   AIR_CAST(float, vert[4]),
-                   AIR_CAST(float, vert[5]),
+                   AIR_FLOAT(vert[3]),
+                   AIR_FLOAT(vert[4]),
+                   AIR_FLOAT(vert[5]),
                    1);
         lastLook = lookIdx;
         ELL_3V_COPY_TT(lastRGB, float, vert+3);
@@ -367,9 +368,9 @@
             lineCount, vertGot, lookIdx, partIdx);
     */
     limnObjectVertexAdd(obj, partIdx,
-                        AIR_CAST(float, vert[0]),
-                        AIR_CAST(float, vert[1]),
-                        AIR_CAST(float, vert[2]));
+                        AIR_FLOAT(vert[0]),
+                        AIR_FLOAT(vert[1]),
+                        AIR_FLOAT(vert[2]));
     vertGot++;
   }
   /* read face information */
@@ -682,7 +683,7 @@
                me, name, primIdx, primNum);
       return 1;
     }
-    pld->type[primIdx] = airEnumVal(limnPrimitive, line);
+    pld->type[primIdx] = AIR_UCHAR(airEnumVal(limnPrimitive, line));
     if (!(pld->type[primIdx])) {
       biffAddf(LIMN, "%s: couldn't parse \"%s\" %s line %u/%u",
                me, line, name, primIdx, primNum);
@@ -747,10 +748,10 @@
     biffAddf(LIMN, "%s: didn't get 1-D %s-type %u-sample array "
              "(got %u-D %s-type %u-by-? array)", me,
              airEnumStr(nrrdType, nrrdTypeUInt),
-             AIR_CAST(unsigned int, indxNum),
+             AIR_UINT(indxNum),
              nrrd->dim,
              airEnumStr(nrrdType, nrrd->type),
-             AIR_CAST(unsigned int, nrrd->axis[0].size));
+             AIR_UINT(nrrd->axis[0].size));
     airMopError(mop); return 1;
   }
   /* now copy the data */
@@ -786,11 +787,11 @@
     biffAddf(LIMN, "%s: didn't get 2-D %s-type 4-by-%u array "
              "(got %u-D %s-type %u-by-%u array)", me,
              airEnumStr(nrrdType, nrrdTypeFloat),
-             AIR_CAST(unsigned int, vertNum),
+             AIR_UINT(vertNum),
              nrrd->dim,
              airEnumStr(nrrdType, nrrd->type),
-             AIR_CAST(unsigned int, nrrd->axis[0].size),
-             AIR_CAST(unsigned int, nrrd->axis[1].size));
+             AIR_UINT(nrrd->axis[0].size),
+             AIR_UINT(nrrd->axis[1].size));
     airMopError(mop); return 1;
   }
   /* now copy the data */
@@ -866,11 +867,11 @@
         biffAddf(LIMN, "%s: didn't get 2-D %s-type %u-by-%u array "
                  "(got %u-D %s-type %u-by-%u-by-? array)", me,
                  airEnumStr(nrrdType, wantType),
-                 wantSize, AIR_CAST(unsigned int, vertNum),
+                 wantSize, AIR_UINT(vertNum),
                  nrrd->dim,
                  airEnumStr(nrrdType, nrrd->type),
-                 AIR_CAST(unsigned int, nrrd->axis[0].size),
-                 AIR_CAST(unsigned int, nrrd->axis[1].size));
+                 AIR_UINT(nrrd->axis[0].size),
+                 AIR_UINT(nrrd->axis[1].size));
         airMopError(mop); return 1;
       }
       /* now copy the data */
@@ -884,7 +885,8 @@
 }
 
 int
-_limnHestPolyDataLMPDParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+_limnHestPolyDataLMPDParse(void *ptr, const char *str,
+                           char err[AIR_STRLEN_HUGE]) {
   static const char me[] = "_limnHestPolyDataLMPDParse";
   char *nerr;
   limnPolyData **lpldP;
@@ -934,7 +936,8 @@
 limnHestPolyDataLMPD = &_limnHestPolyDataLMPD;
 
 int
-_limnHestPolyDataOFFParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+_limnHestPolyDataOFFParse(void *ptr, const char *str,
+                          char err[AIR_STRLEN_HUGE]) {
   static const char me[] = "_limnHestPolyDataOFFParse";
   char *nerr;
   limnPolyData **lpldP;
diff --color -ruN teem-1.11.0-src.orig/src/limn/light.c teem-1.11.0-src/src/limn/light.c
--- teem-1.11.0-src.orig/src/limn/light.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/light.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/limn.h teem-1.11.0-src/src/limn/limn.h
--- teem-1.11.0-src.orig/src/limn/limn.h	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/limn.h	2021-02-18 15:42:32.000000000 +0800
@@ -1,9 +1,9 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
+  Copyright (C) 2012, 2011, 2010  Thomas Schultz
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
-  Copyright (C) 2012, 2011, 2010  Thomas Schultz
 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License
@@ -511,6 +511,125 @@
   double B, C;       /* B,C values for BC-splines */
 } limnSplineTypeSpec;
 
+/*
+******** limnCBFSeg
+**
+** how one cubic Bezier spline segment is represented for limnCBF functions
+*/
+typedef struct {
+  double xy[8];      /* four control points of cubic Bezier:
+                        x0, y0,   x1, y1,   x2, y2,   x3, y3
+                        0   1     2   3     4   5     6  7   */
+  int corner[2];     /* corner[0,1] non-zero if xy[0,3] are corner vertices;
+                        segments otherwise assumed geometrically continuous */
+  unsigned int pNum; /* (if non-zero) this segment approximates pNum points */
+} limnCBFSeg;
+
+/*
+******** limnCBFPath
+**
+** a multi-segment path in the context of cubic Bezier fitting
+*/
+typedef struct {
+  limnCBFSeg *seg;      /* array of limnCBFSeg */
+  unsigned int segNum;  /* length of seg array */
+  airArray *segArr;     /* manages seg and segNum */
+  int isLoop;           /* path is closed loop */
+} limnCBFPath;
+
+/*
+******** limnCBFContext
+**
+** The bag of state for limnCBF functions. Callers of limnCBF functions do not
+** need to worry about the dynamically allocated things within (so: no
+** limnCBFContextNew or limnCBFContextNix), but a limnCBFContext variable
+** should be initialized with limnCBFContextInit() in order to set default
+** parameters, before passing to limnCBF functions.
+**
+** note: "nrp" = Newton-based Re-Parameterization of where the given points
+** fall along the spline, the iterative process inside limnCBFSingle
+*/
+typedef struct {
+  /* ----------- input ---------- */
+  int verbose,              /* verbosity level */
+    cornNMS;                /* non-minimal-suppression of corners: accept as
+                               corners only those with locally minimal angle */
+  unsigned int nrpIterMax;  /* max # iters of nrp */
+  double scale,             /* scale (in sense of nrrdKernelDiscreteGaussian)
+                               at which to estimate spline endpoints and
+                               tangents; scale=0 means the endpoints are
+                               exactly on vertices, and tangents are from
+                               the smallest-support finite differences */
+    distMin,                /* min distance to given points: this controls
+                               both splitting done by limnCBFMulti, and nrp
+                               within limnCBFSingle */
+    nrpDeltaMax,            /* in nrp, capping parameterization change to this
+                               scaling of average u[i+1]-u[i]. This wasn't in
+                               author's original code (so their idea of doing
+                               at most ~5 iters of nrp may no longer hold), but
+                               it can help stabilize things */
+    nrpDistScl,             /* scaling on distMin to use when testing distance
+                               during nrp; setting this < 1 means that nrp
+                               tries to be more stringent that the overall
+                               fitting, but with the benefit of sometimes
+                               being smarter about where to split, when that
+                               is needed */
+    nrpPsi,                 /* don't even try nrp if max dist is bigger than
+                               nrpPsi*distMin, instead just subdivide */
+    nrpDeltaMin,            /* min total parameterization change by nrp */
+    alphaMin,               /* alpha can't be negative, and we enforce
+                               distinct positivity to ensure that spline
+                               doesn't slow down too much near endpoints */
+    detMin,                 /* absolute value of determinant of 2x2 matrix
+                               to invert can't below this */
+    cornAngle;              /* angle, in degrees, between (one-sided) incoming
+                               and outgoing tangents, *below* which a vertex
+                               should be considered a corner. Vertices in a
+                               straight line have an angle of 180 degrees. Or,
+                               if 0, no effort is made to detect corners. */
+  /* ----------- internal --------- */
+  double *uu,               /* buffer used for nrp */
+    *vw,                    /* weights for endpoint vertex calculation */
+    *tw,                    /* weights for endpoint tangent calculation */
+    *mine;                  /* helps remember who allocated the above */
+  unsigned int wLen;        /* how long are vw, tw */
+  double lenF2L;            /* length of segment from first to last */
+  /* ----------- output --------- */
+  unsigned int nrpIterDone, /* number of nrp iters taken */
+    distIdx;                /* which point had distance distDone */
+  double dist,              /* max distance to given points */
+    nrpDeltaDone,           /* latest total parameterization change by nrp */
+    alphaDet;               /* min det of matrix inverted to find alpha */
+  int distBig;              /* how big dist (above) is:
+                               0: dist <= nD
+                               1: nD < dist <= DM
+                               2: DM < dist <= fD
+                               3: fD < dist
+                               where
+                               DM = distMin,
+                               nD = nrpDistScl*distMin,
+                               fD = nrpPsi*distMin: */
+} limnCBFContext;
+
+/*
+******** limnPoints
+**
+** a container for 1D array of points; currently used for limnCBF functions
+** Both pp and ppOwn can point to the array of point locations, but exactly
+** one of pp and ppOwn can be non-NULL.
+**
+** NOTE: For now, point data is only double (not float), and only in 2D (not
+** 3D), but if this becomes more general, that generality will be inside here
+*/
+typedef struct {
+  const double *pp;         /* point coords, we do not own buffer */
+  double *ppOwn;            /* point coords, we DO own buffer */
+  unsigned int num;         /* how many points */
+  int isLoop;               /* points form a loop: logical indices into coord
+                               array are . . . num-2, num-1, 0, 1, . . .
+                               and index 0 is effectively arbitrary */
+} limnPoints;
+
 /* defaultsLimn.c */
 LIMN_EXPORT const int limnPresent;
 LIMN_EXPORT const char *limnBiffKey;
@@ -691,6 +810,9 @@
                                   unsigned int uRes, unsigned int vRes);
 LIMN_EXPORT int limnPolyDataSquare(limnPolyData *pld,
                                    unsigned int infoBitFlag);
+LIMN_EXPORT int limnPolyDataSuperquadric2D(limnPolyData *pld,
+                                           unsigned int infoBitFlag,
+                                           float alpha, unsigned int res);
 
 /* polymod.c */
 LIMN_EXPORT int limnPolyDataEdgeHalve(limnPolyData *pldOut,
@@ -802,8 +924,8 @@
 /* splineMisc.c */
 LIMN_EXPORT const airEnum *const limnSplineType;
 LIMN_EXPORT const airEnum *const limnSplineInfo;
-LIMN_EXPORT limnSpline *limnSplineParse(char *str);
-LIMN_EXPORT limnSplineTypeSpec *limnSplineTypeSpecParse(char *str);
+LIMN_EXPORT limnSpline *limnSplineParse(const char *str);
+LIMN_EXPORT limnSplineTypeSpec *limnSplineTypeSpecParse(const char *str);
 LIMN_EXPORT hestCB *limnHestSpline;
 LIMN_EXPORT hestCB *limnHestSplineTypeSpec;
 LIMN_EXPORT unsigned int limnSplineInfoSize[LIMN_SPLINE_INFO_MAX+1];
@@ -821,6 +943,33 @@
 LIMN_EXPORT int limnSplineSample(Nrrd *nout, limnSpline *spline,
                                  double minT, size_t M, double maxT);
 
+/* splineFit.c */
+LIMN_EXPORT limnPoints *limnPointsNew(const double *pp,
+                                      unsigned int nn, int isLoop);
+LIMN_EXPORT limnPoints *limnPointsNix(limnPoints *lpnt);
+LIMN_EXPORT void limnCBFSegEval(double *xy, const limnCBFSeg *seg, double tt);
+LIMN_EXPORT limnCBFPath *limnCBFPathNew(void);
+LIMN_EXPORT limnCBFPath *limnCBFPathNix(limnCBFPath *path);
+LIMN_EXPORT void limnCBFPathSample(double *xy, unsigned int pNum,
+                                   const limnCBFPath *path);
+LIMN_EXPORT void limnCBFContextInit(limnCBFContext *fctx, int outputOnly);
+LIMN_EXPORT int limnCBFCheck(const limnCBFContext *fctx,
+                             const limnPoints *lpnt);
+LIMN_EXPORT int limnCBFitSingle(double alpha[2], limnCBFContext *fctx,
+                                const double vv0[2], const double tt1[2],
+                                const double tt2[2], const double vv3[2],
+                                const double *xy,
+                                unsigned int pNum, int isLoop);
+LIMN_EXPORT int limnCBFMulti(limnCBFPath *path, limnCBFContext *fctx,
+                             const double vv0[2], const double tt1[2],
+                             const double tt2[2], const double vv3[2],
+                             const limnPoints *lpnt,
+                             unsigned int loi, unsigned int hii);
+LIMN_EXPORT int limnCBFCorners(unsigned int **cornIdx, unsigned int *cornNum,
+                               limnCBFContext *fctx, const limnPoints *lpnt);
+LIMN_EXPORT int limnCBFit(limnCBFPath *path, limnCBFContext *fctx,
+                          const double *xy, unsigned int pNum, int isLoop);
+
 /* lpu{Flotsam,. . .}.c */
 #define LIMN_DECLARE(C) LIMN_EXPORT unrrduCmd limnpu_##C##Cmd;
 #define LIMN_LIST(C) &limnpu_##C##Cmd,
@@ -834,10 +983,11 @@
 F(rast) \
 F(verts) \
 F(meas) \
-F(sort)
+F(sort) \
+F(cbfit)
 LIMN_MAP(LIMN_DECLARE)
 LIMN_EXPORT unrrduCmd *limnpuCmdList[];
-LIMN_EXPORT void limnpuUsage(char *me, hestParm *hparm);
+LIMN_EXPORT void limnpuUsage(const char *me, hestParm *hparm);
 
 #ifdef __cplusplus
 }
diff --color -ruN teem-1.11.0-src.orig/src/limn/lpu_about.c teem-1.11.0-src/src/limn/lpu_about.c
--- teem-1.11.0-src.orig/src/limn/lpu_about.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/lpu_about.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -28,7 +28,7 @@
 int
 limnpu_aboutMain(int argc, const char **argv, const char *me,
                  hestParm *hparm) {
-  char buff[AIR_STRLEN_MED], fmt[AIR_STRLEN_MED];
+  char buff[AIR_STRLEN_LARGE], fmt[AIR_STRLEN_MED];
   char par1[] = "\t\t\t\t"
     "\"lpu\" is a complete hack.\n";
   char par2[] = "\t\t\t\t"
@@ -43,8 +43,7 @@
   sprintf(fmt, "%%%ds\n",
           (int)((hparm->columns-strlen(buff))/2 + strlen(buff) - 1));
   fprintf(stderr, fmt, buff);
-  sprintf(buff, "(Teem version %s, %s)",
-          airTeemVersion, airTeemReleaseDate);
+  airTeemVersionSprint(buff);
   sprintf(fmt, "%%%ds\n",
           (int)((hparm->columns-strlen(buff))/2 + strlen(buff) - 1));
   fprintf(stderr, fmt, buff);
@@ -56,5 +55,5 @@
   return 0;
 }
 
-unrrduCmd limnpu_aboutCmd = { "about", INFO, limnpu_aboutMain };
+unrrduCmd limnpu_aboutCmd = { "about", INFO, limnpu_aboutMain, AIR_FALSE };
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/lpu_cbfit.c teem-1.11.0-src/src/limn/lpu_cbfit.c
--- teem-1.11.0-src.orig/src/limn/lpu_cbfit.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/limn/lpu_cbfit.c	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,243 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "limn.h"
+#include "privateLimn.h"
+
+#define INFO "Fit Bezier cubic spline to points"
+static const char *myinfo =
+(INFO
+ ". \"nrp\" == Newton-based ReParameterization of spline domain");
+
+int
+limnpu_cbfitMain(int argc, const char **argv, const char *me,
+                 hestParm *hparm) {
+  hestOpt *hopt = NULL;
+  char *err, *perr;
+  airArray *mop;
+  int pret;
+
+  Nrrd *_nin, *nin;
+  double *xy, alpha[2],
+    vv0[2], tt1[2], tt2[2], vv3[2],
+    deltaMin, psi, cangle, distMin, distScl, utt1[2], utt2[2],
+    time0, dtime, scale;
+  unsigned int ii, pNum, iterMax;
+  int loop, petc, verbose, synth, nofit;
+  char *synthOut;
+  limnCBFContext fctx;
+  limnCBFPath *path;
+
+  hestOptAdd(&hopt, "i", "input", airTypeOther, 1, 1, &_nin, NULL,
+             "input xy points",
+             NULL, NULL, nrrdHestNrrd);
+  hestOptAdd(&hopt, "v", "verbose", airTypeInt, 1, 1, &verbose, "1",
+             "verbosity level");
+  hestOptAdd(&hopt, "s", "synth", airTypeInt, 0, 0, &synth, NULL,
+             "synthesize xy points from control points");
+  hestOptAdd(&hopt, "so", "synth out", airTypeString, 1, 1, &synthOut, "",
+             "if non-empty, filename in which to save synthesized xy pts");
+  hestOptAdd(&hopt, "snf", NULL, airTypeInt, 0, 0, &nofit, NULL,
+             "actually do not fit, just save -so synthetic "
+             "output and quit");
+  hestOptAdd(&hopt, "t1", "tan", airTypeDouble, 2, 2, utt1, "nan nan",
+             "if non-nan, the outgoing tangent from the first point");
+  hestOptAdd(&hopt, "t2", "tan", airTypeDouble, 2, 2, utt2, "nan nan",
+             "if non-nan, the incoming tangent to the last point");
+  hestOptAdd(&hopt, "im", "max", airTypeUInt, 1, 1, &iterMax, "0",
+             "(if non-zero) max # nrp iterations to run");
+  hestOptAdd(&hopt, "deltam", "delta", airTypeDouble, 1, 1, &deltaMin, "0.0005",
+             "(if non-zero) stop nrp when change in spline "
+             "domain sampling goes below this");
+  hestOptAdd(&hopt, "distm", "dist", airTypeDouble, 1, 1, &distMin, "0.01",
+             "(if non-zero) stop nrp when distance between spline "
+             "and points goes below this");
+  hestOptAdd(&hopt, "dists", "scl", airTypeDouble, 1, 1, &distScl, "0.25",
+             "scaling on nrp distMin check");
+  hestOptAdd(&hopt, "psi", "psi", airTypeDouble, 1, 1, &psi, "10",
+             "psi, of course");
+  hestOptAdd(&hopt, "ca", "angle", airTypeDouble, 1, 1, &cangle, "100",
+             "angle indicating a corner");
+  hestOptAdd(&hopt, "scl", "scale", airTypeDouble, 1, 1, &scale, "0",
+             "scale for geometry estimation");
+  hestOptAdd(&hopt, "loop", NULL, airTypeInt, 0, 0, &loop, NULL,
+             "given xy points are actually a loop; BUT "
+             "the first and last points need to be the same!");
+  hestOptAdd(&hopt, "petc", NULL, airTypeInt, 0, 0, &petc, NULL,
+             "(Press Enter To Continue) ");
+  /*
+  hestOptAdd(&hopt, NULL, "output", airTypeString, 1, 1, &out, NULL,
+             "output nrrd filename");
+  */
+
+  mop = airMopNew();
+  airMopAdd(mop, hopt, (airMopper)hestOptFree, airMopAlways);
+
+  USAGE(myinfo);
+  PARSE();
+  airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);
+
+  if (!( 2 == _nin->dim && 2 == _nin->axis[0].size )) {
+    fprintf(stderr, "%s: want 2-D (not %u) array with axis[0].size "
+            "2 (not %u)\n", me, _nin->dim,
+            (unsigned int)_nin->axis[0].size);
+    airMopError(mop);
+    return 1;
+  }
+  if (synth && 6 != _nin->axis[1].size) {
+    fprintf(stderr, "%s: need 2-by-6 array (not 2-by-%u) for synthetic xy\n",
+            me, (unsigned int)_nin->axis[1].size);
+    airMopError(mop);
+    return 1;
+  }
+
+  nin = nrrdNew();
+  airMopAdd(mop, nin, (airMopper)nrrdNuke, airMopAlways);
+  if (nrrdConvert(nin, _nin, nrrdTypeDouble)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: trouble:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+
+  if (!synth) {
+    xy = (double*)nin->data;
+    pNum = (unsigned int)nin->axis[1].size;
+  } else {
+    /* synthesize data from control points */
+    double *cpt = (double*)nin->data;
+    limnCBFSeg seg;
+    pNum = (unsigned int)cpt[1];
+    if (!( 0 == cpt[0] && pNum == cpt[1] )) {
+      fprintf(stderr, "%s: need 0,int for first 2 cpt values (not %g,%g)\n",
+              me, cpt[0], cpt[1]);
+      airMopError(mop);
+      return 1;
+    }
+    ELL_2V_COPY(alpha, cpt + 2);
+    ELL_2V_COPY(vv0, cpt + 4);  ELL_2V_COPY(seg.xy + 0, vv0);
+    ELL_2V_COPY(tt1, cpt + 6);
+    ELL_2V_COPY(tt2, cpt + 8);
+    ELL_2V_COPY(vv3, cpt + 10); ELL_2V_COPY(seg.xy + 6, vv3);
+    ELL_2V_SCALE_ADD2(seg.xy + 2, 1, vv0, alpha[0], tt1);
+    ELL_2V_SCALE_ADD2(seg.xy + 4, 1, vv3, alpha[1], tt2);
+    printf("%s: synth seg: (%g,%g) -- (%g,%g) -- (%g,%g) -- (%g,%g)\n", me,
+           seg.xy[0], seg.xy[1], seg.xy[2], seg.xy[3],
+           seg.xy[4], seg.xy[5], seg.xy[6], seg.xy[7]);
+    xy = AIR_MALLOC(2*pNum, double);
+    airMopAdd(mop, xy, airFree, airMopAlways);
+    for (ii=0; ii<pNum; ii++) {
+      limnCBFSegEval(xy + 2*ii, &seg, AIR_AFFINE(0, ii, pNum-1, 0, 1));
+    }
+    if (airStrlen(synthOut)) {
+      Nrrd *nsyn = nrrdNew();
+      airMopAdd(mop, nsyn, (airMopper)nrrdNix, airMopAlways);
+      if (nrrdWrap_va(nsyn, xy, nrrdTypeDouble, 2, (size_t)2, (size_t)pNum)
+          || nrrdSave(synthOut, nsyn, NULL)) {
+        airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+        fprintf(stderr, "%s: trouble saving synthetic data:\n%s", me, err);
+        airMopError(mop);
+        return 1;
+      }
+      if (nofit) {
+        fprintf(stderr, "%s: got -nf nofit; bye\n", me);
+        airMopOkay(mop);
+        return 0;
+      }
+    }
+  }
+  {
+    /* set up 2-vector-valued arguments to fitting */
+    double len;
+    ELL_2V_COPY(vv0, xy);
+    ELL_2V_COPY(vv3, xy + 2*(pNum-1));
+    if (ELL_2V_EXISTS(utt1)) {
+      ELL_2V_COPY(tt1, utt1);
+    } else {
+      /* TODO: better tangent estimation */
+      ELL_2V_SUB(tt1, xy + 2, xy);
+    }
+    if (ELL_2V_EXISTS(utt2)) {
+      ELL_2V_COPY(tt2, utt2);
+    } else {
+      ELL_2V_SUB(tt2, xy + 2*(pNum-2), vv3);
+    }
+    ELL_2V_NORM(tt1, tt1, len);
+    ELL_2V_NORM(tt2, tt2, len);
+  }
+  path = limnCBFPathNew();
+  airMopAdd(mop, path, (airMopper)limnCBFPathNix, airMopAlways);
+  limnCBFContextInit(&fctx, AIR_FALSE);
+  fctx.nrpIterMax = iterMax;
+  fctx.nrpDeltaMin = deltaMin;
+  fctx.distMin = distMin;
+  fctx.nrpDistScl = distScl;
+  fctx.verbose = verbose;
+  fctx.nrpPsi = psi;
+  fctx.cornAngle = cangle;
+  fctx.scale = scale;
+  time0 = airTime();
+  if (petc) {
+    fprintf(stderr, "%s: Press Enter to Continue ... ", me);
+    fflush(stderr);
+    getchar();
+  }
+  if (limnCBFit(path, &fctx, xy, pNum, loop)) {
+    airMopAdd(mop, err = biffGetDone(LIMN), airFree, airMopAlways);
+    fprintf(stderr, "%s: trouble:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+  dtime = (airTime() - time0)*1000;
+  printf("%s: time= %g ms;iterDone= %u ;deltaDone=%g, dist=%g (@%u)\n", me,
+         dtime, fctx.nrpIterDone, fctx.nrpDeltaDone,
+         fctx.dist, fctx.distIdx);
+  {
+    unsigned int si;
+    printf("%s: path has %u segments:\n", me, path->segNum);
+    for (si=0; si<path->segNum; si++) {
+      limnCBFSeg *seg = path->seg + si;
+      printf("seg %u (%3u): (%g,%g) -- (%g,%g) -- (%g,%g) -- (%g,%g)\n",
+             si, seg->pNum,
+             seg->xy[0], seg->xy[1],
+             seg->xy[2], seg->xy[3],
+             seg->xy[4], seg->xy[5],
+             seg->xy[6], seg->xy[7]);
+    }
+  }
+
+  if (1) {
+    unsigned int oNum = pNum*100;
+    double *pp = AIR_MALLOC(oNum*2, double);
+    airMopAdd(mop, pp, airFree, airMopAlways);
+    limnCBFPathSample(pp, oNum, path);
+    for (ii=0; ii<oNum; ii++) {
+      printf("done %u %g %g\n", ii, (pp + 2*ii)[0], (pp + 2*ii)[1]);
+    }
+  }
+
+  airMopOkay(mop);
+  return 0;
+}
+
+unrrduCmd limnpu_cbfitCmd = { "cbfit", INFO, limnpu_cbfitMain, AIR_FALSE };
diff --color -ruN teem-1.11.0-src.orig/src/limn/lpu_ccfind.c teem-1.11.0-src/src/limn/lpu_ccfind.c
--- teem-1.11.0-src.orig/src/limn/lpu_ccfind.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/lpu_ccfind.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -71,5 +71,5 @@
   return 0;
 }
 
-unrrduCmd limnpu_ccfindCmd = { "ccfind", INFO, limnpu_ccfindMain };
+unrrduCmd limnpu_ccfindCmd = { "ccfind", INFO, limnpu_ccfindMain, AIR_FALSE };
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/lpuFlotsam.c teem-1.11.0-src/src/limn/lpuFlotsam.c
--- teem-1.11.0-src.orig/src/limn/lpuFlotsam.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/lpuFlotsam.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -42,22 +42,22 @@
 ** with their one-line descriptions
 */
 void
-limnpuUsage(char *me, hestParm *hparm) {
-  int i, maxlen, len, c;
+limnpuUsage(const char *me, hestParm *hparm) {
+  unsigned int i, maxlen, len, c;
   char buff[AIR_STRLEN_LARGE], fmt[AIR_STRLEN_LARGE];
 
   maxlen = 0;
   for (i=0; limnpuCmdList[i]; i++) {
-    maxlen = AIR_MAX(maxlen, (int)strlen(limnpuCmdList[i]->name));
+    maxlen = AIR_MAX(maxlen, AIR_UINT(strlen(limnpuCmdList[i]->name)));
   }
 
   sprintf(buff, "--- LimnPolyData Hacking ---");
-  sprintf(fmt, "%%%ds\n",
-          (int)((hparm->columns-strlen(buff))/2 + strlen(buff) - 1));
+  sprintf(fmt, "%%%us\n",
+          AIR_UINT((hparm->columns-strlen(buff))/2 + strlen(buff) - 1));
   fprintf(stderr, fmt, buff);
 
   for (i=0; limnpuCmdList[i]; i++) {
-    len = strlen(limnpuCmdList[i]->name);
+    len = AIR_UINT(strlen(limnpuCmdList[i]->name));
     strcpy(buff, "");
     for (c=len; c<maxlen; c++)
       strcat(buff, " ");
@@ -65,7 +65,7 @@
     strcat(buff, " ");
     strcat(buff, limnpuCmdList[i]->name);
     strcat(buff, " ... ");
-    len = strlen(buff);
+    len = AIR_UINT(strlen(buff));
     fprintf(stderr, "%s", buff);
     _hestPrintStr(stderr, len, len, hparm->columns,
                   limnpuCmdList[i]->info, AIR_FALSE);
diff --color -ruN teem-1.11.0-src.orig/src/limn/lpu_meas.c teem-1.11.0-src/src/limn/lpu_meas.c
--- teem-1.11.0-src.orig/src/limn/lpu_meas.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/lpu_meas.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -75,5 +75,5 @@
   return 0;
 }
 
-unrrduCmd limnpu_measCmd = { "meas", INFO, limnpu_measMain };
+unrrduCmd limnpu_measCmd = { "meas", INFO, limnpu_measMain, AIR_FALSE };
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/lpu_psel.c teem-1.11.0-src/src/limn/lpu_psel.c
--- teem-1.11.0-src.orig/src/limn/lpu_psel.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/lpu_psel.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -102,5 +102,5 @@
   return 0;
 }
 
-unrrduCmd limnpu_pselCmd = { "psel", INFO, limnpu_pselMain };
+unrrduCmd limnpu_pselCmd = { "psel", INFO, limnpu_pselMain, AIR_FALSE };
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/lpu_rast.c teem-1.11.0-src/src/limn/lpu_rast.c
--- teem-1.11.0-src.orig/src/limn/lpu_rast.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/lpu_rast.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -86,5 +86,5 @@
   return 0;
 }
 
-unrrduCmd limnpu_rastCmd = { "rast", INFO, limnpu_rastMain };
+unrrduCmd limnpu_rastCmd = { "rast", INFO, limnpu_rastMain, AIR_FALSE };
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/lpu_sort.c teem-1.11.0-src/src/limn/lpu_sort.c
--- teem-1.11.0-src.orig/src/limn/lpu_sort.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/lpu_sort.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -75,5 +75,5 @@
   return 0;
 }
 
-unrrduCmd limnpu_sortCmd = { "sort", INFO, limnpu_sortMain };
+unrrduCmd limnpu_sortCmd = { "sort", INFO, limnpu_sortMain, AIR_FALSE };
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/lpu_verts.c teem-1.11.0-src/src/limn/lpu_verts.c
--- teem-1.11.0-src.orig/src/limn/lpu_verts.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/lpu_verts.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -69,5 +69,4 @@
   return 0;
 }
 
-unrrduCmd limnpu_vertsCmd = { "verts", INFO, limnpu_vertsMain };
-
+unrrduCmd limnpu_vertsCmd = { "verts", INFO, limnpu_vertsMain, AIR_FALSE };
diff --color -ruN teem-1.11.0-src.orig/src/limn/methodsLimn.c teem-1.11.0-src/src/limn/methodsLimn.c
--- teem-1.11.0-src.orig/src/limn/methodsLimn.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/methodsLimn.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/obj.c teem-1.11.0-src/src/limn/obj.c
--- teem-1.11.0-src.orig/src/limn/obj.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/obj.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/polydata.c teem-1.11.0-src/src/limn/polydata.c
--- teem-1.11.0-src.orig/src/limn/polydata.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/polydata.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,9 +1,9 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2011  Thomas Schultz
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
-  Copyright (C) 2011  Thomas Schultz
 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License
@@ -686,9 +686,9 @@
            AIR_IN_OP(min[2], xyz[2], max[2]) )) {
       continue;
     }
-    xi = airIndex(min[0], xyz[0], max[0], size[0]);
-    yi = airIndex(min[1], xyz[1], max[1], size[1]);
-    zi = airIndex(min[2], xyz[2], max[2], size[2]);
+    xi = airIndex(min[0], xyz[0], max[0], AIR_UINT(size[0]));
+    yi = airIndex(min[1], xyz[1], max[1], AIR_UINT(size[1]));
+    zi = airIndex(min[2], xyz[2], max[2], AIR_UINT(size[2]));
     ins(nout->data, xi + size[0]*(yi + size[1]*zi), 1.0);
   }
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/polyfilter.c teem-1.11.0-src/src/limn/polyfilter.c
--- teem-1.11.0-src.orig/src/limn/polyfilter.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/polyfilter.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,9 +1,9 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2011  Thomas Schultz
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
-  Copyright (C) 2011  Thomas Schultz
 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License
diff --color -ruN teem-1.11.0-src.orig/src/limn/polymod.c teem-1.11.0-src/src/limn/polymod.c
--- teem-1.11.0-src.orig/src/limn/polymod.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/polymod.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,9 +1,9 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2012, 2011, 2010, 2009, 2008  Thomas Schultz
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
-  Copyright (C) 2012, 2011, 2010, 2009, 2008  Thomas Schultz
 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License
@@ -73,7 +73,7 @@
 
   vertWithTri = AIR_CAST(unsigned int*, nVertWithTri->data);
   triWithVert = AIR_CAST(unsigned int*, nTriWithVert->data);
-  maxTriPerVert = nTriWithVert->axis[0].size - 1;
+  maxTriPerVert = AIR_UINT(nTriWithVert->axis[0].size - 1);
   for (ii=0; ii<3; ii++) {
     vertA = (vertWithTri + 3*triIdx)[ii];
     vertB = (vertWithTri + 3*triIdx)[AIR_MOD(ii+1, 3)];
@@ -523,7 +523,7 @@
   unsigned int maxTriPerVert, *triWithVert,
     *vertWithTri, *triLine, *vertLine, triCurr, vertLast, vertNext;
 
-  maxTriPerVert = AIR_CAST(unsigned int, nTriWithVert->axis[0].size-1);
+  maxTriPerVert = AIR_UINT(nTriWithVert->axis[0].size-1);
   triWithVert = AIR_CAST(unsigned int*, nTriWithVert->data);
   vertWithTri = AIR_CAST(unsigned int*, nVertWithTri->data);
 
@@ -604,7 +604,7 @@
   len0 = len1 = 0;
   edgeData = AIR_CAST(unsigned int*, edgeArr->data);
   edgeData += 5*startIdx;
-  /* maxTriPerVert = AIR_CAST(unsigned int, nTriWithVert->axis[0].size-1); */
+  /* maxTriPerVert = AIR_UINT(nTriWithVert->axis[0].size-1); */
   /* triWithVert = AIR_CAST(unsigned int*, nTriWithVert->data); */
   /* vertWithTri = AIR_CAST(unsigned int*, nVertWithTri->data); */
 
@@ -943,7 +943,7 @@
   vertNum = pld->xyzwNum;
   hitCount = AIR_CAST(unsigned char *, calloc(vertNum,
                                               sizeof(unsigned char)));
-  maxTriPerVert = AIR_CAST(unsigned int, nTriWithVert->axis[0].size - 1);
+  maxTriPerVert = AIR_UINT(nTriWithVert->axis[0].size - 1);
   track0 = AIR_CAST(unsigned int *, calloc(maxTriPerVert*edgeArr->len,
                                            sizeof(unsigned int)));
   track1 = AIR_CAST(unsigned int *, calloc(maxTriPerVert*edgeArr->len,
@@ -1059,13 +1059,13 @@
                                 track0, track0Len, passIdx);
       if (E) {
         biffAddf(LIMN, "%s: trouble on split %u (done %u/%u)", me,
-                 splitNum, edgeDoneNum, AIR_CAST(unsigned int, edgeArr->len));
+                 splitNum, edgeDoneNum, AIR_UINT(edgeArr->len));
         return 1;
       }
       edgeDoneNum += listLen;
       /*
         fprintf(stderr, "!%s: edgeDoneNum now %u (%u)\n", me,
-        edgeDoneNum, AIR_CAST(unsigned int, edgeArr->len));
+        edgeDoneNum, AIR_UINT(edgeArr->len));
       */
       if (0 == passIdx) {
         SEARCH(1);
@@ -1158,7 +1158,7 @@
   vertWithTri = AIR_CAST(unsigned int*, nVertWithTri->data);
   /* triWithVert = AIR_CAST(unsigned int*, nTriWithVert->data); */
 
-  maxTriPerVert = nTriWithVert->axis[0].size - 1;
+  maxTriPerVert = AIR_UINT(nTriWithVert->axis[0].size - 1);
   intxBuff = AIR_CAST(unsigned int*, calloc(maxTriPerVert,
                                             sizeof(unsigned int)));
   if (!intxBuff) {
@@ -1431,7 +1431,7 @@
              "(not %u-D type %s, axis[0].size %u)", me,
              pld->primNum,
              _nval->dim, airEnumStr(nrrdType, _nval->type),
-             AIR_CAST(unsigned int, _nval->axis[0].size));
+             AIR_UINT(_nval->axis[0].size));
     return 1;
   }
 
@@ -1478,7 +1478,7 @@
   baseIndx = indxNew;
   for (primIdx=0; primIdx<pld->primNum; primIdx++) {
     unsigned int sortIdx;
-    sortIdx = AIR_CAST(unsigned int, rec[1 + 2*primIdx]);
+    sortIdx = AIR_UINT(rec[1 + 2*primIdx]);
     memcpy(baseIndx, startIndx[sortIdx],
            pld->icnt[sortIdx]*sizeof(unsigned int));
     icntNew[primIdx] = pld->icnt[sortIdx];
@@ -1549,7 +1549,7 @@
     biffAddf(LIMN, "%s: need 1-D %u-len scalar nrrd "
              "(not %u-D type %s, axis[0].size %u)", me,
              pldIn->primNum, _nmask->dim, airEnumStr(nrrdType, _nmask->type),
-             AIR_CAST(unsigned int, _nmask->axis[0].size));
+             AIR_UINT(_nmask->axis[0].size));
     return 1;
   }
 
@@ -1677,7 +1677,7 @@
     next=llist[next+2];
   }
   /* we need to interpolate - find the weight */
-  nk=(nval->dim==1)?1:nval->axis[0].size;
+  nk=AIR_UINT((nval->dim==1)?1:nval->axis[0].size);
   for (i=0; i<nk; i++) {
     double discval = lup(nval->data, nk*disc+i);
     double keptval = lup(nval->data, nk*kept+i);
@@ -1766,9 +1766,9 @@
   }
 
   if (nval->dim==1) {
-    nk=1; nvert=nval->axis[0].size;
+    nk=1; nvert=AIR_UINT(nval->axis[0].size);
   } else if (nval->dim==2) {
-    nk=nval->axis[0].size; nvert=nval->axis[1].size;
+    nk=AIR_UINT(nval->axis[0].size); nvert=AIR_UINT(nval->axis[1].size);
   } else {
     biffAddf(LIMN, "%s: need 1D or 2D input array, got %uD", me, nval->dim);
     return 1;
@@ -2337,7 +2337,7 @@
   if (depth>*maxnb)
     *maxnb=depth;
   /* do the registration */
-  nblist[pointer]=*len;
+  nblist[pointer]=AIR_UINT(*len);
   nblist[*len]=v;
   nblist[*len+1]=0;
   (*len)+=2;
@@ -2348,7 +2348,7 @@
     pointer=idx+1;
     idx=nblist[pointer];
   }
-  nblist[pointer]=*len;
+  nblist[pointer]=AIR_UINT(*len);
   nblist[*len]=u;
   nblist[*len+1]=0;
   (*len)+=2;
diff --color -ruN teem-1.11.0-src.orig/src/limn/polyshapes.c teem-1.11.0-src/src/limn/polyshapes.c
--- teem-1.11.0-src.orig/src/limn/polyshapes.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/polyshapes.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2010, 2009, 2008  Thomas Schultz
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
@@ -114,7 +114,7 @@
       ELL_3V_SET(pld->norm + 3*22,  0,  0,  1);
     } else {
       float cn;
-      cn = AIR_CAST(float, sqrt(3.0));
+      cn = AIR_FLOAT(sqrt(3.0));
       ELL_3V_SET(pld->norm + 3*0, -cn, -cn, -cn);
       ELL_3V_SET(pld->norm + 3*1, -cn,  cn, -cn);
       ELL_3V_SET(pld->norm + 3*2,  cn,  cn, -cn);
@@ -246,7 +246,7 @@
       ELL_3V_SET(pld->norm + 3* 9,  0,  0,  1);
     } else {
       float cn;
-      cn = AIR_CAST(float, 1.0/sqrt(3.0));
+      cn = AIR_FLOAT(1.0/sqrt(3.0));
       ELL_3V_SET(pld->norm + 3*0,  cn, -cn,  cn);
       ELL_3V_SET(pld->norm + 3*1, -cn, -cn,  cn);
       ELL_3V_SET(pld->norm + 3*2,  cn,  cn,  cn);
@@ -324,7 +324,7 @@
       ELL_3V_SET(pld->tang + 3* 9,  1,  0,  0);
     } else {
       float sn;
-      sn = AIR_CAST(float, 1.0/sqrt(2.0));
+      sn = AIR_FLOAT(1.0/sqrt(2.0));
       ELL_3V_SET(pld->tang + 3*0, -sn,  sn,  0);
       ELL_3V_SET(pld->tang + 3*1,  sn,  sn,  0);
       ELL_3V_SET(pld->tang + 3*2, -sn, -sn,  0);
@@ -407,7 +407,7 @@
   if ((1 << limnPolyDataInfoNorm) & infoBitFlag) {
     if (sharpEdge) {
       float cn;
-      cn = AIR_CAST(float, 1.0/sqrt(3));
+      cn = AIR_FLOAT( 1.0/sqrt(3));
       /* 0 */
       ELL_3V_SET(pld->norm +  3*0,  cn,  cn,  cn);
       ELL_3V_SET(pld->norm +  3*8,  cn,  cn,  cn);
@@ -925,8 +925,8 @@
         yy = (pld->xyzw + 4*vertIdx)[1];
         rr = sqrt(xx*xx + yy*yy);
         if (rr) {
-          (pld->xyzw + 4*vertIdx)[0] *= AIR_CAST(float, AIR_AFFINE(0, rr, 1, minRad/rr, 1/rr));
-          (pld->xyzw + 4*vertIdx)[1] *= AIR_CAST(float, AIR_AFFINE(0, rr, 1, minRad/rr, 1/rr));
+          (pld->xyzw + 4*vertIdx)[0] *= AIR_FLOAT(AIR_AFFINE(0, rr, 1, minRad/rr, 1/rr));
+          (pld->xyzw + 4*vertIdx)[1] *= AIR_FLOAT(AIR_AFFINE(0, rr, 1, minRad/rr, 1/rr));
         }
       }
       if (((1 << limnPolyDataInfoNorm) & infoBitFlag)
@@ -1368,9 +1368,9 @@
 
   vertIdx = 0;
   for (vIdx=0; vIdx<vRes; vIdx++) {
-    vv = AIR_CAST(float, AIR_AFFINE(0, vIdx, vRes-1, -1.0, 1.0));
+    vv = AIR_FLOAT(AIR_AFFINE(0, vIdx, vRes-1, -1.0, 1.0));
     for (uIdx=0; uIdx<uRes; uIdx++) {
-      uu = AIR_CAST(float, AIR_AFFINE(0, uIdx, uRes-1, -1.0, 1.0));
+      uu = AIR_FLOAT(AIR_AFFINE(0, uIdx, uRes-1, -1.0, 1.0));
       ELL_4V_SET(pld->xyzw + 4*vertIdx, uu, vv, 0.0, 1.0);
       if ((1 << limnPolyDataInfoNorm) & infoBitFlag) {
         ELL_3V_SET_TT(pld->norm + 3*vertIdx, float, 0.0, 0.0, 1.0);
@@ -1443,4 +1443,61 @@
 
   return 0;
 }
+
+int
+limnPolyDataSuperquadric2D(limnPolyData *pld,
+                           unsigned int infoBitFlag,
+                           float alpha, unsigned int res) {
+  static const char me[]="limnPolyDataSuperquadric2D";
+  unsigned int i, vertNum;
+  double phi;
+
+  vertNum = res+1; /* initial vertex at origin */
+  if (limnPolyDataAlloc(pld, infoBitFlag, vertNum,
+                        vertNum+1, /* last index wraps around */
+                        1)) {
+    biffAddf(LIMN, "%s: couldn't allocate output", me);
+    return 1;
+  }
+  /* initial vertex at origin */
+  ELL_4V_SET(pld->xyzw + 4*0, 0.0, 0.0, 0.0, 1.0);
+  /* printf("!%s: xyzw[0] = %g %g %g %g\n", me, (pld->xyzw + 4*0)[0], (pld->xyzw + 4*0)[1], (pld->xyzw + 4*0)[2], (pld->xyzw + 4*0)[3]); */
+  for (i=1; i<vertNum; i++) {
+    phi = AIR_AFFINE(1, i, vertNum, 0, 2*AIR_PI);
+    ELL_4V_SET_TT(pld->xyzw + 4*i, float,
+                  airSgnPow(cos(phi),alpha),
+                  airSgnPow(sin(phi),alpha),
+                  0.0, 1.0);
+    /* printf("!%s: xyzw[%u] = %g %g %g %g\n", me, i ,(pld->xyzw + 4*i)[0], (pld->xyzw + 4*i)[1], (pld->xyzw + 4*i)[2], (pld->xyzw + 4*i)[3]); */
+  }
+  if ((1 << limnPolyDataInfoNorm) & infoBitFlag) {
+    for (i=0; i<vertNum; i++) {
+      ELL_3V_SET(pld->norm + 3*i, 0.0, 0.0, 1.0);
+    }
+  }
+  if ((1 << limnPolyDataInfoRGBA) & infoBitFlag) {
+    for (i=0; i<vertNum; i++) {
+      ELL_4V_SET(pld->rgba + 4*i, 255, 255, 255, 255);
+    }
+  }
+  if ((1 << limnPolyDataInfoTex2) & infoBitFlag) {
+    /* punting */
+    ELL_2V_COPY(pld->tex2 + 2*i, pld->xyzw + 4*i);
+  }
+  if ((1 << limnPolyDataInfoTang) & infoBitFlag) {
+    /* punting */
+    ELL_3V_SET(pld->tang + 3*i, 0.0, 0.0, 0.0);
+  }
+  pld->type[0] = limnPrimitiveTriangleFan;
+  for (i=0; i<vertNum; i++) {
+    pld->indx[i] = i;
+    /* printf("!%s: idx[%u] = %u\n", me, i, pld->indx[i]); */
+  }
+  /* very last index loops around to first non-origin point */
+  pld->indx[i] = 1;
+  /* printf("!%s: idx[%u] = %u\n", me, i, pld->indx[i]); */
+  pld->icnt[0] = vertNum+1;
+
+  return 0;
+}
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/privateLimn.h teem-1.11.0-src/src/limn/privateLimn.h
--- teem-1.11.0-src.orig/src/limn/privateLimn.h	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/privateLimn.h	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/qn.c teem-1.11.0-src/src/limn/qn.c
--- teem-1.11.0-src.orig/src/limn/qn.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/qn.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -51,7 +51,7 @@
   x = (qn & 0x2000) ? -x : x;
   y = (qn & 0x4000) ? -y : y;
   z = (qn & 0x8000) ? -z : z;
-  n = AIR_CAST(float, 1.0/sqrt(x*x + y*y + z*z));
+  n = AIR_FLOAT(1.0/sqrt(x*x + y*y + z*z));
   vec[0] = x*n;
   vec[1] = y*n;
   vec[2] = z*n;
@@ -82,8 +82,8 @@
     return 0;
   }
   w = 126.0f/L;
-  xi = AIR_CAST(unsigned int, x*w);
-  yi = AIR_CAST(unsigned int, y*w);
+  xi = AIR_UINT(x*w);
+  yi = AIR_UINT(y*w);
   if (xi >= 64) {
     xi = 127 - xi;
     yi = 127 - yi;
@@ -100,13 +100,13 @@
 
   ui = qn & 0xFF;
   vi = qn >> 8;
-  u = AIR_CAST(float, AIR_AFFINE(0.5, ui, 254.5, -0.5, 0.5));
-  v = AIR_CAST(float, AIR_AFFINE(0.5, vi, 254.5, -0.5, 0.5));
+  u = AIR_FLOAT(AIR_AFFINE(0.5, ui, 254.5, -0.5, 0.5));
+  v = AIR_FLOAT(AIR_AFFINE(0.5, vi, 254.5, -0.5, 0.5));
   x =  u + v;
   y =  u - v;
   z = 1 - AIR_ABS(x) - AIR_ABS(y);
-  z *= AIR_CAST(int, ((ui&1) ^ (vi&1)) << 1) - 1;
-  n = AIR_CAST(float, 1.0/sqrt(x*x + y*y + z*z));
+  z *= AIR_INT(((ui&1) ^ (vi&1)) << 1) - 1;
+  n = AIR_FLOAT(1.0/sqrt(x*x + y*y + z*z));
   vec[0] = x*n;
   vec[1] = y*n;
   vec[2] = z*n;
@@ -173,7 +173,7 @@
   x =  u + v;                                     \
   y =  u - v;                                     \
   z = 1 - AIR_ABS(x) - AIR_ABS(y);                \
-  z *= AIR_CAST(int, ((ui & 1) ^ (vi & 1)) << 1) - 1; \
+  z *= AIR_INT(((ui & 1) ^ (vi & 1)) << 1) - 1;   \
   n = 1.0/sqrt(x*x + y*y + z*z); \
   (vec)[0] = AIR_CAST(TT, x*n); \
   (vec)[1] = AIR_CAST(TT, y*n); \
@@ -373,7 +373,7 @@
   x =  u + v; \
   y =  u - v; \
   z = 1 - AIR_ABS(x) - AIR_ABS(y); \
-  z *= AIR_CAST(int, zi << 1) - 1;    \
+  z *= AIR_INT(zi << 1) - 1;    \
   n = AIR_CAST(TT, 1.0/sqrt(x*x + y*y + z*z)); \
   vec[0] = AIR_CAST(TT, x*n); \
   vec[1] = AIR_CAST(TT, y*n); \
diff --color -ruN teem-1.11.0-src.orig/src/limn/renderLimn.c teem-1.11.0-src/src/limn/renderLimn.c
--- teem-1.11.0-src.orig/src/limn/renderLimn.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/renderLimn.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -107,6 +107,7 @@
 void
 _limnPSDrawFace(limnObject *obj, limnFace *face,
                 limnCamera *cam, Nrrd *nmap, limnWindow *win) {
+  /* static const char me[]="_limnPSDrawFace"; */
   unsigned int vii;
   limnVertex *vert;
   limnLook *look;
@@ -138,7 +139,14 @@
   R = AIR_CLAMP(0, R, 1);
   G = AIR_CLAMP(0, G, 1);
   B = AIR_CLAMP(0, B, 1);
-  if (R == G && G == B) {
+  if (0 && R == G && G == B) {
+    /* As of Sat Mar 1 23:06:14 CST 2014 some version of ghostscript
+       and/or imagemagick will assign (when rasterizing) different
+       colors for RGB color (g,g,g) and graylevel g, which caused
+       strange appearance bugs that were hard to track down. Even if
+       there's a way of preventing this from happening with the right
+       incantation in the EPS header, for now it is simpler to forego
+       the small economy implemented here */
     fprintf(win->file, "CP %g Gr F\n", R);
   }
   else {
@@ -282,9 +290,8 @@
         if (!face1) {
           edge->type = limnEdgeTypeBorder;
         } else {
-          angle = AIR_CAST(float,
-                           180/AIR_PI*acos(ELL_3V_DOT(face0->worldNormal,
-                                                      face1->worldNormal)));
+          angle = AIR_FLOAT(180/AIR_PI*acos(ELL_3V_DOT(face0->worldNormal,
+                                                       face1->worldNormal)));
           if (face0->visible && face1->visible) {
             edge->type = (angle > win->ps.creaseAngle
                           ? limnEdgeTypeFrontCrease
@@ -366,8 +373,8 @@
     if (!face1) {
       edge->type = limnEdgeTypeBorder;
     } else {
-      angle = AIR_CAST(float, 180/AIR_PI*acos(ELL_3V_DOT(face0->worldNormal,
-                                                         face1->worldNormal)));
+      angle = AIR_FLOAT(180/AIR_PI*acos(ELL_3V_DOT(face0->worldNormal,
+                                                   face1->worldNormal)));
       if (face0->visible && face1->visible) {
         edge->type = (angle > win->ps.creaseAngle
                       ? limnEdgeTypeFrontCrease
diff --color -ruN teem-1.11.0-src.orig/src/limn/shapes.c teem-1.11.0-src/src/limn/shapes.c
--- teem-1.11.0-src.orig/src/limn/shapes.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/shapes.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -107,31 +107,31 @@
     case 0:
       tmp = limnObjectVertexAdd(obj, partIdx,
                                 1,
-                                AIR_CAST(float, -sin(theta)),
-                                AIR_CAST(float, cos(theta)));
+                                AIR_FLOAT(-sin(theta)),
+                                AIR_FLOAT(cos(theta)));
       limnObjectVertexAdd(obj, partIdx,
                           -1,
-                          AIR_CAST(float, -sin(theta)),
-                          AIR_CAST(float, cos(theta)));
+                          AIR_FLOAT(-sin(theta)),
+                          AIR_FLOAT(cos(theta)));
       break;
     case 1:
       tmp = limnObjectVertexAdd(obj, partIdx,
-                                AIR_CAST(float, sin(theta)),
+                                AIR_FLOAT(sin(theta)),
                                 1,
-                                AIR_CAST(float, cos(theta)));
+                                AIR_FLOAT(cos(theta)));
       limnObjectVertexAdd(obj, partIdx,
-                          AIR_CAST(float, sin(theta)),
+                          AIR_FLOAT(sin(theta)),
                           -1,
-                          AIR_CAST(float, cos(theta)));
+                          AIR_FLOAT(cos(theta)));
       break;
     case 2: default:
       tmp = limnObjectVertexAdd(obj, partIdx,
-                                AIR_CAST(float, cos(theta)),
-                                AIR_CAST(float, sin(theta)),
+                                AIR_FLOAT(cos(theta)),
+                                AIR_FLOAT(sin(theta)),
                                 1);
       limnObjectVertexAdd(obj, partIdx,
-                          AIR_CAST(float, cos(theta)),
-                          AIR_CAST(float, sin(theta)),
+                          AIR_FLOAT(cos(theta)),
+                          AIR_FLOAT(sin(theta)),
                           -1);
       break;
     }
@@ -179,19 +179,19 @@
     case 0:
       tmp = limnObjectVertexAdd(obj, partIdx,
                                 0,
-                                AIR_CAST(float, -sin(th)),
-                                AIR_CAST(float, cos(th)));
+                                AIR_FLOAT(-sin(th)),
+                                AIR_FLOAT(cos(th)));
       break;
     case 1:
       tmp = limnObjectVertexAdd(obj, partIdx,
-                                AIR_CAST(float, sin(th)),
+                                AIR_FLOAT(sin(th)),
                                 0,
-                                AIR_CAST(float, cos(th)));
+                                AIR_FLOAT(cos(th)));
       break;
     case 2: default:
       tmp = limnObjectVertexAdd(obj, partIdx,
-                                AIR_CAST(float, cos(th)),
-                                AIR_CAST(float, sin(th)),
+                                AIR_FLOAT(cos(th)),
+                                AIR_FLOAT(sin(th)),
                                 0);
       break;
     }
@@ -256,21 +256,21 @@
       switch(axis) {
       case 0:
         limnObjectVertexAdd(obj, partIdx,
-                            AIR_CAST(float, cos(p)),
-                            AIR_CAST(float, -sin(t)*sin(p)),
-                            AIR_CAST(float, cos(t)*sin(p)));
+                            AIR_FLOAT(cos(p)),
+                            AIR_FLOAT(-sin(t)*sin(p)),
+                            AIR_FLOAT(cos(t)*sin(p)));
         break;
       case 1:
         limnObjectVertexAdd(obj, partIdx,
-                            AIR_CAST(float, sin(t)*sin(p)),
-                            AIR_CAST(float, cos(p)),
-                            AIR_CAST(float, cos(t)*sin(p)));
+                            AIR_FLOAT(sin(t)*sin(p)),
+                            AIR_FLOAT(cos(p)),
+                            AIR_FLOAT(cos(t)*sin(p)));
         break;
       case 2: default:
         limnObjectVertexAdd(obj, partIdx,
-                            AIR_CAST(float, cos(t)*sin(p)),
-                            AIR_CAST(float, sin(t)*sin(p)),
-                            AIR_CAST(float, cos(p)));
+                            AIR_FLOAT(cos(t)*sin(p)),
+                            AIR_FLOAT(sin(t)*sin(p)),
+                            AIR_FLOAT(cos(p)));
         break;
       }
     }
@@ -375,9 +375,9 @@
         break;
       }
       limnObjectVertexAdd(obj, partIdx,
-                          AIR_CAST(float, x),
-                          AIR_CAST(float, y),
-                          AIR_CAST(float, z));
+                          AIR_FLOAT(x),
+                          AIR_FLOAT(y),
+                          AIR_FLOAT(z));
     }
   }
   switch(axis) {
diff --color -ruN teem-1.11.0-src.orig/src/limn/sources.cmake teem-1.11.0-src/src/limn/sources.cmake
--- teem-1.11.0-src.orig/src/limn/sources.cmake	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(LIMN_SOURCES
-  cam.c
-  defaultsLimn.c
-  enumsLimn.c
-  envmap.c
-  hestLimn.c
-  io.c
-  light.c
-  limn.h
-  methodsLimn.c
-  obj.c
-  polydata.c
-  polyfilter.c
-  polymod.c
-  polyshapes.c
-  privateLimn.h
-  qn.c
-  renderLimn.c
-  shapes.c
-  splineEval.c
-  splineMethods.c
-  splineMisc.c
-  transform.c
-  )
-
-ADD_TEEM_LIBRARY(limn ${LIMN_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/limn/splineEval.c teem-1.11.0-src/src/limn/splineEval.c
--- teem-1.11.0-src.orig/src/limn/splineEval.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/splineEval.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -40,9 +40,9 @@
 void
 _limnSplineIntervalFind_NonWarp(int *ii, double *ff,
                                 limnSpline *spline, double tt) {
-  int N;
+  int N; /* HEY should be unsigned */
 
-  N = spline->ncpt->axis[2].size + (spline->loop ? 1 : 0);
+  N = AIR_INT(spline->ncpt->axis[2].size + (spline->loop ? 1 : 0));
   tt = AIR_CLAMP(0, tt, N-1);
   *ii = (int)tt;
   *ff = tt - *ii;
@@ -54,7 +54,7 @@
                              limnSpline *spline, double tt) {
   int N;
 
-  N = spline->ncpt->axis[2].size;
+  N = AIR_INT(spline->ncpt->axis[2].size); /* HEY should be unsigned */
   tt = AIR_CLAMP(spline->time[0], tt, spline->time[N-1]);
   *ii = AIR_CLAMP(0, *ii, N-2);
   /* the last value of ii may be the right one */
@@ -175,7 +175,7 @@
 _limnSplineIndexFind(int *idx, limnSpline *spline, int ii) {
   int N, ti[4];
 
-  N = spline->ncpt->axis[2].size;
+  N = AIR_INT(spline->ncpt->axis[2].size); /* should be unsigned */
   if (limnSplineTypeHasImplicitTangents[spline->type]) {
     if (spline->loop) {
       ELL_4V_SET(ti,
diff --color -ruN teem-1.11.0-src.orig/src/limn/splineFit.c teem-1.11.0-src/src/limn/splineFit.c
--- teem-1.11.0-src.orig/src/limn/splineFit.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/limn/splineFit.c	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,1246 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2021  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+
+#include "limn.h"
+typedef unsigned int uint;
+#include <assert.h>
+
+/*
+  This file contains GLK's implementation of the curve fitting described in:
+  Philip J. Schneider. “An Algorithm for Automatically Fitting Digitized
+  Curves”. In Graphics Gems, Academic Press, 1990, pp. 612–626.
+  https://dl.acm.org/doi/10.5555/90767.90941
+  The author's code is here:
+  http://www.realtimerendering.com/resources/GraphicsGems/gems/FitCurves.c
+
+  The functions below do not use any existing limnSpline structs or functions;
+  those were written a long time ago, and reflect GLK's ignorance about
+  splines at the time.  Hopefully this will be revisited and re-organized in a
+  later version of Teem, at which point the code below can be integrated with
+  the rest of limn, but this too will benefit from ongoing scrutiny and
+  re-writing; ignorance persists.
+*/
+
+limnPoints *
+limnPointsNew(const double *pp, uint nn, int isLoop) {
+  limnPoints *lpnt;
+  lpnt = AIR_CALLOC(1, limnPoints); assert(lpnt);
+  if (pp) {
+    /* we are wrapping around a given pre-allocated buffer */
+    lpnt->pp = pp;
+    lpnt->ppOwn = NULL;
+  } else {
+    /* we are allocating our own buffer */
+    lpnt->pp = NULL;
+    lpnt->ppOwn = AIR_CALLOC(nn, double); assert(lpnt->pp);
+  }
+  lpnt->num = nn;
+  lpnt->isLoop = isLoop;
+  return lpnt;
+}
+
+limnPoints *
+limnPointsNix(limnPoints *lpnt) {
+  if (lpnt) {
+    /* don't touch lpnt->pp */
+    if (lpnt->ppOwn) free(lpnt->ppOwn);
+    free(lpnt);
+  }
+  return NULL;
+}
+
+static int
+pointsCheck(const limnPoints *lpnt) {
+  const char me[]="pointsCheck";
+  uint pnmin;
+  int have;
+
+  if (!lpnt) {
+    biffAddf(LIMN, "%s: got NULL pointer", me);
+    return 1;
+  }
+  pnmin = lpnt->isLoop ? 3 : 2;
+  if (!(lpnt->num >= pnmin)) {
+    biffAddf(LIMN, "%s: need %u or more points in limnPoints (not %u)%s",
+             me, pnmin, lpnt->num,
+             lpnt->isLoop ? " for loop" : "");
+    return 1;
+  }
+  have = !!lpnt->pp + !!lpnt->ppOwn;
+  if (1 != have) {
+    biffAddf(LIMN, "%s: need 1 coord pointers (not %d)", me, have);
+    return 1;
+  }
+  return 0;
+}
+
+#define PP(lpnt) ((lpnt)->pp ? (lpnt)->pp : (lpnt)->ppOwn)
+
+/* number of points between low,high indices loi,hii */
+static uint
+pntNum(const limnPoints *lpnt, uint loi, uint hii) {
+  if (hii < loi) {
+    assert(lpnt->isLoop);
+    hii += lpnt->num;
+  }
+  return hii-loi+1;
+}
+
+/* coordinates of point with index loi+ii */
+static const double *
+pntCrd(const limnPoints *lpnt, uint loi, uint ii) {
+  uint jj = loi + ii;
+  if (jj >= lpnt->num) jj -= lpnt->num;
+  return PP(lpnt) + 2*jj;
+}
+
+/* CB0, CB1, CB2, CB3 = degree 3 Bernstein polynomials, for *C*ubic
+   *B*ezier curves, and their derivatives D0, D1, D2 (not using any
+   nice recursion properties for evaluation, oh well) */
+#define CB0D0(T) ((1-(T))*(1-(T))*(1-(T)))
+#define CB1D0(T) (3*(T)*(1-(T))*(1-(T)))
+#define CB2D0(T) (3*(T)*(T)*(1-(T)))
+#define CB3D0(T) ((T)*(T)*(T))
+
+#define CB0D1(T) (-3*(1-(T))*(1-(T)))
+#define CB1D1(T) (3*((T)-1)*(3*(T)-1))
+#define CB2D1(T) (3*(T)*(2-3*(T)))
+#define CB3D1(T) (3*(T)*(T))
+
+#define CB0D2(T) (6*(1-(T)))
+#define CB1D2(T) (6*(3*(T)-2))
+#define CB2D2(T) (6*(1-3*(T)))
+#define CB3D2(T) (6*(T))
+
+/* set 4-vector of weights W by evaluating all CBi at T */
+#define VCBD0(W,T) ((W)[0] = CB0D0(T), \
+                    (W)[1] = CB1D0(T), \
+                    (W)[2] = CB2D0(T), \
+                    (W)[3] = CB3D0(T))
+#define VCBD1(W,T) ((W)[0] = CB0D1(T), \
+                    (W)[1] = CB1D1(T), \
+                    (W)[2] = CB2D1(T), \
+                    (W)[3] = CB3D1(T))
+#define VCBD2(W,T) ((W)[0] = CB0D2(T), \
+                    (W)[1] = CB1D2(T), \
+                    (W)[2] = CB2D2(T), \
+                    (W)[3] = CB3D2(T))
+
+/* get 4-vector of weights at T, and evaluate spline by adding up
+   control points, using weight vector buffer W */
+#define CBDI(P, CB, V0, V1, V2, V3, T, W)             \
+  (CB(W, T),                                          \
+   ELL_2V_SCALE_ADD4(P,                               \
+                     (W)[0], (V0),                    \
+                     (W)[1], (V1),                    \
+                     (W)[2], (V2),                    \
+                     (W)[3], (V3)))
+#define CBD0(P, V0, V1, V2, V3, T, W) CBDI(P, VCBD0, V0, V1, V2, V3, T, W)
+#define CBD1(P, V0, V1, V2, V3, T, W) CBDI(P, VCBD1, V0, V1, V2, V3, T, W)
+#define CBD2(P, V0, V1, V2, V3, T, W) CBDI(P, VCBD2, V0, V1, V2, V3, T, W)
+
+/*
+******** limnCBFSegEval
+**
+** evaluates a single limnCBFSeg at one point tt in [0.0,1.0]
+*/
+void
+limnCBFSegEval(double *vv, const limnCBFSeg *seg, double tt) {
+  double ww[4];
+  const double *xy = seg->xy;
+  CBD0(vv,
+       xy + 0, xy + 2, xy + 4, xy + 6,
+       tt, ww);
+  /*
+  fprintf(stderr, "!%s: tt=%g -> ww={%g,%g,%g,%g} * "
+          "{(%g,%g),(%g,%g),(%g,%g),(%g,%g)} = (%g,%g)\n",
+          "limnCBFSegEval", tt, ww[0], ww[1], ww[2], ww[3],
+          (xy + 0)[0], (xy + 0)[1],
+          (xy + 2)[0], (xy + 2)[1],
+          (xy + 4)[0], (xy + 4)[1],
+          (xy + 6)[0], (xy + 6)[1], vv[0], vv[1]);
+  */
+  return;
+}
+
+/*
+******** limnCBFPathSample
+**
+** evaluates limnCBFPath at pNum locations, uniformly (and very naively)
+** distributed among the path segments, and saves into (pre-allocated) xy
+*/
+void
+limnCBFPathSample(double *xy, uint pNum, const limnCBFPath *path) {
+  uint ii, sNum = path->segNum;
+  for (ii=0; ii<pNum; ii++) {
+    uint segi = airIndex(0, ii, pNum-1, sNum);
+    const limnCBFSeg *seg = path->seg + segi;
+    double tmpf = AIR_AFFINE(0, ii, pNum-1, 0, sNum);
+    double tt = tmpf - segi;
+    limnCBFSegEval(xy + 2*ii, seg, tt);
+    /*
+    fprintf(stderr, "!%s: %u -> %u (%g) %g -> (%g,%g)\n",
+            "limnCBFPathSample", ii, segi, tmpf, tt,
+            (xy + 2*ii)[0], (xy + 2*ii)[1]);
+    */
+  }
+  return;
+}
+
+/*
+** Find endpoint vertex vv and tangent tt (constraints for spline fitting)
+** from the given points lpnt at coord index ii within index range [loi,hoi]
+** (e.g. ii=1 means looking at lpnt coord index loi+1). The tangent direction
+** dir controls which points are looked at:
+** >0: considering only ii and higher-index vertices,
+**  0: for tangent centered at ii, using lower- and higher-index vertices
+** <0: considering only ii and lower-index vertices
+** For >0 and 0: the tangent points towards the positions of higher-
+** index vertices.  For <0, it points the other way.
+** The only point indices accessed will be in [loi,hii]; this is what
+** enforces the possible corner-ness of those indices (which prevents
+** vertices past corners influencing how vv or tt are found)
+*/
+static void
+findVT(double vv[2], double tt[2],
+       const limnCBFContext *fctx,
+       const limnPoints *lpnt, uint loi, uint hii,
+       uint ii, int dir) {
+  /* const char me[]="findVT"; */
+  double len;
+  uint pNum, /* total number of points in lpnts */
+    sgsz;    /* segment size: number of points in [loi,hii] */
+
+  dir = airSgn(dir);
+  pNum = lpnt->num;
+  if (lpnt->isLoop) {
+    sgsz = (hii < loi ? pNum : 0) + hii - loi + 1;
+  } else {
+    sgsz = hii - loi + 1;
+  }
+  if (0 == fctx->scale) {
+    uint mi, pi, iplus, imnus;
+    const double *xy, *xyP, *xyM;
+    if (lpnt->isLoop) {
+      iplus = AIR_MOD(loi+ii+1, pNum);
+      imnus = (uint)AIR_MOD((int)(loi+ii)-1, (int)pNum);
+    } else {
+      /* regardless of lpnt->isLoop, we only look in [loi,hii] */
+      iplus = loi + AIR_MIN(ii+1, sgsz-1);
+      imnus = loi + AIR_MAX(1, ii) - 1;
+    }
+    xy = pntCrd(lpnt, loi, ii);
+    if (vv) ELL_2V_COPY(vv, xy);
+    switch (dir) {
+    case 1:
+      pi = iplus;
+      mi = ii;
+      break;
+    case 0:
+      pi = iplus;
+      mi = imnus;
+      break;
+    case -1:
+      /* mi and pi switched to point other way */
+      mi = ii;
+      pi = imnus;
+      break;
+    }
+    /* if (with !isLoop) ii=0 and dir=-1, or, ii=pNum-1 and dir=+1
+       ==> mi=pi ==> tt will be (nan,nan), which is appropriate */
+    xyP = pntCrd(lpnt, loi, pi);
+    xyM = pntCrd(lpnt, loi, mi);
+    ELL_2V_SUB(tt, xyP, xyM);
+    ELL_2V_NORM(tt, tt, len);
+  } else {
+#if 0
+    /* using scale>0 for endpoint and tangent estimation */
+    const double *vw = fctx->vw;
+    const double *tw = fctx->tw;
+    /* various signed indices */
+    int sii=(int)ii,       /* we compute around vertex ii */
+      smax=(int)fctx->wLen - 1, /* bound of loop index */
+      sj;                  /* loop through [-smax,smax] */
+    if (vv) ELL_2V_SET(vv, 0, 0);
+    ELL_2V_SET(tt, 0, 0);
+    /* printf("!%s: ii = %u, dir=%d\n", me, ii, dir); */
+    /* j indices are for the local looping */
+    for (sj=-smax; sj<=smax; sj++) {
+      uint xj, /* eventual index into data */
+        asj = (uint)AIR_ABS(sj); /* index into vw, tw */
+      int sgn=1,
+        sxj = sii + sj; /* signed (tmp) j idx into data */
+      double ttw;
+      /* printf("!%s[sj=%d,asj=%u]: sxj0 = %d\n", me, sj, asj, sxj); */
+      switch (dir) {
+      case 1:
+        sxj = AIR_MAX(sxj, sii);
+        break;
+      case -1:
+        sgn=-1;
+        sxj = AIR_MIN(sxj, sii);
+        break;
+      }
+      /* sxj = sii+sj, but capped at sii according to dir */
+      /* printf("!%s[sj=%d]: dir=%d -> sxj1 = %d\n", me, sj, dir, sxj); */
+      if (lpnt->isLoop) {
+        sxj = AIR_MOD(sxj, (int)pNum);
+      } else {
+        sxj = AIR_CLAMP(0, sxj, (int)pNum-1);
+      }
+      xj = (uint)sxj;
+      /* printf("!%s[sj=%d]: isLoop=%d -> sxj2 = %d -> xj = %u\n", me, sj, lpnt->isLoop, sxj, xj); */
+      if (vv) ELL_2V_SCALE_INCR(vv, vw[asj], xy + 2*xj);
+      /* printf("!%s[sj=%d]: vv += %g*(%g,%g) -> (%g,%g)\n", me, sj, vw[asj], (xy + 2*xj)[0], (xy + 2*xj)[1], vv[0], vv[1]); */
+      ttw = sgn*airSgn(sj)*tw[asj];
+      /* printf("!%s[sj=%d]: %d * %d * %g = %g\n", me, sj, sgn, airSgn(sj), tw[asj], ttw); */
+      ELL_2V_SCALE_INCR(tt, ttw, xy + 2*xj);
+      /* printf("!%s[sj=%d]: tt += %g*(%g,%g) -> (%g,%g)\n", me, sj, ttw, (xy + 2*xj)[0], (xy + 2*xj)[1], tt[0], tt[1]); */
+    }
+    ELL_2V_NORM(tt, tt, len);
+    /* fix the boundary conditions as a post-process */
+    if (     0==ii && -1==dir) ELL_2V_SET(tt, AIR_NAN, AIR_NAN);
+    if (pNum-1==ii && +1==dir) ELL_2V_SET(tt, AIR_NAN, AIR_NAN);
+    if (vv) {
+      /* some post-proceessing of computed spline endpoint */
+      double off[2], pp[2], operp;
+      ELL_2V_SET(pp, tt[1], -tt[0]); /* pp is perpendicular to tt */
+      ELL_2V_SUB(off, vv, xy + 2*ii);
+      operp = ELL_2V_DOT(off, pp);
+      /* limit distance from chosen (x,y) datapoint to spline endpoint to be
+         (HEY harcoded) 95% of fctx->distMin. Being allowed to be further away
+         can cause annoyances */
+      operp = AIR_MIN(0.95*fctx->distMin, operp);
+      /* constrain difference between chosen (x,y) datapoint and spline
+         endpoint to be perpendicular to estimated tangent */
+      ELL_2V_SCALE_ADD2(vv, 1, xy + 2*ii, operp, pp);
+    }
+#endif
+  }
+  return;
+}
+
+static int
+setVTTV(int *given,
+        double vv0[2], double tt1[2], double tt2[2], double vv3[2],
+        const double _vv0[2], const double _tt1[2],
+        const double _tt2[2], const double _vv3[2],
+        const limnCBFContext *fctx,
+        const limnPoints *lpnt, uint loi, uint hii) {
+  static const char me[]="setVTTV";
+
+  /* either all the _vv0, _tt1, _tt2, _vv3 can be NULL, or none */
+  if (!( _vv0 && _tt1 && _tt2 && _vv3 )) {
+    if ( _vv0 || _tt1 || _tt2 || _vv3 ) {
+      biffAddf(LIMN, "%s: either all or none of vv0,tt1,tt2,vv3 "
+               "should be NULL", me);
+      return 1;
+    }
+    if (lpnt->isLoop) {
+      findVT(vv0, tt1, fctx, lpnt, loi, hii, loi, 0);
+      ELL_2V_COPY(vv3, vv0);
+      ELL_2V_SCALE(tt2, -1, tt1);
+    } else {
+      findVT(vv0, tt1, fctx, lpnt, loi, hii, loi, +1);
+      findVT(vv0, tt1, fctx, lpnt, loi, hii, hii, -1);
+    }
+    if (given) {
+      *given = AIR_FALSE;
+    }
+  } else {
+    /* copy the given endpoint geometry */
+    ELL_2V_COPY(vv0, _vv0);  ELL_2V_COPY(tt1, _tt1);
+    ELL_2V_COPY(tt2, _tt2);  ELL_2V_COPY(vv3, _vv3);
+    if (given) {
+      *given = AIR_TRUE;
+    }
+  }
+  return 0;
+}
+
+/*
+** (from paper page 620) solves for the alpha that minimize squared error
+** between xy[i] and Q(uu[i]) where Q(t) is cubic Bezier spline through vv0,
+** vv0 + alpha[0]*tt1, vv3 + alpha[1]*tt2, and vv3.
+**
+** There are various conditions where the generated spline ignores the
+** xy array and instead is what one could call a "simple arc" (with
+** control points at 1/3 and 2/3 the distance between the end points):
+**  - having only two points (xy contains only the end points)
+**  - the determinant of the 2x2 matrix that is inverted to solve
+**    for alpha is too close to zero (this test was not part of the
+**    author's code)
+**  - the solved alphas are not convincingly positive
+** This function is the only place where the "simple arc" is
+** generated, and generating the simple arc is not actually an error
+** or problem: if it is bad at fitting the data (as determined by
+** finddist) then it may be subdivided, and that's ok. What GLK hasn't
+** thought through is: what is the interaction of nrp iterations and
+** findalpha generating the simple arc on some but not all iterations
+** (possibly unstable?)
+*/
+static void
+findalpha(double alpha[2],
+          limnCBFContext *fctx, /* must be non-NULL */
+          const double vv0[2], const double tt1[2],
+          const double tt2[2], const double vv3[2],
+          const limnPoints *lpnt, uint loi, uint hii) {
+  const char me[]="findalpha";
+  uint ii, pNum;
+  double det;
+
+  pNum = pntNum(lpnt, loi, hii);
+  if (pNum > 2) {
+    double xx[2], m11, m12, m22, MM[4], MI[4];
+    const double *uu = fctx->uu;
+    xx[0] = xx[1] = m11 = m12 = m22 = 0;
+    for (ii=0; ii<pNum; ii++) {
+      const double *xy;
+      double bb[4], Ai1[2], Ai2[2], Pi[2], dmP[2];
+      double ui = uu[ii];
+      VCBD0(bb, ui);
+      ELL_2V_SCALE(Ai1, bb[1], tt1);
+      ELL_2V_SCALE(Ai2, bb[2], tt2);
+      /* GLK using "m" and "M" instead author's "C". Note that Ai1 and
+         Ai2 are scalings of (nominally) unit-length tt1 and tt2 by
+         evaluations of the spline basis functions, so they (and the M
+         computed from them, and det(M)), are invariant w.r.t over-all
+         rescalings of the data points */
+      m11 += ELL_2V_DOT(Ai1, Ai1);
+      m12 += ELL_2V_DOT(Ai1, Ai2);
+      m22 += ELL_2V_DOT(Ai2, Ai2);
+      ELL_2V_SCALE_ADD2(Pi, bb[0]+bb[1], vv0, bb[2]+bb[3], vv3);
+      xy = pntCrd(lpnt, loi, ii);
+      ELL_2V_SUB(dmP, xy, Pi);
+      xx[0] += ELL_2V_DOT(dmP, Ai1);
+      xx[1] += ELL_2V_DOT(dmP, Ai2);
+    }
+    ELL_4V_SET(MM, m11, m12, m12, m22);
+    ELL_2M_INV(MI, MM, det);
+    ELL_2MV_MUL(alpha, MI, xx);
+  } else { /* pNum <= 2 */
+    det = 1; /* bogus but harmless */
+    alpha[0] = alpha[1] = 0; /* trigger simple arc code */
+  }
+  /* test if we should return simple arc */
+  if (!( AIR_EXISTS(det) && AIR_ABS(det) > fctx->detMin
+         && alpha[0] > (fctx->lenF2L)*(fctx->alphaMin)
+         && alpha[1] > (fctx->lenF2L)*(fctx->alphaMin) )) {
+    if (fctx->verbose) {
+      printf("%s: bad |det| %g (vs %g) or alpha %g,%g (vs %g*%g) "
+             "--> simple arc\n",
+             me, AIR_ABS(det), fctx->detMin, alpha[0], alpha[1],
+             fctx->lenF2L, fctx->alphaMin);
+    }
+    /* generate simple arc: set both alphas to 1/3 of distance from
+       first to last point, but also handle non-unit-length tt1 and
+       tt2 */
+    alpha[0] = fctx->lenF2L/(3*ELL_2V_LEN(tt1));
+    alpha[1] = fctx->lenF2L/(3*ELL_2V_LEN(tt2));
+  } else {
+    if (fctx->verbose > 1) {
+      printf("%s: all good: det %g, alpha %g,%g\n",
+             me, det, alpha[0], alpha[1]);
+    }
+  }
+  fctx->alphaDet = det;
+  return;
+}
+
+/*
+** using Newton iterations to try to find a better places at which
+** to evaluate the spline in order to match the given points xy
+*/
+static double
+reparm(const limnCBFContext *fctx, /* must be non-NULL */
+       const double alpha[2],
+       const double vv0[2], const double tt1[2],
+       const double tt2[2], const double vv3[2],
+       const limnPoints *lpnt, uint loi, uint hii) {
+  const char me[]="reparm";
+  uint ii, pNum;
+  double vv1[2], vv2[2], delta, maxdelu;
+  double *uu = fctx->uu;
+
+  pNum = pntNum(lpnt, loi, hii);
+  assert(pNum >= 3);
+  /* average u[i+1]-u[i] is 1/(pNum-1) */
+  maxdelu = fctx->nrpDeltaMax/(pNum-1);
+  ELL_2V_SCALE_ADD2(vv1, 1, vv0, alpha[0], tt1);
+  ELL_2V_SCALE_ADD2(vv2, 1, vv3, alpha[1], tt2);
+  delta = 0;
+  /* only changing parameterization of interior points,
+     not the first (ii=0) or last (ii=pNum-1) */
+  for (ii=1; ii<pNum-1; ii++) {
+    double numer, denom, delu, df[2], ww[4], tt, Q[2], QD[2], QDD[2];
+    const double *xy;
+    tt = uu[ii];
+    CBD0(Q,   vv0, vv1, vv2, vv3, tt, ww);
+    CBD1(QD,  vv0, vv1, vv2, vv3, tt, ww);
+    CBD2(QDD, vv0, vv1, vv2, vv3, tt, ww);
+    xy = pntCrd(lpnt, loi, ii);
+    ELL_2V_SUB(df, Q, xy);
+    numer = ELL_2V_DOT(df, QD);
+    denom = ELL_2V_DOT(QD, QD) + ELL_2V_DOT(df, QDD);
+    delu = numer/denom;
+    if (AIR_ABS(delu) > maxdelu) {
+      /* cap Newton step */
+      delu = maxdelu*airSgn(delu);
+    }
+    uu[ii] = tt - delu;
+    delta += AIR_ABS(delu);
+    if (fctx->verbose > 1) {
+      printf("%s[%2u]: %g <-- %g - %g\n", me, ii,
+             uu[ii], tt, delu);
+    }
+  }
+  delta /= pNum-2;
+  /* HEY TODO: need to make sure that half-way between points,
+     spline isn't wildly diverging; this can happen with the
+     spline making a loop away from a small number of points, e.g.:
+     4 points spline defined by vv0 = (1,1), tt1 = (1,2),
+     tt2 = (1,2), vv3 = (0,1) */
+  return delta;
+}
+
+/* sets fctx->dist to max distance to spline, at point fctx->distIdx,
+   and then sets fctx->distBig accordingly */
+static void
+finddist(limnCBFContext *fctx,
+         const double alpha[2],
+         const double vv0[2], const double tt1[2],
+         const double tt2[2], const double vv3[2],
+         const limnPoints *lpnt, uint loi, uint hii) {
+  uint ii, distI, pNum;
+  double vv1[2], vv2[2], dist;
+  const double *uu = fctx->uu;
+
+  pNum = pntNum(lpnt, loi, hii);
+  assert(pNum >= 3);
+  ELL_2V_SCALE_ADD2(vv1, 1, vv0, alpha[0], tt1);
+  ELL_2V_SCALE_ADD2(vv2, 1, vv3, alpha[1], tt2);
+  dist = AIR_NAN;
+  /* NOTE that the first and last points are actually not part of the max
+     distance calculation, which motivates ensuring that the endpoints
+     generated by findVT are actually sufficiently close to the first and last
+     points (or else the fit spline won't meet the expected accuracy
+     threshold) */
+  for (ii=1; ii<pNum-1; ii++) {
+    double len, Q[2], df[2], ww[4];
+    const double *xy;
+    CBD0(Q, vv0, vv1, vv2, vv3, uu[ii], ww);
+    xy = pntCrd(lpnt, loi, ii);
+    ELL_2V_SUB(df, Q, xy);
+    len = ELL_2V_LEN(df);
+    if (!AIR_EXISTS(dist) || len > dist) {
+      dist = len;
+      distI = ii;
+    }
+  }
+  fctx->dist = dist;
+  fctx->distIdx = distI;
+  fctx->distBig = (dist <= fctx->nrpDistScl * fctx->distMin
+                   ? 0
+                   : (dist <= fctx->distMin
+                      ? 1
+                      : (dist <= fctx->nrpPsi * fctx->distMin
+                         ? 2
+                         : 3)));
+  return;
+}
+
+void
+limnCBFContextInit(limnCBFContext *fctx, int outputOnly) {
+  if (!fctx) return;
+  if (!outputOnly) {
+    /* defaults for input parameters to various CBF functions */
+    fctx->verbose = 0;
+    fctx->cornNMS = AIR_TRUE;
+    fctx->nrpIterMax = 10;
+    fctx->scale = 0;
+    fctx->distMin = 0;
+    fctx->nrpDeltaMax = 3.0;
+    fctx->nrpDistScl = 0.8;
+    fctx->nrpPsi = 6;
+    fctx->nrpDeltaMin = 0.001;
+    fctx->alphaMin = 0.001;
+    fctx->detMin = 0.01;
+    fctx->cornAngle = 100.0; /* degrees */
+  }
+  /* internal */
+  fctx->uu = fctx->vw = fctx->tw = NULL;
+  fctx->mine = NULL;
+  fctx->wLen = 0;
+  fctx->lenF2L = AIR_NAN;
+  /* initialize outputs to bogus valus */
+  fctx->nrpIterDone = (uint)(-1);
+  fctx->distIdx = (uint)(-1);
+  fctx->dist = AIR_POS_INF;
+  fctx->nrpDeltaDone = AIR_POS_INF;
+  fctx->alphaDet = 0;
+  fctx->distBig = 0;
+  return;
+}
+
+/*
+******** limnCBFCheck
+**
+** checks the things that are going to be passed around a lot
+*/
+int
+limnCBFCheck(const limnCBFContext *fctx, const limnPoints *lpnt) {
+  const char me[]="limnCBFCheck";
+
+  if (!(fctx && lpnt)) {
+    biffAddf(LIMN, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (pointsCheck(lpnt)) {
+    biffAddf(LIMN, "%s: problem with points", me);
+    return 1;
+  }
+  if (!(fctx->scale >= 0)) {
+    biffAddf(LIMN, "%s: need non-negative scale (not %g)", me, fctx->scale);
+    return 1;
+  }
+  if (!(fctx->distMin > 0)) {
+    biffAddf(LIMN, "%s: need positive distMin (not %g)", me, fctx->distMin);
+    return 1;
+  }
+  if (fctx->nrpDeltaMin < 0 || fctx->distMin < 0) {
+    biffAddf(LIMN, "%s: cannot have negative nrpDeltaMin (%g) or "
+             "distMin (%g)", me, fctx->nrpDeltaMin, fctx->distMin);
+    return 1;
+  }
+  if (!( 0 < fctx->nrpDistScl && fctx->nrpDistScl <= 1 )) {
+    biffAddf(LIMN, "%s: nrpDistScl (%g) must be in (0,1]",
+             me, fctx->nrpDistScl);
+    return 1;
+  }
+  if (!( 1 <= fctx->nrpPsi )) {
+    biffAddf(LIMN, "%s: nrpPsi (%g) must be >= 1", me, fctx->nrpPsi);
+    return 1;
+  }
+  if (!( fctx->cornAngle < 179 )) {
+    biffAddf(LIMN, "%s: cornAngle (%g) seems too big", me, fctx->cornAngle);
+    return 1;
+  }
+  return 0;
+}
+
+/*
+** fitSingle: fits a single cubic Bezier spline, w/out error checking,
+** limnCBFSingle is a wrapper around this.
+**
+** The given points coordinates are in limnPoints lpnt, between low/high
+** indices loi/hii (inclusively); hii can be < loi in the case of a point
+** loop. From initial endpoint vv0, initial tangent tt1, final endpoint vv3
+** and final tangent tt2 (pointing backwards), this function finds alpha such
+** that the cubic Bezier spline with control points vv0, vv0 + alpha[0]*tt1,
+** vv3 + alpha[1]*tt2, vv3 approximates all the given points.  This is an
+** iterative process, in which alpha is solved for multiples times, after
+** taking a Newton step to try to optimize the parameterization of the points
+** (in an array that is not passed in but instead internal to this function);
+** limn.h calls this process "nrp". nrp iterations are stopped after any one
+** of following is true (the original published method did not have these
+** fine-grained controls):
+**  - have done nrpIterMax iterations of nrp
+**  - if fctx->nrpDeltaMin > 0: parameterization change falls below deltaMin
+**  - if fctx->distMin > 0: distance from spline (as evaluated at the
+**    current parameterization) to the given points falls below
+**    fctx->nrpDistScl * fctx->distMin
+** Information about the results of this process are set in the given
+** fctx.
+*/
+static void
+fitSingle(double alpha[2], limnCBFContext *fctx,
+          const double vv0[2], const double tt1[2],
+          const double tt2[2], const double vv3[2],
+          const limnPoints *lpnt, uint loi, uint hii) {
+  static const char me[]="fitSingle";
+  uint iter, pNum;
+  const double *xy;
+
+  if (fctx->verbose) {
+    printf("%s[%d,%d]: hello, vv0=(%g,%g), tt1=(%g,%g), "
+           "tt2=(%g,%g), vv3=(%g,%g)\n",
+           me, loi, hii, vv0[0], vv0[1], tt1[0], tt1[1],
+           tt2[0], tt2[1], vv3[0], vv3[1]);
+  }
+  { double F2L[2];
+    xy = PP(lpnt);
+    ELL_2V_SUB(F2L, xy + 2*hii, xy + 2*loi);
+    fctx->lenF2L = ELL_2V_LEN(F2L);
+  }
+  pNum = pntNum(lpnt, loi, hii);
+  if (2 == pNum) {
+    /* relying on code in findalpha() that handles pNum==2 */
+    findalpha(alpha, fctx, vv0, tt1, tt2, vv3, lpnt, loi, hii);
+    /* nrp is moot */
+    fctx->nrpIterDone = 0;
+    /* emmulate results of calling finddist() */
+    fctx->dist = fctx->nrpDeltaDone = 0;
+    fctx->distIdx = 0;
+    fctx->distBig = 0;
+  } else { /* pNum >= 3 */
+    double delta; /* avg parameterization change of interior points */
+    /* initialize uu parameterization to chord length */
+    { unsigned int ii; double len;
+      const double *xyP, *xyM;
+      fctx->uu[0] = len = 0;
+      xyP = pntCrd(lpnt, loi, 1);
+      xyM = pntCrd(lpnt, loi, 0);
+      for (ii=1; ii<pNum; ii++) {
+        double dd[2];
+        ELL_2V_SUB(dd, xyP, xyM);
+        len += ELL_2V_LEN(dd);
+        fctx->uu[ii] = len;
+        xyM = xyP;
+        xyP = pntCrd(lpnt, loi, ii+1);
+      }
+      delta = 0;
+      for (ii=0; ii<pNum; ii++) {
+        fctx->uu[ii] /= len;
+        if (fctx->verbose > 1) {
+          printf("%s[%d,%d]: intial uu[%u] = %g\n",
+                 me, loi, hii, ii, fctx->uu[ii]);
+        }
+        delta += AIR_ABS(fctx->uu[ii]);
+      }
+      delta /= pNum-2;
+      if (fctx->verbose) {
+        printf("%s[%d,%d]: initial (chord length) delta = %g\n",
+               me, loi, hii, delta);
+      }
+    }
+    findalpha(alpha, fctx, vv0, tt1, tt2, vv3, lpnt, loi, hii);
+    finddist( fctx, alpha, vv0, tt1, tt2, vv3, lpnt, loi, hii);
+    if (fctx->distBig < 3) {
+      /* initial fit isn't awful; try making it better with nrp */
+      for (iter=0; fctx->distBig && iter<fctx->nrpIterMax; iter++) {
+        if (fctx->verbose) {
+          printf("%s[%d,%d]: iter %u starting with alpha %g,%g (det %g)\n",
+                 me, loi, hii, iter, alpha[0], alpha[1], fctx->alphaDet);
+        }
+        delta = reparm(fctx, alpha, vv0, tt1, tt2, vv3, lpnt, loi, hii);
+        findalpha(alpha, fctx, vv0, tt1, tt2, vv3, lpnt, loi, hii);
+        finddist(fctx, alpha, vv0, tt1, tt2, vv3, lpnt, loi, hii);
+        if (fctx->verbose) {
+          printf("%s[%d,%d]: iter %u (reparm) delta = %g\n", me, loi, hii,
+                 iter, delta);
+        }
+        if (fctx->nrpDeltaMin && delta <= fctx->nrpDeltaMin) {
+          if (fctx->verbose) {
+            printf("%s[%d,%d]: iter %u delta %g <= min %g --> break\n", me,
+                   loi, hii, iter, delta, fctx->nrpDeltaMin);
+          }
+          break;
+        }
+      }
+      if (fctx->verbose) {
+        if (!fctx->distBig) {
+          printf("%s[%d,%d]: iter %u finished with good small dist %g\n",
+                 me, loi, hii, iter, fctx->dist);
+        } else {
+          printf("%s[%d,%d]: hit max iters %u with bad (%d) dist %g\n",
+                 me, loi, hii, iter, fctx->distBig, fctx->dist);
+        }
+      }
+      fctx->nrpIterDone = iter;
+    } else {
+      /* else dist so big that we don't even try nrp */
+      fctx->nrpIterDone = 0;
+    }
+    fctx->nrpDeltaDone = delta;
+  }
+  return;
+}
+
+
+/*
+** buffersNew: allocates in fctx:
+** uu, vw, tw
+*/
+static int
+buffersNew(limnCBFContext *fctx, uint pNum) {
+  const char me[]="buffers";
+  double kw, kparm[2], vsum, tsum, scl = fctx->scale;
+  /* one: what value in summing kernel weights should count as 1.0. This
+     should probably be a parm in fctx, but not very interesting to
+     change */
+  double one = 0.999;
+  uint ii, len;
+
+  fctx->uu = AIR_CALLOC(pNum*2, double);
+  if (!fctx->uu) {
+    biffAddf(LIMN, "%s: failed to allocate parameter buffer", me);
+    return 1;
+  }
+  if (0 == scl) {
+    /* will do simplest possible finite differences; we're done */
+    fctx->vw = fctx->tw = NULL;
+    return 0;
+  }
+  /* else need to allocate and set vw and tw buffers */
+  kparm[0] = scl;
+  kparm[1] = 1000000; /* effectively no cut-off */
+  ii = 0;
+  vsum = 0;
+  do {
+    kw = nrrdKernelDiscreteGaussian->eval1_d(ii, kparm);
+    vsum += (!ii ? 1 : 2)*kw;
+    ii++;
+  } while (vsum < one);
+  /* intended length of vectors */
+  len = ii+1;
+  if (len > 128) {
+    biffAddf(LIMN, "%s: weight buffer length %u (from scale %g) seems "
+             "unreasonable", me, len, scl);
+    return 1;
+  }
+  fctx->vw = AIR_CALLOC(len, double);
+  fctx->tw = AIR_CALLOC(len, double);
+  if (!(fctx->vw && fctx->tw)) {
+    biffAddf(LIMN, "%s: couldn't allocate weight buffers (len %u)", me, len);
+    return 1;
+  }
+  fctx->wLen = len;
+  /* normalization intent:
+     1 = sum_i(vw[|i|]) for i=-(len-1)...len-1
+     1 = sum_i(tw[i]) for i=0...len-1
+  */
+  vsum = tsum = 0;
+  for (ii=0; ii<len; ii++) {
+    kw = nrrdKernelDiscreteGaussian->eval1_d(ii, kparm);
+    vsum += (!ii ? 1 : 2)*(fctx->vw[ii] = kw);
+    tsum += (fctx->tw[ii] = ii*kw);
+  }
+  for (ii=0; ii<len; ii++) {
+    fctx->vw[ii] /= vsum;
+    fctx->tw[ii] /= tsum;
+    /* printf("!%s: %u     %g       %g\n", me, ii, fctx->vw[ii], fctx->tw[ii]); */
+  }
+  return 0;
+}
+
+/* returning a pointer so compatible with an airMopper */
+static void *
+buffersNix(limnCBFContext *fctx) {
+  fctx->uu = airFree(fctx->uu);
+  fctx->vw = airFree(fctx->vw);
+  fctx->tw = airFree(fctx->tw);
+  return NULL;
+}
+
+/* macros to manage the heap-allocated things inside limnCBFContext; working
+   with the idea that each caller passes an OWN variable on their stack, so
+   the NIX macro only frees thing when the address of OWN matches that passed
+   to the NEW. Nothing else in Teem uses this strategy; it may be exploring
+   the clever/stupid boundary that David and Nigel famously identified. */
+#define BUFFERS_NEW(FCTX, NN, OWN)                              \
+  if (!(FCTX)->uu) {                                            \
+    if (buffersNew((FCTX), (NN))) {                             \
+      biffAddf(LIMN, "%s: failed to allocate buffers", me);     \
+      return 1;                                                 \
+    }                                                           \
+    (FCTX)->mine = &(OWN);                                      \
+  }
+
+#define BUFFERS_NIX(FCTX, OWN)                  \
+  if ((FCTX)->mine == &(OWN)) {                 \
+    buffersNix(FCTX);                           \
+    (FCTX)->mine = NULL;                        \
+  }
+
+/*
+******** limnCBFitSingle
+**
+** builds a limnPoints around given xy, determines spline
+** constraints if necessary, and calls fitSingle
+*/
+int
+limnCBFitSingle(double alpha[2], limnCBFContext *_fctx,
+                const double _vv0[2], const double _tt1[2],
+                const double _tt2[2], const double _vv3[2],
+                const double *xy, uint pNum, int isLoop) {
+  const char me[]="limnCBFSingle";
+  double own, vv0[2], tt1[2], tt2[2], vv3[2];
+  uint loi, hii;
+  limnCBFContext *fctx, myfctx;
+  limnPoints *lpnt;
+
+  if (!(alpha && xy && pNum)) {
+    biffAddf(LIMN, "%s: got NULL pointer or 0 points", me);
+    return 1;
+  }
+  lpnt = limnPointsNew(xy, pNum, isLoop);
+  loi = 0;
+  hii = pNum-1;
+  if (_fctx) {
+    fctx = _fctx;   /* caller has supplied info */
+    if (limnCBFCheck(fctx, lpnt)) {
+      biffAddf(LIMN, "%s: problem with fctx", me);
+      limnPointsNix(lpnt); return 1;
+    }
+    limnCBFContextInit(fctx, AIR_TRUE /* outputOnly */);
+  } else {
+    fctx = &myfctx; /* caller supplied nothing: use defaults */
+    limnCBFContextInit(fctx, AIR_FALSE /* outputOnly */);
+  }
+  BUFFERS_NEW(fctx, pNum, own);
+  if (setVTTV(NULL, vv0, tt1, tt2, vv3, _vv0, _tt1, _tt2, _vv3,
+              fctx, lpnt, loi, hii)) {
+    biffAddf(LIMN, "%s: trouble", me);
+    limnPointsNix(lpnt); return 1;
+  }
+  fitSingle(alpha, fctx, vv0, tt1, tt2, vv3, lpnt, loi, hii);
+  BUFFERS_NIX(fctx, own);
+
+  limnPointsNix(lpnt);
+  return 0;
+}
+
+static void
+segInit(void *_seg) {
+  limnCBFSeg *seg = (limnCBFSeg *)_seg;
+  ELL_2V_NAN_SET(seg->xy + 0);
+  ELL_2V_NAN_SET(seg->xy + 2);
+  ELL_2V_NAN_SET(seg->xy + 4);
+  ELL_2V_NAN_SET(seg->xy + 6);
+  seg->corner[0] = seg->corner[1] = AIR_FALSE;
+  seg->pNum = 0;
+  return;
+}
+
+limnCBFPath *
+limnCBFPathNew() {
+  limnCBFPath *path;
+  path = AIR_MALLOC(1, limnCBFPath);
+  if (path) {
+    path->segArr = airArrayNew((void**)(&path->seg), &path->segNum,
+                               sizeof(limnCBFSeg), 128 /* incr */);
+    airArrayStructCB(path->segArr, segInit, NULL);
+    path->isLoop = AIR_FALSE;
+  }
+  return path;
+}
+
+limnCBFPath *
+limnCBFPathNix(limnCBFPath *path) {
+  if (path) {
+    airArrayNuke(path->segArr);
+    free(path);
+  }
+  return NULL;
+}
+
+void
+limnCBFPathJoin(limnCBFPath *dst, const limnCBFPath *src) {
+  uint bb = airArrayLenIncr(dst->segArr, src->segNum);
+  memcpy(dst->seg + bb, src->seg, (src->segNum)*sizeof(limnCBFSeg));
+  return;
+}
+
+/*
+******** limnCBFMulti
+**
+** Fits one or more geometrically continuous splines to a set of points.  Does
+** not look for new internal "corners" (points where the incoming and outgoing
+** tangents are different), but does recursively subdivide the points into
+** left and right sides around points with the highest error from fitSingle.
+*/
+int
+limnCBFMulti(limnCBFPath *path, limnCBFContext *fctx,
+             const double _vv0[2], const double _tt1[2],
+             const double _tt2[2], const double _vv3[2],
+             const limnPoints *lpnt, uint loi, uint hii) {
+  const char me[]="limnCBFMulti";
+  double vv0[2], tt1[2], tt2[2], vv3[2], alpha[2];
+  /* &ownbuff determines who frees buffers inside fctx, since each
+     function call will have distinct stack location for ownbuff */
+  double ownbuff;
+  int geomGiven;
+  uint pNum;
+
+  /* need non-NULL fctx in order to know fctx->distMin */
+  if (limnCBFCheck(fctx, lpnt)) {
+    biffAddf(LIMN, "%s: got bad args", me);
+    return 1;
+  }
+  if (!( loi < lpnt->num && hii < lpnt->num )) {
+    biffAddf(LIMN, "%s: need loi (%u), hii (%u) < #points %u", me,
+             loi, hii, lpnt->num);
+    return 1;
+  }
+  if (loi == hii) {
+    biffAddf(LIMN, "%s: need loi (%u) != hii (%u)", me, loi, hii);
+    return 1;
+  }
+  if (hii < loi && !lpnt->isLoop) {
+    biffAddf(LIMN, "%s: hii (%u) can be < loi (%u) only in loop",
+             me, loi, hii);
+    return 1;
+  }
+  pNum = pntNum(lpnt, loi, hii);
+  BUFFERS_NEW(fctx, pNum, ownbuff);
+  if (setVTTV(&geomGiven, vv0, tt1, tt2, vv3, _vv0, _tt1, _tt2, _vv3,
+              fctx, lpnt, loi, hii)) {
+    biffAddf(LIMN, "%s: trouble", me);
+    return 1;
+  }
+  if (fctx->verbose) {
+    printf("%s[%u,%u]: hello; %s v0=(%g,%g), t1=(%g,%g), t2=(%g,%g), "
+           "v3=(%g,%g)\n", me, loi, hii,
+           geomGiven ? "given" : "computed",
+           vv0[0], vv0[1], tt1[0], tt1[1], tt2[0], tt2[1], vv3[0], vv3[1]);
+  }
+
+  /* first try fitting a single spline */
+  if (fctx->verbose) {
+    printf("%s[%u,%u]: trying single fit on all points\n", me, loi, hii);
+  }
+  fitSingle(alpha, fctx, vv0, tt1, tt2, vv3, lpnt, loi, hii);
+  if (fctx->distBig <= 1) {
+    /* max dist was <= fctx->distMin: single fit was good enough */
+    if (fctx->verbose) {
+      printf("%s[%u,%u]: single fit good: nrpi=%u; dist=%g@%u <= %g; "
+             "det=%g; alpha=%g,%g\n", me, loi, hii, fctx->nrpIterDone,
+             fctx->dist, fctx->distIdx, fctx->distMin,
+             fctx->alphaDet, alpha[0], alpha[1]);
+    }
+    airArrayLenSet(path->segArr, 1);
+    ELL_2V_COPY(path->seg[0].xy + 0, vv0);
+    ELL_2V_SCALE_ADD2(path->seg[0].xy + 2, 1, vv0, alpha[0], tt1);
+    ELL_2V_SCALE_ADD2(path->seg[0].xy + 4, 1, vv3, alpha[1], tt2);
+    ELL_2V_COPY(path->seg[0].xy + 6, vv3);
+    path->seg[0].pNum = pNum;
+  } else { /* need to subdivide at fctx->distIdx and recurse */
+    uint mi = fctx->distIdx;
+    double ttL[2], mid[2], ttR[2];
+    limnCBFPath *prth = limnCBFPathNew(); /* right path */
+    limnCBFContext fctxL, fctxR;
+    memcpy(&fctxL, fctx, sizeof(limnCBFContext));
+    memcpy(&fctxR, fctx, sizeof(limnCBFContext));
+    if (fctx->verbose) {
+      printf("%s[%u,%u]: dist %g big (%d) --> split at %u\n",
+             me, loi, hii, fctx->dist, fctx->distBig,
+             mi);
+    }
+    findVT(mid, ttR, fctx, lpnt, loi, hii, mi, 0);
+    ELL_2V_SCALE(ttL, -1, ttR);
+    /* on recursion, can't be a loop, so isLoop is AIR_FALSE */
+    if (limnCBFMulti(path, &fctxL, vv0, tt1, ttL, mid, lpnt, loi, mi) ||
+        limnCBFMulti(prth, &fctxR, mid, ttR, tt2, vv3, lpnt, mi, hii)) {
+      biffAddf(LIMN, "%s[%u,%u]: trouble on recursive fit", me, loi, hii);
+      limnCBFPathNix(prth); return 1;
+    }
+    limnCBFPathJoin(path, prth);
+    limnCBFPathNix(prth);
+    fctx->nrpIterDone = fctxL.nrpIterDone + fctxR.nrpIterDone;
+    if (fctxL.dist > fctxR.dist) {
+      fctx->dist    = fctxL.dist;
+      fctx->distIdx = fctxL.distIdx;
+      fctx->distBig = fctxL.distBig;
+    } else {
+      fctx->dist    = fctxR.dist;
+      fctx->distIdx = fctxR.distIdx;
+      fctx->distBig = fctxR.distBig;
+    }
+    fctx->nrpDeltaDone = AIR_MAX(fctxL.nrpDeltaDone, fctxR.nrpDeltaDone);
+    fctx->alphaDet = AIR_MIN(fctxL.alphaDet, fctxR.alphaDet);
+  }
+
+  BUFFERS_NIX(fctx, ownbuff);
+  return 0;
+}
+
+int
+limnCBFCorners(uint **cornIdx, uint *cornNum, limnCBFContext *fctx,
+               const limnPoints *lpnt) {
+  const char me[]="limnCBFCorners";
+  airArray *mop, *cornArr;
+  double ownbuff, *angle;
+  uint ii, pNum, loi, hii;
+  int *corn;
+
+  if (!(cornIdx && cornNum && fctx && lpnt)) {
+    biffAddf(LIMN, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (limnCBFCheck(fctx, lpnt)) {
+    biffAddf(LIMN, "%s: got bad args", me);
+    return 1;
+  }
+  if (!fctx->cornAngle) {
+    /* nothing much to do here, because caller doesn't want corners */
+    *cornIdx = NULL;
+    *cornNum = 0;
+    return 0;
+  }
+  loi = 0;
+  hii = lpnt->num-1;
+  pNum = pntNum(lpnt, loi, hii);
+  angle = AIR_CALLOC(pNum, double); assert(angle);
+  /* why assert: GLK tiring of using biff to report allocation failures */
+  corn = AIR_CALLOC(pNum, int); assert(corn);
+  mop = airMopNew();
+  airMopAdd(mop, angle, airFree, airMopAlways);
+  airMopAdd(mop, corn, airFree, airMopAlways);
+  cornArr = airArrayNew(AIR_CAST(void**, cornIdx), cornNum, sizeof(uint), 32);
+  /* free with Nix, not Nuke, because we are managing the given pointers */
+  airMopAdd(mop, cornArr, (airMopper)airArrayNix, airMopAlways);
+  BUFFERS_NEW(fctx, pNum, ownbuff);
+  for (ii=0; ii<pNum; ii++) {
+    double LT[2], RT[2];
+    findVT(NULL, LT, fctx, lpnt, loi, hii, ii, -1);
+    findVT(NULL, RT, fctx, lpnt, loi, hii, ii, +1);
+    angle[ii] = 180*ell_2v_angle_d(LT, RT)/AIR_PI;
+    corn[ii] = (angle[ii] < fctx->cornAngle);
+  }
+  if (fctx->cornNMS) {
+    for (ii=0; ii<pNum; ii++) {
+      uint iplus, imnus;
+      iplus = (ii < pNum-1
+               ? ii+1
+               : (lpnt->isLoop ? 1 : pNum-1));
+      imnus = (ii
+               ? ii-1
+               : (lpnt->isLoop ? pNum-2 : 0));
+      /* stays a corner only if angle smaller than neighbors */
+      corn[ii] &= (angle[ii] < angle[iplus] &&
+                   angle[ii] < angle[imnus]);
+    }
+  }
+  for (ii=0; ii<pNum; ii++) {
+    uint ci;
+    if (!corn[ii]) continue;
+    ci = airArrayLenIncr(cornArr, 1);
+    (*cornIdx)[ci] = ii;
+  }
+  BUFFERS_NIX(fctx, ownbuff);
+  airMopOkay(mop);
+  return 0;
+}
+
+/*
+******** limnCBFit
+**
+** top-level function for fitting cubic beziers to given points
+*/
+int
+limnCBFit(limnCBFPath *path, limnCBFContext *fctx,
+          const double *xy, uint pNum, int isLoop) {
+  const char me[]="limnFctxt";
+  uint *cornIdx=NULL, cornNum=0, cii, loi, hii;
+  limnCBFPath *rpth;
+  limnPoints *lpnt;
+  int ret;
+  airArray *mop;
+
+  if (!(path && fctx && xy)) {
+    biffAddf(LIMN, "%s: got NULL pointer", me);
+    return 1;
+  }
+  lpnt = limnPointsNew(xy, pNum, isLoop);
+  mop = airMopNew();
+  airMopAdd(mop, lpnt, (airMopper)limnPointsNix, airMopAlways);
+  if (limnCBFCheck(fctx, lpnt)) {
+    biffAddf(LIMN, "%s: got bad args", me);
+    airMopError(mop); return 1;
+  }
+  if (fctx->uu) {
+    biffAddf(LIMN, "%s: not expecting limnCBFContext buffers allocated", me);
+    airMopError(mop); return 1;
+  }
+  if (buffersNew(fctx, pNum)) {
+    biffAddf(LIMN, "%s: failed to allocate buffers", me);
+    airMopError(mop); return 1;
+  }
+  airMopAdd(mop, fctx, (airMopper)buffersNix, airMopAlways);
+
+  if (limnCBFCorners(&cornIdx, &cornNum, fctx, lpnt)) {
+    biffAddf(LIMN, "%s: trouble finding corners", me);
+    airMopError(mop); return 1;
+  }
+  if (!cornNum) {
+    /* no corners; do everything with one multi call */
+    ret = limnCBFMulti(path, fctx, NULL, NULL, NULL, NULL, lpnt, 0, pNum-1);
+    path->isLoop = isLoop;
+    if (ret) biffAddf(LIMN, "%s: trouble", me);
+    airMopDone(mop, ret); return ret;
+  }
+  /* else do have corners: split points into segments between corners */
+  /* TODO: if fitting between corners involves wrapping idx past pNum-1? */
+  airArrayLenSet(path->segArr, 0);
+  loi = 0;
+  for (cii=0; cii<cornNum; cii++) {
+    hii = cornIdx[cii];
+    rpth = limnCBFPathNew();
+    ret = limnCBFMulti(rpth, fctx, NULL, NULL, NULL, NULL, lpnt, loi, hii);
+    if (ret) {
+      biffAddf(LIMN, "%s: trouble on corner %u", me, cii);
+      airMopError(mop); return 1;
+    }
+    rpth->seg[0].corner[0] = 1;
+    rpth->seg[rpth->segNum-1].corner[1] = 1;
+    limnCBFPathJoin(path, rpth);
+    limnCBFPathNix(rpth);
+    loi = hii;
+  }
+  rpth = limnCBFPathNew();
+  ret = limnCBFMulti(rpth, fctx, NULL, NULL, NULL, NULL, lpnt, loi, pNum-1);
+  if (ret) {
+    biffAddf(LIMN, "%s: trouble after last corner", me);
+    airMopError(mop); return 1;
+  }
+  rpth->seg[0].corner[0] = 1;
+  rpth->seg[rpth->segNum-1].corner[1] = 1;
+  limnCBFPathJoin(path, rpth);
+  limnCBFPathNix(rpth);
+
+  path->isLoop = isLoop;
+  airMopOkay(mop);
+  return 0;
+}
+
+/*
+TODO:
+rewrite things to use limnPointList, with first and last indices,
+naturally handling the case that last < first, with isLoop
+and new logic: isLoop does NOT depend on duplicate 1st,last coords
+and subtlty that if (with isLoop) hii = (loi-1 % #points) then using
+all points, with no notion of corner possible
+
+testing corners: corners at start==stop of isLoop
+corners not at start or stop of isLoop: do spline wrap around from last to first index?
+
+limnCBFPrune to remove (in-place) coincident and nearly coincident points in xy
+
+use performance tests to explore optimal settings in fctx:
+  nrpIterMax, nrpDeltaMax, nrpDistScl, nrpPsi, nrpDeltaMin
+evaluated in terms of time and #splines needed for fit
+(may want to pay in time for more economical representation)
+
+valgrind everything
+*/
diff --color -ruN teem-1.11.0-src.orig/src/limn/splineMethods.c teem-1.11.0-src/src/limn/splineMethods.c
--- teem-1.11.0-src.orig/src/limn/splineMethods.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/splineMethods.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -64,7 +64,7 @@
   int ii, N;
 
   cpt = (double*)(spline->ncpt->data);
-  N = spline->ncpt->axis[2].size;
+  N = AIR_INT(spline->ncpt->axis[2].size); /* HEY be unsigned */
   time = spline->time;
 
   for (ii=0; ii<N; ii++) {
diff --color -ruN teem-1.11.0-src.orig/src/limn/splineMisc.c teem-1.11.0-src/src/limn/splineMisc.c
--- teem-1.11.0-src.orig/src/limn/splineMisc.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/splineMisc.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -179,7 +179,7 @@
 
   ret = -1;
   if (spline) {
-    ret = spline->ncpt->axis[2].size;
+    ret = AIR_INT(spline->ncpt->axis[2].size); /* HEY be unsigned */
   }
   return ret;
 }
@@ -202,7 +202,7 @@
 
   ret = AIR_NAN;
   if (spline) {
-    N = spline->ncpt->axis[2].size;
+    N = AIR_INT(spline->ncpt->axis[2].size); /* HEY be unsigned */
     if (spline->time) {
       ret = spline->time[N-1];
     } else {
@@ -222,7 +222,7 @@
 }
 
 limnSplineTypeSpec *
-limnSplineTypeSpecParse(char *_str) {
+limnSplineTypeSpecParse(const char *_str) {
   static const char me[]="limnSplineTypeSpecParse";
   limnSplineTypeSpec *spec;
   int type;
@@ -279,7 +279,7 @@
 }
 
 limnSpline *
-limnSplineParse(char *_str) {
+limnSplineParse(const char *_str) {
   static const char me[]="limnSplineParse";
   char *str, *col, *fnameS, *infoS, *typeS, *tmpS;
   int info;
@@ -358,7 +358,8 @@
 ** <splineType>[:B,C]
 */
 int
-_limnHestSplineTypeSpecParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+_limnHestSplineTypeSpecParse(void *ptr, const char *str,
+                             char err[AIR_STRLEN_HUGE]) {
   static const char me[] = "_limnHestSplineTypeSpecParse";
   char *err2;
   limnSplineTypeSpec **specP;
@@ -396,7 +397,8 @@
 ** <nrrdFileName>:<splineInfo>:<splineType>[:B,C]
 */
 int
-_limnHestSplineParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+_limnHestSplineParse(void *ptr, const char *str,
+                     char err[AIR_STRLEN_HUGE]) {
   static const char me[] = "_limnHestSplineParse";
   char *err2;
   limnSpline **splineP;
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/clip.c teem-1.11.0-src/src/limn/test/clip.c
--- teem-1.11.0-src.orig/src/limn/test/clip.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/clip.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -22,7 +23,7 @@
 
 #include "teem/limn.h"
 
-char *info = ("test limnPolyDataClip");
+const char *info = ("test limnPolyDataClip");
 
 int
 main(int argc, const char *argv[]) {
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/didthis.soid.txt teem-1.11.0-src/src/limn/test/didthis.soid.txt
--- teem-1.11.0-src.orig/src/limn/test/didthis.soid.txt	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/didthis.soid.txt	2021-02-18 15:42:32.000000000 +0800
@@ -6,9 +6,9 @@
 alias SOID test/soid -fr $FR -or -e emap.nrrd -rh \
   -ur -0.95 0.95 -vr -0.95 0.95 -wd 1.5 0.7 0.05 -r 0.012
 
-SOID -sc 0.8 0.18 0.18 -o demo-linear.eps 
-SOID -sc 0.8 0.8 0.18 -o demo-planar.eps 
-SOID -sc 0.7 0.7 0.7 -o demo-sphere.eps 
+SOID -sc 0.8 0.18 0.18 -o demo-linear.eps
+SOID -sc 0.8 0.8 0.18 -o demo-planar.eps
+SOID -sc 0.7 0.7 0.7 -o demo-sphere.eps
 
 rm -f emap.nrrd
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/intx.c teem-1.11.0-src/src/limn/test/intx.c
--- teem-1.11.0-src.orig/src/limn/test/intx.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/intx.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../limn.h"
 
-char *info = ("test intersection of two lists.");
+const char *info = ("test intersection of two lists.");
 
 static unsigned int
 flipListIntx(unsigned int *dstC,
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/light.c teem-1.11.0-src/src/limn/test/light.c
--- teem-1.11.0-src.orig/src/limn/test/light.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/light.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/lpu.c teem-1.11.0-src/src/limn/test/lpu.c
--- teem-1.11.0-src.orig/src/limn/test/lpu.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/lpu.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/map.c teem-1.11.0-src/src/limn/test/map.c
--- teem-1.11.0-src.orig/src/limn/test/map.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/map.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/off2eps.c teem-1.11.0-src/src/limn/test/off2eps.c
--- teem-1.11.0-src.orig/src/limn/test/off2eps.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/off2eps.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../limn.h"
 
-char *info = ("Renders an OFF file to an EPS file.");
+const char *info = ("Renders an OFF file to an EPS file.");
 
 int
 main(int argc, const char *argv[]) {
@@ -34,7 +35,6 @@
   hestOpt *hopt=NULL;
   airArray *mop;
   limnObject *obj;
-  limnLook *look; unsigned int lookIdx;
   limnWindow *win;
   Nrrd *nmap;
   FILE *file;
@@ -150,13 +150,6 @@
   airMopAdd(mop, win, (airMopper)limnWindowNix, airMopAlways);
   win->scale = winscale;
 
-  for (lookIdx=0; lookIdx<obj->lookNum; lookIdx++) {
-    look = obj->look + lookIdx;
-    /* earlier version of limn/test/soid used (0.2,0.8,0.0), I think.
-       Now we assume that any useful shading is happening in the emap */
-    ELL_3V_SET(look->kads, 0.2, 0.8, 0);
-  }
-
   if (limnObjectRender(obj, cam, win)
       || (concave
           ? limnObjectPSDrawConcave(obj, cam, nmap, win)
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/plot.c teem-1.11.0-src/src/limn/test/plot.c
--- teem-1.11.0-src.orig/src/limn/test/plot.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/plot.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../limn.h"
 
-char *info = ("Plot!");
+const char *info = ("Plot!");
 
 typedef struct {
   FILE *file;
@@ -224,7 +225,7 @@
 
 void
 plotGraph(plotPS *pps, plotParm *pparm, Nrrd **ndata, int nidx) {
-  int ii, npts;
+  unsigned int ii, npts;
   double xx, yy, *data, val;
 
   if (!( pparm->graphThick[nidx] > 0 )) {
@@ -232,7 +233,7 @@
   }
 
   data = (double *)(ndata[nidx]->data);
-  npts = ndata[nidx]->axis[1].size;
+  npts = AIR_UINT(ndata[nidx]->axis[1].size);
   plotGray(pps, pparm, pparm->graphGray[nidx]);
   fprintf(pps->file, "%g W\n", pps->psc*pparm->graphThick[nidx]);
   for (ii=0; ii<npts; ii++) {
@@ -251,7 +252,7 @@
 
 void
 plotDots(plotPS *pps, plotParm *pparm, Nrrd **ndata, int nidx) {
-  int ii, npts;
+  unsigned int ii, npts;
   double xx, yy, orad, irad, *data, val;
 
   if (!( pparm->dotDiameter[nidx] > 0 )) {
@@ -262,7 +263,7 @@
   fprintf(pps->file, "newpath\n");
   plotWidth(pps, pparm, 0);
   data = (double *)(ndata[nidx]->data);
-  npts = ndata[nidx]->axis[1].size;
+  npts = AIR_UINT(ndata[nidx]->axis[1].size);
   orad = pparm->dotDiameter[nidx]/2;
   irad = pparm->dotInnerDiameterFraction*orad;
   for (ii=0; ii<npts; ii++) {
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/soid.c teem-1.11.0-src/src/limn/test/soid.c
--- teem-1.11.0-src.orig/src/limn/test/soid.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/soid.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,14 +24,15 @@
 
 #include "../limn.h"
 
-char *info = ("Save a single ellipsoid or superquadric into an OFF file.");
+const char *info = ("Save a single ellipsoid or superquadric into an OFF file.");
 
 int
 main(int argc, const char *argv[]) {
   const char *me;
   char *err, *outS;
-  float p[3], q[4], mR[9], eval[3]={0,0,0}, scale[3], len, sh, cl, cp, qA, qB;
+  float p[3], mR[9], eval[3]={0,0,0}, scale[3], sh, cl, cp, qA, qB;
   float matA[16], matB[16], os, rad, AB[2];
+  double q[4], len, mRd[9];
   hestOpt *hopt=NULL;
   airArray *mop;
   limnObject *obj;
@@ -75,7 +77,7 @@
   lookSoid = limnObjectLookAdd(obj);
   look = obj->look + lookSoid;
   ELL_4V_SET(look->rgba, 1, 1, 1, 1);
-  ELL_3V_SET(look->kads, 0.2, 0.8, 0);
+  ELL_3V_SET(look->kads, 0.2f, 0.8f, 0);
   look->spow = 0;
   lookRod = limnObjectLookAdd(obj);
   look = obj->look + lookRod;
@@ -85,11 +87,12 @@
 
   ELL_4V_SET(q, 1, p[0], p[1], p[2]);
   ELL_4V_NORM(q, q, len);
-  ell_q_to_3m_f(mR, q);
+  ell_q_to_3m_d(mRd, q);
+  ELL_3M_COPY_TT(mR, float, mRd); /* just to avoid warnings */
 
   if (AIR_EXISTS(AB[0]) && AIR_EXISTS(AB[1])) {
-    qA = AB[0];
-    qB = AB[1];
+    qA = (float)AB[0];
+    qB = (float)AB[1];
     axis = 2;
   } else {
     ELL_3V_SCALE(scale, os, scale);
@@ -99,12 +102,12 @@
     cp = 2*(eval[1] - eval[2])/(eval[0] + eval[1] + eval[2]);
     if (cl > cp) {
       axis = ELL_MAX3_IDX(scale[0], scale[1], scale[2]);
-      qA = pow(1-cp, sh);
-      qB = pow(1-cl, sh);
+      qA = (float)pow(1-cp, sh);
+      qB = (float)pow(1-cl, sh);
     } else {
       axis = ELL_MIN3_IDX(scale[0], scale[1], scale[2]);
-      qA = pow(1-cl, sh);
-      qB = pow(1-cp, sh);
+      qA = (float)pow(1-cl, sh);
+      qB = (float)pow(1-cp, sh);
     }
     /*
     fprintf(stderr, "eval = %g %g %g -> cl=%g %s cp=%g -> axis = %d\n",
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/tbc.c teem-1.11.0-src/src/limn/test/tbc.c
--- teem-1.11.0-src.orig/src/limn/test/tbc.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/tbc.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -47,7 +48,7 @@
 
 #include "../limn.h"
 
-char *info = ("Visualize the space of BC cubics with a spline.");
+const char *info = ("Visualize the space of BC cubics with a spline.");
 
 int
 main(int argc, const char *argv[]) {
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/tcamanim.c teem-1.11.0-src/src/limn/test/tcamanim.c
--- teem-1.11.0-src.orig/src/limn/test/tcamanim.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/tcamanim.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../limn.h"
 
-char *info = ("Works with camanim.tcl to test camera path splines.");
+const char *info = ("Works with camanim.tcl to test camera path splines.");
 
 #define _LIMNMAGIC "LIMN0000"
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/tcam.c teem-1.11.0-src/src/limn/test/tcam.c
--- teem-1.11.0-src.orig/src/limn/test/tcam.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/tcam.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -66,12 +67,12 @@
   }
 
   printf("%s: W2V:\n", me);
-  ELL_4M_COPY(mat, cam->W2V);
+  ELL_4M_COPY_TT(mat, float, cam->W2V);
   ell_4m_print_f(stdout, mat);
 
   printf("\n");
   printf("%s: V2W:\n", me);
-  ELL_4M_COPY(mat, cam->V2W);
+  ELL_4M_COPY_TT(mat, float, cam->V2W);
   ell_4m_print_f(stdout, mat);
 
   airMopOkay(mop);
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/tio.c teem-1.11.0-src/src/limn/test/tio.c
--- teem-1.11.0-src.orig/src/limn/test/tio.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/tio.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../limn.h"
 
-char *info = ("throw-away.");
+const char *info = ("throw-away.");
 
 int
 main(int argc, char *argv[]) {
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/tps.c teem-1.11.0-src/src/limn/test/tps.c
--- teem-1.11.0-src.orig/src/limn/test/tps.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/tps.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../limn.h"
 
-char *info = ("Render something in postscript.");
+const char *info = ("Render something in postscript.");
 
 int
 main(int argc, const char *argv[]) {
@@ -107,40 +108,40 @@
   /* X axis: rod */
   partIdx = limnObjectCylinderAdd(obj, 0, 0, 16);
   ELL_4M_IDENTITY_SET(matA);
-  ELL_4M_SCALE_SET(matB, 1, 0.2, 0.2); ell_4m_post_mul_f(matA, matB);
-  ELL_4M_TRANSLATE_SET(matB, 1.3, 0.0, 0.0); ell_4m_post_mul_f(matA, matB);
+  ELL_4M_SCALE_SET(matB, 1, 0.2f, 0.2f); ell_4m_post_mul_f(matA, matB);
+  ELL_4M_TRANSLATE_SET(matB, 1.3f, 0, 0); ell_4m_post_mul_f(matA, matB);
   limnObjectPartTransform(obj, partIdx, matA);
 
   /* Y axis: rod + ball */
   partIdx = limnObjectCylinderAdd(obj, 0, 1, 16);
   ELL_4M_IDENTITY_SET(matA);
-  ELL_4M_SCALE_SET(matB, 0.2, 1, 0.2); ell_4m_post_mul_f(matA, matB);
-  ELL_4M_TRANSLATE_SET(matB, 0.0, 1.3, 0.0); ell_4m_post_mul_f(matA, matB);
+  ELL_4M_SCALE_SET(matB, 0.2f, 1, 0.2f); ell_4m_post_mul_f(matA, matB);
+  ELL_4M_TRANSLATE_SET(matB, 0, 1.3f, 0); ell_4m_post_mul_f(matA, matB);
   limnObjectPartTransform(obj, partIdx, matA);
 
   partIdx = limnObjectPolarSphereAdd(obj, 0, 0, 32, 16);
   ELL_4M_IDENTITY_SET(matA);
-  ELL_4M_SCALE_SET(matB, 0.28, 0.28, 0.28); ell_4m_post_mul_f(matA, matB);
-  ELL_4M_TRANSLATE_SET(matB, 0.0, 2.6, 0.0); ell_4m_post_mul_f(matA, matB);
+  ELL_4M_SCALE_SET(matB, 0.28f, 0.28f, 0.28f); ell_4m_post_mul_f(matA, matB);
+  ELL_4M_TRANSLATE_SET(matB, 0, 2.6f, 0); ell_4m_post_mul_f(matA, matB);
   limnObjectPartTransform(obj, partIdx, matA);
 
   /* Z axis: rod + ball + ball */
   partIdx = limnObjectCylinderAdd(obj, 0, 2, 16);
   ELL_4M_IDENTITY_SET(matA);
-  ELL_4M_SCALE_SET(matB, 0.2, 0.2, 1); ell_4m_post_mul_f(matA, matB);
-  ELL_4M_TRANSLATE_SET(matB, 0.0, 0.0, 1.3); ell_4m_post_mul_f(matA, matB);
+  ELL_4M_SCALE_SET(matB, 0.2f, 0.2f, 1); ell_4m_post_mul_f(matA, matB);
+  ELL_4M_TRANSLATE_SET(matB, 0, 0, 1.3f); ell_4m_post_mul_f(matA, matB);
   limnObjectPartTransform(obj, partIdx, matA);
 
   partIdx = limnObjectPolarSphereAdd(obj, 0, 1, 32, 16);
   ELL_4M_IDENTITY_SET(matA);
-  ELL_4M_SCALE_SET(matB, 0.28, 0.28, 0.28); ell_4m_post_mul_f(matA, matB);
-  ELL_4M_TRANSLATE_SET(matB, 0.0, 0.0, 2.6); ell_4m_post_mul_f(matA, matB);
+  ELL_4M_SCALE_SET(matB, 0.28f, 0.28f, 0.28f); ell_4m_post_mul_f(matA, matB);
+  ELL_4M_TRANSLATE_SET(matB, 0, 0, 2.6f); ell_4m_post_mul_f(matA, matB);
   limnObjectPartTransform(obj, partIdx, matA);
 
   partIdx = limnObjectPolarSphereAdd(obj, 0, 2, 32, 16);
   ELL_4M_IDENTITY_SET(matA);
-  ELL_4M_SCALE_SET(matB, 0.28, 0.28, 0.28); ell_4m_post_mul_f(matA, matB);
-  ELL_4M_TRANSLATE_SET(matB, 0.0, 0.0, 3.2); ell_4m_post_mul_f(matA, matB);
+  ELL_4M_SCALE_SET(matB, 0.28f, 0.28f, 0.28f); ell_4m_post_mul_f(matA, matB);
+  ELL_4M_TRANSLATE_SET(matB, 0, 0, 3.2f); ell_4m_post_mul_f(matA, matB);
   limnObjectPartTransform(obj, partIdx, matA);
 
   win = limnWindowNew(limnDevicePS);
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/tqn.c teem-1.11.0-src/src/limn/test/tqn.c
--- teem-1.11.0-src.orig/src/limn/test/tqn.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/tqn.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/triimg.c teem-1.11.0-src/src/limn/test/triimg.c
--- teem-1.11.0-src.orig/src/limn/test/triimg.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/triimg.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,9 +24,9 @@
 
 #include "../limn.h"
 
-char *info = ("Save a triangular piece of an image to an EPS file. "
-              "You might want to ilk -t 1,-0.5,0,0,0.866,0 -k tent "
-              "-0 u:0,1 -b pad -bg 0 before you use this. ");
+const char *info = ("Save a triangular piece of an image to an EPS file. "
+                    "You might want to ilk -t 1,-0.5,0,0,0.866,0 -k tent "
+                    "-0 u:0,1 -b pad -bg 0 before you use this. ");
 
 int
 main(int argc, const char *argv[]) {
@@ -37,8 +38,8 @@
   FILE *file;
   char *outS;
   Nrrd *nin;
-  float width, scale, hack, minX, maxX, minY, maxY;
-  int gray, sx, sy, labels;
+  double width, scale, hack, minX, maxX, minY, maxY;
+  unsigned int gray, sx, sy, labels;
 
   mop = airMopNew();
   me = argv[0];
@@ -68,8 +69,8 @@
             airEnumStr(nrrdType, nin->type));
     airMopError(mop); return 1;
   }
-  sx = (2 == nin->dim ? nin->axis[0].size : nin->axis[1].size);
-  sy = (2 == nin->dim ? nin->axis[1].size : nin->axis[2].size);
+  sx = AIR_UINT(2 == nin->dim ? nin->axis[0].size : nin->axis[1].size);
+  sy = AIR_UINT(2 == nin->dim ? nin->axis[1].size : nin->axis[2].size);
   gray = 2 == nin->dim || 1 == nin->axis[0].size;
   if (!( sx == sy )) {
     fprintf(stderr, "%s: image must be square (not %d x %d)\n", me, sx, sy);
diff --color -ruN teem-1.11.0-src.orig/src/limn/test/tspline.c teem-1.11.0-src/src/limn/test/tspline.c
--- teem-1.11.0-src.orig/src/limn/test/tspline.c	2012-12-20 22:07:28.000000000 +0800
+++ teem-1.11.0-src/src/limn/test/tspline.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -47,9 +48,9 @@
 
 #include "../limn.h"
 
-char *info = ("Test limnSplines by drawing postscript curves. "
-              "As such, the only limnSpline allowed is 2vector. "
-              "The output is written to standard out.");
+const char *info = ("Test limnSplines by drawing postscript curves. "
+                    "As such, the only limnSpline allowed is 2vector. "
+                    "The output is written to standard out.");
 
 int
 main(int argc, const char *argv[]) {
diff --color -ruN teem-1.11.0-src.orig/src/limn/transform.c teem-1.11.0-src/src/limn/transform.c
--- teem-1.11.0-src.orig/src/limn/transform.c	2012-12-20 22:07:36.000000000 +0800
+++ teem-1.11.0-src/src/limn/transform.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -37,7 +37,7 @@
   }
   for (vertIdx=0; vertIdx<obj->vertNum; vertIdx++) {
     vert = obj->vert + vertIdx;
-    h = AIR_CAST(float, 1.0/vert->world[3]);
+    h = AIR_FLOAT(1.0/vert->world[3]);
     ELL_3V_SCALE(vert->world, h, vert->world);
     vert->world[3] = 1.0;
     ELL_3V_NORM_TT(vert->worldNormal, float, vert->worldNormal, h);
@@ -137,7 +137,7 @@
   for (vertIdx=0; vertIdx<obj->vertNum; vertIdx++) {
     vert = obj->vert + vertIdx;
     ELL_4MV_MUL_TT(vert->coord, float, cam->W2V, vert->world);
-    d = AIR_CAST(float, 1.0/vert->world[3]);
+    d = AIR_FLOAT(1.0/vert->world[3]);
     ELL_4V_SCALE(vert->coord, d, vert->coord);
     /*
     printf("%s: w[%d] = %g %g %g %g --> v = %g %g %g\n",
@@ -166,7 +166,7 @@
     vert = obj->vert + vertIdx;
     d = (cam->orthographic
          ? 1.0f
-         : AIR_CAST(float, cam->vspDist/vert->coord[2]));
+         : AIR_FLOAT(cam->vspDist/vert->coord[2]));
     vert->coord[0] *= d;
     vert->coord[1] *= d;
     /* coord[2] unchanged */
@@ -194,19 +194,19 @@
     return 1;
   }
   wx0 = 0;
-  wx1 = AIR_CAST(float, (cam->uRange[1] - cam->uRange[0])*win->scale);
+  wx1 = AIR_FLOAT((cam->uRange[1] - cam->uRange[0])*win->scale);
   wy0 = 0;
-  wy1 = AIR_CAST(float, (cam->vRange[1] - cam->vRange[0])*win->scale);
+  wy1 = AIR_FLOAT((cam->vRange[1] - cam->vRange[0])*win->scale);
   ELL_4V_SET(win->bbox, wx0, wy0, wx1, wy1);
   if (win->yFlip) {
     ELL_SWAP2(wy0, wy1, t);
   }
   for (vertIdx=0; vertIdx<obj->vertNum; vertIdx++) {
     vert = obj->vert + vertIdx;
-    vert->coord[0] = AIR_CAST(float, AIR_AFFINE(cam->uRange[0], vert->coord[0],
-                                                cam->uRange[1], wx0, wx1));
-    vert->coord[1] = AIR_CAST(float, AIR_AFFINE(cam->vRange[0], vert->coord[1],
-                                                cam->vRange[1], wy0, wy1));
+    vert->coord[0] = AIR_FLOAT(AIR_AFFINE(cam->uRange[0], vert->coord[0],
+                                          cam->uRange[1], wx0, wx1));
+    vert->coord[1] = AIR_FLOAT(AIR_AFFINE(cam->vRange[0], vert->coord[1],
+                                          cam->vRange[1], wy0, wy1));
     /* coord[2] unchanged */
     /*
     printf("%s: s[%d] = %g %g --> s = %g %g\n", "_limnObjectDTransform",
diff --color -ruN teem-1.11.0-src.orig/src/make/darwin.mk teem-1.11.0-src/src/make/darwin.mk
--- teem-1.11.0-src.orig/src/make/darwin.mk	2012-12-20 22:08:22.000000000 +0800
+++ teem-1.11.0-src/src/make/darwin.mk	2021-02-18 15:42:37.000000000 +0800
@@ -27,7 +27,7 @@
 
 LD = gcc
 
-OPT_CFLAG ?= -O3
+OPT_CFLAG ?= -O3 -g
 STATIC_CFLAG = -Wl,-prebind
 SHARED_CFLAG =
 SHARED_LDFLAG = -dynamic -dynamiclib -fno-common
diff --color -ruN teem-1.11.0-src.orig/src/make/old/README.txt teem-1.11.0-src/src/make/old/README.txt
--- teem-1.11.0-src.orig/src/make/old/README.txt	2012-12-20 22:08:22.000000000 +0800
+++ teem-1.11.0-src/src/make/old/README.txt	2021-02-18 15:42:37.000000000 +0800
@@ -29,7 +29,7 @@
   used to create binaries, so as to control whether shared or static
   libraries are linked against.
 
-BIN_CFLAGS: any flags to $(CC) which should be used for compiling 
+BIN_CFLAGS: any flags to $(CC) which should be used for compiling
   binaries (in addition to the SHARED_CFLAG, STATIC_CFLAG flags above)
 
 OPT_CFLAG: how to control optimization
@@ -49,7 +49,7 @@
 LDFLAGS: any flags to $(LD) for making shared libraries, in addition
   to $(ARCH_LDFLAG) $(SHARED_LDFLAG)
 
-NONPIC_CFLAG, PIC_CFLAG (*): flags to $(CC) to force generation of PIC 
+NONPIC_CFLAG, PIC_CFLAG (*): flags to $(CC) to force generation of PIC
   objects off and on
 
 PIC_MATTERS: if set to "true", then a seperate set of .o files,
diff --color -ruN teem-1.11.0-src.orig/src/make/README.txt teem-1.11.0-src/src/make/README.txt
--- teem-1.11.0-src.orig/src/make/README.txt	2012-12-20 22:08:22.000000000 +0800
+++ teem-1.11.0-src/src/make/README.txt	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 #
-# Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Teem: Tools to process and visualize scientific data and images
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -58,7 +58,7 @@
   used to create binaries, so as to control whether shared or static
   libraries are linked against.
 
-BIN_CFLAGS: any flags to $(CC) which should be used for compiling 
+BIN_CFLAGS: any flags to $(CC) which should be used for compiling
   binaries (in addition to the SHARED_CFLAG, STATIC_CFLAG flags above)
 
 OPT_CFLAG: how to control optimization (if desired)
@@ -78,7 +78,7 @@
 LDFLAGS: any flags to $(LD) for making shared libraries, in addition
   to $(ARCH_LDFLAG) $(SHARED_LDFLAG)
 
-OTHER_CLEAN: other files that might have been created automatically 
+OTHER_CLEAN: other files that might have been created automatically
   as part of compilation, but which should be deleted if "make clean"
   is to be true to its word (e.g. "so_locations" on SGI)
 
@@ -90,14 +90,14 @@
   assumption is that there is no new library to compile, but simply
   a set of binaries which depend on other libraries
 
-LIB_BASENAME: the base name of the archive and shared library files; 
+LIB_BASENAME: the base name of the archive and shared library files;
   by default this is set to "lib$(LIB)", but setting this allows one
   to over-ride that.
 
 HEADERS: the "public" .h files for this library; these will be installed
 
 PRIV_HEADERS: .h files needed for this library, but not installed
-  
+
 LIBOBJS: the .o files (created from .c files) which comprise this library
 
 TEST_BINS: executables which are used to debug a library, but which will
diff --color -ruN teem-1.11.0-src.orig/src/make/release-def-check.csh teem-1.11.0-src/src/make/release-def-check.csh
--- teem-1.11.0-src.orig/src/make/release-def-check.csh	2012-12-20 22:08:22.000000000 +0800
+++ teem-1.11.0-src/src/make/release-def-check.csh	2021-02-18 15:42:37.000000000 +0800
@@ -1,7 +1,7 @@
 #!/bin/csh
 #
 # Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -34,6 +34,7 @@
 echo "======================"
 echo "looking in $D; assuming its up-to-date"
 echo "Should see only TEEM-related #defines below"
+echo "as well as Tau-related gage/air stuff"
 echo "======================"
 
 cd ~/teem-install/include
diff --color -ruN teem-1.11.0-src.orig/src/make/release-nm-check.csh teem-1.11.0-src/src/make/release-nm-check.csh
--- teem-1.11.0-src.orig/src/make/release-nm-check.csh	2012-12-20 22:08:22.000000000 +0800
+++ teem-1.11.0-src/src/make/release-nm-check.csh	2021-02-18 15:42:37.000000000 +0800
@@ -1,7 +1,7 @@
 #!/bin/csh
 #
 # Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/make/template.mk teem-1.11.0-src/src/make/template.mk
--- teem-1.11.0-src.orig/src/make/template.mk	2012-12-20 22:08:22.000000000 +0800
+++ teem-1.11.0-src/src/make/template.mk	2021-02-18 15:42:37.000000000 +0800
@@ -1,5 +1,5 @@
 #
-# Teem: Tools to process and visualize scientific data and images              
+# Teem: Tools to process and visualize scientific data and images
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -20,7 +20,7 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-#### 
+####
 #### template.mk: Defines rules which have the same structure for each
 #### library, but which refer to the specific constituents and
 #### prerequisites of the library.  The rules defined here are
@@ -129,10 +129,10 @@
 ##   then add SHARED_INSTALL_NAME flag to the link command making the shared lib
 ## - ... $(LDFLAGS) $(LPATH) ...
 ## - all architectures: add "-l<lib>" for all <lib> that this lib relies on
-## - all architectures: add -L<path> and -l<lib> for external libraries that 
+## - all architectures: add -L<path> and -l<lib> for external libraries that
 ##   this library could depend on
 
-## maybebanner.(L)(obj) returns "echo ..." to show a library banner 
+## maybebanner.(L)(obj) returns "echo ..." to show a library banner
 ## progress indicator, but only if obj is the first object in $(L).OBJS.
 ## This mimics the behavior under the old recursive teem makefile.
 ##
diff --color -ruN teem-1.11.0-src.orig/src/matlab/nrrdLoad.c teem-1.11.0-src/src/matlab/nrrdLoad.c
--- teem-1.11.0-src.orig/src/matlab/nrrdLoad.c	2012-12-20 22:09:21.000000000 +0800
+++ teem-1.11.0-src/src/matlab/nrrdLoad.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/matlab/nrrdLoadOrientation.c teem-1.11.0-src/src/matlab/nrrdLoadOrientation.c
--- teem-1.11.0-src.orig/src/matlab/nrrdLoadOrientation.c	2012-12-20 22:09:21.000000000 +0800
+++ teem-1.11.0-src/src/matlab/nrrdLoadOrientation.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/matlab/nrrdSave.c teem-1.11.0-src/src/matlab/nrrdSave.c
--- teem-1.11.0-src.orig/src/matlab/nrrdSave.c	2012-12-20 22:09:21.000000000 +0800
+++ teem-1.11.0-src/src/matlab/nrrdSave.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/meet/CMakeLists.txt teem-1.11.0-src/src/meet/CMakeLists.txt
--- teem-1.11.0-src.orig/src/meet/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/meet/CMakeLists.txt	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,13 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(MEET_SOURCES
+  enumall.c
+  meetNrrd.c
+  meetGage.c
+  meetPull.c
+  meet.h
+  )
+
+target_sources(teem PRIVATE ${MEET_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( meet FILES ${MEET_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/meet/enumall.c teem-1.11.0-src/src/meet/enumall.c
--- teem-1.11.0-src.orig/src/meet/enumall.c	2012-12-20 22:09:21.000000000 +0800
+++ teem-1.11.0-src/src/meet/enumall.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -83,6 +83,8 @@
   ii = airArrayLenIncr(arr, 1); enm[ii] = nrrdField;
   ii = airArrayLenIncr(arr, 1); enm[ii] = nrrdSpace;
   ii = airArrayLenIncr(arr, 1); enm[ii] = nrrdSpacingStatus;
+  ii = airArrayLenIncr(arr, 1); enm[ii] = nrrdFormatPNGsRGBIntent;
+  ii = airArrayLenIncr(arr, 1); enm[ii] = nrrdOrientationHave;
   ii = airArrayLenIncr(arr, 1); enm[ii] = nrrdBoundary;
   ii = airArrayLenIncr(arr, 1); enm[ii] = nrrdMeasure;
   ii = airArrayLenIncr(arr, 1); enm[ii] = nrrdUnaryOp;
@@ -90,8 +92,10 @@
   ii = airArrayLenIncr(arr, 1); enm[ii] = nrrdTernaryOp;
   ii = airArrayLenIncr(arr, 1); enm[ii] = nrrdFFTWPlanRigor;
   ii = airArrayLenIncr(arr, 1); enm[ii] = nrrdResampleNonExistent;
+  ii = airArrayLenIncr(arr, 1); enm[ii] = nrrdMetaDataCanonicalVersion;
 
   /* ell */
+  ii = airArrayLenIncr(arr, 1); enm[ii] = ell_quadratic_root;
   ii = airArrayLenIncr(arr, 1); enm[ii] = ell_cubic_root;
 
   /* unrrdu: no airEnums */
@@ -113,8 +117,11 @@
   ii = airArrayLenIncr(arr, 1); enm[ii] = gageItemPackPart;
   ii = airArrayLenIncr(arr, 1); enm[ii] = gageScl;
   ii = airArrayLenIncr(arr, 1); enm[ii] = gageVec;
+  ii = airArrayLenIncr(arr, 1); enm[ii] = gage2Vec;
+  ii = airArrayLenIncr(arr, 1); enm[ii] = gageSigmaSampling;
 
-  /* dye: no airEnums */
+  /* dye */
+  ii = airArrayLenIncr(arr, 1); enm[ii] = dyeSpace;
 
 #if defined(TEEM_BUILD_EXPERIMENTAL_LIBS)
   /* bane */
@@ -166,6 +173,7 @@
   ii = airArrayLenIncr(arr, 1); enm[ii] = pullProp;
   ii = airArrayLenIncr(arr, 1); enm[ii] = pullProcessMode;
   ii = airArrayLenIncr(arr, 1); enm[ii] = pullTraceStop;
+  ii = airArrayLenIncr(arr, 1); enm[ii] = pullInitMethod;
   ii = airArrayLenIncr(arr, 1); enm[ii] = pullCount;
   ii = airArrayLenIncr(arr, 1); enm[ii] = pullConstraintFail;
 
@@ -207,7 +215,7 @@
     fprintf(file, "\n");
     ei++;
   }
-  free(AIR_CAST(void *, enm));
+  free(AIR_VOIDP(enm));
   return;
 }
 
diff --color -ruN teem-1.11.0-src.orig/src/meet/GNUmakefile teem-1.11.0-src/src/meet/GNUmakefile
--- teem-1.11.0-src.orig/src/meet/GNUmakefile	2012-12-20 22:09:21.000000000 +0800
+++ teem-1.11.0-src/src/meet/GNUmakefile	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -49,7 +49,7 @@
 $(L).NEED = air hest biff nrrd ell unrrdu alan moss tijk gage dye bane limn echo hoover seek ten elf pull coil push mite
 $(L).PUBLIC_HEADERS = meet.h
 $(L).OBJS = enumall.o meetNrrd.o meetGage.o meetPull.o
-$(L).TESTS = test/strace test/tenums
+$(L).TESTS = test/strace test/vpnts test/tenums
 ####
 ####
 ####
diff --color -ruN teem-1.11.0-src.orig/src/meet/meetGage.c teem-1.11.0-src/src/meet/meetGage.c
--- teem-1.11.0-src.orig/src/meet/meetGage.c	2012-12-20 22:09:21.000000000 +0800
+++ teem-1.11.0-src/src/meet/meetGage.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -38,6 +38,8 @@
   }
   if (!strcmp(gageKindScl->name, str)) {
     ret = gageKindScl;
+  } else if (!strcmp(gageKind2Vec->name, str)) {
+    ret = gageKind2Vec;
   } else if (!strcmp(gageKindVec->name, str)) {
     ret = gageKindVec;
   } else if (!strcmp(tenGageKind->name, str)) {
@@ -68,7 +70,8 @@
 ** which isn't const
 */
 int
-_meetHestConstGageKindParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+_meetHestConstGageKindParse(void *ptr, const char *str,
+                            char err[AIR_STRLEN_HUGE]) {
   char me[] = "_meetHestGageConstKindParse";
   const gageKind **kindP;
 
@@ -81,9 +84,9 @@
   kindP = (const gageKind **)ptr;
   *kindP = meetConstGageKindParse(str);
   if (!*kindP) {
-    sprintf(err, "%s: \"%s\" not \"%s\", \"%s\", or \"%s\"", me, str,
-            gageKindScl->name, gageKindVec->name,
-            tenGageKind->name);
+    sprintf(err, "%s: \"%s\" not \"%s\", \"%s\", \"%s\", or \"%s\"", me, str,
+            gageKindScl->name, gageKind2Vec->name,
+            gageKindVec->name, tenGageKind->name);
     return 1;
   }
 
@@ -91,7 +94,8 @@
 }
 
 int
-_meetHestGageKindParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+_meetHestGageKindParse(void *ptr, const char *str,
+                       char err[AIR_STRLEN_HUGE]) {
   char me[] = "_meetHestGageKindParse";
   gageKind **kindP;
 
@@ -102,8 +106,8 @@
   kindP = (gageKind **)ptr;
   *kindP = meetGageKindParse(str);
   if (!*kindP) {
-    sprintf(err, "%s: \"%s\" not \"%s\", \"%s\", \"%s\", or \"%s\"", me,
-            str, gageKindScl->name, gageKindVec->name,
+    sprintf(err, "%s: \"%s\" not \"%s\", \"%s\", \"%s\", \"%s\", or \"%s\"", me,
+            str, gageKindScl->name, gageKind2Vec->name, gageKindVec->name,
             tenGageKind->name, TEN_DWI_GAGE_KIND_NAME);
     return 1;
   }
diff --color -ruN teem-1.11.0-src.orig/src/meet/meet.h teem-1.11.0-src/src/meet/meet.h
--- teem-1.11.0-src.orig/src/meet/meet.h	2012-12-20 22:09:21.000000000 +0800
+++ teem-1.11.0-src/src/meet/meet.h	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -118,19 +118,23 @@
   const gageKind *kind;
   char *fileName,
     *volName;
-  int derivNormSS,             /* normalize derivatives based on scale */
-    uniformSS,                 /* uniform sampling along scale */
-    optimSS,                   /* optimal (non-uniform) sampling of scale */
-    leeching,                  /* non-zero iff using the same nin and ninSS
-                                  as another meetPullVol (so as to avoid
-                                  redundant copies in memory) */
-    recomputedSS;              /* (OUTPUT) non-zero if meetPullVolLoadMulti
-                                  had to recompute these, versus being read
-                                  from disk */
-  unsigned int numSS;
-  double rangeSS[2], derivNormBiasSS, *posSS;
-  Nrrd *nin;                             /* we DO own */
-  Nrrd **ninSS;                          /* we DO own */
+  gageStackBlurParm *sbp;  /* the right place to store everything about how to
+                              pre-compute a blurring of an image, replacing
+                              uniformSS, optimSS, needSpatialBlurSS,
+                              rangeSS[2], numSS, and posSS.  More sensible to
+                              have this here, now that gage can parse the
+                              terse string-based description of scale-space
+                              sampling that originated in meet (via Deft) */
+  int leeching,            /* non-zero iff using the same nin and ninSS
+                              as another meetPullVol (so as to avoid
+                              redundant copies in memory) */
+    derivNormSS,           /* normalize derivatives based on scale */
+    recomputedSS;          /* (OUTPUT) non-zero if meetPullVolLoadMulti
+                              had to recompute these, versus being read
+                              from disk */
+  double derivNormBiasSS;  /* for gageParmStackNormalizeDerivBias */
+  Nrrd *nin;               /* we DO own */
+  Nrrd **ninSS;            /* we DO own */
 } meetPullVol;
 
 /*
@@ -158,15 +162,22 @@
 
 /* meetPull.c */
 MEET_EXPORT meetPullVol *meetPullVolNew(void);
+MEET_EXPORT meetPullVol *meetPullVolCopy(const meetPullVol *mpv);
 MEET_EXPORT int meetPullVolParse(meetPullVol *mpv, const char *str);
-MEET_EXPORT int meetPullVolLeechable(const meetPullVol *orig,
-                                     const meetPullVol *lchr);
+MEET_EXPORT int meetPullVolLeechable(const meetPullVol *lchr,
+                                     const meetPullVol *orig,
+                                     int *can,
+                                     char explain[AIR_STRLEN_LARGE]);
 MEET_EXPORT meetPullVol *meetPullVolNix(meetPullVol *pvol);
 MEET_EXPORT hestCB *meetHestPullVol;
+MEET_EXPORT int meetPullVolStackBlurParmFinishMulti(meetPullVol **mpv,
+                                                    unsigned int mpvNum,
+                                                    unsigned int *kssSetP,
+                                                    unsigned int *bspSetP,
+                                                    const NrrdKernelSpec *ksp,
+                                                    const NrrdBoundarySpec *bsp);
 MEET_EXPORT int meetPullVolLoadMulti(meetPullVol **mpv, unsigned int mpvNum,
-                                     char *cachePath, NrrdKernelSpec *kSSblur,
-                                     int boundary, double padValue,
-                                     int verbose);
+                                     char *cachePath, int verbose);
 MEET_EXPORT int meetPullVolAddMulti(pullContext *pctx,
                                     meetPullVol **mpv, unsigned int mpvNum,
                                     const NrrdKernelSpec *k00,
diff --color -ruN teem-1.11.0-src.orig/src/meet/meetNrrd.c teem-1.11.0-src/src/meet/meetNrrd.c
--- teem-1.11.0-src.orig/src/meet/meetNrrd.c	2012-12-20 22:09:21.000000000 +0800
+++ teem-1.11.0-src/src/meet/meetNrrd.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -130,9 +130,9 @@
    (for D and C, index 0 accesses the function for -1)
     NRRD_EXPORT NrrdKernel *const nrrdKernelTMF[4][5][5];
   */
-  dmax = AIR_CAST(int, nrrdKernelTMF_maxD);
-  cmax = AIR_CAST(int, nrrdKernelTMF_maxC);
-  amax = AIR_CAST(int, nrrdKernelTMF_maxA);
+  dmax = AIR_INT(nrrdKernelTMF_maxD);
+  cmax = AIR_INT(nrrdKernelTMF_maxC);
+  amax = AIR_INT(nrrdKernelTMF_maxA);
   for (di=-1; di<=dmax; di++) {
     for (ci=-1; ci<=cmax; ci++) {
       for (ai=1; ai<=amax; ai++) {
@@ -235,7 +235,7 @@
 
   mop = airMopNew();
   kern = meetNrrdKernelAll();
-  airMopAdd(mop, AIR_CAST(void*, kern), airFree, airMopAlways);
+  airMopAdd(mop, AIR_VOIDP(kern), airFree, airMopAlways);
   evalNum = 120000; /* success of kernel integral test is surprisingly
                        dependent on this, likely due to the naive way
                        the integral is numerically computed; the current
@@ -387,7 +387,7 @@
 #undef CHECK
     if (EE) {
       biffMovef(MEET, NRRD, "%s: problem with kern[%u] \"%s\"", me, ki,
-                kk->name ? kk->name : "(NULL name)");
+                kk->name);
       airMopError(mop); return 1;
     }
     ki++;
diff --color -ruN teem-1.11.0-src.orig/src/meet/meetPull.c teem-1.11.0-src/src/meet/meetPull.c
--- teem-1.11.0-src.orig/src/meet/meetPull.c	2012-12-20 22:09:21.000000000 +0800
+++ teem-1.11.0-src/src/meet/meetPull.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -31,14 +31,11 @@
   if (ret) {
     ret->kind = NULL;
     ret->fileName = ret->volName = NULL;
-    ret->derivNormSS = AIR_FALSE;
-    ret->uniformSS = AIR_FALSE;
-    ret->optimSS = AIR_FALSE;
+    ret->sbp = NULL;
     ret->leeching = AIR_FALSE;
-    ret->numSS = 0;
-    ret->rangeSS[0] = ret->rangeSS[1] = AIR_NAN;
+    ret->derivNormSS = AIR_FALSE;
+    ret->recomputedSS = AIR_FALSE;
     ret->derivNormBiasSS = 0.0;
-    ret->posSS = NULL;
     ret->nin = NULL;
     ret->ninSS = NULL;
   }
@@ -46,6 +43,56 @@
 }
 
 /*
+** DOES use biff
+*/
+meetPullVol *
+meetPullVolCopy(const meetPullVol *mpv) {
+  static const char me[]="meetPullVolCopy";
+  meetPullVol *ret;
+  unsigned int si;
+  airArray *mop;
+
+  mop = airMopNew();
+  ret = meetPullVolNew();
+  airMopAdd(mop, ret, (airMopper)meetPullVolNix, airMopOnError);
+  /* HEY: hope this is okay for dynamic kinds */
+  ret->kind = mpv->kind;
+  ret->fileName = airStrdup(mpv->fileName);
+  ret->volName = airStrdup(mpv->volName);
+  if (mpv->sbp) {
+    ret->sbp = gageStackBlurParmNew();
+    if (gageStackBlurParmCopy(ret->sbp, mpv->sbp)) {
+      biffMovef(MEET, GAGE, "%s: problem", me);
+      airMopError(mop); return NULL;
+    }
+  }
+  ret->leeching = AIR_FALSE;
+  ret->derivNormSS = mpv->derivNormSS;
+  ret->recomputedSS = AIR_FALSE;
+  ret->derivNormBiasSS = mpv->derivNormBiasSS;
+  if (mpv->sbp) {
+    ret->nin = NULL;
+    ret->ninSS = AIR_CALLOC(ret->sbp->num, Nrrd *);
+    for (si=0; si<mpv->sbp->num; si++) {
+      ret->ninSS[si] = nrrdNew();
+      if (nrrdCopy(ret->ninSS[si], mpv->ninSS[si])) {
+        biffMovef(MEET, NRRD, "%s: problem with ninSS[%u]", me, si);
+        airMopError(mop); return NULL;
+      }
+    }
+  } else {
+    ret->nin = nrrdNew();
+    if (nrrdCopy(ret->nin, mpv->nin)) {
+      biffMovef(MEET, NRRD, "%s: problem with nin", me);
+      airMopError(mop); return NULL;
+    }
+    ret->ninSS = NULL;
+  }
+  airMopOkay(mop);
+  return ret;
+}
+
+/*
 ******** meetPullVolParse
 **
 ** parses a string to extract all the information necessary to create
@@ -55,11 +102,13 @@
 meetPullVolParse(meetPullVol *mpv, const char *_str) {
   static const char me[]="meetPullVolParse";
 #define VFMT_SHRT "<fileName>:<kind>:<volName>"
-#define SFMT "<minScl>-<#smp>-<maxScl>[-no|u]"
+  /* there are other flags and parms but these are the main ones */
+#define SFMT "<minScl>-<#smp>-<maxScl>[-n][/k=kss][/b=bspec][/s=smpling]"
 #define VFMT_LONG "<fileName>:<kind>:" SFMT ":<volName>"
-  char *str, *ctok, *clast=NULL, *dtok, *dlast=NULL;
+  char *str, *ctok, *clast=NULL;
   airArray *mop;
   int wantSS;
+  unsigned int ctokn;
 
   if (!(mpv && _str)) {
     biffAddf(MEET, "%s: got NULL pointer", me);
@@ -72,13 +121,20 @@
 
   mop = airMopNew();
   airMopAdd(mop, str, airFree, airMopAlways);
-  if (!( 3 == airStrntok(str, ":") || 4 == airStrntok(str, ":") )) {
-    biffAddf(MEET, "%s: didn't get 3 or 4 \":\"-separated tokens in \"%s\"; "
-             "not of form " VFMT_SHRT " or " VFMT_LONG , me, _str);
+  ctokn = airStrntok(str, ":");
+  /* An annoying side-effect of putting the blurring kernel specification and
+     boundary specification inside the string representation of the
+     gageStackBlurParm, is that the colon in dg:1,6" or "pad:10" is now
+     confused as a delimiter in the (e.g.) "vol.nrrd:scalar:0-8-5.5:V" string
+     representation of meetPullVol, as in
+     "vol.nrrd:scalar:0-8-5.5/k=dg:1,6/b=pad:1:V". So we have to be more
+     permissive in the number of tokens (hacky) */
+  if (!( ctokn >= 3 )) {
+    biffAddf(MEET, "%s: didn't get at least 3 \":\"-separated tokens in "
+             "\"%s\"; not of form " VFMT_SHRT " or " VFMT_LONG , me, _str);
     airMopError(mop); return 1;
   }
-  /* mpv->nin is set elsewhere */
-  wantSS = (4 == airStrntok(str, ":"));
+  wantSS = (ctokn > 3);
 
   ctok = airStrtok(str, ":", &clast);
   if (!(mpv->fileName = airStrdup(ctok))) {
@@ -93,80 +149,62 @@
     airMopError(mop); return 1;
   }
   if (wantSS) {
-    int haveFlags;
-    ctok = airStrtok(NULL, ":", &clast);
-    if (!( 3 == airStrntok(ctok, "-") || 4 == airStrntok(ctok, "-") )) {
-      biffAddf(MEET, "%s: didn't get 3 or 4 \"-\"-separated tokens in \"%s\"; "
-               "not of form SFMT" , me, ctok);
-      airMopError(mop); return 1;
-    }
-    haveFlags = (4 == airStrntok(ctok, "-"));
-    dtok = airStrtok(ctok, "-", &dlast);
-    if (1 != sscanf(dtok, "%lg", &(mpv->rangeSS[0]))) {
-      biffAddf(MEET, "%s: couldn't parse \"%s\" as min scale", me, dtok);
-      airMopError(mop); return 1;
-    }
-    dtok = airStrtok(NULL, "-", &dlast);
-    if (1 != sscanf(dtok, "%u", &(mpv->numSS))) {
-      biffAddf(MEET, "%s: couldn't parse \"%s\" as # scale samples", me, dtok);
-      airMopError(mop); return 1;
-    }
-    if (!( mpv->numSS >= 2 )) {
-      biffAddf(MEET, "%s: need # scale samples >= 2 (not %u)", me, mpv->numSS);
-      airMopError(mop); return 1;
-    }
-    dtok = airStrtok(NULL, "-", &dlast);
-    if (1 != sscanf(dtok, "%lg", &(mpv->rangeSS[1]))) {
-      biffAddf(MEET, "%s: couldn't parse \"%s\" as max scale", me, dtok);
-      airMopError(mop); return 1;
-    }
-    /* initialize things as if there were no flags */
-    mpv->derivNormSS = AIR_FALSE;
-    mpv->uniformSS = AIR_FALSE;
-    mpv->optimSS = AIR_FALSE;
-    mpv->derivNormBiasSS = 0.0;
-    if (haveFlags) {
-      char *flags, *bias;
-      /* look for various things in flags */
-      flags = airToLower(airStrdup(airStrtok(NULL, "-", &dlast)));
-      airMopAdd(mop, flags, airFree, airMopAlways);
-      if (strchr(flags, 'n')) {
-        mpv->derivNormSS = AIR_TRUE;
-      }
-      if (strchr(flags, 'u')) {
-        mpv->uniformSS = AIR_TRUE;
-      }
-      if (strchr(flags, 'o')) {
-        mpv->optimSS = AIR_TRUE;
-      }
-      if (mpv->optimSS && mpv->uniformSS) {
-        biffAddf(MEET, "%s: can't have both optimal ('o') and uniform ('u') "
-                 "flags set in \"%s\"", me, flags);
+    int extraFlag[256]; char *extraParm=NULL, *ptok, *plast;
+    unsigned int efi, cti;
+    char *sbps;
+    /* the hack to make the ":" inside a blurring kernel specification or
+       boundary specification be unlike the ":" that delimits the real
+       meetPullVol fields */
+    sbps = airStrdup(_str); /* to have a buffer big enough */
+    airMopAdd(mop, sbps, airFree, airMopAlways);
+    strcpy(sbps, "");
+    for (cti=0; cti<ctokn-3; cti++) {
+      if (cti) {
+        strcat(sbps, ":");
+      }
+      ctok = airStrtok(NULL, ":", &clast);
+      strcat(sbps, ctok);
+    }
+    mpv->sbp = gageStackBlurParmNix(mpv->sbp);
+    mpv->sbp = gageStackBlurParmNew();
+    if (gageStackBlurParmParse(mpv->sbp, extraFlag, &extraParm, sbps)) {
+      biffMovef(MEET, GAGE, "%s: problem parsing sbp from \"%s\"", me, sbps);
+      airMopError(mop); return 1;
+    }
+    mpv->derivNormSS = !!extraFlag['n'];
+    extraFlag['n'] = AIR_FALSE;
+    for (efi=0; efi<256; efi++) {
+      if (extraFlag[AIR_UCHAR(efi)]) {
+        biffAddf(MEET, "%s: got unknown extra flag '%c' in \"%s\"", me,
+                 AIR_CAST(char, efi), sbps);
         airMopError(mop); return 1;
       }
-      if ((bias = strchr(flags, '+'))) {
-        /* indicating a bias, unfortunately only a positive one is
-           possible here, because of the way that other fields are
-           tokenized by '-' */
-        bias++;
-        if (1 != sscanf(bias, "%lf", &(mpv->derivNormBiasSS))) {
-          biffAddf(MEET, "%s: couldn't parse bias \"%s\"", me, bias);
+    }
+    if (extraParm) {
+      unsigned int pmi, pmn;
+      static const char dnbiase[]="dnbias=";
+      airMopAdd(mop, extraParm, airFree, airMopAlways);
+      pmn = airStrntok(extraParm, "/");
+      for (pmi=0; pmi<pmn; pmi++) {
+        ptok = airStrtok(!pmi ? extraParm : NULL, "/", &plast);
+        if (strstr(ptok, dnbiase) == ptok) {
+          if (1 != sscanf(ptok + strlen(dnbiase), "%lg",
+                          &(mpv->derivNormBiasSS))) {
+            biffAddf(MEET, "%s: couldn't parse \"%s\" as double in \"%s\"",
+                     me, ptok + strlen(dnbiase), ptok);
+            airMopError(mop); return 1;
+          }
+        } else {
+          biffAddf(MEET, "%s: got unknown extra parm %s in \"%s\"",
+                   me, ptok, extraParm);
           airMopError(mop); return 1;
         }
       }
     }
-    /* mpv->ninSS and mpv->posSS are allocated and filled elsewhere */
-    mpv->ninSS = NULL;
-    mpv->posSS = NULL;
-    /* we don't actually create nrrds nor load the volumes here,
-       because we don't know cachePath, and because we might want
-       different pullVolumes to share the same underlying Nrrds */
   } else {
     /* no scale-space stuff wanted */
-    mpv->numSS = 0;
-    mpv->rangeSS[0] = mpv->rangeSS[1] = AIR_NAN;
+    mpv->sbp = NULL;
     mpv->ninSS = NULL;
-    mpv->posSS = NULL;
   }
   ctok = airStrtok(NULL, ":", &clast);
   if (!(mpv->volName = airStrdup(ctok))) {
@@ -187,7 +225,7 @@
 }
 
 int
-meetHestPullVolParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+meetHestPullVolParse(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   static const char me[]="meetHestPullVolParse";
   meetPullVol *mpv, **mpvP;
   airArray *mop;
@@ -224,19 +262,19 @@
     if (!mpv->leeching && mpv->nin) {
       nrrdNuke(mpv->nin);
     }
-    if (mpv->numSS) {
+    if (mpv->sbp) {
       unsigned int ssi;
       if (mpv->ninSS) {
         /* need this check because the mpv may not have benefitted
            from meetPullVolLoadMulti, so it might be incomplete */
-        for (ssi=0; ssi<mpv->numSS; ssi++) {
+        for (ssi=0; ssi<mpv->sbp->num; ssi++) {
           if (!mpv->leeching) {
             nrrdNuke(mpv->ninSS[ssi]);
           }
         }
         airFree(mpv->ninSS);
       }
-      airFree(mpv->posSS);
+      gageStackBlurParmNix(mpv->sbp);
     }
     airFree(mpv->fileName);
     airFree(mpv->volName);
@@ -259,51 +297,79 @@
 /*
 ******** meetPullVolLeechable
 **
-** indicates whether lchr can leech from orig
+** indicates whether lchr can leech from orig (saved in *can), and if not,
+** explanation is saved in explain (if non-NULL)
+**
+** always uses biff
 */
 int
 meetPullVolLeechable(const meetPullVol *lchr,
-                     const meetPullVol *orig) {
+                     const meetPullVol *orig,
+                     int *can, char explain[AIR_STRLEN_LARGE]) {
   static const char me[]="meetPullVolLeechable";
-  int can, verbose;
+  char subexplain[AIR_STRLEN_LARGE];
 
-  verbose = 0;
-  can = !!strcmp(orig->fileName, "-");  /* can, if not reading from stdin */
-  if (verbose && !can) {
-    fprintf(stderr, "%s: no: from stdin\n", me);
-  }
-  can &= !strcmp(orig->fileName, lchr->fileName);  /* come from same file */
-  if (verbose && !can) {
-    fprintf(stderr, "%s: no: not from same file\n", me);
-  }
-  can &= (orig->kind == lchr->kind);               /* same kind */
-  if (verbose && !can) {
-    fprintf(stderr, "%s: no: not same kind\n", me);
-  }
-  /* need to have different volname */
-  can &= (orig->numSS == lchr->numSS);             /* same scale space */
-  if (verbose && !can) {
-    fprintf(stderr, "%s: no: not same scale space\n", me);
-  }
-  if (lchr->numSS) {
-    /* DO allow difference in derivNormSS (the main reason for leeching) */
-    /* same SS sampling strategy */
-    can &= (orig->uniformSS == lchr->uniformSS);
-    if (verbose && !can) {
-      fprintf(stderr, "%s: no: not same uniformSS\n", me);
-    }
-    can &= (orig->optimSS == lchr->optimSS);
-    if (verbose && !can) {
-      fprintf(stderr, "%s: no: not same optimSS\n", me);
-    }
-    /* same SS range */
-    can &= (orig->rangeSS[0] == lchr->rangeSS[0]);
-    can &= (orig->rangeSS[1] == lchr->rangeSS[1]);
-    if (verbose && !can) {
-      fprintf(stderr, "%s: no: not same rangeSS\n", me);
+  if (!( lchr && orig && can )) {
+    biffAddf(MEET, "%s: got NULL pointer (%p %p %p)", me,
+             (const void*)lchr, (const void*)orig, (void*)can);
+    return 1;
+  }
+  /* can leech, if not reading from stdin */
+  *can = !!strcmp(orig->fileName, "-");
+  if (!*can) {
+    if (explain) {
+      sprintf(explain, "original loaded from stdin");
+    }
+    return 0;
+  }
+  /* can, if coming from same file */
+  *can = !strcmp(orig->fileName, lchr->fileName);
+  if (!*can) {
+    if (explain) {
+      sprintf(explain, "not from same file (\"%s\" vs \"%s\")\n",
+              lchr->fileName, orig->fileName);
+    }
+    return 0;
+  }
+  /* can, if same kind */
+  *can = (orig->kind == lchr->kind);
+  if (!*can) {
+    if (explain) {
+      sprintf(explain, "not same kind (%s vs %s)\n",
+              lchr->kind->name, orig->kind->name);
+    }
+    return 0;
+  }
+  /* can, if both using or both not using scale-space */
+  *can = (!!lchr->sbp == !!orig->sbp);
+  if (!*can) {
+    if (explain) {
+      sprintf(explain, "not agreeing on use of scale-space (%s vs %s)\n",
+              lchr->sbp ? "yes" : "no", orig->sbp ? "yes" : "no");
+    }
+    return 0;
+  }
+  if (orig->sbp) {
+    int differ;
+    if (gageStackBlurParmCompare(lchr->sbp, "potential leecher",
+                                 orig->sbp, "original",
+                                 &differ, subexplain)) {
+      biffAddf(MEET, "%s: problem comparing sbps", me);
+      return 1;
+    }
+    if (differ) {
+      if (explain) {
+        sprintf(explain, "different uses of scale-space: %s", subexplain);
+      }
+      *can = AIR_FALSE;
+      return 0;
     }
   }
-  return can;
+  /* DO allow difference in derivNormSS (the main reason for leeching),
+     as well as derivNormBiasSS */
+  /* no differences so far */
+  *can = AIR_TRUE;
+  return 0;
 }
 
 void
@@ -312,17 +378,13 @@
 
   if (vol && volPrev) {
     vol->nin = volPrev->nin;
-    if (vol->numSS) {
+    if (vol->sbp) {
       unsigned int ni;
       /* have to allocate ninSS here; in volPrev it was probably allocated
          by gageStackBlurManage */
-      vol->ninSS = AIR_CALLOC(vol->numSS, Nrrd *);
-      /* have to allocate posSS here; in volPrev is was probably allocated
-         by meetPullVolLoadMulti */
-      vol->posSS = AIR_CALLOC(vol->numSS, double);
-      for (ni=0; ni<vol->numSS; ni++) {
+      vol->ninSS = AIR_CALLOC(vol->sbp->num, Nrrd *);
+      for (ni=0; ni<vol->sbp->num; ni++) {
         vol->ninSS[ni] = volPrev->ninSS[ni];
-        vol->posSS[ni] = volPrev->posSS[ni];
       }
     }
     vol->leeching = AIR_TRUE;
@@ -331,41 +393,111 @@
 }
 
 /*
+** This is kind of a sad function. The big re-write of gageStackBlurParm in
+** late August 2013 was motivated by the frustration of how there was no
+** centralized and consistent way of representing (by text or by command-line
+** options) all the things that determine scale-space "stack" creation.
+** Having re-organized gageStackBlurParm, the meetPullVol was re-organized to
+** include one inside, which is clearly better than the previous reduplication
+** of the stack blur parms inside the meetPullVol. Parsing the meetPullVol
+** from the command-line (as in done in puller) highlights the annoying fact
+** that hest wants to be the origin of information: you can't have hest
+** supplement existing information with whatever it learns from the
+** command-line, especially when hest is parsing 1 or more of something, and
+** especially when the existing information would be coming from other
+** command-line arguments.
+**
+** So, this sad function says, "ok all you meetPullVol parsed from the
+** command-line: if you don't already have a boundary or a kernel set, here's
+** one to use". What makes it sad is how the whole point of the
+** gageStackBlurParm re-org was that knowledge about the internals of the
+** gageStackBlurParm was now going to be entirely localized in gage. But here
+** we are listing off two of its fields as parameters to this function, which
+** means its API might change the next time the gageStackBlurParm is updated.
+**
+** To help keep track of what info was actually used, *kssSetP and *bspSetP
+** (if non-NULL) are set to the number of kernel and boundary specs that are
+** "finished" in this way.
+*/
+int
+meetPullVolStackBlurParmFinishMulti(meetPullVol **mpv, unsigned int mpvNum,
+                                    unsigned int *kssSetP,
+                                    unsigned int *bspSetP,
+                                    const NrrdKernelSpec *kssblur,
+                                    const NrrdBoundarySpec *bspec) {
+  static const char me[]="meetPullVolStackBlurParmFinishMulti";
+  unsigned int ii, kssSet, bspSet;
+
+  if (!mpv || !mpvNum) {
+    biffAddf(MEET, "%s: got NULL mpv (%p) or 0 mpvNum (%u)",
+             me, AIR_VOIDP(mpv), mpvNum);
+    return 1;
+  }
+  kssSet = bspSet = 0;
+  for (ii=0; ii<mpvNum; ii++) {
+    if (kssblur && mpv[ii]->sbp && !(mpv[ii]->sbp->kspec)) {
+      if (gageStackBlurParmKernelSet(mpv[ii]->sbp, kssblur)) {
+        biffMovef(MEET, GAGE, "%s: trouble w/ kernel on mpv[%u]", me, ii);
+        return 1;
+      }
+      kssSet++;
+    }
+    if (bspec && mpv[ii]->sbp && !(mpv[ii]->sbp->bspec)) {
+      if (gageStackBlurParmBoundarySpecSet(mpv[ii]->sbp, bspec)) {
+        biffMovef(MEET, GAGE, "%s: trouble w/ boundary on mpv[%u]", me, ii);
+        return 1;
+      }
+      bspSet++;
+    }
+  }
+  if (kssSetP) {
+    *kssSetP = kssSet;
+  }
+  if (bspSetP) {
+    *bspSetP = bspSet;
+  }
+  return 0;
+}
+
+/*
 ******** meetPullVolLoadMulti
 **
-** at this point the per-pullVolume information required for
-** loading/creating the volumes, which is NOT in the meetPullVol, is
-** the cachePath and the info we have to set in the gageStackBlurParm,
-** so these have to be passed explicitly.
+** at this point the only per-pullVolume information required for
+** loading/creating the volumes, which isn't already in the
+** meetPullVol, is the cachePath, so that is passed explicitly.
 */
 int
 meetPullVolLoadMulti(meetPullVol **mpv, unsigned int mpvNum,
-                     char *cachePath, NrrdKernelSpec *kSSblur,
-                     int boundary, double padValue, int verbose) {
+                     char *cachePath, int verbose) {
   static const char me[]="meetPullVolLoadMulti";
-  char formatSS[AIR_STRLEN_LARGE];
   unsigned int mpvIdx;
-  gageStackBlurParm *sbp;
   airArray *mop;
   meetPullVol *vol;
 
-  if (!( mpv && cachePath && kSSblur )) {
+  if (!( mpv && cachePath)) {
     biffAddf(MEET, "%s: got NULL pointer", me);
     return 1;
   }
   mop = airMopNew();
-
-  /* this can be re-used for different volumes */
-  sbp = gageStackBlurParmNew();
-  airMopAdd(mop, sbp, (airMopper)gageStackBlurParmNix, airMopAlways);
-
   for (mpvIdx=0; mpvIdx<mpvNum; mpvIdx++) {
-    unsigned int pvi, ssi;
+    unsigned int pvi;
+    int leechable;
+    char explain[AIR_STRLEN_LARGE];
     vol = mpv[mpvIdx];
     for (pvi=0; pvi<mpvIdx; pvi++) {
-      if (meetPullVolLeechable(vol, mpv[pvi])) {
+      if (meetPullVolLeechable(vol, mpv[pvi], &leechable, explain)) {
+        biffAddf(MEET, "%s: problem testing leechable(v[%u]->v[%u])",
+                 me, mpvIdx, pvi);
+        return 1;
+      }
+      if (leechable) {
         meetPullVolLeech(vol, mpv[pvi]);
         break; /* prevent a chain of leeching */
+      } else {
+        if (verbose) {
+          fprintf(stderr, "%s: mpv[%u] cannot leech mpv[%u]: %s\n", me,
+                  mpvIdx, pvi, explain);
+        }
       }
     }
     if (pvi < mpvIdx) {
@@ -378,12 +510,6 @@
     }
     /* else we're not leeching */
     vol->leeching = AIR_FALSE;
-    if (verbose) {
-      fprintf(stderr, "%s: vspec[%u] (%s) cannot leech\n",
-              me, mpvIdx, vol->volName);
-    }
-    /* if this is the pull we only have to learn the scale samples,
-       but these might even be used */
     vol->nin = nrrdNew();
     airMopAdd(mop, &(vol->nin), (airMopper)airSetNull, airMopOnError);
     airMopAdd(mop, vol->nin, (airMopper)nrrdNuke, airMopOnError);
@@ -392,21 +518,16 @@
                 me, mpvIdx, vol->volName);
       airMopError(mop); return 1;
     }
-    if (vol->numSS) {
+    if (vol->sbp) {
+      char formatSS[AIR_STRLEN_LARGE];
       sprintf(formatSS, "%s/%s-%%03u-%03u.nrrd",
-              cachePath, vol->volName, vol->numSS);
+              cachePath, vol->volName, vol->sbp->num);
       if (verbose) {
         fprintf(stderr, "%s: managing %s ... \n", me, formatSS);
       }
-      if (gageStackBlurParmScaleSet(sbp, vol->numSS,
-                                    vol->rangeSS[0], vol->rangeSS[1],
-                                    vol->uniformSS, vol->optimSS)
-          || gageStackBlurParmKernelSet(sbp, kSSblur, AIR_TRUE)
-          || gageStackBlurParmBoundarySet(sbp, boundary, padValue)
-          || gageStackBlurParmVerboseSet(sbp, verbose)
-          || gageStackBlurManage(&(vol->ninSS), &(vol->recomputedSS), sbp,
-                                 formatSS, AIR_TRUE, NULL,
-                                 vol->nin, vol->kind)) {
+      if (gageStackBlurManage(&(vol->ninSS), &(vol->recomputedSS), vol->sbp,
+                              formatSS, AIR_TRUE, NULL,
+                              vol->nin, vol->kind)) {
         biffMovef(MEET, GAGE, "%s: trouble getting volume stack (\"%s\")",
                   me, formatSS);
         airMopError(mop); return 1;
@@ -415,13 +536,6 @@
         fprintf(stderr, "%s: ... done\n", me);
       }
     }
-    /* allocate and set vol->posSS from sbp-scale regardless of kind */
-    if (vol->numSS) {
-      vol->posSS = AIR_CALLOC(sbp->num, double);
-      for (ssi=0; ssi<sbp->num; ssi++) {
-        vol->posSS[ssi] = sbp->scale[ssi];
-      }
-    }
   }
   airMopOkay(mop);
   return 0;
@@ -431,7 +545,8 @@
 ******** meetPullVolAddMulti
 **
 ** the spatial (k00, k11, k22) and scale (kSSrecon) reconstruction
-** kernels are not part of the meetPullVol, so have to be passed in here
+** kernels are not (yet) part of the meetPullVol, so have to be passed
+** in here
 */
 int
 meetPullVolAddMulti(pullContext *pctx,
@@ -451,14 +566,14 @@
     meetPullVol *vol;
     int E;
     vol = mpv[mpvIdx];
-    if (!vol->numSS) {
+    if (!vol->sbp) {
       E = pullVolumeSingleAdd(pctx, vol->kind, vol->volName,
                               vol->nin, k00, k11, k22);
     } else {
       E = pullVolumeStackAdd(pctx, vol->kind, vol->volName, vol->nin,
                              AIR_CAST(const Nrrd *const *,
                                       vol->ninSS),
-                             vol->posSS, vol->numSS,
+                             vol->sbp->sigma, vol->sbp->num,
                              vol->derivNormSS, vol->derivNormBiasSS,
                              k00, k11, k22, kSSrecon);
     }
@@ -620,7 +735,7 @@
 }
 
 int
-meetHestPullInfoParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+meetHestPullInfoParse(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   static const char me[]="meetHestPullInfoParse";
   airArray *mop;
   meetPullInfo **minfP, *minf;
@@ -699,6 +814,13 @@
       biffMovef(MEET, PULL, "%s: trouble adding ispec from minf[%u]", me, ii);
       airMopError(mop); return 1;
     }
+    /* else added the ispec okay. If we have an error with a different
+       ispec later in this loop, who's job is it to free up the ispecs
+       that have been added successfully?  In teem/src/bin/puller, that
+       is done by pullContextNix. So we now extricate ourself from the
+       business of freeing this ispec in case of error; one of the few
+       times that airMopSub is really needed */
+    airMopSub(mop, ispec, (airMopper)pullInfoSpecNix);
   }
 
   airMopOkay(mop);
diff --color -ruN teem-1.11.0-src.orig/src/meet/sources.cmake teem-1.11.0-src/src/meet/sources.cmake
--- teem-1.11.0-src.orig/src/meet/sources.cmake	2012-12-20 22:09:21.000000000 +0800
+++ teem-1.11.0-src/src/meet/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(MEET_SOURCES
-  enumall.c
-  meetNrrd.c
-  meetGage.c
-  meetPull.c
-  meet.h
-  )
-
-ADD_TEEM_LIBRARY(meet ${MEET_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/meet/test/strace.c teem-1.11.0-src/src/meet/test/strace.c
--- teem-1.11.0-src.orig/src/meet/test/strace.c	2012-12-20 22:09:21.000000000 +0800
+++ teem-1.11.0-src/src/meet/test/strace.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -34,120 +34,15 @@
  */
 
 int
-pullScaleTracePlotAdd(pullContext *pctx, Nrrd *nwild, Nrrd *nccd,
-                      Nrrd *nmask, double mth, airArray *insideArr,
-                      double velHalf, pullTrace *pts) {
-  static const char me[]="pullScaleTracePlotAdd";
-  double ssr[2], *pos, *velo, *wild, *ccd, *mask;
-  unsigned int pnum, pidx, sizeS, sizeV;
-
-  if (!(pctx && nwild && nccd && pts)) {
-    biffAddf(PULL, "%s: got NULL pointer", me);
-    return 1;
-  }
-  if (!nrrdSameSize(nwild, nccd, AIR_TRUE)) {
-    biffMovef(PULL, NRRD, "%s: nwild not same size as nccd", me);
-    return 1;
-  }
-  if (nmask || insideArr) {
-    if (!insideArr) {
-      biffAddf(PULL, "%s: got nmask but not insideArr", me);
-      return 1;
-    }
-    if (!nmask) {
-      biffAddf(PULL, "%s: got insideArr but not nmask", me);
-      return 1;
-    }
-    if (nrrdTypeDouble != nmask->type) {
-      biffAddf(PULL, "%s: nmask has type %s but want %s", me,
-               airEnumStr(nrrdType, nmask->type),
-               airEnumStr(nrrdType, nrrdTypeDouble));
-      return 1;
-    }
-    if (!nrrdSameSize(nwild, nmask, AIR_TRUE)) {
-      biffMovef(PULL, NRRD, "%s: nwild not same size as nmask", me);
-      return 1;
-    }
-    if (!nrrdSameSize(nccd, nmask, AIR_TRUE)) {
-      biffMovef(PULL, NRRD, "%s: nccd not same size as nmask", me);
-      return 1;
-    }
-    if (!AIR_EXISTS(mth)) {
-      biffAddf(PULL, "%s: got non-existent mask thresh %g", me, mth);
-      return 1;
-    }
-  }
-  ssr[0] = nwild->axis[0].min;
-  ssr[1] = nwild->axis[0].max;
-  sizeS = AIR_CAST(unsigned int, nwild->axis[0].size);
-  sizeV = AIR_CAST(unsigned int, nwild->axis[1].size);
-  wild = AIR_CAST(double *, nwild->data);
-  ccd = AIR_CAST(double *, nccd->data);
-  if (nmask) {
-    mask = AIR_CAST(double *, nmask->data);
-  } else {
-    mask = NULL;
-  }
-
-  pnum = AIR_CAST(unsigned int, pts->nvert->axis[1].size);
-  pos = AIR_CAST(double *, pts->nvert->data);
-  velo = AIR_CAST(double *, pts->nvelo->data);
-  for (pidx=0; pidx<pnum; pidx++) {
-    double *pp;
-    unsigned int sidx, vidx;
-    pp = pos + 4*pidx;
-    if (!(AIR_IN_OP(ssr[0], pp[3], ssr[1]))) {
-      continue;
-    }
-    if (velo[pidx] <= 0.0) {
-      continue;
-    }
-    /*
-    if (!(AIR_IN_OP(vlr[0], velo[pidx], vlr[1]))) {
-      continue;
-    }
-    */
-    sidx = airIndex(ssr[0], pp[3], ssr[1], sizeS);
-    //vidx = airIndex(sqrt(vlr[0]), sqrt(velo[pidx]), sqrt(vlr[1]), sizeV);
-    //vidx = airIndex(vlr[0], velo[pidx], vlr[1], sizeV);
-    /* weird that Clamp is needed, but it is, but this atan()
-       does sometime return a negative value */
-    vidx = airIndexClamp(0.0, atan(velo[pidx]/velHalf), AIR_PI/2, sizeV);
-
-    if (0 /* pts->calstop */) {
-      ccd[sidx + sizeS*vidx] += 1;
-    } else {
-      wild[sidx + sizeS*vidx] += 1;
-    }
-
-    if (nmask && mask[sidx + sizeS*vidx] >= mth) {
-      unsigned int ii;
-      double *inside;
-      ii = airArrayLenIncr(insideArr, 1);
-      inside = AIR_CAST(double *, insideArr->data);
-      ELL_4V_COPY(inside + 4*ii, pp);
-    }
-  }
-
-  return 0;
-}
-#if 0
-    if (pullScaleTracePlotAdd(pctx, nwild, nccd,
-                              nmask, 0.5 /* mask thresh */, insideArr,
-                              shalf, pts)) {
-      airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
-      fprintf(stderr, "%s: trouble on point %u:\n%s", me, pidx, err);
-      airMopError(mop); return 1;
-    }
-#endif
-
-int
 findAndTraceMorePoints(Nrrd *nplot,
-                      pullContext *pctx, pullVolume *scaleVol,
-                      double scaleStep, double scaleHalfLen,
-                      double speedLimit, unsigned int traceArrIncr,
-                      pullTraceMulti *mtrc,
-                      unsigned int pointNum) {
+                       pullContext *pctx, pullVolume *scaleVol,
+                       int strengthUse,
+                       int smooth, int flatWght,
+                       double scaleStep, double scaleHalfLen,
+                       double orientTestLen,
+                       unsigned int traceArrIncr,
+                       pullTraceMulti *mtrc,
+                       unsigned int pointNum) {
   static const char me[]="findAndTraceMorePoints";
   unsigned int pointsSoFar, idtagBase, pidx, addedNum;
   pullTrace *trace;
@@ -165,7 +60,6 @@
          me, pointNum, pointsSoFar,
          airPrettySprintSize_t(doneStr, pullTraceMultiSizeof(mtrc)));
   for (pidx=0; pidx<pointNum; pidx++) {
-    int added;
     printf("%s", airDoneStr(0, pidx, pointNum, doneStr)); fflush(stdout);
     if (!point) {
       point = pullPointNew(pctx);
@@ -176,27 +70,25 @@
                pidx, point->idtag);
       airMopError(mop); return 1;
     }
-    if (pullBinsPointMaybeAdd(pctx, point, NULL, &added)) {
+    if (pullBinsPointAdd(pctx, point, NULL)) {
       biffAddf(PULL, "%s: trouble binning point %u", me, point->idtag);
       airMopError(mop); return 1;
     }
-    if (added) {
-      point = NULL;
-    }
+    point = NULL;
   }
   printf("%s\n", airDoneStr(0, pidx, pointNum, doneStr));
   if (point) {
     /* we created a new test point, but it was never placed in the volume */
     /* so, HACK: undo pullPointNew . . . */
     point = pullPointNix(point);
-    pctx->idtagNext -= 1;
+    /* pctx->idtagNext -= 1; */
   }
 
   nPosOut = nrrdNew();
   airMopAdd(mop, nPosOut, (airMopper)nrrdNuke, airMopAlways);
   if (pullOutputGetFilter(nPosOut, NULL, NULL, NULL, 0.0,
                           pctx, idtagBase, 0)) {
-    biffAddf(PULL, "%s: trouble", me);
+    biffAddf(PULL, "%s: trouble A", me);
     airMopError(mop); return 1;
   }
   pos = AIR_CAST(double *, nPosOut->data);
@@ -208,10 +100,11 @@
     printf("%s", airDoneStr(0, pidx, addedNum, doneStr)); fflush(stdout);
     trace = pullTraceNew();
     ELL_4V_COPY(seedPos, pos + 4*pidx);
-    if (pullTraceSet(pctx, trace, AIR_TRUE,
+    if (pullTraceSet(pctx, trace,
+                     AIR_TRUE /* recordStrength */,
                      scaleStep, scaleHalfLen,
-                     speedLimit, traceArrIncr,
-                     seedPos)
+                     orientTestLen,
+                     traceArrIncr, seedPos)
         || pullTraceMultiAdd(mtrc, trace, &added)) {
       biffAddf(PULL, "%s: trouble on point %u", me, pidx);
       airMopError(mop); return 1;
@@ -222,8 +115,12 @@
   }
   printf("%s\n", airDoneStr(0, pidx, pointNum, doneStr));
 
-  if (pullTraceMultiPlotAdd(nplot, mtrc, NULL, 0, 0)) {
-    biffAddf(PULL, "%s: trouble plotting", me);
+  if (pullTraceMultiPlotAdd(nplot, mtrc, NULL,
+                            strengthUse,
+                            smooth, flatWght,
+                            0, 0,
+                            NULL, NULL)) {
+    biffAddf(PULL, "%s: trouble w/ PlotAdd (A)", me);
     airMopError(mop); return 1;
   }
 
@@ -236,10 +133,10 @@
 int
 resamplePlot(Nrrd *nprob, const Nrrd *nplot) {
   static const char me[]="resamplePlot";
-  unsigned int ii, nn;
+  unsigned int ii, nn, sx, sy;
 
-  double scls[2] = {0.4, 0.4}, kparm[2] = {2.0, 20.0};
-  const NrrdKernel *kern = nrrdKernelGaussian;
+  double scls[2] = {0.2, 0.2}, kparm[2] = {1.0, 0.0};
+  const NrrdKernel *kern = nrrdKernelTent;
 
   /*
   double scls[2] = {1.0, 1.0}, kparm[2] = {2.0, 4.0};
@@ -248,17 +145,27 @@
   double sum, *prob;
 
   if (nrrdSimpleResample(nprob, nplot, kern, kparm, NULL, scls)) {
-    biffMovef(PULL, NRRD, "%s: trouble", me);
+    biffMovef(PULL, NRRD, "%s: trouble B", me);
     return 1;
   }
-  sum = 0;
   prob = AIR_CAST(double *, nprob->data);
-  nn = AIR_CAST(unsigned int, nrrdElementNumber(nprob));
-  for (ii=0; ii<nn; ii++) {
-    sum += log(LOFF+prob[ii]);
+  sx = AIR_UINT(nprob->axis[0].size);
+  sy = AIR_UINT(nprob->axis[1].size);
+  for (ii=0; ii<sx; ii++) {
+    /* zero out bottom line, useless crap piles up there */
+    prob[ii + sx*(sy-1)] = 0;
   }
+  sum = 0;
+  nn = AIR_UINT(nrrdElementNumber(nprob));
   for (ii=0; ii<nn; ii++) {
-    prob[ii] = log(LOFF+prob[ii])/sum;
+    /* sum += log(LOFF+prob[ii]); why? */
+    sum += prob[ii];
+  }
+  if (sum) {
+    for (ii=0; ii<nn; ii++) {
+      /* prob[ii] = log(LOFF+prob[ii])/sum; why? */
+      prob[ii] = prob[ii]/sum;
+    }
   }
   return 0;
 }
@@ -268,7 +175,7 @@
   double *pp, *qq, dist=0.0;
   unsigned int ii, nn;
 
-  nn = AIR_CAST(unsigned int, nrrdElementNumber(npp));
+  nn = AIR_UINT(nrrdElementNumber(npp));
   pp = AIR_CAST(double *, npp->data);
   qq = AIR_CAST(double *, nqq->data);
   for (ii=0; ii<nn; ii++) {
@@ -279,6 +186,22 @@
   return dist;
 }
 
+void
+savePlot(Nrrd *nout) {
+  static const char me[]="saveProb";
+  static int count=0;
+  char fname[128], *err;
+  sprintf(fname, "pdf-%03u.nrrd", count);
+  if (nrrdSave(fname, nout, NULL)) {
+    err = biffGetDone(NRRD);
+    fprintf(stderr, "%s: HEY couldn't save pdf to %s; moving on ...\n",
+            me, fname);
+    free(err);
+  }
+  count++;
+  return;
+}
+
 static const char *info = ("Endless hacking!");
 
 int
@@ -288,40 +211,42 @@
   airArray *mop;
   const char *me;
 
+
   char *err, *posOutS, *outS, *extraOutBaseS, *addLogS, *cachePathSS,
-    *tracesInS, *tracesOutS;
+    *tracesInS, *tracesOutS, *trcListOutS=NULL, *trcVolOutS=NULL,
+    *traceMaskPosOutS=NULL;
   FILE *addLog, *tracesFile;
   meetPullVol **vspec;
   meetPullInfo **idef;
-  Nrrd *nPosIn=NULL, *nPosOut, *nplot, *nplotA, *nplotB, *nfilt;
+  Nrrd *nPosIn=NULL, *nPosOut, *nplot, *nplotA, *nplotB, *nfilt, *nTraceMaskIn,
+    *nmaskedpos;
   pullEnergySpec *enspR, *enspS, *enspWin;
   NrrdKernelSpec *k00, *k11, *k22, *kSSrecon, *kSSblur;
+  NrrdBoundarySpec *bspec;
   pullContext *pctx=NULL;
   pullVolume *scaleVol=NULL;
   pullTraceMulti *mtrc=NULL;
-  int E=0, ret=0;
+  int ret=0;
   unsigned int vspecNum, idefNum;
-  double scaleVec[3], glyphScaleRad;
   /* things that used to be set directly inside pullContext */
-  int energyFromStrength, nixAtVolumeEdgeSpace, constraintBeforeSeedThresh,
-    binSingle, liveThresholdOnInit, permuteOnRebin, noPopCntlWithZeroAlpha,
-    useBetaForGammaLearn, restrictiveAddToBins, noAdd, unequalShapesAllow,
-    popCntlEnoughTest;
+  int nixAtVolumeEdgeSpace, constraintBeforeSeedThresh,
+    binSingle, liveThresholdOnInit, permuteOnRebin,
+    noAdd, unequalShapesAllow,
+    zeroZ, strnUse;
   int verbose;
-  int interType, allowCodimension3Constraints, scaleIsTau, useHalton;
+  int interType, allowCodimension3Constraints, scaleIsTau,
+    smoothPlot, flatWght;
   unsigned int samplesAlongScaleNum, pointNumInitial, pointPerVoxel,
-    ppvZRange[2], snap, iterMax, stuckIterMax, constraintIterMax,
-    popCntlPeriod, addDescent, iterCallback, rngSeed, progressBinMod,
-    threadNum, eipHalfLife,
-    tracePointNum, passNumMax;
+    ppvZRange[2], snap, stuckIterMax, constraintIterMax,
+    rngSeed, progressBinMod,
+    threadNum, tracePointNum, passNumMax,
+    kssOpi, kssFinished, bspOpi, bspFinished;
   double jitter, stepInitial, constraintStepMin, radiusSpace, binWidthSpace,
-    radiusScale, alpha, beta, gamma, theta, wall, energyIncreasePermit,
-    backStepScale, opporStepScale, energyDecreaseMin, energyDecreasePopCntlMin,
-    neighborTrueProb, probeProb, fracNeighNixedMax, tpdThresh;
+    radiusScale, orientTestLen,
+    backStepScale, opporStepScale, energyDecreaseMin, tpdThresh;
 
-  double sstep, sswin, shalf, sslim, ssrange[2];
+  double sstep, sswin, ssrange[2];
   unsigned int pres[2];
-  char *trcListOutS=NULL;
 
   mop = airMopNew();
   hparm = hestParmNew();
@@ -345,21 +270,22 @@
   hparm->respFileEnable = AIR_TRUE;
   me = argv[0];
 
-  hestOptAdd(&hopt, "int", "int", airTypeEnum, 1, 1, &interType,
-             "justr", "inter-particle energy type", NULL, pullInterType);
-  hestOptAdd(&hopt, "enr", "spec", airTypeOther, 1, 1, &enspR, "cotan",
-             "inter-particle energy, radial component",
-             NULL, NULL, pullHestEnergySpec);
-  hestOptAdd(&hopt, "ens", "spec", airTypeOther, 1, 1, &enspS, "zero",
-             "inter-particle energy, scale component",
-             NULL, NULL, pullHestEnergySpec);
-  hestOptAdd(&hopt, "enw", "spec", airTypeOther, 1, 1, &enspWin,
-             "butter:16,0.8", "windowing to create locality with additive "
-             "scale-space interaction (\"-int add\")",
-             NULL, NULL, pullHestEnergySpec);
-  hestOptAdd(&hopt, "efs", "bool", airTypeBool, 1, 1,
-             &energyFromStrength, "false",
-             "whether or not strength contributes to particle-image energy");
+  /* these don't need to be visible on the command-line */
+  interType = pullInterTypeUnivariate;
+  enspR = pullEnergySpecNew();
+  airMopAdd(mop, enspR, (airMopper)pullEnergySpecNix, airMopAlways);
+  pullEnergySpecParse(enspR, "cotan");
+  enspS = pullEnergySpecNew();
+  airMopAdd(mop, enspS, (airMopper)pullEnergySpecNix, airMopAlways);
+  pullEnergySpecParse(enspS, "zero");
+  enspWin = pullEnergySpecNew();
+  airMopAdd(mop, enspWin, (airMopper)pullEnergySpecNix, airMopAlways);
+  pullEnergySpecParse(enspWin, "butter:16,0.8");
+
+  hestOptAdd(&hopt, "zz", "bool", airTypeBool, 1, 1, &zeroZ, "false",
+             "always constrain Z=0, to process 2D images");
+  hestOptAdd(&hopt, "su", "bool", airTypeBool, 1, 1, &strnUse, "false",
+             "weigh contributions to traces with strength");
   hestOptAdd(&hopt, "nave", "bool", airTypeBool, 1, 1,
              &nixAtVolumeEdgeSpace, "false",
              "whether or not to nix points at edge of volume, where gage had "
@@ -374,9 +300,6 @@
              &unequalShapesAllow, "false",
              "allow volumes to have different shapes (false is safe as "
              "different volume sizes are often accidental)");
-  hestOptAdd(&hopt, "pcet", "bool", airTypeBool, 1, 1, &popCntlEnoughTest,
-             "true", "use neighbor-counting \"enough\" heuristic to "
-             "bail out of pop cntl");
   hestOptAdd(&hopt, "nobin", NULL, airTypeBool, 0, 0,
              &binSingle, NULL,
              "turn off spatial binning (which prevents multi-threading "
@@ -387,20 +310,6 @@
   hestOptAdd(&hopt, "por", "bool", airTypeBool, 1, 1,
              &permuteOnRebin, "true",
              "permute points during rebinning");
-  hestOptAdd(&hopt, "npcwza", "bool", airTypeBool, 1, 1,
-             &noPopCntlWithZeroAlpha, "false",
-             "no pop cntl with zero alpha");
-  hestOptAdd(&hopt, "ubfgl", "bool", airTypeBool, 1, 1,
-             &useBetaForGammaLearn, "false",
-             "use beta for gamma learning");
-  hestOptAdd(&hopt, "ratb", "bool", airTypeBool, 1, 1,
-             &restrictiveAddToBins, "true",
-             "be choosy when adding points to bins to avoid overlap");
-  hestOptAdd(&hopt, "svec", "vec", airTypeDouble, 3, 3, scaleVec, "0 0 0",
-             "if non-zero (length), vector to use for displaying scale "
-             "in 3-space");
-  hestOptAdd(&hopt, "gssr", "rad", airTypeDouble, 1, 1, &glyphScaleRad, "0.0",
-             "if non-zero (length), scaling of scale to cylindrical tensors");
   hestOptAdd(&hopt, "v", "verbosity", airTypeInt, 1, 1, &verbose, "1",
              "verbosity level");
   hestOptAdd(&hopt, "vol", "vol0 vol1", airTypeOther, 1, -1, &vspec, NULL,
@@ -424,9 +333,14 @@
   hestOptAdd(&hopt, "sscp", "path", airTypeString, 1, 1, &cachePathSS, "./",
              "path (without trailing /) for where to read/write "
              "pre-blurred volumes for scale-space");
+  kssOpi =
   hestOptAdd(&hopt, "kssb", "kernel", airTypeOther, 1, 1, &kSSblur,
-             "ds:1,5", "blurring kernel, to sample scale space",
+             "ds:1,5", "default blurring kernel, to sample scale space",
              NULL, NULL, nrrdHestKernelSpec);
+  bspOpi =
+  hestOptAdd(&hopt, "bsp", "boundary", airTypeOther, 1, 1, &bspec,
+             "wrap", "default boundary behavior of scale-space blurring",
+             NULL, NULL, nrrdHestBoundarySpec);
   hestOptAdd(&hopt, "kssr", "kernel", airTypeOther, 1, 1, &kSSrecon,
              "hermite", "kernel for reconstructing from scale space samples",
              NULL, NULL, nrrdHestKernelSpec);
@@ -437,11 +351,7 @@
 
   hestOptAdd(&hopt, "np", "# points", airTypeUInt, 1, 1,
              &pointNumInitial, "1000",
-             "number of points to start in simulation");
-  hestOptAdd(&hopt, "halton", NULL, airTypeInt, 0, 0,
-             &useHalton, NULL,
-             "use Halton sequence initialization instead of "
-             "uniform random");
+             "number of points to initialize with");
   hestOptAdd(&hopt, "tnp", "# points", airTypeUInt, 1, 1,
              &tracePointNum, "1000",
              "number of points to add in each iteration of "
@@ -452,9 +362,9 @@
   hestOptAdd(&hopt, "tpdt", "thresh", airTypeDouble, 1, 1,
              &tpdThresh, "1.0", "KL-distance threshold");
   hestOptAdd(&hopt, "ti", "fname", airTypeString, 1, 1,
-             &tracesInS, "", "input file of pre-computed traces");
+             &tracesInS, "", "input file of *pre-computed* traces");
   hestOptAdd(&hopt, "to", "fname", airTypeString, 1, 1,
-             &tracesOutS, "", "file for saving *computed* traces");
+             &tracesOutS, "", "file for saving out *computed* traces");
 
   hestOptAdd(&hopt, "ppv", "# pnts/vox", airTypeUInt, 1, 1,
              &pointPerVoxel, "0",
@@ -479,9 +389,6 @@
   hestOptAdd(&hopt, "snap", "# iters", airTypeUInt, 1, 1,
              &snap, "0",
              "if non-zero, # iters between saved snapshots");
-  hestOptAdd(&hopt, "maxi", "# iters", airTypeUInt, 1, 1,
-             &iterMax, "0",
-             "if non-zero, max # iterations to run whole system");
   hestOptAdd(&hopt, "stim", "# iters", airTypeUInt, 1, 1,
              &stuckIterMax, "5",
              "if non-zero, max # iterations to allow a particle "
@@ -498,28 +405,6 @@
   hestOptAdd(&hopt, "bws", "bin width", airTypeDouble, 1, 1,
              &binWidthSpace, "1.001",
              "spatial bin width as multiple of spatial radius");
-  hestOptAdd(&hopt, "alpha", "alpha", airTypeDouble, 1, 1,
-             &alpha, "0.5",
-             "blend between particle-image (alpha=0) and "
-             "inter-particle (alpha=1) energies");
-  hestOptAdd(&hopt, "beta", "beta", airTypeDouble, 1, 1,
-             &beta, "1.0",
-             "when using Phi2 energy, blend between pure "
-             "space repulsion (beta=0) and "
-             "scale attraction (beta=1)");
-  hestOptAdd(&hopt, "gamma", "gamma", airTypeDouble, 1, 1,
-             &gamma, "1.0",
-             "scaling factor on energy from strength");
-  hestOptAdd(&hopt, "theta", "theta", airTypeDouble, 1, 1,
-             &theta, "0.0",
-             "slope of increasing livethresh wrt scale");
-  hestOptAdd(&hopt, "wall", "k", airTypeDouble, 1, 1,
-             &wall, "0.0",
-             "spring constant on walls");
-  hestOptAdd(&hopt, "eip", "k", airTypeDouble, 1, 1,
-             &energyIncreasePermit, "0.0",
-             "amount by which its okay for *per-particle* energy to increase "
-             "during gradient descent process");
   hestOptAdd(&hopt, "ess", "scl", airTypeDouble, 1, 1,
              &backStepScale, "0.5",
              "when energy goes up instead of down, scale step "
@@ -532,23 +417,6 @@
              &energyDecreaseMin, "0.0001",
              "convergence threshold: stop when fractional improvement "
              "(decrease) in energy dips below this");
-  hestOptAdd(&hopt, "edpcmin", "frac", airTypeDouble, 1, 1,
-             &energyDecreasePopCntlMin, "0.01",
-             "population control is triggered when energy improvement "
-             "goes below this threshold");
-  hestOptAdd(&hopt, "fnnm", "frac", airTypeDouble, 1, 1,
-             &fracNeighNixedMax, "0.25",
-             "don't nix if this fraction (or more) of neighbors "
-             "have been nixed");
-  hestOptAdd(&hopt, "pcp", "period", airTypeUInt, 1, 1,
-             &popCntlPeriod, "20",
-             "# iters to wait between attempts at population control");
-  hestOptAdd(&hopt, "iad", "# iters", airTypeUInt, 1, 1,
-             &addDescent, "10",
-             "# iters to run descent on tentative new points during PC");
-  hestOptAdd(&hopt, "icb", "# iters", airTypeUInt, 1, 1,
-             &iterCallback, "1",
-             "periodicity of calling rendering callback");
 
   hestOptAdd(&hopt, "ac3c", "ac3c", airTypeBool, 1, 1,
              &allowCodimension3Constraints, "false",
@@ -557,31 +425,25 @@
              "scale is tau");
   hestOptAdd(&hopt, "rng", "seed", airTypeUInt, 1, 1,
              &rngSeed, "42",
-             "base seed value for RNGs");
+             "base seed value for RNGs (and as a hack, start index for "
+             "Halton-based sampling)");
   hestOptAdd(&hopt, "pbm", "mod", airTypeUInt, 1, 1,
              &progressBinMod, "50",
              "progress bin mod");
-  hestOptAdd(&hopt, "eiphl", "hl", airTypeUInt, 1, 1, &eipHalfLife, "0",
-             "half-life of energyIncreasePermute (\"-eip\")");
   hestOptAdd(&hopt, "nt", "# threads", airTypeInt, 1, 1,
              &threadNum, "1",
              (airThreadCapable
-              ? "number of threads hoover should use"
-              : "if threads where enabled in this Teem build, this is how "
-              "you would control the number of threads to use"));
-  hestOptAdd(&hopt, "nprob", "prob", airTypeDouble, 1, 1,
-             &neighborTrueProb, "1.0",
-             "do full neighbor discovery with this probability");
-  hestOptAdd(&hopt, "pprob", "prob", airTypeDouble, 1, 1,
-             &probeProb, "1.0",
-             "probe local image values with this probability");
-
+              ? "number of threads to use"
+              : "IF threads had beeen enabled in this Teem build (but "
+              "they are NOT), this is how you would control the number "
+              "of threads to use"));
   hestOptAdd(&hopt, "addlog", "fname", airTypeString, 1, 1, &addLogS, "",
              "name of file in which to log all particle additions");
-  hestOptAdd(&hopt, "po", "nout", airTypeString, 1, 1, &posOutS, "pos.nrrd",
-             "position output");
+  hestOptAdd(&hopt, "po", "nout", airTypeString, 1, 1, &posOutS, "",
+             "if a filename is given here, the positions of the initialized "
+             "particles are saved");
   hestOptAdd(&hopt, "o", "nout", airTypeString, 1, 1, &outS, "trace.nrrd",
-             "trace volume");
+             "plotted trace image");
   hestOptAdd(&hopt, "eob", "base", airTypeString, 1, 1, &extraOutBaseS, "",
              "save extra info (besides position), and use this string as "
              "the base of the filenames.  Not using this means the extra "
@@ -591,14 +453,33 @@
              "fraction of SS range used as step along scale for tracing");
   hestOptAdd(&hopt, "sw", "swin", airTypeDouble, 1, 1, &sswin, "0.1",
              "fraction of SS range that caps length of trace along scale");
-  hestOptAdd(&hopt, "sh", "shalf", airTypeDouble, 1, 1, &shalf, "5.0",
-             "velocity that will be half-way down vertical axis of plot");
-  hestOptAdd(&hopt, "sl", "sslim", airTypeDouble, 1, 1, &sslim, "50.0",
-             "velocity at which we give up tracking");
+  hestOptAdd(&hopt, "otl", "len", airTypeDouble, 1, 1, &orientTestLen, "0",
+             "when probing the tangents of the contraint surface, this is "
+             "(when nonzero) the length in world-space of "
+             "the offset to the second test position at which to sample "
+             "the constraint");
   hestOptAdd(&hopt, "pr", "sx sy", airTypeUInt, 2, 2, pres, "1000 420",
              "resolution of the 2D plot");
+  hestOptAdd(&hopt, "sp", "smoothing", airTypeInt, 1, 1, &smoothPlot, "0",
+             "if greater than zero, amount of smoothing of computed "
+             "stabilities, prior to plotting");
+  hestOptAdd(&hopt, "fw", "flatwght", airTypeInt, 1, 1, &flatWght, "0",
+             "if greater than zero, amount by which to increase "
+             "weighting of more horizontal (flat) sections of the plot");
   hestOptAdd(&hopt, "tlo", "fname", airTypeString, 1, 1, &trcListOutS, "",
              "output filename of list of all points in all traces");
+  hestOptAdd(&hopt, "tmi", "nmask", airTypeOther, 1, 1, &nTraceMaskIn, "",
+             "if this is an 8-bit 2D array, of the same size as given by "
+             "the \"-pr\" option, then it is used as a mask on the "
+             "pre-computed trace given by \"-ti\", to find points in traces "
+             "that overlap with the trace mask, and save them in the file "
+             "given by \"-tmpo\"",
+             NULL, NULL, nrrdHestNrrd);
+  hestOptAdd(&hopt, "tmpo", "nout", airTypeString, 1, 1, &traceMaskPosOutS, "",
+             "if a filename is given here, this is where to save positions "
+             "of positions on traces masked by \"-tmi\"");
+  hestOptAdd(&hopt, "tvo", "fname", airTypeString, 1, 1, &trcVolOutS, "",
+             "output filename for rasterized trace of scale-space volume");
 
   hestParseOrDie(hopt, argc-1, argv+1, hparm,
                  me, info, AIR_TRUE, AIR_TRUE, AIR_TRUE);
@@ -619,59 +500,41 @@
     addLog = NULL;
   }
 
+  if (nTraceMaskIn && airStrlen(traceMaskPosOutS)) {
+    nmaskedpos = nrrdNew();
+    airMopAdd(mop, nmaskedpos, (airMopper)nrrdNuke, airMopAlways);
+  } else {
+    nmaskedpos = NULL;
+  }
+
   pctx = pullContextNew();
   airMopAdd(mop, pctx, (airMopper)pullContextNix, airMopAlways);
   if (pullVerboseSet(pctx, verbose)
-      || pullFlagSet(pctx, pullFlagEnergyFromStrength, energyFromStrength)
+      || pullFlagSet(pctx, pullFlagZeroZ, zeroZ)
       || pullFlagSet(pctx, pullFlagNixAtVolumeEdgeSpace, nixAtVolumeEdgeSpace)
       || pullFlagSet(pctx, pullFlagConstraintBeforeSeedThresh,
                      constraintBeforeSeedThresh)
-      || pullFlagSet(pctx, pullFlagPopCntlEnoughTest, popCntlEnoughTest)
       || pullFlagSet(pctx, pullFlagBinSingle, binSingle)
       || pullFlagSet(pctx, pullFlagNoAdd, noAdd)
       || pullFlagSet(pctx, pullFlagPermuteOnRebin, permuteOnRebin)
-      || pullFlagSet(pctx, pullFlagNoPopCntlWithZeroAlpha,
-                     noPopCntlWithZeroAlpha)
-      || pullFlagSet(pctx, pullFlagUseBetaForGammaLearn,
-                     useBetaForGammaLearn)
-      || pullFlagSet(pctx, pullFlagRestrictiveAddToBins,
-                     restrictiveAddToBins)
+      /* want this to be true; tracing is different than regular particles */
+      || pullFlagSet(pctx, pullFlagRestrictiveAddToBins, AIR_TRUE)
       || pullFlagSet(pctx, pullFlagAllowCodimension3Constraints,
                      allowCodimension3Constraints)
       || pullFlagSet(pctx, pullFlagScaleIsTau, scaleIsTau)
       || pullInitUnequalShapesAllowSet(pctx, unequalShapesAllow)
       || pullIterParmSet(pctx, pullIterParmSnap, snap)
-      || pullIterParmSet(pctx, pullIterParmMax, iterMax)
       || pullIterParmSet(pctx, pullIterParmStuckMax, stuckIterMax)
       || pullIterParmSet(pctx, pullIterParmConstraintMax, constraintIterMax)
-      || pullIterParmSet(pctx, pullIterParmPopCntlPeriod, popCntlPeriod)
-      || pullIterParmSet(pctx, pullIterParmAddDescent, addDescent)
-      || pullIterParmSet(pctx, pullIterParmCallback, iterCallback)
-      || pullIterParmSet(pctx, pullIterParmEnergyIncreasePermitHalfLife,
-                         eipHalfLife)
       || pullSysParmSet(pctx, pullSysParmStepInitial, stepInitial)
       || pullSysParmSet(pctx, pullSysParmConstraintStepMin, constraintStepMin)
       || pullSysParmSet(pctx, pullSysParmRadiusSpace, radiusSpace)
       || pullSysParmSet(pctx, pullSysParmRadiusScale, radiusScale)
       || pullSysParmSet(pctx, pullSysParmBinWidthSpace, binWidthSpace)
-      || pullSysParmSet(pctx, pullSysParmAlpha, alpha)
-      || pullSysParmSet(pctx, pullSysParmBeta, beta)
-      || pullSysParmSet(pctx, pullSysParmGamma, gamma)
-      || pullSysParmSet(pctx, pullSysParmTheta, theta)
-      || pullSysParmSet(pctx, pullSysParmWall, wall)
-      || pullSysParmSet(pctx, pullSysParmEnergyIncreasePermit,
-                        energyIncreasePermit)
       || pullSysParmSet(pctx, pullSysParmEnergyDecreaseMin,
                         energyDecreaseMin)
-      || pullSysParmSet(pctx, pullSysParmFracNeighNixedMax,
-                        fracNeighNixedMax)
-      || pullSysParmSet(pctx, pullSysParmEnergyDecreasePopCntlMin,
-                        energyDecreasePopCntlMin)
       || pullSysParmSet(pctx, pullSysParmBackStepScale, backStepScale)
       || pullSysParmSet(pctx, pullSysParmOpporStepScale, opporStepScale)
-      || pullSysParmSet(pctx, pullSysParmNeighborTrueProb,
-                        neighborTrueProb)
-      || pullSysParmSet(pctx, pullSysParmProbeProb, probeProb)
       || pullRngSeedSet(pctx, rngSeed)
       || pullProgressBinModSet(pctx, progressBinMod)
       || pullThreadNumSet(pctx, threadNum)
@@ -683,25 +546,15 @@
     airMopError(mop); return 1;
   }
 
-  if (nPosIn) {
-    E = pullInitGivenPosSet(pctx, nPosIn);
-  } else if (pointPerVoxel) {
-    E = pullInitPointPerVoxelSet(pctx, pointPerVoxel,
-                                 ppvZRange[0], ppvZRange[1],
-                                 samplesAlongScaleNum, jitter);
-  } else if (useHalton) {
-    E = pullInitHaltonSet(pctx, pointNumInitial, 0);
-  } else {
-    E = pullInitRandomSet(pctx, pointNumInitial);
-  }
-  if (E) {
+  if (pullInitHaltonSet(pctx, pointNumInitial, rngSeed)) {
     airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
-    fprintf(stderr, "%s: trouble with flags:\n%s", me, err);
+    fprintf(stderr, "%s: trouble setting halton:\n%s", me, err);
     airMopError(mop); return 1;
   }
-  if (meetPullVolLoadMulti(vspec, vspecNum, cachePathSS,
-                           kSSblur, nrrdBoundaryBleed, AIR_NAN,
-                           verbose)
+  if (meetPullVolStackBlurParmFinishMulti(vspec, vspecNum,
+                                          &kssFinished, &bspFinished,
+                                          kSSblur, bspec)
+      || meetPullVolLoadMulti(vspec, vspecNum, cachePathSS, verbose)
       || meetPullVolAddMulti(pctx, vspec, vspecNum,
                              k00, k11, k22, kSSrecon)
       || meetPullInfoAddMulti(pctx, idef, idefNum)) {
@@ -709,6 +562,16 @@
     fprintf(stderr, "%s: trouble with volumes or infos:\n%s", me, err);
     airMopError(mop); return 1;
   }
+  if (!kssFinished && hestSourceUser == hopt[kssOpi].source) {
+    fprintf(stderr, "\n\n%s: WARNING! Used the -%s flag, but the "
+            "meetPullVol specified blurring kernels\n\n\n", me,
+            hopt[kssOpi].flag);
+  }
+  if (!bspFinished && hestSourceUser == hopt[bspOpi].source) {
+    fprintf(stderr, "\n\n%s: WARNING! Used the -%s flag, but the "
+            "meetPullVol specified boundary specs\n\n\n", me,
+            hopt[bspOpi].flag);
+  }
 
   if (airStrlen(tracesInS)) {
     /* don't need to initialize points if we're reading a trace,
@@ -717,6 +580,9 @@
        associated with the constraint */
     pullFlagSet(pctx, pullFlagStartSkipsPoints, AIR_TRUE);
   }
+  if (pctx->verbose) {
+    fprintf(stderr, "%s: about to pullStart\n", me);
+  }
   if (pullStart(pctx)) {
     airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
     fprintf(stderr, "%s: trouble starting system:\n%s", me, err);
@@ -732,17 +598,20 @@
   }
   if (pullConstraintScaleRange(pctx, ssrange)) {
     airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
-    fprintf(stderr, "%s: trouble:\n%s", me, err);
+    fprintf(stderr, "%s: trouble C:\n%s", me, err);
     airMopError(mop); return 1;
   }
   fprintf(stderr, "!%s: ================== ssrange %g %g\n", me,
           ssrange[0], ssrange[1]);
-  fprintf(stderr, "!%s: ======== mvol %u %g %g\n", me, vspec[0]->numSS,
-          vspec[0]->rangeSS[0], vspec[0]->rangeSS[1]);
+  if (vspec[0]->sbp) {
+    char stmp[AIR_STRLEN_LARGE];
+    gageStackBlurParmSprint(stmp, vspec[0]->sbp, NULL, NULL);
+    fprintf(stderr, "!%s: ======== %s\n", me, stmp);
+  }
   nplotA->axis[0].min = ssrange[0];
   nplotA->axis[0].max = ssrange[1];
-  nplotA->axis[1].min = 0.0;
-  nplotA->axis[1].max = 2*shalf;
+  nplotA->axis[1].min = 1.0;
+  nplotA->axis[1].max = 0.0;
   nrrdCopy(nplotB, nplotA);
   if (airStrlen(tracesInS)) {
     if (!(tracesFile = airFopen(tracesInS, stdin, "rb"))) {
@@ -757,7 +626,7 @@
     airFclose(tracesFile);
     goto plotting;
   }
-  /* else */
+  /* else not reading in traces, have to compute them */
 
   if (!pctx->constraint) {
     fprintf(stderr, "%s: this programs requires a constraint\n", me);
@@ -780,10 +649,12 @@
 
   if (pullOutputGet(nPosOut, NULL, NULL, NULL, 0.0, pctx)) {
     airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
-    fprintf(stderr, "%s: trouble 3.1:\n%s", me, err);
+    fprintf(stderr, "%s: trouble D:\n%s", me, err);
     airMopError(mop); return 1;
   }
-  nrrdSave(posOutS, nPosOut, NULL);
+  if (airStrlen(posOutS)) {
+    nrrdSave(posOutS, nPosOut, NULL);
+  }
 
   {
     double *pos, seedPos[4], scaleWin, scaleStep, dist=0;
@@ -817,9 +688,11 @@
       printf("%s", airDoneStr(0, pidx, pnum, doneStr)); fflush(stdout);
       pts = pullTraceNew();
       ELL_4V_COPY(seedPos, pos + 4*pidx);
-      if (pullTraceSet(pctx, pts, AIR_TRUE,
+      if (pullTraceSet(pctx, pts,
+                       AIR_TRUE /* recordStrength */,
                        scaleStep, scaleWin/2,
-                       sslim, AIR_CAST(unsigned int, sslim/scaleStep),
+                       orientTestLen,
+                       AIR_UINT((scaleWin/2)/scaleStep),
                        seedPos)
           || pullTraceMultiAdd(mtrc, pts, &added)) {
         airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
@@ -827,38 +700,61 @@
         airMopError(mop); return 1;
       }
       if (!added) {
+        /*
+        fprintf(stderr, "!%s: whynowhere %s, why stop %s(%s)  %s(%s)\n", me,
+                airEnumStr(pullTraceStop, pts->whyNowhere),
+                airEnumStr(pullTraceStop, pts->whyStop[0]),
+                (pts->whyStop[0] == pullTraceStopConstrFail
+                 ? airEnumStr(pullConstraintFail, pts->whyConstrFail[0])
+                 : ""),
+                airEnumStr(pullTraceStop, pts->whyStop[1]),
+                (pts->whyStop[1] == pullTraceStopConstrFail
+                 ? airEnumStr(pullConstraintFail, pts->whyConstrFail[1])
+                 : ""));
+        */
         pts = pullTraceNix(pts);
       }
     }
     printf("%s\n", airDoneStr(0, pidx, pnum, doneStr));
-    if (pullTraceMultiPlotAdd(nprogA, mtrc, NULL, 0, 0)) {
+    if (!mtrc->traceNum) {
+      fprintf(stderr, "%s: %u initial points led to zero traces\n", me, pnum);
+      airMopError(mop); return 1;
+    }
+    if (pullTraceMultiPlotAdd(nprogA, mtrc, NULL,
+                              strnUse, smoothPlot, flatWght,
+                              0, 0, NULL, NULL)) {
       airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
-      fprintf(stderr, "%s: trouble ploting:\n%s", me, err);
+      fprintf(stderr, "%s: trouble PlotAdd'ing (B):\n%s", me, err);
       airMopError(mop); return 1;
     }
     resamplePlot(nlsplot, nprogA);
+    /* savePlot(nlsplot); */
 
-    for (passIdx=0; (passNumMax ? passIdx<passNumMax : 1); passIdx++) {
+    for (passIdx=0; passIdx<passNumMax; passIdx++) {
       double dd;
       fprintf(stderr, "!%s: pass %u/%u ==================\n",
               me, passIdx, passNumMax);
       nrrdZeroSet(nprogB);
       if (findAndTraceMorePoints(nprogB, pctx, scaleVol,
+                                 strnUse, smoothPlot, flatWght,
                                  scaleStep, scaleWin/2,
-                                 sslim, AIR_CAST(unsigned int, sslim/scaleStep),
+                                 orientTestLen,
+                                 AIR_UINT((scaleWin/2)/scaleStep),
                                  mtrc, tracePointNum)
           || resamplePlot(nsplot, nprogB)) {
         airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
         fprintf(stderr, "%s: trouble on pass %u:\n%s", me, passIdx, err);
         airMopError(mop); return 1;
       }
-      dd = tracePointNum*distanceProb(nsplot, nlsplot);
+      /* savePlot(nsplot); */
+      dd = distanceProb(nsplot, nlsplot)/tracePointNum;
       if (!passIdx) {
         dist = dd;
       } else {
-        dist = 0.5*(dist + dd);
+        dist = AIR_LERP(0.9, dist, dd);
       }
-      fprintf(stderr, "%s: dd = %g -> dist = %g\n", me, dd, dist);
+      fprintf(stderr, "%s: dd = %g -> dist = %g (%s %g)\n", me, dd, dist,
+              dist < tpdThresh ? "<" : ">=",  tpdThresh);
       nrrdCopy(nlsplot, nsplot);
       if (dist < tpdThresh) {
         fprintf(stderr, "%s: converged: dist %g < thresh %g\n",
@@ -882,7 +778,7 @@
   plotting:
     if (airStrlen(trcListOutS)) {
       /* format:
-      ** trcIdx  isSeed  X  Y  Z  S  f(velo)  strn qual
+      ** trcIdx  isSeed  X  Y  Z  S  f(stab)  strn qual
       **   0        1    2  3  4  5    6       7     8  (9)
       */
       Nrrd *ntlo;
@@ -893,7 +789,10 @@
       unsigned int ti;
       for (ti=0; ti<mtrc->traceNum; ti++) {
         trc = mtrc->trace[ti];
-        totn += trc->nvelo->axis[0].size;
+        fprintf(stderr, "!%s: ti %u/%u : stab (%d-D) %u %u\n", me, ti, mtrc->traceNum,
+                trc->nstab->dim, AIR_UINT(trc->nstab->axis[0].size),
+                AIR_UINT(trc->nstab->axis[1].size));
+        totn += trc->nstab->axis[0].size;
       }
       ntlo = nrrdNew();
       lpnt = pullPointNew(pctx);
@@ -906,12 +805,14 @@
       tlo = AIR_CAST(double *, ntlo->data);
       for (ti=0; ti<mtrc->traceNum; ti++) {
         unsigned int vi, vn;
-        double *vert, *velo, *strn, qual;
+        double *vert, *stab, *strn, qual;
         trc = mtrc->trace[ti];
-        vn = AIR_CAST(unsigned int, trc->nvelo->axis[0].size);
+        vn = AIR_UINT(trc->nstab->axis[0].size);
         vert = AIR_CAST(double *, trc->nvert->data);
-        velo = AIR_CAST(double *, trc->nvelo->data);
-        strn = AIR_CAST(double *, trc->nstrn ? trc->nstrn->data : NULL);
+        stab = AIR_CAST(double *, trc->nstab->data);
+        strn = AIR_CAST(double *, (trc->nstrn
+                                   ? trc->nstrn->data
+                                   : NULL));
         for (vi=0; vi<vn; vi++) {
           tlo[sx*toti + 0] = AIR_CAST(double, ti);
           tlo[sx*toti + 1] = (vi == trc->seedIdx);
@@ -923,7 +824,7 @@
           } else {
             qual = 0.0;
           }
-          tlo[sx*toti + 6] = atan(velo[vi]/shalf)/(AIR_PI/2);
+          tlo[sx*toti + 6] = stab[vi];
           tlo[sx*toti + 7] = strn ? strn[vi] : 0.0;
           tlo[sx*toti + 8] = qual;
           toti++;
@@ -935,11 +836,133 @@
         airMopError(mop); return 1;
       }
     }
-    if (pullTraceMultiPlotAdd(nplotA, mtrc, NULL, 0, 0)
-        || pullTraceMultiFilterConcaveDown(nfilt, mtrc, 0.05)
-        || pullTraceMultiPlotAdd(nplotB, mtrc, nfilt, 0, 0)) {
+    if (airStrlen(trcVolOutS)) {
+      /* HEY: copy and paste from above */
+      Nrrd *nout;
+      const gagePoint *pnt;
+      meetPullVol *mpv;
+      pullTrace *trc;
+      pullPoint *lpnt;
+      unsigned int size[4], idx[4], iii, ti, si;
+      double idxd[4], val, (*lup)(const void *v, size_t I),
+        (*ins)(void *v, size_t I, double d);
+      /* HEY this will segfault around here if the mask volume is
+         first, because of the following line of code */
+      if (!( mpv = meetPullVolCopy(vspec[0]) )) {
+        airMopAdd(mop, err = biffGetDone(MEET), airFree, airMopAlways);
+        fprintf(stderr, "%s: couldn't copy volume:\n%s", me, err);
+        airMopError(mop); return 1;
+      }
+      airMopAdd(mop, mpv, (airMopper)meetPullVolNix, airMopAlways);
+      /* at this point we actually have to hijack the mpv in case its
+         a non-scalar kind, because all we want is a scalar output */
+      if (0 != mpv->kind->baseDim) {
+        unsigned int ni;
+        Nrrd *nslice;
+        nslice = nrrdNew();
+        airMopAdd(mop, nslice, (airMopper)nrrdNuke, airMopAlways);
+        fprintf(stderr, "!%s: slicing %u %s vols to %s\n", me,
+                mpv->sbp->num, mpv->kind->name, gageKindScl->name);
+        for (ni=0; ni<mpv->sbp->num; ni++) {
+          if (nrrdSlice(nslice, mpv->ninSS[ni], 0, 0)
+              || nrrdCopy(mpv->ninSS[ni], nslice)) {
+            airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+            fprintf(stderr, "%s: couldn't slice volume %u:\n%s", me, ni, err);
+            airMopError(mop); return 1;
+          }
+        }
+        /* can we just do this? */
+        mpv->kind = gageKindScl;
+      }
+      size[0] = AIR_UINT(mpv->ninSS[0]->axis[0].size);
+      size[1] = AIR_UINT(mpv->ninSS[0]->axis[1].size);
+      size[2] = AIR_UINT(mpv->ninSS[0]->axis[2].size);
+      size[3] = mpv->sbp->num;
+      printf("!%s: size = (%u,%u,%u,%u)\n", me, size[0], size[1], size[2], size[3]);
+      lpnt = pullPointNew(pctx);
+      airMopAdd(mop, lpnt, (airMopper)pullPointNix, airMopAlways);
+      for (si=0; si<size[3]; si++) {
+        nrrdZeroSet(mpv->ninSS[si]);
+      }
+      lup = nrrdDLookup[mpv->ninSS[0]->type];
+      ins = nrrdDInsert[mpv->ninSS[0]->type];
+      /* HEY here also assuming scale-space volume is first volume  */
+      pnt = &(pctx->task[0]->vol[0]->gctx->point);
+      for (ti=0; ti<mtrc->traceNum; ti++) {
+        unsigned int vi, vn, orn, ori;
+        double *vert, *stab, *strn, *orin, wght;
+        trc = mtrc->trace[ti];
+        vn = AIR_UINT(trc->nstab->axis[0].size);
+        vert = AIR_CAST(double *, trc->nvert->data);
+        stab = AIR_CAST(double *, trc->nstab->data);
+        orin = AIR_CAST(double *, trc->norin->data);
+        strn = AIR_CAST(double *, (strnUse && trc->nstrn
+                                   ? trc->nstrn->data
+                                   : NULL));
+        /* orn = (orin ? 20 : 1); */
+        orn = 1;
+        for (vi=0; vi<vn; vi++) {
+          for (ori=0; ori < orn; ori++) {
+            ELL_4V_COPY(lpnt->pos, vert + 4*vi);
+            if (orn > 1) {
+              /* hack to draw a dotted line along tangent */
+              double oscl = AIR_AFFINE(0, ori, orn-1, -100, 100);
+              lpnt->pos[0] += oscl*(orin + 3*vi)[0];
+              lpnt->pos[1] += oscl*(orin + 3*vi)[1];
+            }
+            if (zeroZ && lpnt->pos[2] != 0) {
+              fprintf(stderr, "%s: zeroZ violated\n", me);
+              airMopError(mop); return 1;
+            }
+            wght = stab[vi];
+            if (strn) {
+              wght *= strn[vi];
+            }
+            /* probe just to get the transform to idx-space from gage */
+            if (pullProbe(pctx->task[0], lpnt)) {
+              airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
+              fprintf(stderr, "%s: couldn't probe:\n%s", me, err);
+              airMopError(mop); return 1;
+            }
+            ELL_4V_ADD2(idxd, pnt->frac, pnt->idx);
+            /* because of gage subtlety that gagePoint->idx is index
+               of upper, not lower, corner, idxd is too big by 1 */
+            idx[0] = airIndexClamp(-0.5, idxd[0]-1, size[0]-0.5, size[0]);
+            idx[1] = airIndexClamp(-0.5, idxd[1]-1, size[1]-0.5, size[1]);
+            idx[2] = airIndexClamp(-0.5, idxd[2]-1, size[2]-0.5, size[2]);
+            idx[3] = airIndexClamp(0, idxd[3], size[3]-1, size[3]);
+            iii = idx[0] + size[0]*(idx[1] + size[1]*idx[2]);
+            val = lup(mpv->ninSS[idx[3]]->data, iii);
+            ins(mpv->ninSS[idx[3]]->data, iii, wght + val);
+            /*
+              printf("!%s: (%g,%g,%g,%g) -> (%g,%g,%g,%g) -> (%u,%u,%u,%u) -> %u: %g\n",
+              me, lpnt->pos[0], lpnt->pos[1], lpnt->pos[2], lpnt->pos[3],
+              idxd[0], idxd[1], idxd[2], idxd[3],
+              idx[0], idx[1], idx[2], idx[3], iii, val);
+            */
+          }
+        }
+      }
+      nout = nrrdNew();
+      airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
+      if (nrrdJoin(nout, AIR_CAST(const Nrrd *const *, mpv->ninSS),
+                   size[3], 3, AIR_FALSE)
+          || nrrdSave(trcVolOutS, nout, NULL)) {
+        airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+        fprintf(stderr, "%s: couldn't join or save SS output:\n%s", me, err);
+        airMopError(mop); return 1;
+      }
+    }
+    if (pullTraceMultiPlotAdd(nplotA, mtrc, NULL,
+                              strnUse, smoothPlot, flatWght,
+                              0, 0, nmaskedpos, nTraceMaskIn)
+        /* || pullTraceMultiFilterConcaveDown(nfilt, mtrc, 0.05) */
+        /* The filter concave down idea didn't really work */
+        || pullTraceMultiPlotAdd(nplotB, mtrc, NULL /* nfilt */,
+                                 AIR_TRUE, smoothPlot, flatWght,
+                                 0, 0, NULL, NULL)) {
       airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
-      fprintf(stderr, "%s: trouble plotting:\n%s", me, err);
+      fprintf(stderr, "%s: trouble PlotAdd'ing (C):\n%s", me, err);
       airMopError(mop); return 1;
     }
     {
@@ -948,15 +971,22 @@
       nin[1] = nplotB;
       if (nrrdJoin(nplot, nin, 2, 0, AIR_TRUE)) {
         airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
-        fprintf(stderr, "%s: trouble:\n%s", me, err);
+        fprintf(stderr, "%s: trouble E:\n%s", me, err);
         airMopError(mop); return 1;
       }
     }
     if (nrrdSave(outS, nplot, NULL)) {
       airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
-      fprintf(stderr, "%s: trouble:\n%s", me, err);
+      fprintf(stderr, "%s: trouble F:\n%s", me, err);
       airMopError(mop); return 1;
     }
+    if (nmaskedpos && nmaskedpos->data && airStrlen(traceMaskPosOutS)) {
+      if (nrrdSave(traceMaskPosOutS, nmaskedpos, NULL)) {
+        airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+        fprintf(stderr, "%s: trouble G:\n%s", me, err);
+        airMopError(mop); return 1;
+      }
+    }
   }
 
   pullFinish(pctx);
diff --color -ruN teem-1.11.0-src.orig/src/meet/test/tenums.c teem-1.11.0-src/src/meet/test/tenums.c
--- teem-1.11.0-src.orig/src/meet/test/tenums.c	2012-12-20 22:09:21.000000000 +0800
+++ teem-1.11.0-src/src/meet/test/tenums.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/meet/test/vpnts.c teem-1.11.0-src/src/meet/test/vpnts.c
--- teem-1.11.0-src.orig/src/meet/test/vpnts.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/meet/test/vpnts.c	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,194 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <teem/pull.h>
+#include "../meet.h"
+
+static const char *info =
+  ("For the simple task of generating N locations inside a volume. As "
+   "controlled by \"-m\", can be per voxel, uniform quasi-random, or "
+   "or uniform random.");
+
+int
+main(int argc, const char **argv) {
+  hestOpt *hopt=NULL;
+  hestParm *hparm;
+  airArray *mop;
+  const char *me;
+
+  char *err, *outS;
+  Nrrd *nin, *npos, *nout;
+  gageKind *kind;
+  pullEnergySpec *enspR;
+  meetPullInfo *minf[3];
+  NrrdKernelSpec *k00, *k11, *k22;
+  pullContext *pctx=NULL;
+  int ret=0, verbose, method;
+  unsigned int num, ss;
+  double jitter;
+
+  mop = airMopNew();
+  hparm = hestParmNew();
+  airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);
+
+  npos = nrrdNew();
+  airMopAdd(mop, npos, (airMopper)nrrdNuke, airMopAlways);
+
+  hparm->respFileEnable = AIR_TRUE;
+  me = argv[0];
+
+  /* these don't need to be visible on the command-line */
+  enspR = pullEnergySpecNew();
+  airMopAdd(mop, enspR, (airMopper)pullEnergySpecNix, airMopAlways);
+  pullEnergySpecParse(enspR, "cotan");
+
+  hestOptAdd(&hopt, "i", "nin", airTypeOther, 1, 1, &nin, NULL,
+             "input volume", NULL, NULL, nrrdHestNrrd);
+  hestOptAdd(&hopt, "k", "kind", airTypeOther, 1, 1, &kind, "scalar",
+             "\"kind\" of volume (\"scalar\", \"vector\", "
+             "\"tensor\", or \"dwi\")",
+             NULL, NULL, meetHestGageKind);
+  hestOptAdd(&hopt, "v", "verbosity", airTypeInt, 1, 1, &verbose, "0",
+             "verbosity level");
+  hestOptAdd(&hopt, "m", "method", airTypeEnum, 1, 1, &method, "ppv",
+             "way of creating point locations. Can be:\n "
+             "\b\bo \"ppv\": some points per-voxel (\"-n\" is how "
+             "many per-voxel, can be N < -1 for every Nth voxel)\n "
+             "\b\bo \"halton\": use halton sequence for quasi-random "
+             "(\"-s\" gives initial value)\n "
+             "\b\bo \"random\": use uniform random positions "
+             "(\"-s\" gives RNG seed)",
+             NULL, pullInitMethod);
+  hestOptAdd(&hopt, "n", "#points or #ppv", airTypeUInt, 1, 1, &num, "1",
+             "number of points to initialize with with random and halton, "
+             "or, number points per voxel with ppv");
+  hestOptAdd(&hopt, "s", "seed or start", airTypeUInt, 1, 1, &ss, "1",
+             "random number seed for random and ppv, or (hack), start "
+             "index for Halton-based sampling");
+  hestOptAdd(&hopt, "jit", "jitter", airTypeDouble, 1, 1, &jitter, "1",
+             "amount of jittering to do with ppv");
+  hestOptAdd(&hopt, "o", "nout", airTypeString, 1, 1, &outS, "out.nrrd",
+             "filename for saving positions");
+  hestParseOrDie(hopt, argc-1, argv+1, hparm,
+                 me, info, AIR_TRUE, AIR_TRUE, AIR_TRUE);
+  airMopAdd(mop, hopt, (airMopper)hestOptFree, airMopAlways);
+  airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);
+
+  /* other parms that we set just to keep pull happy */
+  enspR = pullEnergySpecNew();
+  airMopAdd(mop, enspR, (airMopper)pullEnergySpecNix, airMopAlways);
+  k00 = nrrdKernelSpecNew();
+  airMopAdd(mop, k00, (airMopper)nrrdKernelSpecNix, airMopAlways);
+  k11 = nrrdKernelSpecNew();
+  airMopAdd(mop, k11, (airMopper)nrrdKernelSpecNix, airMopAlways);
+  k22 = nrrdKernelSpecNew();
+  airMopAdd(mop, k22, (airMopper)nrrdKernelSpecNix, airMopAlways);
+  if (pullEnergySpecParse(enspR, "cotan")) {
+    airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
+    fprintf(stderr, "%s: trouble setting up faux energies:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+  if (nrrdKernelSpecParse(k00, "box")
+      || nrrdKernelSpecParse(k11, "zero")
+      || nrrdKernelSpecParse(k22, "zero")) {
+    airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
+    fprintf(stderr, "%s: trouble setting up faux kernels:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+#define VNAME "bingo"
+
+  pctx = pullContextNew();
+  airMopAdd(mop, pctx, (airMopper)pullContextNix, airMopAlways);
+  minf[0] = meetPullInfoNew();
+  airMopAdd(mop, minf[0], (airMopper)*meetPullInfoNix, airMopAlways);
+  minf[1] = meetPullInfoNew();
+  airMopAdd(mop, minf[1], (airMopper)*meetPullInfoNix, airMopAlways);
+  minf[2] = meetPullInfoNew();
+  airMopAdd(mop, minf[2], (airMopper)*meetPullInfoNix, airMopAlways);
+  int E = pullVerboseSet(pctx, verbose);
+  if (pullInitMethodRandom == method) {
+    if (!E) E |= pullRngSeedSet(pctx, ss);
+    if (!E) E |= pullInitRandomSet(pctx, num);
+  } else if (pullInitMethodHalton == method) {
+    if (!E) E |= pullInitHaltonSet(pctx, num, ss);
+  } else if (pullInitMethodPointPerVoxel == method) {
+    if (!E) E |= pullRngSeedSet(pctx, ss);
+    if (!E) E |= pullInitPointPerVoxelSet(pctx, num, 1, 0, 0, jitter);
+  } else if (pullInitMethodGivenPos == method) {
+    fprintf(stderr, "%s: this utility is for making point positions; "
+            "init method %s not available", me,
+            airEnumStr(pullInitMethod, method));
+    airMopError(mop); return 1;
+  } else {
+    fprintf(stderr, "%s: unsupported %s %s\n", me, pullInitMethod->name,
+            airEnumStr(pullInitMethod, method));
+    airMopError(mop); return 1;
+  }
+  if (E
+      || pullFlagSet(pctx, pullFlagNixAtVolumeEdgeSpaceInitRorH, AIR_TRUE)
+      || pullInterEnergySet(pctx, pullInterTypeJustR,
+                            enspR, NULL, NULL)
+      || pullVolumeSingleAdd(pctx, kind, VNAME, nin,
+                             k00, k11, k22)) {
+    airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
+    fprintf(stderr, "%s: trouble starting system:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+  /* figure out how big a voxel is, so that the bins set up don't
+     get overflowed.  The fact that there is binning happening
+     at all is a sign that we shouldn't have to rely on so much
+     pull infrastructure just to figure out this sampling ... */
+  const double *spc = pctx->vol[0]->gctx->shape->spacing;
+  double vlen = (spc[0] + spc[1] + spc[2])/3;
+  /* "<info>[-c]:<volname>:<item>[:<zero>:<scale>]" */
+  if (meetPullInfoParse(minf[0], "h:" VNAME ":val:0:1")
+      || meetPullInfoParse(minf[1], "hgvec:" VNAME ":gvec")
+      /* can you see the hack on the next line */
+      || meetPullInfoParse(minf[2], "sthr:" VNAME ":val:-88888888:1")
+      || meetPullInfoAddMulti(pctx, minf, 3)) {
+    airMopAdd(mop, err = biffGetDone(MEET), airFree, airMopAlways);
+    fprintf(stderr, "%s: trouble setting up faux info:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+  if (pullSysParmSet(pctx, pullSysParmRadiusSpace, vlen)
+      || pullStart(pctx)
+      || pullOutputGet(npos, NULL, NULL, NULL, 0.0, pctx)) {
+    airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
+    fprintf(stderr, "%s: trouble starting or getting output:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+  nout = nrrdNew();
+  airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
+  size_t cmin[2] = {0,0};
+  size_t cmax[2] = {2,npos->axis[1].size-1};
+  if (nrrdCrop(nout, npos, cmin, cmax)
+      || nrrdSave(outS, nout, NULL)) {
+    airMopAdd(mop, err = biffGetDone(PULL), airFree, airMopAlways);
+    fprintf(stderr, "%s: trouble saving output:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+
+  pullFinish(pctx);
+  airMopOkay(mop);
+  return ret;
+}
diff --color -ruN teem-1.11.0-src.orig/src/mite/CMakeLists.txt teem-1.11.0-src/src/mite/CMakeLists.txt
--- teem-1.11.0-src.orig/src/mite/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/mite/CMakeLists.txt	2021-02-18 15:42:37.000000000 +0800
@@ -0,0 +1,18 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(MITE_SOURCES
+  defaultsMite.c
+  kindnot.c
+  mite.h
+  privateMite.h
+  ray.c
+  renderMite.c
+  shade.c
+  thread.c
+  txf.c
+  user.c
+  )
+
+target_sources(teem PRIVATE ${MITE_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( mite FILES ${MITE_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/mite/defaultsMite.c teem-1.11.0-src/src/mite/defaultsMite.c
--- teem-1.11.0-src.orig/src/mite/defaultsMite.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/mite/defaultsMite.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/mite/GNUmakefile teem-1.11.0-src/src/mite/GNUmakefile
--- teem-1.11.0-src.orig/src/mite/GNUmakefile	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/mite/GNUmakefile	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/mite/kindnot.c teem-1.11.0-src/src/mite/kindnot.c
--- teem-1.11.0-src.orig/src/mite/kindnot.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/mite/kindnot.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/mite/mite.h teem-1.11.0-src/src/mite/mite.h
--- teem-1.11.0-src.orig/src/mite/mite.h	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/mite/mite.h	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -135,8 +135,8 @@
   double *debug;         /* data for verbose pixel (verbUi, verbVi) debug */
   airArray *debugArr;    /* airArray around debug */
   Nrrd *ndebug;          /* nrrd re-allocation of debug data */
-  int debugIdx;          /* index into debug data */
-  int ntxfNum;           /* allocated and valid length of ntxf[] */
+  unsigned int debugIdx, /* index into debug data */
+    ntxfNum;             /* allocated and valid length of ntxf[] */
   /* the issue of regular shading, txf-based shading, and surface normals:
      phong and lit-tensor shading ("regular shading") methods need to specify
      one or more vectors that are used for shading calculations.  These will
@@ -251,7 +251,7 @@
                                  refStep) has been applied to these, and
                                  these have been converted/unquantized to
                                  type mite_t */
-  int ntxfNum;                /* allocated and valid length of ntxf[] */
+  unsigned int ntxfNum;       /* allocated and valid length of ntxf[] */
   int sclPvlIdx, vecPvlIdx,
     tenPvlIdx;                /* indices of the different gageKinds of
                                  volumes in the gageContext's array of
@@ -304,8 +304,8 @@
                                    pervolumes, or into ansMiteVal in the
                                    miteThread.  It can be either a scalar
                                    or a vector */
-  int size,                     /* number of entries along this txf axis */
-    op;                         /* from miteStageOp* enum.  Note that this
+  unsigned int size;            /* number of entries along this txf axis */
+  int op;                       /* from miteStageOp* enum.  Note that this
                                    operation applies to ALL the range variables
                                    adjusted by this txf (can't add color while
                                    multiplying opacity) */
@@ -318,9 +318,9 @@
                                    from corresponding axis of the nrrd */
   mite_t *data;                 /* pointer to txf data.  If non-NULL, the
                                    following fields are meaningful */
-  int rangeIdx[MITE_RANGE_NUM], /* indices into miteThread's range, so that
+  int rangeIdx[MITE_RANGE_NUM]; /* indices into miteThread's range, so that
                                    we know which quantities to update */
-    rangeNum;                   /* number of range variables set by the txf
+  unsigned int rangeNum;        /* number of range variables set by the txf
                                    == number of pointers in range[] to use */
   char *label;                  /* pointer into axis label identifying txf
                                    domain variable, NOT COPIED */
@@ -412,7 +412,7 @@
     samples;                    /* number of samples handled so far by
                                    this thread */
   miteStage *stage;             /* array of stages for txf computation */
-  int stageNum;                 /* number of stages == length of stage[] */
+  unsigned int stageNum;        /* number of stages == length of stage[] */
   mite_t range[MITE_RANGE_NUM], /* rendering variables, which are either
                                    copied from miteUser's rangeInit[], or
                                    over-written by txf evaluation */
diff --color -ruN teem-1.11.0-src.orig/src/mite/privateMite.h teem-1.11.0-src/src/mite/privateMite.h
--- teem-1.11.0-src.orig/src/mite/privateMite.h	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/mite/privateMite.h	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/mite/ray.c teem-1.11.0-src/src/mite/ray.c
--- teem-1.11.0-src.orig/src/mite/ray.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/mite/ray.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -247,7 +247,8 @@
 
   /* initialize txf range quantities, and apply all txfs */
   if (mtt->verbose) {
-    muu->debugIdx = airArrayLenIncr(muu->debugArr, muu->ndebug->axis[0].size);
+    muu->debugIdx = airArrayLenIncr(muu->debugArr,
+                                    AIR_INT(muu->ndebug->axis[0].size));
   }
 
   memcpy(mtt->range, muu->rangeInit, MITE_RANGE_NUM*sizeof(mite_t));
@@ -299,13 +300,13 @@
 
 int
 miteRayEnd(miteThread *mtt, miteRender *mrr, miteUser *muu) {
-  int idx, slen, stageIdx;
+  unsigned int idx, slen, stageIdx;
   mite_t *imgData;
   double A;
 
   AIR_UNUSED(mrr);
   mtt->samples += mtt->raySample;
-  idx = mtt->ui + (muu->nout->axis[1].size)*mtt->vi;
+  idx = mtt->ui + AIR_UINT(muu->nout->axis[1].size)*mtt->vi;
   imgData = (mite_t*)muu->nout->data;
   A = 1 - mtt->TT;
   if (A) {
diff --color -ruN teem-1.11.0-src.orig/src/mite/renderMite.c teem-1.11.0-src/src/mite/renderMite.c
--- teem-1.11.0-src.orig/src/mite/renderMite.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/mite/renderMite.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -67,10 +67,10 @@
 miteRenderBegin(miteRender **mrrP, miteUser *muu) {
   static const char me[]="miteRenderBegin";
   gagePerVolume *pvl;
-  int E, T, pvlIdx;
+  int E, pvlIdx;
   gageQuery queryScl, queryVec, queryTen;
   gageItemSpec isp;
-  unsigned int axi, thr;
+  unsigned int axi, thr, T;
 
   if (!(mrrP && muu)) {
     biffAddf(MITE, "%s: got NULL pointer", me);
diff --color -ruN teem-1.11.0-src.orig/src/mite/shade.c teem-1.11.0-src/src/mite/shade.c
--- teem-1.11.0-src.orig/src/mite/shade.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/mite/shade.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/mite/sources.cmake teem-1.11.0-src/src/mite/sources.cmake
--- teem-1.11.0-src.orig/src/mite/sources.cmake	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/mite/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,16 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(MITE_SOURCES
-  defaultsMite.c
-  kindnot.c
-  mite.h
-  privateMite.h
-  ray.c
-  renderMite.c
-  shade.c
-  thread.c
-  txf.c
-  user.c
-  )
-
-ADD_TEEM_LIBRARY(mite ${MITE_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/mite/thread.c teem-1.11.0-src/src/mite/thread.c
--- teem-1.11.0-src.orig/src/mite/thread.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/mite/thread.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/mite/txf.c teem-1.11.0-src/src/mite/txf.c
--- teem-1.11.0-src.orig/src/mite/txf.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/mite/txf.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -396,7 +396,8 @@
 int
 _miteNtxfCopy(miteRender *mrr, miteUser *muu) {
   static const char me[]="_miteNtxfCopy";
-  int ni, E;
+  unsigned int ni;
+  int E;
 
   mrr->ntxf = AIR_CALLOC(muu->ntxfNum, Nrrd *);
   if (!mrr->ntxf) {
@@ -447,7 +448,7 @@
 int
 _miteNtxfAlphaAdjust(miteRender *mrr, miteUser *muu) {
   static const char me[]="_miteNtxfAlphaAdjust";
-  int ni, ei, ri, nnum, rnum;
+  unsigned int ni, ei, ri, nnum, rnum;
   Nrrd *ntxf;
   mite_t *data, alpha, frac;
 
@@ -463,8 +464,8 @@
     }
     /* else this txf sets opacity */
     data = (mite_t *)ntxf->data;
-    rnum = ntxf->axis[0].size;
-    nnum = nrrdElementNumber(ntxf)/rnum;
+    rnum = AIR_UINT(ntxf->axis[0].size);
+    nnum = AIR_UINT(nrrdElementNumber(ntxf)/rnum);
     for (ei=0; ei<nnum; ei++) {
       for (ri=0; ri<rnum; ri++) {
         if (ntxf->axis[0].label[ri] == miteRangeChar[miteRangeAlpha]) {
@@ -479,7 +480,7 @@
 
 int
 _miteStageNum(miteRender *mrr) {
-  int num, ni;
+  unsigned int num, ni;
 
   num = 0;
   for (ni=0; ni<mrr->ntxfNum; ni++) {
@@ -543,7 +544,7 @@
 _miteStageSet(miteThread *mtt, miteRender *mrr) {
   static const char me[]="_miteStageSet";
   char *value;
-  int ni, di, stageIdx, rii, stageNum, ilog2;
+  unsigned int ni, di, stageIdx, rii, stageNum, ilog2;
   Nrrd *ntxf;
   miteStage *stage;
   gageItemSpec isp;
@@ -571,7 +572,7 @@
       fprintf(stderr, "!%s: ans=%p + offset[%d]=%d == %p\n", me,
               mtt->ans, dom, kind->ansOffset[dom], stage->val);
       */
-      stage->size = ntxf->axis[di].size;
+      stage->size = AIR_UINT(ntxf->axis[di].size);
       stage->min =  ntxf->axis[di].min;
       stage->max =  ntxf->axis[di].max;
       if (di > 1) {
@@ -591,7 +592,7 @@
           stage->qn = NULL;
         } else if (3 == isp.kind->table[isp.item].answerLength) {
           char stmp[AIR_STRLEN_SMALL];
-          ilog2 = airLog2(ntxf->axis[di].size);
+          ilog2 = AIR_UINT(airLog2(ntxf->axis[di].size));
           switch(ilog2) {
           case 8:  stage->qn = limnVtoQN_d[ limnQN8octa]; break;
           case 9:  stage->qn = limnVtoQN_d[ limnQN9octa]; break;
@@ -617,10 +618,11 @@
                    isp.kind->table[isp.item].answerLength);
           return 1;
         }
-        stage->rangeNum = ntxf->axis[0].size;
+        stage->rangeNum = AIR_UINT(ntxf->axis[0].size);
         for (rii=0; rii<stage->rangeNum; rii++) {
           rc = ntxf->axis[0].label[rii];
-          stage->rangeIdx[rii] = strchr(miteRangeChar, rc) - miteRangeChar;
+          stage->rangeIdx[rii] = AIR_INT(strchr(miteRangeChar, rc)
+                                         - miteRangeChar);
           /*
           fprintf(stderr, "!%s: range: %c -> %d\n", "_miteStageSet",
                   ntxf->axis[0].label[rii], stage->rangeIdx[rii]);
@@ -636,8 +638,7 @@
 void
 _miteStageRun(miteThread *mtt, miteUser *muu) {
   static const char me[]="_miteStageRun";
-  int stageIdx, ri, rii;
-  unsigned int txfIdx, finalIdx;
+  unsigned int stageIdx, ri, rii, txfIdx, finalIdx;
   miteStage *stage;
   mite_t *rangeData;
   double *dbg=NULL;
diff --color -ruN teem-1.11.0-src.orig/src/mite/user.c teem-1.11.0-src/src/mite/user.c
--- teem-1.11.0-src.orig/src/mite/user.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/mite/user.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -88,12 +88,12 @@
 int
 _miteUserCheck(miteUser *muu) {
   static const char me[]="_miteUserCheck";
-  int T, gotOpac;
+  int gotOpac;
   gageItemSpec isp;
   gageQuery queryScl, queryVec, queryTen, queryMite;
   miteShadeSpec *shpec;
   airArray *mop;
-  unsigned int axi;
+  unsigned int axi, T;
 
   if (!muu) {
     biffAddf(MITE, "%s: got NULL pointer", me);
diff --color -ruN teem-1.11.0-src.orig/src/moss/CMakeLists.txt teem-1.11.0-src/src/moss/CMakeLists.txt
--- teem-1.11.0-src.orig/src/moss/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/moss/CMakeLists.txt	2021-02-18 15:42:34.000000000 +0800
@@ -0,0 +1,15 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(MOSS_SOURCES
+  defaultsMoss.c
+  hestMoss.c
+  methodsMoss.c
+  moss.h
+  privateMoss.h
+  sampler.c
+  xform.c
+  )
+
+target_sources(teem PRIVATE ${MOSS_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( moss FILES ${MOSS_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/moss/defaultsMoss.c teem-1.11.0-src/src/moss/defaultsMoss.c
--- teem-1.11.0-src.orig/src/moss/defaultsMoss.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/moss/defaultsMoss.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/moss/GNUmakefile teem-1.11.0-src/src/moss/GNUmakefile
--- teem-1.11.0-src.orig/src/moss/GNUmakefile	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/moss/GNUmakefile	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/moss/hestMoss.c teem-1.11.0-src/src/moss/hestMoss.c
--- teem-1.11.0-src.orig/src/moss/hestMoss.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/moss/hestMoss.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -25,7 +25,8 @@
 #include "privateMoss.h"
 
 int
-_mossHestTransformParse (void *ptr, char *_str, char err[AIR_STRLEN_HUGE]) {
+_mossHestTransformParse (void *ptr, const char *_str,
+                         char err[AIR_STRLEN_HUGE]) {
   char me[]="_mossHestTransformParse", *str;
   double **matP, tx, ty, sx, sy, angle, mat[6], shf, sha;
   airArray *mop;
@@ -99,7 +100,7 @@
 ** u(x,y): position in unit box [0,1]x[0,1] --> val[3] = (1,x,y)
 */
 int
-_mossHestOriginParse (void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+_mossHestOriginParse (void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   char me[]="_mossHestOriginParse";
   double **valP;
   airArray *mop;
diff --color -ruN teem-1.11.0-src.orig/src/moss/methodsMoss.c teem-1.11.0-src/src/moss/methodsMoss.c
--- teem-1.11.0-src.orig/src/moss/methodsMoss.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/moss/methodsMoss.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -65,8 +65,8 @@
   smplr->ivc = (float*)calloc(fdiam*fdiam*ncol, sizeof(float));
   smplr->xFslw = (double*)calloc(fdiam, sizeof(double));
   smplr->yFslw = (double*)calloc(fdiam, sizeof(double));
-  smplr->xIdx = (int*)calloc(fdiam, sizeof(int));
-  smplr->yIdx = (int*)calloc(fdiam, sizeof(int));
+  smplr->xIdx = AIR_CALLOC(fdiam, unsigned int);
+  smplr->yIdx = AIR_CALLOC(fdiam, unsigned int);
   if (!( smplr->ivc && smplr->xFslw && smplr->yFslw
          && smplr->xIdx && smplr->yIdx )) {
     biffAddf(MOSS, "%s: couldn't allocate buffers", me);
@@ -84,8 +84,8 @@
     smplr->ivc = (float *)airFree(smplr->ivc);
     smplr->xFslw = (double *)airFree(smplr->xFslw);
     smplr->yFslw = (double *)airFree(smplr->yFslw);
-    smplr->xIdx = (int *)airFree(smplr->xIdx);
-    smplr->yIdx = (int *)airFree(smplr->yIdx);
+    smplr->xIdx = (unsigned int *)airFree(smplr->xIdx);
+    smplr->yIdx = (unsigned int *)airFree(smplr->yIdx);
     smplr->fdiam = 0;
     smplr->ncol = 0;
   }
diff --color -ruN teem-1.11.0-src.orig/src/moss/moss.h teem-1.11.0-src/src/moss/moss.h
--- teem-1.11.0-src.orig/src/moss/moss.h	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/moss/moss.h	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -52,14 +52,9 @@
 
 #define MOSS mossBiffKey
 
-#define MOSS_NCOL(img) (3 == (img)->dim ? (img)->axis[0].size : 1)
+/* used by ilk, hence not in privateMoss.h */
 #define MOSS_AXIS0(img) (3 == (img)->dim ? 1 : 0)
-#define MOSS_SX(img) (3 == (img)->dim \
-                      ? (img)->axis[1].size \
-                      : (img)->axis[0].size )
-#define MOSS_SY(img) (3 == (img)->dim \
-                      ? (img)->axis[2].size \
-                      : (img)->axis[1].size )
+#define MOSS_NCOL(img) AIR_UINT(3 == (img)->dim ? (img)->axis[0].size : 1)
 
 enum {
   mossFlagUnknown=-1,  /* -1: nobody knows */
@@ -75,10 +70,10 @@
   double kparm[NRRD_KERNEL_PARMS_NUM]; /* kernel arguments */
   float *ivc;                          /* intermediate value cache */
   double *xFslw, *yFslw;               /* filter sample locations->weights */
-  int fdiam, ncol;                     /* filter diameter; ivc is allocated
+  unsigned int fdiam, ncol;            /* filter diameter; ivc is allocated
                                           for (fdiam+1) x (fdiam+1) x ncol
                                           doubles, with that axis ordering */
-  int *xIdx, *yIdx;                    /* arrays for x and y coordinates,
+  unsigned int *xIdx, *yIdx;           /* arrays for x and y coordinates,
                                           both allocated for fdiam */
   float *bg;                           /* background color */
   int boundary;                        /* from nrrdBoundary* enum */
diff --color -ruN teem-1.11.0-src.orig/src/moss/privateMoss.h teem-1.11.0-src/src/moss/privateMoss.h
--- teem-1.11.0-src.orig/src/moss/privateMoss.h	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/moss/privateMoss.h	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -21,6 +21,13 @@
   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
 
+#define MOSS_SX(img) AIR_UINT((3 == (img)->dim            \
+                               ? (img)->axis[1].size      \
+                               : (img)->axis[0].size ))
+#define MOSS_SY(img) AIR_UINT((3 == (img)->dim            \
+                               ? (img)->axis[2].size      \
+                               : (img)->axis[1].size ))
+
 #define MOSS_MAT_SET(mat, a, b, x, c, d, y) \
   (mat)[0]=(a); (mat)[1]=(b); (mat)[2]=(x); \
   (mat)[3]=(c); (mat)[4]=(d); (mat)[5]=(y)
diff --color -ruN teem-1.11.0-src.orig/src/moss/sampler.c teem-1.11.0-src/src/moss/sampler.c
--- teem-1.11.0-src.orig/src/moss/sampler.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/moss/sampler.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -27,7 +27,7 @@
 int
 mossSamplerImageSet (mossSampler *smplr, Nrrd *image, float *bg) {
   static const char me[]="mossSamplerImageSet";
-  int ci, ncol;
+  unsigned int ci, ncol;
 
   if (!(smplr && image)) {
     biffAddf(MOSS, "%s: got NULL pointer", me);
@@ -71,7 +71,7 @@
 int
 mossSamplerUpdate (mossSampler *smplr) {
   static const char me[]="mossSamplerUpdate";
-  int ncol=0, fdiam=0;
+  unsigned int ncol=0, fdiam=0;
 
   if (!(smplr)) {
     biffAddf(MOSS, "%s: got NULL pointer", me);
@@ -86,7 +86,7 @@
     }
   }
   if (smplr->flag[mossFlagKernel]) {
-    fdiam = 2*AIR_ROUNDUP(smplr->kernel->support(smplr->kparm));
+    fdiam = 2*AIR_ROUNDUP_UI(smplr->kernel->support(smplr->kparm));
     if (fdiam != smplr->fdiam) {
       mossSamplerEmpty(smplr);
       smplr->fdiam = fdiam;
@@ -110,7 +110,7 @@
 int
 mossSamplerSample (float *val, mossSampler *smplr, double xPos, double yPos) {
   static const char me[]="mossSamplerSample";
-  int i, xi, yi, ci, sx, sy, fdiam, frad, ncol;
+  unsigned int i, xi, yi, ci, sx, sy, fdiam, frad, ncol;
   double xf, yf, tmp;
   float (*lup)(const void *v, size_t I);
 
@@ -129,8 +129,8 @@
   }
   sx = MOSS_SX(smplr->image);
   sy = MOSS_SY(smplr->image);
-  xi = (int)floor(xPos); xf = xPos - xi;
-  yi = (int)floor(yPos); yf = yPos - yi;
+  xi = AIR_ROUNDDOWN_UI(xPos); xf = xPos - xi;
+  yi = AIR_ROUNDDOWN_UI(yPos); yf = yPos - yi;
   fdiam = smplr->fdiam;
   frad = fdiam/2;
   for (i=0; i<fdiam; i++) {
@@ -216,7 +216,7 @@
       for (xi=0; xi<fdiam; xi++) {
         tmp += smplr->xFslw[xi]*smplr->ivc[xi + fdiam*(yi + fdiam*ci)];
       }
-      val[ci] += AIR_CAST(float, smplr->yFslw[yi]*tmp);
+      val[ci] += AIR_FLOAT(smplr->yFslw[yi]*tmp);
     }
   }
 
diff --color -ruN teem-1.11.0-src.orig/src/moss/sources.cmake teem-1.11.0-src/src/moss/sources.cmake
--- teem-1.11.0-src.orig/src/moss/sources.cmake	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/moss/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,13 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(MOSS_SOURCES
-  defaultsMoss.c
-  hestMoss.c
-  methodsMoss.c
-  moss.h
-  privateMoss.h
-  sampler.c
-  xform.c
-  )
-
-ADD_TEEM_LIBRARY(moss ${MOSS_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/moss/test/invert.c teem-1.11.0-src/src/moss/test/invert.c
--- teem-1.11.0-src.orig/src/moss/test/invert.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/moss/test/invert.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/moss/xform.c teem-1.11.0-src/src/moss/xform.c
--- teem-1.11.0-src.orig/src/moss/xform.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/moss/xform.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/names.pl teem-1.11.0-src/src/names.pl
--- teem-1.11.0-src.orig/src/names.pl	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/names.pl	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/accessors.c teem-1.11.0-src/src/nrrd/accessors.c
--- teem-1.11.0-src.orig/src/nrrd/accessors.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/accessors.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -226,11 +226,9 @@
 static int _nrrdSprintUL(char *s, const UL *v) {
   return sprintf(s, AIR_ULLONG_FMT, *v);
 }
-/* HEY: sizeof(float) and sizeof(double) assumed here, since we're
-   basing "8" and "17" on 6 == FLT_DIG and 15 == DBL_DIG, which are
-   digits of precision for floats and doubles, respectively */
 static int _nrrdSprintFL(char *s, const FL *v) {
-  return airSinglePrintf(NULL, s, "%.8g", (double)(*v)); }
+  /* having %.8g instead of %.9g was a roughly 20-year old bug */
+  return airSinglePrintf(NULL, s, "%.9g", (double)(*v)); }
 static int _nrrdSprintDB(char *s, const DB *v) {
   return airSinglePrintf(NULL, s, "%.17g", *v); }
 int (*
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/apply1D.c teem-1.11.0-src/src/nrrd/apply1D.c
--- teem-1.11.0-src.orig/src/nrrd/apply1D.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/apply1D.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -65,7 +65,7 @@
 
   ret = nmap->axis[mapAxis].max;
   if (!AIR_EXISTS(ret)) {
-    ret = AIR_CAST(double, nmap->axis[mapAxis].size);
+    ret = AIR_DOUBLE(nmap->axis[mapAxis].size);
     ret = ramps ? ret-1 : ret;
   }
   return ret;
@@ -156,14 +156,20 @@
       copyMapAxis0 = (1 == mapAxis);
       /* need to make sure the relevant sizes match */
       for (ax=0; ax<nin->dim; ax++) {
-        if (nin->axis[ax].size != nmap->axis[mapAxis + 1 + ax].size) {
+        unsigned int taxi = mapAxis + 1 + ax;
+        if (taxi > NRRD_DIM_MAX-1) {
+          biffAddf(NRRD, "%s: test axis index %u exceeds NRRD_DIM_MAX-1 %u",
+                   me, taxi, NRRD_DIM_MAX-1);
+          return 1;
+        }
+        if (nin->axis[ax].size != nmap->axis[taxi].size) {
           char stmp1[AIR_STRLEN_SMALL], stmp2[AIR_STRLEN_SMALL];
           biffAddf(NRRD, "%s: input and mmap don't have compatible sizes: "
                    "nin->axis[%d].size (%s) "
                    "!= nmap->axis[%d].size (%s): ", me,
                    ax, airSprintSize_t(stmp1, nin->axis[ax].size),
                    mapAxis + 1 + ax,
-                   airSprintSize_t(stmp2, nmap->axis[mapAxis + 1 + ax].size));
+                   airSprintSize_t(stmp2, nmap->axis[taxi].size));
           return 1;
         }
       }
@@ -180,7 +186,7 @@
                me, multi ? mnounStr[kind] : nounStr[kind]);
       return 1;
     }
-    entLen = mapAxis ? AIR_CAST(unsigned int, nmap->axis[0].size) : 1;
+    entLen = mapAxis ? AIR_UINT(nmap->axis[0].size) : 1;
   } else {
     if (multi) {
       biffAddf(NRRD, "%s: sorry, multi irregular maps not implemented", me);
@@ -194,7 +200,7 @@
     /* mapAxis has no meaning for irregular maps, but we'll pretend ... */
     mapAxis = nmap->axis[0].size == 2 ? 0 : 1;
     copyMapAxis0 = AIR_TRUE;
-    entLen = AIR_CAST(unsigned int, nmap->axis[0].size-1);
+    entLen = AIR_UINT(nmap->axis[0].size-1);
   }
   if (mapAxis + nin->dim > NRRD_DIM_MAX) {
     biffAddf(NRRD, "%s: input nrrd dim %d through non-scalar %s exceeds "
@@ -290,7 +296,7 @@
 int
 _nrrdApply1DLutOrRegMap(Nrrd *nout, const Nrrd *nin, const NrrdRange *range,
                         const Nrrd *nmap, int ramps, int rescale, int multi) {
-  /* static const char me[]="_nrrdApply1DLutOrRegMap"; */
+  static const char me[]="_nrrdApply1DLutOrRegMap";
   char *inData, *outData, *mapData, *entData0, *entData1;
   size_t N, I;
   double (*inLoad)(const void *v), (*mapLup)(const void *v, size_t I),
@@ -308,25 +314,30 @@
   domMin = _nrrdApplyDomainMin(nmap, ramps, mapAxis);
                                        /* high end of map domain */
   domMax = _nrrdApplyDomainMax(nmap, ramps, mapAxis);
-  mapLen = AIR_CAST(unsigned int, nmap->axis[mapAxis].size);   /* number of entries in map */
+  mapLen = AIR_UINT(nmap->axis[mapAxis].size);   /* number of entries in map */
   mapLup = nrrdDLookup[nmap->type];    /* how to get doubles out of map */
   inData = (char *)nin->data;          /* input data, as char* */
   inLoad = nrrdDLoad[nin->type];       /* how to get doubles out of nin */
-  inSize = AIR_CAST(unsigned int, nrrdElementSize(nin));       /* size of one input value */
+  inSize = AIR_UINT(nrrdElementSize(nin));       /* size of one input value */
   outData = (char *)nout->data;        /* output data, as char* */
   outInsert = nrrdDInsert[nout->type]; /* putting doubles into output */
   entLen = (mapAxis                    /* number of elements in one entry */
-            ? AIR_CAST(unsigned int, nmap->axis[0].size)
+            ? AIR_UINT(nmap->axis[0].size)
             : 1);
-  outSize = entLen*AIR_CAST(unsigned int, nrrdElementSize(nout)); /* size of entry in output */
-  entSize = entLen*AIR_CAST(unsigned int, nrrdElementSize(nmap)); /* size of entry in map */
+  if (ramps && !(mapLen >= 2)) {
+     biffAddf(NRRD, "%s: ramps need >= 2 control points (not %u) of %u vals",
+              me, mapLen, entLen);
+     return 1;
+  }
+  outSize = entLen*AIR_UINT(nrrdElementSize(nout)); /* size of entry in output */
+  entSize = entLen*AIR_UINT(nrrdElementSize(nmap)); /* size of entry in map */
 
   N = nrrdElementNumber(nin);       /* the number of values to be mapped */
   if (ramps) {
     /* regular map */
     for (I=0; I<N; I++) {
       /* ...
-      if (!(I % 100)) fprintf(stderr, "I = %d\n", (int)I);
+      fprintf(stderr, "I = %d\n", (int)I);
       ... */
       val = inLoad(inData);
       /* ...
@@ -610,8 +621,8 @@
              me, nmap->dim);
     return 1;
   }
-  entLen = AIR_CAST(unsigned int,nmap->axis[0].size);
-  mapLen = AIR_CAST(unsigned int,nmap->axis[1].size);
+  entLen = AIR_UINT(nmap->axis[0].size);
+  mapLen = AIR_UINT(nmap->axis[1].size);
   if (!( entLen >= 2 && mapLen >= 2 )) {
     biffAddf(NRRD, "%s: both map's axes sizes should be >= 2 (not %d,%d)",
              me, entLen, mapLen);
@@ -728,8 +739,8 @@
   if (baseIP) {
     *baseIP = baseI;
   }
-  entLen = AIR_CAST(unsigned int,nmap->axis[0].size);
-  posLen = AIR_CAST(unsigned int,nmap->axis[1].size) - baseI;
+  entLen = AIR_UINT(nmap->axis[0].size);
+  posLen = AIR_UINT(nmap->axis[1].size) - baseI;
   if (posLenP) {
     *posLenP = posLen;
   }
@@ -762,7 +773,7 @@
 ** pos[i] <= p <= pos[i+1] for the last interval (in which case
 ** i == hiI)
 */
-int
+static int
 _nrrd1DIrregFindInterval(const double *pos, double p, int loI, int hiI) {
   int midI;
 
@@ -842,8 +853,8 @@
   for (ii=0; ii<=aclLen-1; ii++) {
     lo = AIR_AFFINE(0, ii, aclLen, min, max);
     hi = AIR_AFFINE(0, ii+1, aclLen, min, max);
-    acl[0 + 2*ii] = _nrrd1DIrregFindInterval(pos, lo, 0, posLen-2);
-    acl[1 + 2*ii] = _nrrd1DIrregFindInterval(pos, hi, 0, posLen-2);
+    acl[0 + 2*ii] = AIR_USHORT(_nrrd1DIrregFindInterval(pos, lo, 0, posLen-2));
+    acl[1 + 2*ii] = AIR_USHORT(_nrrd1DIrregFindInterval(pos, hi, 0, posLen-2));
   }
   free(pos);
 
@@ -915,7 +926,7 @@
 
   if (nacl) {
     acl = (int *)nacl->data;
-    aclLen = AIR_CAST(unsigned int,nacl->axis[1].size);
+    aclLen = AIR_UINT(nacl->axis[1].size);
   } else {
     acl = NULL;
     aclLen = 0;
@@ -930,11 +941,11 @@
 
   inData = (char *)nin->data;
   inLoad = nrrdDLoad[nin->type];
-  inSize = AIR_CAST(unsigned int,nrrdElementSize(nin));
+  inSize = AIR_UINT(nrrdElementSize(nin));
   mapLup = nrrdDLookup[nmap->type];
-  entLen = AIR_CAST(unsigned int,nmap->axis[0].size);    /* entLen is really 1 + entry length */
-  entSize = entLen*AIR_CAST(unsigned int,nrrdElementSize(nmap));
-  colSize = (entLen-1)*AIR_CAST(unsigned int,nrrdTypeSize[typeOut]);
+  entLen = AIR_UINT(nmap->axis[0].size);    /* entLen is really 1 + entry length */
+  entSize = entLen*AIR_UINT(nrrdElementSize(nmap));
+  colSize = (entLen-1)*AIR_UINT(nrrdTypeSize[typeOut]);
   outData = (char *)nout->data;
   outInsert = nrrdDInsert[nout->type];
   domMin = pos[0];
@@ -1055,8 +1066,8 @@
   double (*ins)(void *, size_t, double);
   Nrrd *nsubst;
   double val, *subst;
-  size_t ii, num;
-  int jj, asize0, asize1, changed;
+  size_t ii, jj, num, asize0, asize1;
+  int changed;
   airArray *mop;
 
   if (!(nout && _nsubst && nin)) {
@@ -1073,10 +1084,12 @@
              me, _nsubst->dim);
     return 1;
   }
-  nrrdAxisInfoGet_va(_nsubst, nrrdAxisInfoSize, &asize0, &asize1);
+  /* nrrdAxisInfoGet_va(_nsubst, nrrdAxisInfoSize, &asize0, &asize1); */
+  asize0 = _nsubst->axis[0].size;
+  asize1 = _nsubst->axis[1].size;
   if (2 != asize0) {
-    biffAddf(NRRD, "%s: substitution table has to be 2xN, not %dxN",
-             me, asize0);
+    biffAddf(NRRD, "%s: substitution table has to be 2xN, not %uxN",
+             me, AIR_UINT(asize0));
     return 1;
   }
   if (nout != nin) {
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/apply2D.c teem-1.11.0-src/src/nrrd/apply2D.c
--- teem-1.11.0-src.orig/src/nrrd/apply2D.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/apply2D.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -121,7 +121,7 @@
              me, nounStr[kind]);
     return 1;
   }
-  entLen = mapAxis ? AIR_CAST(unsigned int, nmap->axis[0].size) : 1;
+  entLen = mapAxis ? AIR_UINT(nmap->axis[0].size) : 1;
   if (mapAxis + nin->dim - 1 > NRRD_DIM_MAX) {
     biffAddf(NRRD, "%s: input nrrd dim %d through non-scalar %s exceeds "
              "NRRD_DIM_MAX %d",
@@ -144,8 +144,8 @@
   fprintf(stderr, "   nout->dim = %u; nout->type = %d = %s; sizes = %u,%u\n",
           nout->dim, nout->type,
           airEnumStr(nrrdType, nout->type),
-          AIR_CAST(unsigned int, nout->axis[0].size),
-          AIR_CAST(unsigned int, nout->axis[1].size));
+          AIR_UINT(nout->axis[0].size),
+          AIR_UINT(nout->axis[1].size));
   fprintf(stderr, "   typeOut = %d = %s\n", typeOut,
           airEnumStr(nrrdType, typeOut));
   */
@@ -227,19 +227,19 @@
                                        /* high end of map domain */
   domMax0 = _nrrdApplyDomainMax(nmap, ramps, mapAxis + 0);
   domMax1 = _nrrdApplyDomainMax(nmap, ramps, mapAxis + 1);
-  mapLen0 = AIR_CAST(unsigned int, nmap->axis[mapAxis+0].size);   /* number of entries in map axis 0 */
-  mapLen1 = AIR_CAST(unsigned int, nmap->axis[mapAxis+1].size);   /* number of entries in map axis 1 */
+  mapLen0 = AIR_UINT(nmap->axis[mapAxis+0].size);   /* number of entries in map axis 0 */
+  mapLen1 = AIR_UINT(nmap->axis[mapAxis+1].size);   /* number of entries in map axis 1 */
   mapLup = nrrdDLookup[nmap->type];    /* how to get doubles out of map */
   inData = (char *)nin->data;          /* input data, as char* */
   inLoad = nrrdDLoad[nin->type];       /* how to get doubles out of nin */
-  inSize = AIR_CAST(unsigned int, nrrdElementSize(nin));       /* size of one input value */
+  inSize = AIR_UINT(nrrdElementSize(nin));       /* size of one input value */
   outData = (char *)nout->data;        /* output data, as char* */
   outInsert = nrrdDInsert[nout->type]; /* putting doubles into output */
   entLen = (mapAxis                    /* number of elements in one entry */
-            ? AIR_CAST(unsigned int, nmap->axis[0].size)
+            ? AIR_UINT(nmap->axis[0].size)
             : 1);
-  outSize = entLen*AIR_CAST(unsigned int, nrrdElementSize(nout)); /* size of entry in output */
-  entSize = entLen*AIR_CAST(unsigned int, nrrdElementSize(nmap)); /* size of entry in map */
+  outSize = entLen*AIR_UINT(nrrdElementSize(nout)); /* size of entry in output */
+  entSize = entLen*AIR_UINT(nrrdElementSize(nmap)); /* size of entry in map */
 
   /*
   fprintf(stderr, "!%s: entLen = %u, mapLen = %u,%u\n", me,
@@ -312,7 +312,7 @@
 
   if (!(nout && nlut && nin)) {
     biffAddf(NRRD, "%s: got NULL pointer (%p,%p,%p)", me,
-             AIR_CAST(void*,nout), AIR_CVOIDP(nlut), AIR_CVOIDP(nin));
+             AIR_VOIDP(nout), AIR_CVOIDP(nlut), AIR_CVOIDP(nin));
     return 1;
   }
   if (0 != domainAxis) {
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/arith.c teem-1.11.0-src/src/nrrd/arith.c
--- teem-1.11.0-src.orig/src/nrrd/arith.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/arith.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -24,6 +24,18 @@
 #include "nrrd.h"
 #include "privateNrrd.h"
 
+/* these two functions probably logically belong in dye, not nrrd, oh well.
+   The Teem 2.0 plan is to put all of dye inside nrrd, so that nrrd/unu
+   can do color-space conversions, which will be a big API change */
+double
+nrrdSRGBGamma(double val) {
+  return val <= 0.0031308 ? 12.92*val : 1.055*pow(val, 1/2.4) - 0.055;
+}
+double
+nrrdSRGBGammaInverse(double val) {
+  return val <= 0.04045 ? val/12.92 : pow((val + 0.055)/1.055, 2.4);
+}
+
 /*
 ******** nrrdArithGamma()
 **
@@ -38,7 +50,7 @@
 */
 int
 nrrdArithGamma(Nrrd *nout, const Nrrd *nin,
-               const NrrdRange *_range, double gamma) {
+               const NrrdRange *_range, double Gamma) {
   static const char me[]="nrrdArithGamma", func[]="gamma";
   double val, min, max;
   size_t I, num;
@@ -52,7 +64,7 @@
     biffAddf(NRRD, "%s: got NULL pointer", me);
     return 1;
   }
-  if (!( AIR_EXISTS(gamma) )) {
+  if (!( AIR_EXISTS(Gamma) )) {
     biffAddf(NRRD, "%s: gamma doesn't exist", me);
     return 1;
   }
@@ -83,14 +95,14 @@
   }
   lup = nrrdDLookup[nin->type];
   ins = nrrdDInsert[nout->type];
-  gamma = 1/gamma;
+  Gamma = 1/Gamma;
   num = nrrdElementNumber(nin);
-  if (gamma < 0.0) {
-    gamma = -gamma;
+  if (Gamma < 0.0) {
+    Gamma = -Gamma;
     for (I=0; I<num; I++) {
       val = lup(nin->data, I);
       val = AIR_AFFINE(min, val, max, 0.0, 1.0);
-      val = pow(val, gamma);
+      val = pow(val, Gamma);
       val = AIR_AFFINE(1.0, val, 0.0, min, max);
       ins(nout->data, I, val);
     }
@@ -98,12 +110,89 @@
     for (I=0; I<num; I++) {
       val = lup(nin->data, I);
       val = AIR_AFFINE(min, val, max, 0.0, 1.0);
-      val = pow(val, gamma);
+      val = pow(val, Gamma);
       val = AIR_AFFINE(0.0, val, 1.0, min, max);
       ins(nout->data, I, val);
     }
   }
-  if (nrrdContentSet_va(nout, func, nin, "%g,%g,%g", min, max, gamma)) {
+  if (nrrdContentSet_va(nout, func, nin, "%g,%g,%g", min, max, Gamma)) {
+    biffAddf(NRRD, "%s:", me);
+    airMopError(mop); return 1;
+  }
+  if (nout != nin) {
+    nrrdAxisInfoCopy(nout, nin, NULL, NRRD_AXIS_INFO_NONE);
+  }
+  /* basic info handled by nrrdCopy above */
+
+  airMopOkay(mop);
+  return 0;
+}
+
+/*
+******** nrrdArithSRGBGamma()
+**
+** (HEY lots of copy-paste from nrrdArithGamma); map the values in a nrrd
+** through either the ~2.2 gamma correction for sRGB (when "forward" is
+** non-zero), or its ~0.455 gamma inverse (when "forward" is zero).  Unlike
+** nrrdArithGamma, this is does not support inverting values.
+*/
+int
+nrrdArithSRGBGamma(Nrrd *nout, const Nrrd *nin,
+                   const NrrdRange *_range, int forward) {
+  static const char me[]="nrrdArithSRGBGamma", func[]="sRGBgamma";
+  double val, min, max;
+  size_t I, num;
+  NrrdRange *range;
+  airArray *mop;
+  double (*lup)(const void *, size_t);
+  double (*ins)(void *, size_t, double);
+
+  if (!(nout && nin)) {
+    /* _range can be NULL */
+    biffAddf(NRRD, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (!( nrrdTypeBlock != nin->type && nrrdTypeBlock != nout->type )) {
+    biffAddf(NRRD, "%s: can't deal with %s type", me,
+             airEnumStr(nrrdType, nrrdTypeBlock));
+    return 1;
+  }
+  if (nout != nin) {
+    if (nrrdCopy(nout, nin)) {
+      biffAddf(NRRD, "%s: couldn't initialize by copy to output", me);
+      return 1;
+    }
+  }
+  mop = airMopNew();
+  if (_range) {
+    range = nrrdRangeCopy(_range);
+    nrrdRangeSafeSet(range, nin, nrrdBlind8BitRangeState);
+  } else {
+    range = nrrdRangeNewSet(nin, nrrdBlind8BitRangeTrue);
+  }
+  airMopAdd(mop, range, (airMopper)nrrdRangeNix, airMopAlways);
+  min = range->min;
+  max = range->max;
+  if (min == max) {
+    /* this is stupid.  We want min < max to avoid making NaNs */
+    max += 1;
+  }
+  lup = nrrdDLookup[nin->type];
+  ins = nrrdDInsert[nout->type];
+  num = nrrdElementNumber(nin);
+  for (I=0; I<num; I++) {
+    val = lup(nin->data, I);
+    val = AIR_AFFINE(min, val, max, 0.0, 1.0);
+    if (forward) {
+      val = nrrdSRGBGamma(val);
+    } else {
+      val = nrrdSRGBGammaInverse(val);
+    }
+    val = AIR_AFFINE(0.0, val, 1.0, min, max);
+    ins(nout->data, I, val);
+  }
+  if (nrrdContentSet_va(nout, func, nin, "%g,%g,%s", min, max,
+                        forward ? "forw" : "back")) {
     biffAddf(NRRD, "%s:", me);
     airMopError(mop); return 1;
   }
@@ -198,6 +287,8 @@
   AIR_UNUSED(a);
   return 1.0;
 }
+static double _nrrdUnaryOpTauOfSigma(double s) { return airTauOfSigma(s); }
+static double _nrrdUnaryOpSigmaOfTau(double t) { return airSigmaOfTau(t); }
 
 double (*_nrrdUnaryOp[NRRD_UNARY_OP_MAX+1])(double) = {
   NULL,
@@ -230,7 +321,9 @@
   _nrrdUnaryOpNormalRand,
   _nrrdUnaryOpIf,
   _nrrdUnaryOpZero,
-  _nrrdUnaryOpOne
+  _nrrdUnaryOpOne,
+  _nrrdUnaryOpTauOfSigma,
+  _nrrdUnaryOpSigmaOfTau
 };
 
 int
@@ -344,7 +437,11 @@
   _nrrdBinaryOpExists,
   _nrrdBinaryOpIf,
   _nrrdBinaryOpNormalRandScaleAdd,
-  _nrrdBinaryOpRicianRand
+  _nrrdBinaryOpRicianRand,
+  /* for these, the clamping is actually done by the caller */
+  _nrrdBinaryOpAdd, /* for nrrdBinaryOpAddClamp */
+  _nrrdBinaryOpSubtract, /* for nrrdBinaryOpSubtractClamp */
+  _nrrdBinaryOpMultiply, /* for nrrdBinaryOpMultiplyClamp */
 };
 
 /*
@@ -359,7 +456,7 @@
   static const char me[]="nrrdArithBinaryOp";
   char *contA, *contB;
   size_t N, I, size[NRRD_DIM_MAX];
-  double (*ins)(void *v, size_t I, double d),
+  double (*ins)(void *v, size_t I, double d), (*clmp)(double d),
     (*lupA)(const void *v, size_t I), (*lupB)(const void *v, size_t I),
     (*bop)(double a, double b), valA, valB;
 
@@ -410,11 +507,23 @@
   lupA = nrrdDLookup[ninA->type];
   lupB = nrrdDLookup[ninB->type];
   ins = nrrdDInsert[nout->type];
+  if (nrrdBinaryOpAddClamp == op
+      || nrrdBinaryOpSubtractClamp == op
+      || nrrdBinaryOpMultiplyClamp == op) {
+    clmp = nrrdDClamp[nout->type];
+  } else {
+    clmp = NULL;
+  }
   for (I=0; I<N; I++) {
+    double tmp;
     /* HEY: there is a loss of precision issue here with 64-bit ints */
     valA = lupA(ninA->data, I);
     valB = lupB(ninB->data, I);
-    ins(nout->data, I, bop(valA, valB));
+    tmp = bop(valA, valB);
+    if (clmp) {
+      tmp = clmp(tmp);
+    }
+    ins(nout->data, I, tmp);
   }
 
   contA = _nrrdContentGet(ninA);
@@ -437,7 +546,7 @@
   char *contA, *contB;
   size_t N, I, size[NRRD_DIM_MAX];
   int type;
-  double (*insert)(void *v, size_t I, double d),
+  double (*insert)(void *v, size_t I, double d), (*clmp)(double d),
     (*bop)(double a, double b), valA, valB;
   const Nrrd *nin;
 
@@ -487,11 +596,23 @@
   */
   N = nrrdElementNumber(nin);
   insert = nrrdDInsert[type];
+  if (nrrdBinaryOpAddClamp == op
+      || nrrdBinaryOpSubtractClamp == op
+      || nrrdBinaryOpMultiplyClamp == op) {
+    clmp = nrrdDClamp[nout->type];
+  } else {
+    clmp = NULL;
+  }
   for (I=0; I<N; I++) {
+    double tmp;
     /* HEY: there is a loss of precision issue here with 64-bit ints */
     valA = nrrdIterValue(inA);
     valB = nrrdIterValue(inB);
-    insert(nout->data, I, bop(valA, valB));
+    tmp = bop(valA, valB);
+    if (clmp) {
+      tmp = clmp(tmp);
+    }
+    insert(nout->data, I, tmp);
   }
   contA = nrrdIterContent(inA);
   contB = nrrdIterContent(inB);
@@ -848,7 +969,7 @@
   static const char me[]="nrrdArithAffine";
   size_t I, N;
   double (*ins)(void *v, size_t I, double d),
-    (*lup)(const void *v, size_t I);
+    (*lup)(const void *v, size_t I), mmin, mmax;
 
   if ( !nout || nrrdCheck(nin) ) {
     biffAddf(NRRD, "%s: got NULL pointer or invalid input", me);
@@ -863,12 +984,14 @@
   N = nrrdElementNumber(nin);
   ins = nrrdDInsert[nout->type];
   lup = nrrdDLookup[nin->type];
+  mmin = AIR_MIN(minOut, maxOut);
+  mmax = AIR_MAX(minOut, maxOut);
   for (I=0; I<N; I++) {
     double val;
     val = lup(nin->data, I);
     val = AIR_AFFINE(minIn, val, maxIn, minOut, maxOut);
     if (clamp) {
-      val = AIR_CLAMP(minOut, val, maxOut);
+      val = AIR_CLAMP(mmin, val, mmax);
     }
     ins(nout->data, I, val);
   }
@@ -925,7 +1048,9 @@
     maxo = nrrdIterValue(maxOut);
     vout = AIR_AFFINE(mini, vin, maxi, mino, maxo);
     if (clamp) {
-      vout = AIR_CLAMP(mino, vout, maxo);
+      double mmin = AIR_MIN(mino, maxo);
+      double mmax = AIR_MAX(mino, maxo);
+      vout = AIR_CLAMP(mmin, vout, mmax);
     }
     ins(nout->data, I, vout);
   }
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/arraysNrrd.c teem-1.11.0-src/src/nrrd/arraysNrrd.c
--- teem-1.11.0-src.orig/src/nrrd/arraysNrrd.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/arraysNrrd.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -235,8 +235,12 @@
   1, /* nrrdField_comment */
   1, /* nrrdField_content */
   0, /* nrrdField_number */
-  0, /* nrrdField_type: decided AGAINST plain text holding general type
-        (but I forget why ...) */
+  1, /* nrrdField_type: after revision 6359 (2019 T-day @ Hyatt Lost Pines),
+        decided that long-standing but unnecessary restriction of plain text
+        files only holding float (and not, say, double) had to go; hence the
+        new nio->moreThanFloatInText.  With that, this value changed from 0
+        to 1. However, nio->moreThanFloatInText defaults to false (i.e. only
+        float in text), so this should not be disruptive. */
   0, /* nrrdField_block_size */
   1, /* nrrdField_dimension: but can only be 1 or 2 */
   0, /* nrrdField_space */
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/axis.c teem-1.11.0-src/src/nrrd/axis.c
--- teem-1.11.0-src.orig/src/nrrd/axis.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/axis.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -763,7 +763,8 @@
   double min, max, tmp;
 
   if (!( loP && hiP && nrrd && ax <= nrrd->dim-1 )) {
-    *loP = *hiP = AIR_NAN;
+    if (loP) *loP = AIR_NAN;
+    if (hiP) *hiP = AIR_NAN;
     return;
   }
   center = _nrrdCenter(nrrd->axis[ax].center);
@@ -1016,9 +1017,18 @@
   *differ = airStrcmp(axisA->label, axisB->label);
   if (*differ) {
     if (explain) {
-      /* can't print whole string because of fixed-size of explain */
+      /* can't safely print whole labels because of fixed-size of explain */
       sprintf(explain, "axisA->label %s axisB->label",
               *differ < 0 ? "<" : ">");
+      if (strlen(explain) + airStrlen(axisA->label)
+          + airStrlen(axisB->label)
+          + 2*strlen(" \"\" ") + 1 < AIR_STRLEN_LARGE) {
+        /* ok, we can print them */
+        sprintf(explain, "axisA->label \"%s\" %s axisB->label \"%s\"",
+                axisA->label ? axisA->label : "",
+                *differ < 0 ? "<" : ">",
+                axisB->label ? axisB->label : "");
+      }
     }
     return 0;
   }
@@ -1246,7 +1256,7 @@
   NrrdAxisInfo *axis;
 
   if (!(nout && nin)) {
-    biffAddf(NRRD, "%s: got NULL spacing", me);
+    biffAddf(NRRD, "%s: got NULL pointer", me);
     return 1;
   }
 
@@ -1276,3 +1286,357 @@
   return 0;
 }
 
+/* ---- BEGIN non-NrrdIO */
+
+/*
+******** nrrdMetaData
+**
+** The brains of "unu dnorm" (for Diderot normalization): put all meta-data
+** of a nrrd into some simpler canonical form.
+**
+** This function probably doesn't belong in this file, but it is kind
+** the opposite of nrrdOrientationReduce (above), so here it is
+*/
+int
+nrrdMetaDataNormalize(Nrrd *nout, const Nrrd *nin,
+                      int version,
+                      int trivialOrient,
+                      int permuteComponentAxisFastest,
+                      int recenterGrid,
+                      double sampleSpacing,
+                      int *lostMeasurementFrame) {
+  static const char me[]="nrrdMetaDataNormalize";
+  size_t size[NRRD_DIM_MAX];
+  int kindIn, kindOut, haveMM, gotmf;
+  unsigned int kindAxis, axi, si, sj;
+  Nrrd *ntmp;
+  airArray *mop;
+
+  if (!(nout && nin)) {
+    biffAddf(NRRD, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (airEnumValCheck(nrrdMetaDataCanonicalVersion, version)) {
+    biffAddf(NRRD, "%s: version %d not valid %s", me,
+             version, nrrdMetaDataCanonicalVersion->name);
+    return 1;
+  }
+  if (nrrdMetaDataCanonicalVersionAlpha != version) {
+    biffAddf(NRRD, "%s: sorry, %s %s not implemented (only %s)", me,
+             nrrdMetaDataCanonicalVersion->name,
+             airEnumStr(nrrdMetaDataCanonicalVersion, version),
+             airEnumStr(nrrdMetaDataCanonicalVersion,
+                        nrrdMetaDataCanonicalVersionAlpha));
+    return 1;
+  }
+
+  if (_nrrdCheck(nin, AIR_FALSE /* checkData */, AIR_TRUE /* useBiff */)) {
+    biffAddf(NRRD, "%s: basic check failed", me);
+    return 1;
+  }
+  /* but can't deal with block type */
+  if (nrrdTypeBlock == nin->type) {
+    biffAddf(NRRD, "%s: can only have scalar types (not %s)", me,
+             airEnumStr(nrrdType, nrrdTypeBlock));
+    return 1;
+  }
+
+  /* look at all per-axis kinds */
+  /* see if there's a range kind, verify that there's only one */
+  /* set haveMM */
+  haveMM = AIR_TRUE;
+  kindIn = nrrdKindUnknown;
+  kindAxis = 0; /* only means something if kindIn != nrrdKindUnknown */
+  for (axi=0; axi<nin->dim; axi++) {
+    if (nrrdKindUnknown == nin->axis[axi].kind
+        || nrrdKindIsDomain(nin->axis[axi].kind)) {
+      haveMM &= AIR_EXISTS(nin->axis[axi].min);
+      haveMM &= AIR_EXISTS(nin->axis[axi].max);
+    } else {
+      if (nrrdKindUnknown != kindIn) {
+        biffAddf(NRRD, "%s: got non-domain kind %s on axis %u, but already "
+                 "have kind %s on previous axis %u", me,
+                 airEnumStr(nrrdKind, nin->axis[axi].kind), axi,
+                 airEnumStr(nrrdKind, kindIn), kindAxis);
+        return 1;
+      }
+      kindIn = nin->axis[axi].kind;
+      kindAxis = axi;
+    }
+  }
+
+  if (nrrdKindUnknown != kindIn && kindAxis) {
+    /* have a non-domain axis, and it isn't the fastest */
+    if (permuteComponentAxisFastest) {
+      if (nout == nin) {
+        biffAddf(NRRD, "%s: can't permute non-domain axis %u (kind %s) "
+                 "to axis 0 with nout == nin", me,
+                 kindAxis, airEnumStr(nrrdKind, kindIn));
+        return 1;
+      }
+      biffAddf(NRRD, "%s: sorry, permuting non-domain axis %u (kind %s) "
+               "to axis 0 not yet implemented", me,
+               kindAxis, airEnumStr(nrrdKind, kindIn));
+      return 1;
+    } else {
+      /* caller thinks its okay for non-domain axis to be on
+         something other than fastest axis */
+      if (nrrdMetaDataCanonicalVersionAlpha == version) {
+        biffAddf(NRRD, "%s: (%s) non-domain axis %u (kind %s) "
+                 "must be fastest axis", me,
+                 airEnumStr(nrrdMetaDataCanonicalVersion, version),
+                 kindAxis, airEnumStr(nrrdKind, kindIn));
+        return 1;
+      }
+      /* maybe with nrrdMetaDataCanonicalVersionAlpha != version
+         it is okay to have non-domain axis on non-fastest axis? */
+    }
+  }
+
+  /* HEY: would be nice to handle a stub "scalar" axis by deleting it */
+
+  /* see if the non-domain kind is something we can interpret as a tensor */
+  if (nrrdKindUnknown != kindIn) {
+    switch (kindIn) {
+      /* ======= THESE are the kinds that we can possibly output ======= */
+    case nrrdKind2Vector:
+    case nrrdKind3Vector:
+    case nrrdKind4Vector:
+    case nrrdKind2DSymMatrix:
+    case nrrdKind2DMatrix:
+    case nrrdKind3DSymMatrix:
+    case nrrdKind3DMatrix:
+      /* =============================================================== */
+      kindOut = kindIn;
+      break;
+      /* Some other kinds are mapped to those above */
+    case nrrdKind3Color:
+    case nrrdKindRGBColor:
+      kindOut = nrrdKind3Vector;
+      break;
+    case nrrdKind4Color:
+    case nrrdKindRGBAColor:
+      kindOut = nrrdKind4Vector;
+      break;
+    default:
+      biffAddf(NRRD, "%s: got non-conforming kind %s on axis %u", me,
+               airEnumStr(nrrdKind, kindIn), kindAxis);
+      return 1;
+    }
+  } else {
+    /* kindIn is nrrdKindUnknown, so its a simple scalar image,
+       and that's what the output will be too; kindOut == nrrdKindUnknown
+       is used in the code below to say "its a scalar image" */
+    kindOut = nrrdKindUnknown;
+  }
+
+  /* initialize output by copying meta-data from nin to ntmp */
+  mop = airMopNew();
+  ntmp = nrrdNew();
+  airMopAdd(mop, ntmp, (airMopper)nrrdNix, airMopAlways);
+  /* HEY this is doing the work of a shallow copy, which isn't
+     available in the API.  You can pass nrrdCopy() a nin with NULL
+     nin->data, which implements a shallow copy, but we can't set
+     nin->data=NULL here because of const correctness */
+  nrrdAxisInfoGet_nva(nin, nrrdAxisInfoSize, size);
+  if (nrrdWrap_nva(ntmp, NULL, nin->type, nin->dim, size)) {
+    biffAddf(NRRD, "%s: couldn't wrap buffer nrrd around NULL", me);
+    airMopError(mop); return 1;
+  }
+  /* so ntmp->data == NULL */
+  nrrdAxisInfoCopy(ntmp, nin, NULL, NRRD_AXIS_INFO_SIZE_BIT);
+  if (nrrdBasicInfoCopy(ntmp, nin, NRRD_BASIC_INFO_DATA_BIT)) {
+    biffAddf(NRRD, "%s: trouble copying basic info", me);
+    airMopError(mop); return 1;
+  }
+
+  /* no comments */
+  nrrdCommentClear(ntmp);
+
+  /* no measurement frame */
+  gotmf = AIR_FALSE;
+  for (si=0; si<NRRD_SPACE_DIM_MAX; si++) {
+    for (sj=0; sj<NRRD_SPACE_DIM_MAX; sj++) {
+      gotmf |= AIR_EXISTS(ntmp->measurementFrame[si][sj]);
+    }
+  }
+  if (lostMeasurementFrame) {
+    *lostMeasurementFrame = gotmf;
+  }
+  for (si=0; si<NRRD_SPACE_DIM_MAX; si++) {
+    for (sj=0; sj<NRRD_SPACE_DIM_MAX; sj++) {
+      ntmp->measurementFrame[si][sj] = AIR_NAN;
+    }
+  }
+
+  /* no key/value pairs */
+  nrrdKeyValueClear(ntmp);
+
+  /* no content field */
+  ntmp->content = airFree(ntmp->content);
+
+  /* normalize domain kinds to "space" */
+  /* HEY: if Diderot supports time-varying fields, this will have to change */
+  /* turn off centers (current Diderot semantics don't expose centering) */
+  /* turn off thickness */
+  /* turn off labels and units */
+  for (axi=0; axi<ntmp->dim; axi++) {
+    if (nrrdKindUnknown == kindOut) {
+      ntmp->axis[axi].kind = nrrdKindSpace;
+    } else {
+      ntmp->axis[axi].kind = (kindAxis == axi
+                              ? kindOut
+                              : nrrdKindSpace);
+    }
+    ntmp->axis[axi].center = nrrdCenterUnknown;
+    ntmp->axis[axi].thickness = AIR_NAN;
+    ntmp->axis[axi].label = airFree(ntmp->axis[axi].label);
+    ntmp->axis[axi].units = airFree(ntmp->axis[axi].units);
+    ntmp->axis[axi].min = AIR_NAN;
+    ntmp->axis[axi].max = AIR_NAN;
+    ntmp->axis[axi].spacing = AIR_NAN;
+  }
+
+  /* logic of orientation definition:
+     If space dimension is known:
+        set origin to zero if not already set
+        set space direction to unit vector if not already set
+     Else if have per-axis min and max:
+        set spae origin and directions to communicate same intent
+        as original per-axis min and max and original centering
+     Else
+        set origin to zero and all space directions to units.
+     (It might be nice to use gage's logic for mapping from world to index,
+     but we have to accept a greater variety of kinds and dimensions
+     than gage ever has to process.)
+     The result is that space origin and space directions are set.
+     the "space" field is not used, only "spaceDim"
+  */
+  /* no named space */
+  ntmp->space = nrrdSpaceUnknown;
+  if (ntmp->spaceDim && !trivialOrient) {
+    int saxi = 0;
+    if (!nrrdSpaceVecExists(ntmp->spaceDim, ntmp->spaceOrigin)) {
+      nrrdSpaceVecSetZero(ntmp->spaceOrigin);
+    }
+    for (axi=0; axi<ntmp->dim; axi++) {
+      if (nrrdKindUnknown == kindOut || kindAxis != axi) {
+        /* its a domain axis of output */
+        if (!nrrdSpaceVecExists(ntmp->spaceDim,
+                                ntmp->axis[axi].spaceDirection)) {
+          nrrdSpaceVecSetZero(ntmp->axis[axi].spaceDirection);
+          ntmp->axis[axi].spaceDirection[saxi] = sampleSpacing;
+        }
+        /* else we leave existing space vector as is */
+        saxi++;
+      } else {
+        /* else its a range (non-domain, component) axis */
+        nrrdSpaceVecSetNaN(ntmp->axis[axi].spaceDirection);
+      }
+    }
+  } else if (haveMM && !trivialOrient) {
+    int saxi = 0;
+    size_t N;
+    double rng;
+    for (axi=0; axi<ntmp->dim; axi++) {
+      if (nrrdKindUnknown == kindOut || kindAxis != axi) {
+        /* its a domain axis of output */
+        nrrdSpaceVecSetZero(ntmp->axis[axi].spaceDirection);
+        rng = nin->axis[axi].max - nin->axis[axi].min;
+        if (nrrdCenterNode == nin->axis[axi].center) {
+          ntmp->spaceOrigin[saxi] = nin->axis[axi].min;
+          N = nin->axis[axi].size;
+          ntmp->axis[axi].spaceDirection[saxi] = rng/(N-1);
+        } else {
+          /* unknown centering treated as cell */
+          N = nin->axis[axi].size;
+          ntmp->spaceOrigin[saxi] = nin->axis[axi].min + (rng/N)/2;
+          ntmp->axis[axi].spaceDirection[saxi] = rng/N;
+        }
+        saxi++;
+      } else {
+        /* else its a range axis */
+        nrrdSpaceVecSetNaN(ntmp->axis[axi].spaceDirection);
+      }
+    }
+    ntmp->spaceDim = saxi;
+  } else {
+    /* either trivialOrient, or, not spaceDim and not haveMM */
+    int saxi = 0;
+    nrrdSpaceVecSetZero(ntmp->spaceOrigin);
+    for (axi=0; axi<ntmp->dim; axi++) {
+      if (nrrdKindUnknown == kindOut || kindAxis != axi) {
+        /* its a domain axis of output */
+        nrrdSpaceVecSetZero(ntmp->axis[axi].spaceDirection);
+        ntmp->axis[axi].spaceDirection[saxi]
+          = (AIR_EXISTS(nin->axis[axi].spacing)
+             ? nin->axis[axi].spacing
+             : sampleSpacing);
+        saxi++;
+      } else {
+        /* else its a range axis */
+        nrrdSpaceVecSetNaN(ntmp->axis[axi].spaceDirection);
+      }
+    }
+    ntmp->spaceDim = saxi;
+  }
+
+  /* space dimension has to match the number of domain axes */
+  if (ntmp->dim != ntmp->spaceDim + !!kindOut) {
+    biffAddf(NRRD, "%s: output dim %d != spaceDim %d + %d %s%s%s%s",
+             me, ntmp->dim, ntmp->spaceDim, !!kindOut,
+             kindOut ? "for non-scalar (" : "(scalar data)",
+             kindOut ? airEnumStr(nrrdKind, kindOut) : "",
+             kindOut ? ") data" : "",
+             kindOut ? "" : "; a non-domain axis in the input "
+             "may be missing an informative \"kind\", leading to the "
+             "false assumption of a scalar array");
+    airMopError(mop); return 1;
+  }
+
+  if (recenterGrid) {
+    /* sets field's origin so field is centered on the origin. capiche? */
+    /* this code was tacked on later than the stuff above, so its
+       logic could probably be moved up there, but it seems cleaner to
+       have it as a separate post-process */
+    double mean[NRRD_SPACE_DIM_MAX];
+    nrrdSpaceVecSetZero(mean);
+    for (axi=0; axi<ntmp->dim; axi++) {
+      if (nrrdKindUnknown == kindOut || kindAxis != axi) {
+        nrrdSpaceVecScaleAdd2(mean, 1.0, mean,
+                              0.5*(ntmp->axis[axi].size - 1),
+                              ntmp->axis[axi].spaceDirection);
+      }
+    }
+    nrrdSpaceVecScaleAdd2(mean, 1.0, mean,
+                          1.0, ntmp->spaceOrigin);
+    /* now mean is the center of the field */
+    nrrdSpaceVecScaleAdd2(ntmp->spaceOrigin,
+                          1.0, ntmp->spaceOrigin,
+                          -1.0, mean);
+  }
+
+  /* with that all done, now copy from ntmp to nout */
+  if (nout != nin) {
+    /* have to copy data */
+    ntmp->data = nin->data;
+    if (nrrdCopy(nout, ntmp)) {
+      biffAddf(NRRD, "%s: problem copying (with data) to output", me);
+      airMopError(mop); return 1;
+    }
+  } else {
+    /* nout == nin; have to copy only meta-data, leave data as is */
+    void *data = nin->data;
+    /* ntmp->data == NULL, so this is a shallow copy */
+    if (nrrdCopy(nout, ntmp)) {
+      biffAddf(NRRD, "%s: problem copying meta-data to output", me);
+      airMopError(mop); return 1;
+    }
+    nout->data = data;
+  }
+
+  airMopOkay(mop);
+  return 0;
+}
+
+/* ---- END non-NrrdIO */
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/bsplKernel.c teem-1.11.0-src/src/nrrd/bsplKernel.c
--- teem-1.11.0-src.orig/src/nrrd/bsplKernel.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/bsplKernel.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -441,7 +441,7 @@
 }
 
 #define BSPL3_ANI(ret, tmp, x)                  \
-  tmp = AIR_CAST(unsigned int, x+0.5);          \
+  tmp = AIR_UINT(x+0.5);                        \
   if (tmp < BSPL3_AI_LEN) {                     \
     ret = _bspl3_ANI_kvals[tmp];                \
   } else {                                      \
@@ -465,7 +465,7 @@
 
   ax = AIR_ABS(x);
   BSPL3_ANI(r, tmp, ax);
-  return AIR_CAST(float, r);
+  return AIR_FLOAT(r);
 }
 
 static void
@@ -490,7 +490,7 @@
   for (i=0; i<len; i++) {
     ax = x[i]; ax = AIR_ABS(ax);
     BSPL3_ANI(r, tmp, ax);
-    f[i] = AIR_CAST(float, r);
+    f[i] = AIR_FLOAT(r);
   }
 }
 
@@ -754,7 +754,7 @@
 }
 
 #define BSPL5_ANI_T(ret, TT, tmp, x)            \
-  tmp = AIR_CAST(unsigned int, x+0.5);          \
+  tmp = AIR_UINT(x+0.5);                        \
   if (tmp < BSPL5_AI_LEN) {                     \
     ret = AIR_CAST(TT, _bspl5_ANI_kvals[tmp]);  \
   } else {                                      \
@@ -778,7 +778,7 @@
 
   ax = AIR_ABS(x);
   BSPL5_ANI_T(r, float, tmp, ax);
-  return AIR_CAST(float, r);
+  return AIR_FLOAT(r);
 }
 
 static void
@@ -803,7 +803,7 @@
   for (i=0; i<len; i++) {
     ax = x[i]; ax = AIR_ABS(ax);
     BSPL5_ANI_T(r, float, tmp, ax);
-    f[i] = AIR_CAST(float, r);
+    f[i] = AIR_FLOAT(r);
   }
 }
 
@@ -1095,7 +1095,7 @@
 }
 
 #define BSPL7_ANI(ret, tmp, x)                  \
-  tmp = AIR_CAST(unsigned int, x+0.5);          \
+  tmp = AIR_UINT(x+0.5);                        \
   if (tmp < BSPL7_AI_LEN) {                     \
     ret = _bspl7_ANI_kvals[tmp];                \
   } else {                                      \
@@ -1119,7 +1119,7 @@
 
   ax = AIR_ABS(x);
   BSPL7_ANI(r, tmp, ax);
-  return AIR_CAST(float, r);
+  return AIR_FLOAT(r);
 }
 
 static void
@@ -1144,7 +1144,7 @@
   for (i=0; i<len; i++) {
     ax = x[i]; ax = AIR_ABS(ax);
     BSPL7_ANI(r, tmp, ax);
-    f[i] = AIR_CAST(float, r);
+    f[i] = AIR_FLOAT(r);
   }
 }
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/cc.c teem-1.11.0-src/src/nrrd/cc.c
--- teem-1.11.0-src.orig/src/nrrd/cc.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/cc.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -47,7 +47,7 @@
   out[0] = id = 0;
   *numid = 1;
 
-  sx = AIR_CAST(unsigned int, nin->axis[0].size);
+  sx = AIR_UINT(nin->axis[0].size);
   lval = lup(nin->data, 0);
   for (I=1; I<sx; I++) {
     val = lup(nin->data, I);
@@ -82,8 +82,8 @@
   id = 0; /* sssh! compiler warnings */
   lup = nrrdUILookup[nin->type];
   out = AIR_CAST(unsigned int*, nout->data);
-  sx = AIR_CAST(unsigned int, nin->axis[0].size);
-  sy = AIR_CAST(unsigned int, nin->axis[1].size);
+  sx = AIR_UINT(nin->axis[0].size);
+  sy = AIR_UINT(nin->axis[1].size);
 #define GETV_2(x,y) ((AIR_IN_CL(0, AIR_CAST(int, x), AIR_CAST(int, sx-1))     \
                       && AIR_IN_CL(0, AIR_CAST(int, y), AIR_CAST(int, sy-1))) \
                      ? lup(nin->data, (x) + sx*(y)) \
@@ -91,7 +91,7 @@
 #define GETI_2(x,y) ((AIR_IN_CL(0, AIR_CAST(int, x), AIR_CAST(int, sx-1))     \
                       && AIR_IN_CL(0, AIR_CAST(int, y), AIR_CAST(int, sy-1))) \
                      ? out[(x) + sx*(y)] \
-                     : AIR_CAST(unsigned int, -1))  /* CC index (probably!)
+                     : AIR_UINT(-1))  /* CC index (probably!)
                                                        never assigned */
 
   *numid = 0;
@@ -174,9 +174,9 @@
   id = 0; /* sssh! compiler warnings */
   lup = nrrdUILookup[nin->type];
   out = AIR_CAST(unsigned int*, nout->data);
-  sx = AIR_CAST(unsigned int, nin->axis[0].size);
-  sy = AIR_CAST(unsigned int, nin->axis[1].size);
-  sz = AIR_CAST(unsigned int, nin->axis[2].size);
+  sx = AIR_UINT(nin->axis[0].size);
+  sy = AIR_UINT(nin->axis[1].size);
+  sz = AIR_UINT(nin->axis[2].size);
 #define GETV_3(x,y,z) ((AIR_IN_CL(0, AIR_CAST(int, x), AIR_CAST(int, sx-1))   \
                        && AIR_IN_CL(0, AIR_CAST(int, y), AIR_CAST(int, sy-1)) \
                        && AIR_IN_CL(0, AIR_CAST(int, z), AIR_CAST(int, sz-1)))\
@@ -186,7 +186,7 @@
                        && AIR_IN_CL(0, AIR_CAST(int, y), AIR_CAST(int, sy-1)) \
                        && AIR_IN_CL(0, AIR_CAST(int, z), AIR_CAST(int, sz-1)))\
                        ? out[(x) + sx*((y) + sy*(z))]                         \
-                       : AIR_CAST(unsigned int, -1))
+                       : AIR_UINT(-1))
 
   *numid = 0;
   for (z=0; z<sz; z++) {
@@ -434,8 +434,8 @@
   double pid[5]={0,0,0,0,0};
 
   lup = nrrdUILookup[nin->type];
-  sx = AIR_CAST(unsigned int, nin->axis[0].size);
-  sy = AIR_CAST(unsigned int, nin->axis[1].size);
+  sx = AIR_UINT(nin->axis[0].size);
+  sy = AIR_UINT(nin->axis[1].size);
   for (y=0; y<sy; y++) {
     for (x=0; x<sx; x++) {
       if (!x) {
@@ -448,11 +448,11 @@
         pid[3] = pid[4];
       }
       pid[4] = GETV_2(x+1, y-1);
-      id = AIR_CAST(unsigned int, GETV_2(x, y));
+      id = AIR_UINT(GETV_2(x, y));
 #define TADJ(P) \
       if (pid[(P)] != 0.5 && id != pid[(P)]) { \
-        out[id + numid*AIR_CAST(unsigned int, pid[(P)])] = \
-          out[AIR_CAST(unsigned int, pid[(P)]) + numid*id] = 1; \
+        out[id + numid*AIR_UINT(pid[(P)])] = \
+          out[AIR_UINT(pid[(P)]) + numid*id] = 1; \
       }
       TADJ(1);
       TADJ(3);
@@ -473,9 +473,9 @@
   double pid[14]={0,0,0,0,0,0,0,0,0,0,0,0,0,0};
 
   lup = nrrdUILookup[nin->type];
-  sx = AIR_CAST(unsigned int, nin->axis[0].size);
-  sy = AIR_CAST(unsigned int, nin->axis[1].size);
-  sz = AIR_CAST(unsigned int, nin->axis[2].size);
+  sx = AIR_UINT(nin->axis[0].size);
+  sy = AIR_UINT(nin->axis[1].size);
+  sz = AIR_UINT(nin->axis[2].size);
   for (z=0; z<sz; z++) {
     for (y=0; y<sy; y++) {
       for (x=0; x<sx; x++) {
@@ -504,7 +504,7 @@
         pid[ 7] = GETV_3(x+1, y-1, z-1);
         pid[10] = GETV_3(x+1,   y, z-1);
         pid[13] = GETV_3(x+1, y+1, z-1);
-        id = AIR_CAST(unsigned int, GETV_3(x, y, z));
+        id = AIR_UINT(GETV_3(x, y, z));
         TADJ(1);
         TADJ(3);
         TADJ(9);
@@ -683,7 +683,7 @@
   size = (unsigned int*)(nsize->data);
   adj = (unsigned char*)(nadj->data);
   nn = (unsigned int*)(nnn->data);
-  numid = AIR_CAST(unsigned int, nsize->axis[0].size);
+  numid = AIR_UINT(nsize->axis[0].size);
   for (i=0; i<numid; i++) {
     nn[i] = 0;
     for (j=0; j<numid; j++) {
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/ccmethods.c teem-1.11.0-src/src/nrrd/ccmethods.c
--- teem-1.11.0-src.orig/src/nrrd/ccmethods.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/ccmethods.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/CMakeLists.txt teem-1.11.0-src/src/nrrd/CMakeLists.txt
--- teem-1.11.0-src.orig/src/nrrd/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/CMakeLists.txt	2021-02-18 15:42:33.000000000 +0800
@@ -0,0 +1,65 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(NRRD_SOURCES
+  accessors.c
+  apply1D.c
+  apply2D.c
+  arith.c
+  arraysNrrd.c
+  axis.c
+  cc.c
+  ccmethods.c
+  comment.c
+  convertNrrd.c
+  defaultsNrrd.c
+  deringNrrd.c
+  encoding.c
+  encodingAscii.c
+  encodingBzip2.c
+  encodingGzip.c
+  encodingHex.c
+  encodingRaw.c
+  encodingZRL.c
+  endianNrrd.c
+  enumsNrrd.c
+  filt.c
+  format.c
+  formatEPS.c
+  formatNRRD.c
+  formatPNG.c
+  formatPNM.c
+  formatText.c
+  formatVTK.c
+  gzio.c
+  hestNrrd.c
+  histogram.c
+  iter.c
+  kernel.c
+  keyvalue.c
+  map.c
+  measure.c
+  methodsNrrd.c
+  nrrd.h
+  nrrdDefines.h
+  nrrdEnums.h
+  nrrdMacros.h
+  parseNrrd.c
+  privateNrrd.h
+  range.c
+  read.c
+  reorder.c
+  resampleContext.c
+  fftNrrd.c
+  resampleNrrd.c
+  simple.c
+  subset.c
+  superset.c
+  tmfKernel.c
+  winKernel.c
+  bsplKernel.c
+  write.c
+  )
+
+target_sources(teem PRIVATE ${NRRD_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( nrrd FILES ${NRRD_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/comment.c teem-1.11.0-src/src/nrrd/comment.c
--- teem-1.11.0-src.orig/src/nrrd/comment.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/comment.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/convertNrrd.c teem-1.11.0-src/src/nrrd/convertNrrd.c
--- teem-1.11.0-src.orig/src/nrrd/convertNrrd.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/convertNrrd.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -121,22 +121,49 @@
 }
 
 /*
-** This typedef makes the definition of _nrrdConv[][] shorter
+** _nrrdCcrd<Ta><Tb>()
+**
+** like _nrrdClCv<Ta><Tb>() and _nrrdConv<Ta><Tb>(), but with the
+** ability to control if there is rounding and/or clamping. As above,
+** there may be loss of precision with long long input.
+*/
+#define CCRD_DEF(TA, TB)                                        \
+static void                                                     \
+ _nrrdCcrd##TA##TB(TA *a, const TB *b, IT N,                    \
+                   int doClamp, int roundd) {                   \
+   size_t ii;                                                   \
+  for (ii=0; ii<N; ii++) {                                      \
+    double ccrdTmp = AIR_CAST(double, b[ii]);                   \
+    ccrdTmp = (roundd > 0                                       \
+               ? floor(ccrdTmp + 0.5)                           \
+               : (roundd < 0                                    \
+                  ? ceil(ccrdTmp - 0.5)                         \
+                  : ccrdTmp));                                  \
+    ccrdTmp = (doClamp ? _nrrdDClamp##TA(ccrdTmp) : ccrdTmp);   \
+    a[ii] = AIR_CAST(TA, ccrdTmp);                              \
+  }                                                             \
+}
+
+/*
+** These makes the definition of later arrays shorter
 */
 typedef void (*CF)(void *, const void *, IT);
+typedef void (*CN)(void *, const void *, IT, int, int);
 
 /*
 ** the individual converter's appearance in the array initialization,
-** using the cast to the "CF" typedef
+** using the cast to the typedefs above
 */
 #define CONV_LIST(TA, TB) (CF)_nrrdConv##TA##TB,
 #define CLCV_LIST(TA, TB) (CF)_nrrdClCv##TA##TB,
+#define CCRD_LIST(TA, TB) (CN)_nrrdCcrd##TA##TB,
 
 /*
 ** the brace-delimited list of all converters _to_ type TA
 */
 #define CONVTO_LIST(_dummy_, TA) {NULL, MAP2(CONV_LIST, TA) NULL},
 #define CLCVTO_LIST(_dummy_, TA) {NULL, MAP2(CLCV_LIST, TA) NULL},
+#define CCRDTO_LIST(_dummy_, TA) {NULL, MAP2(CCRD_LIST, TA) NULL},
 
 
 
@@ -146,7 +173,7 @@
 
 
 /*
-** the clamping functions where moved here from accessors.c in order
+** the clamping functions were moved here from accessors.c in order
 ** to create the combined clamp-and-convert functions
 */
 
@@ -217,17 +244,19 @@
 
 
 /*
-** Define all 100 of both converters.
+** Define all the converters.
 */
 MAP1(MAP2, CONV_DEF)
 MAP1(MAP2, CLCV_DEF)
+MAP1(MAP2, CCRD_DEF)
 
 
 /*
-** Initialize the whole converter array.
+** Initialize the converter arrays.
 **
-** This generates one incredibly long line of text, which hopefully will not
-** break a poor compiler with limitations on line-length...
+** Each definition generates one incredibly long line of text, which
+** hopefully will not break a poor compiler with limitations on
+** line-length...
 */
 CF
 _nrrdConv[NRRD_TYPE_MAX+1][NRRD_TYPE_MAX+1] = {
@@ -242,3 +271,10 @@
 MAP1(CLCVTO_LIST, _dummy_)
 {NULL}
 };
+
+CN
+_nrrdCastClampRound[NRRD_TYPE_MAX+1][NRRD_TYPE_MAX+1] = {
+{NULL},
+MAP1(CCRDTO_LIST, _dummy_)
+{NULL}
+};
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/defaultsNrrd.c teem-1.11.0-src/src/nrrd/defaultsNrrd.c
--- teem-1.11.0-src.orig/src/nrrd/defaultsNrrd.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/defaultsNrrd.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -40,6 +40,7 @@
 
 int nrrdDefaultWriteEncodingType = nrrdEncodingTypeRaw;
 int nrrdDefaultWriteBareText = AIR_TRUE;
+int nrrdDefaultWriteMoreThanFloatInText = AIR_FALSE;
 unsigned int nrrdDefaultWriteCharsPerLine = 75;
 unsigned int nrrdDefaultWriteValsPerLine = 8;
 /* ---- BEGIN non-NrrdIO */
@@ -109,6 +110,8 @@
   = "NRRD_DEFAULT_WRITE_BARE_TEXT";
 const char *const nrrdEnvVarDefaultWriteBareTextOld
   = "NRRD_DEF_WRITE_BARE_TEXT";
+const char *const nrrdEnvVarDefaultWriteMoreThanFloatInText
+  = "NRRD_DEFAULT_WRITE_MORE_THAN_FLOAT_IN_TEXT";
 const char *const nrrdEnvVarDefaultCenter
   = "NRRD_DEFAULT_CENTER";
 const char *const nrrdEnvVarDefaultCenterOld
@@ -144,6 +147,8 @@
   = "NRRD_STATE_GRAYSCALE_IMAGE_3D";
 
 /*
+**    return
+**     value:
 **        -1: unset, or bad args    ==> *val NOT set
 **  AIR_TRUE: set in a valid way    ==> *val set (to something)
 ** AIR_FALSE: set in an invalid way ==> *val NOT set
@@ -264,7 +269,7 @@
   if (!env) {
     return -1;
   }
-  if (1 != sscanf(env, "%lf", &tmp)) {
+  if (1 != airSingleSscanf(env, "%lf", &tmp)) {
     return AIR_FALSE;
   } else {
     *val = tmp;
@@ -272,6 +277,25 @@
   }
 }
 
+/*
+** This function is not used in the same way within nrrd the same way
+** as the other nrrdGetenv functions; it was added just to have a more
+** convenient wrapper around getenv for strings.
+*/
+int
+nrrdGetenvString(char **envStr, const char *envVar) {
+
+  if (!(envStr && envVar)) {
+    return -1;
+  }
+  *envStr = getenv(envVar);
+  if (!(*envStr)) {
+    return AIR_FALSE;
+  } else {
+    return AIR_TRUE;
+  }
+}
+
 void
 nrrdDefaultGetenv(void) {
 
@@ -288,6 +312,8 @@
   }
   /* these post-date the Def --> Default rename */
 
+  nrrdGetenvBool(/**/ &nrrdDefaultWriteMoreThanFloatInText, NULL,
+                 nrrdEnvVarDefaultWriteMoreThanFloatInText);
   nrrdGetenvEnum(/**/ &nrrdDefaultWriteEncodingType, NULL, nrrdEncodingType,
                  nrrdEnvVarDefaultWriteEncodingType);
   nrrdGetenvUInt(/**/ &nrrdDefaultWriteCharsPerLine, NULL,
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/deringNrrd.c teem-1.11.0-src/src/nrrd/deringNrrd.c
--- teem-1.11.0-src.orig/src/nrrd/deringNrrd.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/deringNrrd.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -170,7 +170,7 @@
                     * nrrdElementSize(nin));
   if (drc->verbose > 2) {
     fprintf(stderr, "%s: sliceSize = %u\n", me,
-            AIR_CAST(unsigned int, drc->sliceSize));
+            AIR_UINT(drc->sliceSize));
   }
 
   return 0;
@@ -500,7 +500,7 @@
   static const char me[]="deringSliceSet";
 
   if (nrrdWrap_va(dbg->nsliceOut,
-                  AIR_CAST(void *, drc->cdataOut + zi*(drc->sliceSize)),
+                  AIR_VOIDP(drc->cdataOut + zi*(drc->sliceSize)),
                   nout->type, 2,
                   nout->axis[0].size,
                   nout->axis[1].size)
@@ -527,9 +527,9 @@
   rr = sqrt(dx*dx + dy*dy);
   th = atan2(-dx, dy);
   rrScl = AIR_AFFINE(-EPS, rr, dbg->radMax+EPS, 0.0, dbg->radNum-1);
-  *rrIdx = AIR_CAST(unsigned int, 0.5 + rrScl);
+  *rrIdx = AIR_UINT(0.5 + rrScl);
   thScl = AIR_AFFINE(-AIR_PI-EPS, th, AIR_PI+EPS, 0.0, drc->thetaNum);
-  *thIdx = AIR_CAST(unsigned int, 0.5 + thScl);
+  *thIdx = AIR_UINT(0.5 + thScl);
   if (rrFrc && thFrc) {
     *rrFrc = rrScl - *rrIdx;
     *thFrc = thScl - *thIdx;
@@ -552,8 +552,8 @@
 
   nrrdZeroSet(dbg->nptxf[ORIG]);
   nrrdZeroSet(dbg->nptxf[WGHT]);
-  sx = AIR_CAST(unsigned int, drc->nin->axis[0].size);
-  sy = AIR_CAST(unsigned int, drc->nin->axis[1].size);
+  sx = AIR_UINT(drc->nin->axis[0].size);
+  sy = AIR_UINT(drc->nin->axis[1].size);
   for (yi=0; yi<sy; yi++) {
     for (xi=0; xi<sx; xi++) {
       double rrFrc, thFrc, val;
@@ -689,8 +689,8 @@
   /* static const char me[]="deringSubtract"; */
   unsigned int sx, sy, xi, yi, rrIdx, thIdx;
 
-  sx = AIR_CAST(unsigned int, drc->nin->axis[0].size);
-  sy = AIR_CAST(unsigned int, drc->nin->axis[1].size);
+  sx = AIR_UINT(drc->nin->axis[0].size);
+  sy = AIR_UINT(drc->nin->axis[1].size);
   for (yi=0; yi<sy; yi++) {
     for (xi=0; xi<sx; xi++) {
       double rrFrc, thFrc, val;
@@ -795,8 +795,8 @@
 
   /* set radLen: radial length of polar transform of data */
   radLen = 0;
-  sx = AIR_CAST(unsigned int, drc->nin->axis[0].size);
-  sy = AIR_CAST(unsigned int, drc->nin->axis[1].size);
+  sx = AIR_UINT(drc->nin->axis[0].size);
+  sy = AIR_UINT(drc->nin->axis[1].size);
   dx = 0 - drc->center[0];
   dy = 0 - drc->center[1];
   len = sqrt(dx*dx + dy*dy);
@@ -882,7 +882,7 @@
 
   sz = (2 == drc->nin->dim
         ? 1
-        : AIR_CAST(unsigned int, drc->nin->axis[2].size));
+        : AIR_UINT(drc->nin->axis[2].size));
   drc->ringMagnitude = 0.0;
   for (zi=0; zi<sz; zi++) {
     if (drc->verbose) {
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/encodingAscii.c teem-1.11.0-src/src/nrrd/encodingAscii.c
--- teem-1.11.0-src.orig/src/nrrd/encodingAscii.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/encodingAscii.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -59,7 +59,7 @@
          echo "0 0 0 0 1 0 0 0 0" \
           | unu reshape -s 9 1 1 \
           | unu pad -min 0 0 0 -max 8 8 8 \
-          | unu make -s 9 9 9 -t float -e ascii -ls 9 \
+          | unu make -s 9 9 9 -t float -e ascii -ls 10 \
             -spc LPS -orig "(0,0,0)" -dirs "(1,0,0) (0,1,0) (0,0,1)"
        This particular case is resolved by changing AIR_STRLEN_HUGE
        to AIR_STRLEN_HUGE*100, but the general problem remains.  This
@@ -116,6 +116,7 @@
   size_t bufflen, linelen;
   const char *data;
   size_t I;
+  int newlined=AIR_FALSE;
 
   if (nrrdTypeBlock == nrrd->type) {
     biffAddf(NRRD, "%s: can't write nrrd type %s to %s", me,
@@ -129,10 +130,12 @@
     nrrdSprint[nrrd->type](buff, data);
     if (1 == nrrd->dim) {
       fprintf(file, "%s\n", buff);
+      newlined = AIR_TRUE;
     } else if (nrrd->dim == 2
                && nrrd->axis[0].size <= nio->valsPerLine) {
-      fprintf(file, "%s%c", buff,
-              (I+1)%(nrrd->axis[0].size) ? ' ' : '\n');
+      int nonewline = AIR_CAST(int, (I+1)%(nrrd->axis[0].size));
+      fprintf(file, "%s%c", buff, nonewline ? ' ' : '\n');
+      newlined = !nonewline;
     } else {
       bufflen = strlen(buff);
       if (linelen+bufflen+1 <= nio->charsPerLine) {
@@ -142,11 +145,16 @@
         fprintf(file, "\n%s", buff);
         linelen = bufflen;
       }
+      newlined = AIR_FALSE;
     }
     data += nrrdElementSize(nrrd);
   }
-  /* just to be sure, we always end with a carraige return */
-  fprintf(file, "\n");
+  if (!newlined) {
+    /* always end file with a carraige return; but guard with this
+       conditional so we don't create a final blank line */
+    fprintf(file, "\n");
+  }
+  fflush(file);
 
   return 0;
 }
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/encodingBzip2.c teem-1.11.0-src/src/nrrd/encodingBzip2.c
--- teem-1.11.0-src.orig/src/nrrd/encodingBzip2.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/encodingBzip2.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/encoding.c teem-1.11.0-src/src/nrrd/encoding.c
--- teem-1.11.0-src.orig/src/nrrd/encoding.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/encoding.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -105,6 +105,7 @@
   &_nrrdEncodingAscii,
   &_nrrdEncodingHex,
   &_nrrdEncodingGzip,
-  &_nrrdEncodingBzip2
+  &_nrrdEncodingBzip2,
+  &_nrrdEncodingZRL,
 };
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/encodingGzip.c teem-1.11.0-src/src/nrrd/encodingGzip.c
--- teem-1.11.0-src.orig/src/nrrd/encodingGzip.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/encodingGzip.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -34,6 +34,7 @@
 #endif
 }
 
+#if TEEM_ZLIB
 /*
 ** Maximum size that allow zlib to try to read or write at once.
 ** The real limit is UINT_MAX, but a smaller value here permits
@@ -41,6 +42,7 @@
 */
 static unsigned int
 _nrrdZlibMaxChunk = UINT_MAX;
+#endif
 
 /*
 ** nio->byteSkip < 0 functionality contributed by Katharina Quintus
@@ -75,7 +77,7 @@
      sizeChunk is used below, we also cap chunk size at _nrrdZlibMaxChunk/2 to
      prevent overflow. */
   maxChunk = _nrrdZlibMaxChunk/2;
-  sizeChunk = AIR_CAST(unsigned int, AIR_MIN(sizeData, maxChunk));
+  sizeChunk = AIR_UINT(AIR_MIN(sizeData, maxChunk));
 
   if (nio->byteSkip < 0) {
     /* We don't know the size of the size to skip before the data, so
@@ -166,7 +168,7 @@
          block (which may be smaller than the original sizeChunk). */
       if (sizeData >= sizeRed
           && sizeData - sizeRed < sizeChunk) {
-        sizeChunk = AIR_CAST(unsigned int, sizeData - sizeRed);
+        sizeChunk = AIR_UINT(sizeData - sizeRed);
       }
     }
     if (error) {
@@ -243,7 +245,7 @@
   /* zlib can only handle data sizes up to UINT_MAX ==> if there's more than
      UINT_MAX bytes to write out, we write out in chunks.  As above, we wrap
      _nrrdZlibMaxChunk around UINT_MAX for testing purposes. */
-  sizeChunk = AIR_CAST(unsigned int, AIR_MIN(sizeData, _nrrdZlibMaxChunk));
+  sizeChunk = AIR_UINT(AIR_MIN(sizeData, _nrrdZlibMaxChunk));
 
   /* keeps track of what how much has been successfully written */
   sizeWrit = 0;
@@ -264,7 +266,7 @@
     */
     if (sizeData >= sizeWrit
         && sizeData - sizeWrit < sizeChunk)
-      sizeChunk = AIR_CAST(unsigned int, sizeData - sizeWrit);
+      sizeChunk = AIR_UINT(sizeData - sizeWrit);
   }
 
   if (error) {
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/encodingHex.c teem-1.11.0-src/src/nrrd/encodingHex.c
--- teem-1.11.0-src.orig/src/nrrd/encodingHex.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/encodingHex.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -90,9 +90,9 @@
       continue;
     }
     /* else it is a valid character, representing a value from 0 to 15 */
-    nibshift = AIR_CAST(unsigned char, nib << (4*(1-(nibIdx & 1))));
+    nibshift = AIR_UCHAR(nib << (4*(1-(nibIdx & 1))));
     /* HEY not sure why the cast is needed with gcc v4.8 -Wconversion */
-    *data = AIR_CAST(unsigned char, *data + nibshift);
+    *data = AIR_UCHAR(*data + nibshift);
     data += nibIdx & 1;
     nibIdx++;
   }
@@ -116,11 +116,16 @@
 static int
 _nrrdEncodingHex_write(FILE *file, const void *_data, size_t elNum,
                        const Nrrd *nrrd, NrrdIoState *nio) {
-  /* static const char me[]="_nrrdEncodingHex_write"; */
+  static const char me[]="_nrrdEncodingHex_write";
   const unsigned char *data;
   size_t byteIdx, byteNum;
   unsigned int bytesPerLine;
 
+  if (!( file && _data && nrrd && nio )) {
+    biffAddf(NRRD, "%s: got NULL pointer (%p,%p,%p,%p)", me,
+             (void*)file, (const void*)_data, (const void*)nrrd, (void*)nio);
+    return 1;
+  }
   bytesPerLine = AIR_MAX(1, nio->charsPerLine/2);
   data = AIR_CAST(const unsigned char*, _data);
   byteNum = elNum*nrrdElementSize(nrrd);
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/encodingRaw.c teem-1.11.0-src/src/nrrd/encodingRaw.c
--- teem-1.11.0-src.orig/src/nrrd/encodingRaw.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/encodingRaw.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/encodingZRL.c teem-1.11.0-src/src/nrrd/encodingZRL.c
--- teem-1.11.0-src.orig/src/nrrd/encodingZRL.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/encodingZRL.c	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,98 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "nrrd.h"
+#include "privateNrrd.h"
+
+static int
+_nrrdEncodingZRL_available(void) {
+
+  return AIR_TRUE;
+}
+
+static int
+_nrrdEncodingZRL_read(FILE *file, void *data, size_t elementNum,
+                      Nrrd *nrrd, NrrdIoState *nio) {
+  unsigned char *output_buffer = (unsigned char *) data;
+  size_t toread = elementNum*nrrdElementSize(nrrd);
+  int cc, dd;
+  unsigned int j = 0;
+  AIR_UNUSED(nio);
+
+  while (j < toread) {
+    cc = fgetc(file);
+    if (cc == 0) {
+      dd = fgetc(file);
+      if (dd == 0) {
+        dd = fgetc(file);
+        j += dd + fgetc(file)*256;
+      } else {
+        j += (unsigned char)dd;
+      }
+    } else {
+      output_buffer[j] = (unsigned char)cc;
+      j++;
+    }
+  }
+
+  return 0;
+}
+
+static int
+_nrrdEncodingZRL_write(FILE *file, const void *data, size_t elementNum,
+                       const Nrrd *nrrd, NrrdIoState *nio) {
+  static const char me[]="_nrrdEncodingZRL_write";
+
+  AIR_UNUSED(file);
+  AIR_UNUSED(data);
+  AIR_UNUSED(elementNum);
+  AIR_UNUSED(nrrd);
+  AIR_UNUSED(nio);
+  biffAddf(NRRD, "%s: sorry, currently a read-only encoding", me);
+
+  return 0;
+}
+
+const NrrdEncoding
+_nrrdEncodingZRL = {
+  "zrl",      /* name */
+  "zrl",      /* suffix */
+  AIR_TRUE,   /* endianMatters */
+  AIR_FALSE,   /* isCompression: HEY this is a hack: this IS certainly a
+                  compression. However, with compressed encodings the nrrd
+                  format has no way of specifying whether a byteskip
+                  between be outside the encoding (in the uncompressed
+                  data) vs inside the encoding (within the compuressed
+                  data).  To date the convention has been that byte skip is
+                  done *inside* compressions, but for the ZRL-encoded data
+                  as currently generated, the relevant byte skipping is
+                  certainly *outside* the compression.  Thus we claim
+                  ignorance about how ZRL is a compression, so that byte
+                  skipping can be used. */
+  _nrrdEncodingZRL_available,
+  _nrrdEncodingZRL_read,
+  _nrrdEncodingZRL_write
+};
+
+const NrrdEncoding *const
+nrrdEncodingZRL = &_nrrdEncodingZRL;
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/endianNrrd.c teem-1.11.0-src/src/nrrd/endianNrrd.c
--- teem-1.11.0-src.orig/src/nrrd/endianNrrd.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/endianNrrd.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -32,11 +32,11 @@
     return;
   }
   data = AIR_CAST(unsigned short *, _data);
-  mask = AIR_CAST(unsigned short, 0x00FFu);
+  mask = AIR_USHORT(0x00FFu);
   for (I=0; I<N; I++) {
     dd = data[I];
     fix = (dd & mask); dd >>= 0x08;
-    fix = (dd & mask) | AIR_CAST(unsigned short, fix << 0x08);
+    fix = (dd & mask) | AIR_USHORT(fix << 0x08);
     data[I] = fix;
   }
 }
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/enumsNrrd.c teem-1.11.0-src/src/nrrd/enumsNrrd.c
--- teem-1.11.0-src.orig/src/nrrd/enumsNrrd.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/enumsNrrd.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -203,6 +203,7 @@
   "hex",
   "gz",
   "bz2",
+  "zrl"
 };
 
 static const char *
@@ -213,6 +214,7 @@
   "case-insenstive hexadecimal encoding (2 chars / byte)",
   "gzip compression of binary encoding",
   "bzip2 compression of binary encoding",
+  "simple compression by encoding run-length of zeros",
 };
 
 static const char *
@@ -222,6 +224,7 @@
   "hex",
   "gz", "gzip",
   "bz2", "bzip2",
+  "zrl",
   ""
 };
 
@@ -232,6 +235,7 @@
   nrrdEncodingTypeHex,
   nrrdEncodingTypeGzip, nrrdEncodingTypeGzip,
   nrrdEncodingTypeBzip2, nrrdEncodingTypeBzip2,
+  nrrdEncodingTypeZRL
 };
 
 airEnum
@@ -655,24 +659,30 @@
 
 /*
   nrrdSpaceUnknown,
-  nrrdSpaceRightAnteriorSuperior,     *  1: NIFTI-1 (right-handed) *
-  nrrdSpaceLeftAnteriorSuperior,      *  2: standard Analyze (left-handed) *
-  nrrdSpaceLeftPosteriorSuperior,     *  3: DICOM 3.0 (right-handed) *
-  nrrdSpaceRightAnteriorSuperiorTime, *  4: *
-  nrrdSpaceLeftAnteriorSuperiorTime,  *  5: *
-  nrrdSpaceLeftPosteriorSuperiorTime, *  6: *
-  nrrdSpaceScannerXYZ,                *  7: ACR/NEMA 2.0 (pre-DICOM 3.0) *
-  nrrdSpaceScannerXYZTime,            *  8: *
-  nrrdSpace3DRightHanded,             *  9: *
-  nrrdSpace3DLeftHanded,              * 10: *
-  nrrdSpace3DRightHandedTime,         * 11: *
-  nrrdSpace3DLeftHandedTime,          * 12: *
+  nrrdSpaceRightUp,                   *  1: 2-D, oriented like upper right
+                                         Cartesian quadrant, number I *
+  nrrdSpaceRightDown,                 *  2: 2-D, oriented like raster
+                                         coordinates *
+  nrrdSpaceRightAnteriorSuperior,     *  3: NIFTI-1 (right-handed) *
+  nrrdSpaceLeftAnteriorSuperior,      *  4: standard Analyze (left-handed) *
+  nrrdSpaceLeftPosteriorSuperior,     *  5: DICOM 3.0 (right-handed) *
+  nrrdSpaceRightAnteriorSuperiorTime, *  6: *
+  nrrdSpaceLeftAnteriorSuperiorTime,  *  7: *
+  nrrdSpaceLeftPosteriorSuperiorTime, *  8: *
+  nrrdSpaceScannerXYZ,                *  9: ACR/NEMA 2.0 (pre-DICOM 3.0) *
+  nrrdSpaceScannerXYZTime,            * 10: *
+  nrrdSpace3DRightHanded,             * 11: *
+  nrrdSpace3DLeftHanded,              * 12: *
+  nrrdSpace3DRightHandedTime,         * 13: *
+  nrrdSpace3DLeftHandedTime,          * 14: *
   nrrdSpaceLast
 */
 
 static const char *
 _nrrdSpaceStr[NRRD_SPACE_MAX+1] = {
   "(unknown_space)",
+  "right-up",
+  "right-down",
   "right-anterior-superior",
   "left-anterior-superior",
   "left-posterior-superior",
@@ -690,6 +700,8 @@
 static const char *
 _nrrdSpaceDesc[NRRD_SPACE_MAX+1] = {
   "unknown space",
+  "right-up (like Cartesian quadrant I)",
+  "right-down (like raster coordinates)",
   "right-anterior-superior (used in NIFTI-1 and SPL's 3D Slicer)",
   "left-anterior-superior (used in Analyze 7.5)",
   "left-posterior-superior (used in DICOM 3)",
@@ -706,6 +718,8 @@
 
 static const char *
 _nrrdSpaceStrEqv[] = {
+  "right-up", "right up",
+  "right-down", "right down",
   "right-anterior-superior", "right anterior superior",
       "rightanteriorsuperior", "RAS",
   "left-anterior-superior", "left anterior superior",
@@ -731,6 +745,8 @@
 
 static const int
 _nrrdSpaceValEqv[] = {
+  nrrdSpaceRightUp, nrrdSpaceRightUp,
+  nrrdSpaceRightDown, nrrdSpaceRightDown,
   nrrdSpaceRightAnteriorSuperior, nrrdSpaceRightAnteriorSuperior,
      nrrdSpaceRightAnteriorSuperior, nrrdSpaceRightAnteriorSuperior,
   nrrdSpaceLeftAnteriorSuperior, nrrdSpaceLeftAnteriorSuperior,
@@ -799,6 +815,144 @@
 
 /* ---- BEGIN non-NrrdIO */
 
+/* ---------------------- nrrdFormatPNGsRGBIntent ------------------------- */
+
+static const char *
+_nrrdFormatPNGsRGBIntentStr[NRRD_FORMAT_PNG_SRGB_INTENT_NUM+1] = {
+  "(unknown_sRGB_intent)",
+  "perceptual",
+  "relative",
+  "saturation",
+  "absolute",
+  "none"
+};
+
+int
+_nrrdFormatPNGsRGBIntentVal[NRRD_FORMAT_PNG_SRGB_INTENT_NUM+1] = {
+  nrrdFormatPNGsRGBIntentUnknown,    /* -1: nobody knows */
+  /* it is true and perhaps odd that we aren't using the values like
+     PNG_sRGB_INTENT_PERCEPTUAL, PNG_sRGB_INTENT_RELATIVE, etc. Why not:
+     1) we need this enum to be valid and consistent regardless of whether
+     this Teem is compiled with PNG support
+     2) The values of those constants are apparently pegged to constants set
+     in ICC profiles, not libpng itself, libpng isn't the authority on them
+     3) The values seem to be set in stone */
+  nrrdFormatPNGsRGBIntentPerceptual, /* 0 */
+  nrrdFormatPNGsRGBIntentRelative,   /* 1 */
+  nrrdFormatPNGsRGBIntentSaturation, /* 2 */
+  nrrdFormatPNGsRGBIntentAbsolute,   /* 3 */
+  nrrdFormatPNGsRGBIntentNone        /* 4 */
+};
+
+static const char *
+_nrrdFormatPNGsRGBIntentStrEqv[] = {
+  "perceptual", "perc", "p",
+  "relative",   "rel",  "r",
+  "saturation", "sat",  "s",
+  "absolute",   "abs",  "a",
+  "none",       "no",   "n",
+  ""
+};
+
+int
+_nrrdFormatPNGsRGBIntentValEqv[] = {
+  nrrdFormatPNGsRGBIntentPerceptual, nrrdFormatPNGsRGBIntentPerceptual, nrrdFormatPNGsRGBIntentPerceptual,
+  nrrdFormatPNGsRGBIntentRelative,   nrrdFormatPNGsRGBIntentRelative,   nrrdFormatPNGsRGBIntentRelative,
+  nrrdFormatPNGsRGBIntentSaturation, nrrdFormatPNGsRGBIntentSaturation, nrrdFormatPNGsRGBIntentSaturation,
+  nrrdFormatPNGsRGBIntentAbsolute,   nrrdFormatPNGsRGBIntentAbsolute,   nrrdFormatPNGsRGBIntentAbsolute,
+  nrrdFormatPNGsRGBIntentNone,       nrrdFormatPNGsRGBIntentNone,       nrrdFormatPNGsRGBIntentNone
+};
+
+static const char *
+_nrrdFormatPNGsRGBIntentDesc[NRRD_FORMAT_PNG_SRGB_INTENT_NUM+1] = {
+  "unknown sRGB rendering intent",
+  /* see http://www.libpng.org/pub/png/book/chapter10.html and
+     https://en.wikipedia.org/wiki/Color_management#Rendering_intent */
+  "perceptual: expand/compress/shift gamut to fit within output",
+  "relative colorimetric: true colors, but shifted by media white point",
+  "saturation: gamut remapping that preserves saturation",
+  "absolute colorimetric: true colors were possible, else clipped",
+  "none: do not store any intent in the sRGB chunk"
+};
+
+static const airEnum
+_nrrdFormatPNGsRGBIntent = {
+  "sRGB intent",
+  NRRD_FORMAT_PNG_SRGB_INTENT_NUM,
+  _nrrdFormatPNGsRGBIntentStr, _nrrdFormatPNGsRGBIntentVal,
+  _nrrdFormatPNGsRGBIntentDesc,
+  _nrrdFormatPNGsRGBIntentStrEqv, _nrrdFormatPNGsRGBIntentValEqv,
+  AIR_FALSE
+};
+const airEnum *const
+nrrdFormatPNGsRGBIntent = &_nrrdFormatPNGsRGBIntent;
+
+/* -------------------- nrrdOrientationHave --------------------- */
+
+static const char *
+_nrrdOrientationHaveStr[NRRD_ORIENTATION_HAVE_MAX+1] = {
+  "(unknown_orientation_have)",
+  "nothing",
+  "spacing",
+  "min+spacing",
+  "min+max",
+  "directions",
+  "origin+directions"
+};
+
+static const char *
+_nrrdOrientationHaveDesc[NRRD_ORIENTATION_HAVE_MAX+1] = {
+  "unknown orientation have",
+  "know nothing",
+  "know per-axis spacing",
+  "know per-axis min and spacing",
+  "know per-axis min and max",
+  "know space directions",
+  "know space origin and directions"
+};
+
+static const char *
+_nrrdOrientationHaveStrEqv[] = {
+  "nothing",
+  "spacing", "spc",
+  "min+spacing", "min+spc", "minspacing", "minspc",
+  "min+max", "minmax",
+  "directions", "dirs",
+  "origin+directions", "origindirections", "oridirs", "full",
+  ""
+};
+
+static const int
+_nrrdOrientationHaveValEqv[] = {
+  nrrdOrientationHaveNothing,
+  nrrdOrientationHaveSpacing,
+  nrrdOrientationHaveSpacing,
+  nrrdOrientationHaveMinSpacing,
+  nrrdOrientationHaveMinSpacing,
+  nrrdOrientationHaveMinSpacing,
+  nrrdOrientationHaveMinSpacing,
+  nrrdOrientationHaveMinMax,
+  nrrdOrientationHaveMinMax,
+  nrrdOrientationHaveDirections,
+  nrrdOrientationHaveDirections,
+  nrrdOrientationHaveOriginDirections,
+  nrrdOrientationHaveOriginDirections,
+  nrrdOrientationHaveOriginDirections,
+  nrrdOrientationHaveOriginDirections
+};
+
+static const airEnum
+_nrrdOrientationHave = {
+  "orientation have",
+  NRRD_ORIENTATION_HAVE_MAX,
+  _nrrdOrientationHaveStr, NULL,
+  _nrrdOrientationHaveDesc,
+  _nrrdOrientationHaveStrEqv, _nrrdOrientationHaveValEqv,
+  AIR_FALSE
+};
+const airEnum *const
+nrrdOrientationHave = &_nrrdOrientationHave;
+
 /* ------------------------ nrrdBoundary ------------------------- */
 
 static const char *
@@ -847,6 +1001,7 @@
   "sum",
   "L1",
   "L2",
+  "L4",
   "normalizedL2",
   "RMS",
   "Linf",
@@ -881,6 +1036,7 @@
   "sum of values",
   "L1 norm of values",
   "L2 norm of values",
+  "L4 norm of values",
   "L2 norm of values divided by # of values",
   "Root of Mean of Squares",
   "Linf norm of values",
@@ -914,6 +1070,7 @@
   "sum",
   "L1",
   "L2",
+  "L4",
   "normalizedL2", "normL2", "nL2",
   "rootmeansquare", "rms",
   "Linf",
@@ -948,6 +1105,7 @@
   nrrdMeasureSum,
   nrrdMeasureL1,
   nrrdMeasureL2,
+  nrrdMeasureL4,
   nrrdMeasureNormalizedL2, nrrdMeasureNormalizedL2, nrrdMeasureNormalizedL2,
   nrrdMeasureRootMeanSquare, nrrdMeasureRootMeanSquare,
   nrrdMeasureLinf,
@@ -1048,7 +1206,9 @@
   "normrand",
   "if",
   "zero",
-  "one"
+  "one",
+  "tauofsig",
+  "sigoftau"
 };
 
 static const char *
@@ -1083,7 +1243,9 @@
   "normally distributed random value, mean 0, stdv 1",
   "if nonzero, 1, else 0",
   "always zero",
-  "always one"
+  "always one",
+  "Lindeberg effective scale Tau as function of Sigma",
+  "Sigma as function of Lindeberg effective scale Tau"
 };
 
 static const char *
@@ -1118,6 +1280,8 @@
   "if",
   "zero", "0",
   "one", "1",
+  "tauofsig", "tos",
+  "sigoftau", "sot",
   ""
 };
 
@@ -1152,7 +1316,9 @@
   nuNrn, nuNrn, nuNrn,
   nuoIf,
   nuZer, nuZer,
-  nuOne, nuOne
+  nuOne, nuOne,
+  nrrdUnaryOpTauOfSigma, nrrdUnaryOpTauOfSigma,
+  nrrdUnaryOpSigmaOfTau, nrrdUnaryOpSigmaOfTau
 };
 
 static const airEnum
@@ -1195,6 +1361,9 @@
   "if",
   "nrand",
   "rrand",
+  "+c",
+  "-c",
+  "xc",
 };
 
 static const char *
@@ -1222,7 +1391,10 @@
   "if exists(a), then a, else b",
   "if a, then a, else b",
   "a + b*gaussianNoise",
-  "sample of Rician with mu a and sigma b"
+  "sample of Rician with mu a and sigma b",
+  "add, but clamp to integer representation range",
+  "subtract, but clamp to integer representation range",
+  "multiply, but clamp to integer representation range",
 };
 
 #define nbAdd nrrdBinaryOpAdd
@@ -1272,6 +1444,9 @@
   "if",
   "nrand",
   "rrand",
+  "+c", "addclamp",
+  "-c", "subtractclamp",
+  "xc", "multiplyclamp",
   ""
 };
 
@@ -1300,6 +1475,9 @@
   nbIf,
   nrrdBinaryOpNormalRandScaleAdd,
   nrrdBinaryOpRicianRand,
+  nrrdBinaryOpAddClamp, nrrdBinaryOpAddClamp,
+  nrrdBinaryOpSubtractClamp, nrrdBinaryOpSubtractClamp,
+  nrrdBinaryOpMultiplyClamp, nrrdBinaryOpMultiplyClamp,
 };
 
 static const airEnum
@@ -1508,4 +1686,30 @@
 const airEnum *const
 nrrdResampleNonExistent = &_nrrdResampleNonExistent_enum;
 
+/* ---------------------- nrrdMetaDataCanonicalVersion -------------------- */
+
+static const char *
+_nrrdMetaDataCanonicalVersionStr[NRRD_META_DATA_CANONICAL_VERSION_MAX+1] = {
+  "(unknown_meta_data_canonical_version)",
+  "alpha",
+};
+
+static const char *
+_nrrdMetaDataCanonicalVersionDesc[NRRD_META_DATA_CANONICAL_VERSION_MAX+1] = {
+  "unknown meta data canonical version",
+  "initial version, used for Diderot until at least 2016",
+};
+
+static const airEnum
+_nrrdMetaDataCanonicalVersion_enum = {
+  "canonical meta-data version",
+  NRRD_META_DATA_CANONICAL_VERSION_MAX,
+  _nrrdMetaDataCanonicalVersionStr, NULL,
+  _nrrdMetaDataCanonicalVersionDesc,
+  NULL, NULL,
+  AIR_FALSE
+};
+const airEnum *const
+nrrdMetaDataCanonicalVersion = &_nrrdMetaDataCanonicalVersion_enum;
+
 /* ---- END non-NrrdIO */
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/fftNrrd.c teem-1.11.0-src/src/nrrd/fftNrrd.c
--- teem-1.11.0-src.orig/src/nrrd/fftNrrd.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/fftNrrd.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -51,6 +51,14 @@
   return NULL;
 }
 
+static void *
+_nrrdFftwDestroyPlanWrapper(void *ptr) {
+  fftw_plan plan;
+  plan = AIR_CAST(fftw_plan, ptr);
+  fftw_destroy_plan(plan);
+  return NULL;
+}
+
 static void
 _nrrdDimsReverse(fftw_iodim *dims, unsigned int len) {
   fftw_iodim buff[NRRD_DIM_MAX];
@@ -172,13 +180,13 @@
   nprod = 1;
   for (axi=1; axi<nin->dim; axi++) {
     if (axisDo[axi]) {
-      txfDims[txfRank].n = AIR_CAST(int, inSize[axi]);
-      txfDims[txfRank].is = txfDims[txfRank].os = AIR_CAST(int, stride);
+      txfDims[txfRank].n = AIR_INT(inSize[axi]);
+      txfDims[txfRank].is = txfDims[txfRank].os = AIR_INT(stride);
       nprod *= inSize[axi];
       txfRank++;
     } else {
-      howDims[howRank].n = AIR_CAST(int, inSize[axi]);
-      howDims[howRank].is = howDims[howRank].os = AIR_CAST(int, stride);
+      howDims[howRank].n = AIR_INT(inSize[axi]);
+      howDims[howRank].is = howDims[howRank].os = AIR_INT(stride);
       howRank++;
     }
     stride *= inSize[axi];
@@ -218,8 +226,8 @@
   }
   /* HEY: figure out why fftw expects txfRank and howRank to be
      signed and not unsigned */
-  plan = fftw_plan_guru_dft(AIR_CAST(int, txfRank), txfDims,
-                            AIR_CAST(int, howRank), howDims,
+  plan = fftw_plan_guru_dft(AIR_INT(txfRank), txfDims,
+                            AIR_INT(howRank), howDims,
                             AIR_CAST(fftw_complex *, inData),
                             AIR_CAST(fftw_complex *, outData),
                             sign, flags);
@@ -227,6 +235,7 @@
     biffAddf(NRRD, "%s: unable to create plan", me);
     airMopError(mop); return 1;
   }
+  airMopAdd(mop, plan, _nrrdFftwDestroyPlanWrapper, airMopAlways);
 
   /* only after planning is done (which can over-write contents of inData)
      do we copy the real input values over */
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/filt.c teem-1.11.0-src/src/nrrd/filt.c
--- teem-1.11.0-src.orig/src/nrrd/filt.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/filt.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -24,7 +24,7 @@
 #include "nrrd.h"
 #include "privateNrrd.h"
 
-int
+int /* HEY unsigned? */
 _nrrdCM_median(const float *hist, float half) {
   float sum = 0;
   const float *hpt;
@@ -34,7 +34,7 @@
   while(sum < half)
     sum += *hpt++;
 
-  return AIR_CAST(int, hpt - 1 - hist);
+  return AIR_INT(hpt - 1 - hist);
 }
 
 int
@@ -80,8 +80,8 @@
   wt = (float *)calloc(diam, sizeof(float));
   wt[radius] = 1.0;
   for (r=1; r<=radius; r++) {
-    wt[radius+r] = AIR_CAST(float, pow(1.0/wght, r));
-    wt[radius-r] = AIR_CAST(float, pow(1.0/wght, r));
+    wt[radius+r] = AIR_FLOAT(pow(1.0/wght, r));
+    wt[radius-r] = AIR_FLOAT(pow(1.0/wght, r));
   }
   sum = 0.0;
   for (r=0; r<diam; r++) {
@@ -114,7 +114,7 @@
   if (1 == wght) {
     /* uniform weighting-> can do sliding histogram optimization */
     /* initialize histogram */
-    half = AIR_CAST(float, diam/2 + 1);
+    half = AIR_FLOAT(diam/2 + 1);
     memset(hist, 0, bins*sizeof(float));
     for (X=0; X<diam; X++) {
       hist[INDEX(nin, range, lup, X, bins, val)]++;
@@ -161,12 +161,12 @@
   double val, (*lup)(const void *, size_t);
 
   diam = 2*radius + 1;
-  sx = AIR_CAST(unsigned int, nin->axis[0].size);
-  sy = AIR_CAST(unsigned int, nin->axis[1].size);
+  sx = AIR_UINT(nin->axis[0].size);
+  sy = AIR_UINT(nin->axis[1].size);
   lup = nrrdDLookup[nin->type];
   if (1 == wght) {
     /* uniform weighting-> can do sliding histogram optimization */
-    half = AIR_CAST(float, diam*diam/2 + 1);
+    half = AIR_FLOAT(diam*diam/2 + 1);
     for (Y=radius; Y<sy-radius; Y++) {
       /* initialize histogram */
       memset(hist, 0, bins*sizeof(float));
@@ -219,20 +219,20 @@
                    int bins, int mode, float *hist) {
   static const char me[]="_nrrdCheapMedian3D";
   char done[13];
-  int X, Y, Z, I, J, K;
-  int sx, sy, sz, idx, diam;
+  int X, Y, Z, I, J, K, sx, sy, sz;
+  int idx, diam;
   float half, *wt;
   double val, (*lup)(const void *, size_t);
 
   diam = 2*radius + 1;
-  sx = AIR_CAST(int, nin->axis[0].size);
-  sy = AIR_CAST(int, nin->axis[1].size);
-  sz = AIR_CAST(int, nin->axis[2].size);
+  sx = AIR_INT(nin->axis[0].size);
+  sy = AIR_INT(nin->axis[1].size);
+  sz = AIR_INT(nin->axis[2].size);
   lup = nrrdDLookup[nin->type];
   fprintf(stderr, "%s: ...       ", me);
   if (1 == wght) {
     /* uniform weighting-> can do sliding histogram optimization */
-    half = AIR_CAST(float, diam*diam*diam/2 + 1);
+    half = AIR_FLOAT(diam*diam*diam/2 + 1);
     fflush(stderr);
     for (Z=radius; Z<sz-radius; Z++) {
       fprintf(stderr, "%s", airDoneStr(radius, Z, sz-radius-1, done));
@@ -298,6 +298,105 @@
   fprintf(stderr, "\b\b\b\b\b\b  done\n");
 }
 
+/* HEY: total copy-and-paste from _nrrdCheapMedian3D */
+void
+_nrrdCheapMedian4D(Nrrd *nout, const Nrrd *nin, const NrrdRange *range,
+                   int radius, float wght,
+                   int bins, int mode, float *hist) {
+  static const char me[]="_nrrdCheapMedian4D";
+  char done[13];
+  int W, X, Y, Z, H, I, J, K;
+  int sw, sx, sy, sz, idx, diam;
+  float half, *wt;
+  double val, (*lup)(const void *, size_t);
+
+  diam = 2*radius + 1;
+  sw = AIR_INT(nin->axis[0].size);
+  sx = AIR_INT(nin->axis[1].size);
+  sy = AIR_INT(nin->axis[2].size);
+  sz = AIR_INT(nin->axis[3].size);
+  lup = nrrdDLookup[nin->type];
+  fprintf(stderr, "%s: ...       ", me);
+  if (1 == wght) {
+    /* uniform weighting-> can do sliding histogram optimization */
+    half = AIR_FLOAT(diam*diam*diam*diam/2 + 1);
+    fflush(stderr);
+    for (Z=radius; Z<sz-radius; Z++) {
+      fprintf(stderr, "%s", airDoneStr(radius, Z, sz-radius-1, done));
+      fflush(stderr);
+      for (Y=radius; Y<sy-radius; Y++) {
+        for (X=radius; X<sx-radius; X++) {
+          /* initialize histogram */
+          memset(hist, 0, bins*sizeof(float));
+          W = radius;
+          for (K=-radius; K<=radius; K++) {
+            for (J=-radius; J<=radius; J++) {
+              for (I=-radius; I<=radius; I++) {
+                for (H=-radius; H<=radius; H++) {
+                  hist[INDEX(nin, range, lup,
+                             H+W + sw*(I+X + sx*(J+Y + sy*(K+Z))),
+                             bins, val)]++;
+                }
+              }
+            }
+          }
+          /* find median at each point using existing histogram */
+          for (W=radius; W<sw-radius; W++) {
+            idx = mode ? _nrrdCM_mode(hist, bins) : _nrrdCM_median(hist, half);
+            val = NRRD_NODE_POS(range->min, range->max, bins, idx);
+            nrrdDInsert[nout->type](nout->data, W + sw*(X + sx*(Y + sy*Z)), val);
+            /* probably update histogram for next iteration */
+            if (W < sw-radius-1) {
+              for (K=-radius; K<=radius; K++) {
+                for (J=-radius; J<=radius; J++) {
+                  for (I=-radius; I<=radius; I++) {
+                    hist[INDEX(nin, range, lup, W+radius+1 + sw*(I+X + sx*(J+Y + sy*(K+Z))),
+                               bins, val)]++;
+                    hist[INDEX(nin, range, lup, W-radius + sw*(I+X + sx*(J+Y + sy*(K+Z))),
+                               bins, val)]--;
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  } else {
+    /* non-uniform weighting --> slow and stupid */
+    wt = _nrrdCM_wtAlloc(radius, wght);
+    half = 0.5;
+    for (Z=radius; Z<sz-radius; Z++) {
+      fprintf(stderr, "%s", airDoneStr(radius, Z, sz-radius-1, done));
+      fflush(stderr);
+      for (Y=radius; Y<sy-radius; Y++) {
+        for (X=radius; X<sx-radius; X++) {
+          for (W=radius; W<sw-radius; W++) {
+            memset(hist, 0, bins*sizeof(float));
+            for (K=-radius; K<=radius; K++) {
+              for (J=-radius; J<=radius; J++) {
+                for (I=-radius; I<=radius; I++) {
+                  for (H=-radius; H<=radius; H++) {
+                    hist[INDEX(nin, range, lup,
+                               H+W + sw*(I+X + sx*(J+Y + sy*(K+Z))),
+                               bins, val)]
+                      += wt[H+radius]*wt[I+radius]*wt[J+radius]*wt[K+radius];
+                  }
+                }
+              }
+            }
+            idx = mode ? _nrrdCM_mode(hist, bins) : _nrrdCM_median(hist, half);
+            val = NRRD_NODE_POS(range->min, range->max, bins, idx);
+            nrrdDInsert[nout->type](nout->data, W + sw*(X + sx*(Y + sy*Z)), val);
+          }
+        }
+      }
+    }
+    free(wt);
+  }
+  fprintf(stderr, "\b\b\b\b\b\b  done\n");
+}
+
 /*
 ******** nrrdCheapMedian
 **
@@ -328,17 +427,17 @@
     biffAddf(NRRD, "%s: need bins >= 1 (got %d)", me, bins);
     return 1;
   }
-  if (!(AIR_IN_CL(1, _nin->dim, 3))) {
+  if (!(AIR_IN_CL(1, _nin->dim, 4))) {
     biffAddf(NRRD, "%s: sorry, can only handle dim 1, 2, 3 (not %d)",
              me, _nin->dim);
     return 1;
   }
-  minsize = AIR_CAST(unsigned int, _nin->axis[0].size);
+  minsize = AIR_UINT(_nin->axis[0].size);
   if (_nin->dim > 1) {
-    minsize = AIR_MIN(minsize, AIR_CAST(unsigned int, _nin->axis[1].size));
+    minsize = AIR_MIN(minsize, AIR_UINT(_nin->axis[1].size));
   }
   if (_nin->dim > 2) {
-    minsize = AIR_MIN(minsize, AIR_CAST(unsigned int, _nin->axis[2].size));
+    minsize = AIR_MIN(minsize, AIR_UINT(_nin->axis[2].size));
   }
   if (!pad && minsize < 2*radius+1) {
     biffAddf(NRRD, "%s: minimum nrrd size (%d) smaller than filtering "
@@ -396,6 +495,9 @@
   case 3:
     _nrrdCheapMedian3D(nout, nin, range, radius, wght, bins, mode, hist);
     break;
+  case 4:
+    _nrrdCheapMedian4D(nout, nin, range, radius, wght, bins, mode, hist);
+    break;
   default:
     biffAddf(NRRD, "%s: sorry, %d-dimensional median unimplemented",
              me, nin->dim);
@@ -475,16 +577,16 @@
   zz[1] = +FLT_MAX;
   for (qq=1; qq<len; qq++) {
     double ss;
-    ss = intx(AIR_CAST(double, qq), ff[qq], vv[kk], ff[vv[kk]], spc);
+    ss = intx(AIR_DOUBLE(qq), ff[qq], vv[kk], ff[vv[kk]], spc);
     /* while (ss <= zz[kk]) {
     ** HEY this can have kk going to -1 and into memory errors!
     */
     while (ss <= zz[kk] && kk) {
       kk--;
-      ss = intx(AIR_CAST(double, qq), ff[qq], vv[kk], ff[vv[kk]], spc);
+      ss = intx(AIR_DOUBLE(qq), ff[qq], vv[kk], ff[vv[kk]], spc);
     }
     kk++;
-    vv[kk] = AIR_CAST(unsigned int, qq);
+    vv[kk] = AIR_UINT(qq);
     zz[kk] = ss;
     zz[kk+1] = +FLT_MAX;
   }
@@ -496,7 +598,7 @@
       kk++;
     }
     /* cast to avoid overflow weirdness on the unsigned ints */
-    dx = AIR_CAST(double, qq) - vv[kk];
+    dx = AIR_DOUBLE(qq) - vv[kk];
     dd[qq] = spc*spc*dx*dx + ff[vv[kk]];
   }
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/format.c teem-1.11.0-src/src/nrrd/format.c
--- teem-1.11.0-src.orig/src/nrrd/format.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/format.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/formatEPS.c teem-1.11.0-src/src/nrrd/formatEPS.c
--- teem-1.11.0-src.orig/src/nrrd/formatEPS.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/formatEPS.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -107,9 +107,10 @@
 static int
 _nrrdFormatEPS_write(FILE *file, const Nrrd *_nrrd, NrrdIoState *nio) {
   static const char me[]="_nrrdFormatEPS_write";
-  int color, cmyk, sx, sy;
+  int color, cmyk;
   Nrrd *nrrd;
   double aspect, minX, minY, maxX, maxY, scale;
+  unsigned int  sx, sy;
   airArray *mop;
 
   mop = airMopNew();
@@ -128,13 +129,13 @@
                                || 4 == nrrd->axis[0].size);
   cmyk = color && 4 == nrrd->axis[0].size;
   if (color) {
-    sx = AIR_CAST(int, nrrd->axis[1].size);
-    sy = AIR_CAST(int, nrrd->axis[2].size);
+    sx = AIR_UINT(nrrd->axis[1].size);
+    sy = AIR_UINT(nrrd->axis[2].size);
   } else {
-    sx = AIR_CAST(int, nrrd->axis[0].size);
-    sy = AIR_CAST(int, nrrd->axis[1].size);
+    sx = AIR_UINT(nrrd->axis[0].size);
+    sy = AIR_UINT(nrrd->axis[1].size);
   }
-  aspect = AIR_CAST(double, sx)/sy;
+  aspect = AIR_DOUBLE(sx)/sy;
   if (aspect > 7.5/10) {
     /* image has a wider aspect ratio than safely printable page area */
     minX = 0.5;
@@ -186,8 +187,8 @@
   fprintf(file, "gsave newpath\n");
   fprintf(file, "%g %g translate\n", minX, minY);
   fprintf(file, "%g %g scale\n", sx*scale, sy*scale);
-  fprintf(file, "%d %d 8\n", sx, sy);
-  fprintf(file, "[%d 0 0 -%d 0 %d]\n", sx, sy, sy);
+  fprintf(file, "%u %u 8\n", sx, sy);
+  fprintf(file, "[%u 0 0 -%u 0 %u]\n", sx, sy, sy);
   if (color) {
     fprintf(file, "{currentfile linestr readhexstring pop} "
             "false %d colorimage\n", cmyk ? 4 : 3);
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/formatNRRD.c teem-1.11.0-src/src/nrrd/formatNRRD.c
--- teem-1.11.0-src.orig/src/nrrd/formatNRRD.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/formatNRRD.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -135,13 +135,14 @@
 ****
 ***/
 
-#define MAGIC "NRRD"
+#define MGIC "NRRD"
 #define MAGIC0 "NRRD00.01"
 #define MAGIC1 "NRRD0001"
 #define MAGIC2 "NRRD0002"
 #define MAGIC3 "NRRD0003"
 #define MAGIC4 "NRRD0004"
 #define MAGIC5 "NRRD0005"
+#define MAGIC6 "NRRD0006"
 
 const char *
 _nrrdFormatURLLine0 = "Complete NRRD file format specification at:";
@@ -289,13 +290,19 @@
 }
 
 /*
-** we try to use the oldest format that will hold the nrrd
+** we try to use the oldest format that will hold the nrrd; this
+** function will determine which NRRD00XX magic gets used for the
+** output file
 */
 int
 _nrrdFormatNRRD_whichVersion(const Nrrd *nrrd, NrrdIoState *nio) {
   int ret;
 
-  if (_nrrdFieldInteresting(nrrd, nio, nrrdField_measurement_frame)) {
+  if (nrrdEncodingZRL == nio->encoding
+      || nrrdSpaceRightUp == nrrd->space
+      || nrrdSpaceRightDown == nrrd->space) {
+    ret = 6;
+  } else if (_nrrdFieldInteresting(nrrd, nio, nrrdField_measurement_frame)) {
     ret = 5;
   } else if (_nrrdFieldInteresting(nrrd, nio, nrrdField_thicknesses)
              || _nrrdFieldInteresting(nrrd, nio, nrrdField_space)
@@ -350,6 +357,7 @@
           || !strcmp(MAGIC3, nio->line)
           || !strcmp(MAGIC4, nio->line)
           || !strcmp(MAGIC5, nio->line)
+          || !strcmp(MAGIC6, nio->line)
           );
 }
 
@@ -526,9 +534,25 @@
     if (!nio->encoding->isCompression) {
       /* bytes are skipped here for non-compression encodings, but are
          skipped within the decompressed stream for compression encodings */
-      if (nrrdByteSkip(dataFile, nrrd, nio)) {
-        biffAddf(NRRD, "%s: couldn't skip bytes", me);
-        return 1;
+      if (nio->dataFSkip) {
+        /* this error checking is clearly done unnecessarily repeated,
+           but it was logically the simplest place to add it */
+        if (nio->byteSkip) {
+          biffAddf(NRRD, "%s: using per-list-line skip, "
+                   "but also set global byte skip %ld", me, nio->byteSkip);
+          return 1;
+        }
+        /* wow, the meaning of nio->dataFNIndex is a little confusing */
+        if (_nrrdByteSkipSkip(dataFile, nrrd, nio, nio->dataFSkip[nio->dataFNIndex-1])) {
+          biffAddf(NRRD, "%s: couldn't skip %ld bytes on for list line %u",
+                   me, nio->dataFSkip[nio->dataFNIndex-1], nio->dataFNIndex-1);
+          return 1;
+        }
+      } else {
+        if (nrrdByteSkip(dataFile, nrrd, nio)) {
+          biffAddf(NRRD, "%s: couldn't skip bytes", me);
+          return 1;
+        }
       }
     }
     /* ---------------- read the data itself */
@@ -656,12 +680,13 @@
 
   /* the magic is in fact the first thing to be written */
   if (file) {
-    fprintf(file, "%s%04d\n", MAGIC, _nrrdFormatNRRD_whichVersion(nrrd, nio));
+    fprintf(file, "%s%04d\n", MGIC, _nrrdFormatNRRD_whichVersion(nrrd, nio));
   } else if (nio->headerStringWrite) {
     sprintf(nio->headerStringWrite, "%s%04d\n",
-            MAGIC, _nrrdFormatNRRD_whichVersion(nrrd, nio));
+            MGIC, _nrrdFormatNRRD_whichVersion(nrrd, nio));
   } else {
-    nio->headerStrlen = AIR_CAST(unsigned int, strlen(MAGIC) + strlen("0000")) + 1;
+    nio->headerStrlen = AIR_UINT(strlen(MGIC)
+                                 + strlen("0000")) + 1;
   }
 
   /* write the advertisement about where to get the file format */
@@ -684,9 +709,9 @@
   for (ii=1; ii<=NRRD_FIELD_MAX; ii++) {
     if (_nrrdFieldInteresting(nrrd, nio, ii)) {
       if (file) {
-        _nrrdFprintFieldInfo(file, "", nrrd, nio, ii);
+        _nrrdFprintFieldInfo(file, "", nrrd, nio, ii, AIR_FALSE);
       } else if (nio->headerStringWrite) {
-        _nrrdSprintFieldInfo(&strptr, "", nrrd, nio, ii);
+        _nrrdSprintFieldInfo(&strptr, "", nrrd, nio, ii, AIR_FALSE);
         if (strptr) {
           strcat(nio->headerStringWrite, strptr);
           strcat(nio->headerStringWrite, "\n");
@@ -694,10 +719,10 @@
           strptr = NULL;
         }
       } else {
-        _nrrdSprintFieldInfo(&strptr, "", nrrd, nio, ii);
+        _nrrdSprintFieldInfo(&strptr, "", nrrd, nio, ii, AIR_FALSE);
         if (strptr) {
-          nio->headerStrlen += AIR_CAST(unsigned int, strlen(strptr));
-          nio->headerStrlen += AIR_CAST(unsigned int, strlen("\n"));
+          nio->headerStrlen += AIR_UINT(strlen(strptr));
+          nio->headerStrlen += AIR_UINT(strlen("\n"));
           free(strptr);
           strptr = NULL;
         }
@@ -719,7 +744,7 @@
       free(strptr);
       strptr = NULL;
     } else {
-      nio->headerStrlen += (1 + AIR_CAST(unsigned int, strlen(" ")
+      nio->headerStrlen += (1 + AIR_UINT(strlen(" ")
                                          + strlen(strtmp)
                                          + strlen("\n")) + 1);
     }
@@ -741,7 +766,7 @@
       _nrrdKeyValueWrite(NULL, &strptr,
                          NULL, nrrd->kvp[0 + 2*jj], nrrd->kvp[1 + 2*jj]);
       if (strptr) {
-        nio->headerStrlen += AIR_CAST(unsigned int, strlen(strptr));
+        nio->headerStrlen += AIR_UINT(strlen(strptr));
         free(strptr);
         strptr = NULL;
       }
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/formatPNG.c teem-1.11.0-src/src/nrrd/formatPNG.c
--- teem-1.11.0-src.orig/src/nrrd/formatPNG.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/formatPNG.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -223,7 +223,11 @@
     png_set_palette_to_rgb(png);
   /* expand grayscale images to 8 bits from 1, 2, or 4 bits */
   if (type == PNG_COLOR_TYPE_GRAY && depth < 8)
+#if PNG_LIBPNG_VER_MINOR > 1
     png_set_expand_gray_1_2_4_to_8(png);
+#else
+    png_set_expand(png);
+#endif
   /* expand paletted or rgb images with transparency to full alpha
      channels so the data will be available as rgba quartets */
   if (png_get_valid(png, info, PNG_INFO_tRNS))
@@ -233,6 +237,8 @@
     png_set_swap(png);
 #if 0
   /* HEY GLK asks why is this commented out? */
+  /* GLK later thinks: perhaps because this would confound the NRRD-centric
+     idea of PNG files as being a mere container of bytes */
   /* set up gamma correction */
   /* NOTE: screen_gamma is platform dependent,
      it can hardwired or set from a parameter/environment variable */
@@ -249,6 +255,15 @@
       png_set_gamma(png, screen_gamma, 1.0);
   }
 #endif
+  {
+    int intent;
+    if (png_get_sRGB(png, info, &intent)) {
+      nio->PNGsRGBIntentKnown = AIR_TRUE;
+      nio->PNGsRGBIntent = intent;
+    } else {
+      nio->PNGsRGBIntentKnown = AIR_FALSE;
+    }
+  }
   /* update reader */
   png_read_update_info(png, info);
   /* allocate memory for the image data */
@@ -295,7 +310,7 @@
     return 1;
   }
   /* query row size */
-  rowsize = png_get_rowbytes(png, info);
+  rowsize = AIR_CAST(png_uint_32, png_get_rowbytes(png, info));
   /* check byte size */
   if (nrrdElementNumber(nrrd)*nrrdElementSize(nrrd) != height*rowsize) {
     png_destroy_read_struct(&png, &info, NULL);
@@ -339,8 +354,8 @@
         if (!nio->seen[ret]
             && nrrdFieldInfoParse[ret](file, nrrd, nio, AIR_FALSE)) {
           if (1 <= nrrdStateVerboseIO) {
-            fprintf(stderr, "(%s: unparsable info for field \"%s\" "
-                    "--> plain comment)\n", me, fs);
+            fprintf(stderr, "(%s: unparsable info \"%s\" for field \"%s\" "
+                    "--> plain comment)\n", me, nio->line + nio->pos, fs);
           }
           ret = 0;
           goto plain;
@@ -406,7 +421,8 @@
                                 _nrrdErrorHandlerPNG,
                                 _nrrdWarningHandlerPNG);
   if (png == NULL) {
-    biffAddf(NRRD, "%s: failed to create PNG write struct", me);
+    biffAddf(NRRD, "%s: failed to create PNG write struct (compiled with "
+             "PNG_LIBPNG_VER_STRING=" PNG_LIBPNG_VER_STRING ")", me);
     return 1;
   }
   /* create image info struct */
@@ -434,30 +450,31 @@
   depth = nrrd->type == nrrdTypeUChar ? 8 : 16;
   switch (nrrd->dim) {
     char stmp[AIR_STRLEN_SMALL];
-    case 2: /* g only */
-    width = nrrd->axis[0].size;
-    height = nrrd->axis[1].size;
+  case 2: /* g only */
+    width = AIR_CAST(png_uint_32, nrrd->axis[0].size);
+    height = AIR_CAST(png_uint_32, nrrd->axis[1].size);
     type = PNG_COLOR_TYPE_GRAY;
-    rowsize = width*nrrdElementSize(nrrd);
+    rowsize = AIR_CAST(png_uint_32, width*nrrdElementSize(nrrd));
     break;
-    case 3: /* g, ga, rgb, rgba */
-    width = nrrd->axis[1].size;
-    height = nrrd->axis[2].size;
-    rowsize = width*nrrd->axis[0].size*nrrdElementSize(nrrd);
+  case 3: /* g, ga, rgb, rgba */
+    width = AIR_CAST(png_uint_32, nrrd->axis[1].size);
+    height = AIR_CAST(png_uint_32, nrrd->axis[2].size);
+    rowsize = AIR_CAST(png_uint_32,
+                       width*nrrd->axis[0].size*nrrdElementSize(nrrd));
     switch (nrrd->axis[0].size) {
-      case 1:
+    case 1:
       type = PNG_COLOR_TYPE_GRAY;
       break;
-      case 2:
+    case 2:
       type = PNG_COLOR_TYPE_GRAY_ALPHA;
       break;
-      case 3:
+    case 3:
       type = PNG_COLOR_TYPE_RGB;
       break;
-      case 4:
+    case 4:
       type = PNG_COLOR_TYPE_RGB_ALPHA;
       break;
-      default:
+    default:
       png_destroy_write_struct(&png, &info);
       biffAddf(NRRD, "%s: nrrd->axis[0].size (%s) not compatible with PNG", me,
                airSprintSize_t(stmp, nrrd->axis[0].size));
@@ -465,7 +482,7 @@
       break;
     }
     break;
-    default:
+  default:
     png_destroy_write_struct(&png, &info);
     biffAddf(NRRD, "%s: dimension (%d) not compatible with PNG",
              me, nrrd->dim);
@@ -476,6 +493,11 @@
   png_set_IHDR(png, info, width, height, depth, type,
                PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE,
                PNG_FILTER_TYPE_BASE);
+  /* set sRGB intent, if known */
+  if (nio->PNGsRGBIntentKnown
+      && nrrdFormatPNGsRGBIntentNone != nio->PNGsRGBIntent) {
+    png_set_sRGB_gAMA_and_cHRM(png, info, nio->PNGsRGBIntent);
+  }
   /* calculate numtxt and allocate txt[] array */
   numtxt = 0;
   for (fi=nrrdField_unknown+1; fi<nrrdField_last; fi++) {
@@ -509,7 +531,8 @@
       if (_nrrdFieldValidInImage[fi] && _nrrdFieldInteresting(nrrd, nio, fi)) {
         txt[txtidx].key = airStrdup(NRRD_PNG_FIELD_KEY);
         txt[txtidx].compression = PNG_TEXT_COMPRESSION_NONE;
-        _nrrdSprintFieldInfo(&(txt[txtidx].text), "", nrrd, nio, fi);
+        _nrrdSprintFieldInfo(&(txt[txtidx].text), "", nrrd, nio, fi,
+                             (3 == nrrd->dim && 1 == nrrd->axis[0].size));
         txtidx++;
       }
     }
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/formatPNM.c teem-1.11.0-src/src/nrrd/formatPNM.c
--- teem-1.11.0-src.orig/src/nrrd/formatPNM.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/formatPNM.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -321,7 +321,9 @@
   for (fi=nrrdField_unknown+1; fi<nrrdField_last; fi++) {
     if (_nrrdFieldValidInImage[fi]
         && _nrrdFieldInteresting(nrrd, nio, fi)) {
-      _nrrdFprintFieldInfo(file, NRRD_PNM_COMMENT, nrrd, nio, fi);
+      /* dropAxis0 is always AIR_FALSE because of code
+         above to delete a stub axis 0 */
+      _nrrdFprintFieldInfo(file, NRRD_PNM_COMMENT, nrrd, nio, fi, AIR_FALSE);
     }
   }
   for (ci=0; ci<nrrd->cmtArr->len; ci++) {
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/formatText.c teem-1.11.0-src/src/nrrd/formatText.c
--- teem-1.11.0-src.orig/src/nrrd/formatText.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/formatText.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -71,12 +71,14 @@
   static const char me[]="_nrrdFormatText_read";
   const char *fs;
   char *errS;
-  unsigned int plen, llen;
-  size_t line, sx, sy, size[NRRD_DIM_MAX];
+  unsigned int llen;
+  size_t line, plen, sx, sy, elsz, size[NRRD_DIM_MAX];
   int nret, fidx, settwo = 0, gotOnePerAxis = AIR_FALSE;
-  /* fl: first line, al: all lines */
-  airArray *flArr, *alArr;
-  float *fl, *al, oneFloat;
+  /* fl: first line (of floats) */
+  airArray *flArr, *dataArr;
+  float oneFloat;
+  char *data;
+  size_t (*parser)(void *, const char *, const char *, size_t);
   airPtrPtrUnion appu;
 
   if (!_nrrdFormatText_contentStartsLike(nio)) {
@@ -91,7 +93,7 @@
 
   /* we only get here with the first line already in nio->line */
   line = 1;
-  llen = AIR_CAST(unsigned int, strlen(nio->line));
+  llen = AIR_UINT(strlen(nio->line));
 
   if (0 == nrrd->dim) {
     settwo = nrrd->dim;
@@ -132,6 +134,7 @@
       }
       if (nrrdField_dimension == fidx) {
         /* "# dimension: 0" lead nrrd->dim being set to 0 */
+        /* HEY reconcile this with 7 lines later! */
         nrrd->dim = 2;
       }
       free(errS);
@@ -174,15 +177,16 @@
     line++;
   }
 
-  /* we supposedly have a line of numbers, see how many there are */
+  /* we supposedly have a line of numbers, now see how many there are.
+     For the specific purpose of counting numbers, we assume float type;
+     but we aren't going to remember these values. */
   if (!airParseStrF(&oneFloat, nio->line, _nrrdTextSep, 1)) {
     char stmp[AIR_STRLEN_SMALL];
     biffAddf(NRRD, "%s: couldn't parse a single number on line %s", me,
              airSprintSize_t(stmp, line));
     UNSETTWO; return 1;
   }
-  appu.f = &fl;
-  flArr = airArrayNew(appu.v, NULL, sizeof(float), _NRRD_TEXT_INCR);
+  flArr = airArrayNew(NULL, NULL, sizeof(float), _NRRD_TEXT_INCR);
   if (!flArr) {
     biffAddf(NRRD, "%s: couldn't create array for first line values", me);
     UNSETTWO; return 1;
@@ -190,21 +194,22 @@
   for (sx=1; 1; sx++) {
     /* there is obviously a limit to the number of numbers that can
        be parsed from a single finite line of input text */
-    airArrayLenSet(flArr, AIR_CAST(unsigned int, sx));
+    airArrayLenSet(flArr, AIR_UINT(sx));
     if (!flArr->data) {
       char stmp[AIR_STRLEN_SMALL];
       biffAddf(NRRD, "%s: couldn't alloc space for %s values", me,
                airSprintSize_t(stmp, sx));
       UNSETTWO; return 1;
     }
-    if (sx > airParseStrF(fl, nio->line, _nrrdTextSep, AIR_CAST(unsigned int, sx))) {
+    if (sx > airParseStrF(flArr->data, nio->line,
+                          _nrrdTextSep, AIR_UINT(sx))) {
       /* We asked for sx ints and got less.  We know that we successfully
          got one value, so we did succeed in parsing sx-1 values */
       sx--;
       break;
     }
   }
-  flArr = airArrayNuke(flArr);
+  flArr = airArrayNuke(flArr); /* forget about values parsed on 1st line */
   if (1 == nrrd->dim && 1 != sx) {
     char stmp[AIR_STRLEN_SMALL];
     biffAddf(NRRD, "%s: wanted 1-D nrrd, but got %s values on 1st line", me,
@@ -213,28 +218,51 @@
   }
   /* else sx == 1 when nrrd->dim == 1 */
 
+  if (nrrdTypeBlock == nrrd->type) {
+    biffAddf(NRRD, "%s: can't read %s type data from text", me,
+             airEnumStr(nrrdType, nrrdTypeBlock));
+    UNSETTWO; return 1;
+  }
+  /* If nrrd->type is non-zero (something other than nrrdTypeUnknown), that
+     means the value type in the text file has been explicitly documented via
+     a "type:" field (thanks to nio->moreThanFloatInText). We learned sx
+     above by counting how many *floats* could be parsed, but next we have to
+     actually learn values of type only known at run-time.
+
+     Else (nrrd->type is zero): nio->moreThanFloatInText describes the
+     capability of plain text file on *write*, but there isn't currently a
+     way of saying "when reading plain text that doesn't say otherwise, we
+     should understand it as of type THIS", so we'll stick with the type that
+     this library has long associated with plain text: float */
+  if (!nrrd->type) {
+    nrrd->type = nrrdTypeFloat;
+  }
+  elsz = nrrdTypeSize[nrrd->type];
+  parser = nrrdStringValsParse[nrrd->type];
+
   /* now see how many more lines there are */
-  appu.f = &al;
-  alArr = airArrayNew(appu.v, NULL, sx*sizeof(float), _NRRD_TEXT_INCR);
-  if (!alArr) {
+  appu.c = &data;
+  dataArr = airArrayNew(appu.v, NULL, sx*elsz, _NRRD_TEXT_INCR);
+  if (!dataArr) {
     biffAddf(NRRD, "%s: couldn't create data buffer", me);
     UNSETTWO; return 1;
   }
   sy = 0;
   while (llen) {
-    airArrayLenIncr(alArr, 1);
-    if (!alArr->data) {
+    airArrayLenIncr(dataArr, 1);
+    if (!dataArr->data) {
       char stmp[AIR_STRLEN_SMALL];
       biffAddf(NRRD, "%s: couldn't create scanline of %s values", me,
                airSprintSize_t(stmp, sx));
       UNSETTWO; return 1;
     }
-    plen = airParseStrF(al + sy*sx, nio->line, _nrrdTextSep, AIR_CAST(unsigned int, sx));
+    plen = parser(data + sy*sx*elsz, nio->line, _nrrdTextSep, sx);
     if (sx > plen) {
-      char stmp1[AIR_STRLEN_SMALL], stmp2[AIR_STRLEN_SMALL];
-      biffAddf(NRRD, "%s: could only parse %d values (not %s) on line %s",
-               me, plen, airSprintSize_t(stmp1, sx),
-               airSprintSize_t(stmp2, line));
+      char stmp1[AIR_STRLEN_SMALL], stmp2[AIR_STRLEN_SMALL],
+        stmp3[AIR_STRLEN_SMALL];
+      biffAddf(NRRD, "%s: could only parse %s values (not %s) on line %s", me,
+               airSprintSize_t(stmp1, plen), airSprintSize_t(stmp2, sx),
+               airSprintSize_t(stmp3, line));
       UNSETTWO; return 1;
     }
     sy++;
@@ -260,46 +288,56 @@
     size[1] = sy;
   }
 
-  if (nio->oldData
-      && nio->oldDataSize == (size_t)(nrrdTypeSize[nrrdTypeFloat]*sx*sy)) {
-    nret = nrrdWrap_nva(nrrd, nio->oldData, nrrdTypeFloat, nrrd->dim, size);
+  if (nio->oldData && nio->oldDataSize == sx*sy*elsz) {
+    nret = nrrdWrap_nva(nrrd, nio->oldData, nrrd->type, nrrd->dim, size);
   } else {
-    nret = nrrdMaybeAlloc_nva(nrrd, nrrdTypeFloat, nrrd->dim, size);
+    nret = nrrdMaybeAlloc_nva(nrrd, nrrd->type, nrrd->dim, size);
   }
   if (nret) {
     biffAddf(NRRD, "%s: couldn't create nrrd for plain text data", me);
     UNSETTWO; return 1;
   }
-  memcpy(nrrd->data, al, sx*sy*sizeof(float));
+  memcpy(nrrd->data, data, sx*sy*elsz);
 
-  alArr = airArrayNuke(alArr);
+  dataArr = airArrayNuke(dataArr);
   return 0;
 }
 
 static int
 _nrrdFormatText_write(FILE *file, const Nrrd *nrrd, NrrdIoState *nio) {
   char cmt[AIR_STRLEN_SMALL], buff[AIR_STRLEN_SMALL];
-  size_t I;
+  size_t I, dsz;
   int i, x, y, sx, sy;
-  void *data;
+  const void *data;
+  const char *cdata;
   float val;
+  int moreThanFloat;
 
+  /* should we exercise new functionality to save more than just
+     float in a text file */
+  moreThanFloat = (nrrdTypeFloat != nrrd->type
+                   && !nio->bareText
+                   && nio->moreThanFloatInText);
   sprintf(cmt, "%c ", NRRD_COMMENT_CHAR);
   if (!nio->bareText) {
     if (1 == nrrd->dim) {
-      _nrrdFprintFieldInfo(file, cmt, nrrd, nio, nrrdField_dimension);
+      _nrrdFprintFieldInfo(file, cmt, nrrd, nio, nrrdField_dimension,
+                           AIR_FALSE);
     }
     for (i=1; i<=NRRD_FIELD_MAX; i++) {
-      if (_nrrdFieldValidInText[i]
+      if (_nrrdFieldValidInText[i] /* (nrrdType is now valid) */
           && nrrdField_dimension != i  /* dimension is handled above */
-          && _nrrdFieldInteresting(nrrd, nio, i)) {
-        _nrrdFprintFieldInfo(file, cmt, nrrd, nio, i);
+          && _nrrdFieldInteresting(nrrd, nio, i)
+          && (nrrdField_type != i /* either not type */
+              || moreThanFloat)) { /* or is type, and we should
+                                      record non-float type */
+        _nrrdFprintFieldInfo(file, cmt, nrrd, nio, i, AIR_FALSE);
       }
     }
     if (nrrdKeyValueSize(nrrd)) {
       unsigned int kvi;
       for (kvi=0; kvi<nrrd->kvpArr->len; kvi++) {
-        _nrrdKeyValueWrite(file, NULL, NULL,
+        _nrrdKeyValueWrite(file, NULL, "#",
                            nrrd->kvp[0 + 2*kvi],
                            nrrd->kvp[1 + 2*kvi]);
       }
@@ -315,11 +353,17 @@
     sy = AIR_CAST(int, nrrd->axis[1].size);
   }
   data = nrrd->data;
+  cdata = (const char*)nrrd->data;
+  dsz = nrrdTypeSize[nrrd->type];
   I = 0;
   for (y=0; y<sy; y++) {
     for (x=0; x<sx; x++) {
-      val = nrrdFLookup[nrrd->type](data, I);
-      nrrdSprint[nrrdTypeFloat](buff, &val);
+      if (moreThanFloat) {
+        nrrdSprint[nrrd->type](buff, cdata + I*dsz);
+      } else {
+        val = nrrdFLookup[nrrd->type](data, I);
+        nrrdSprint[nrrdTypeFloat](buff, &val);
+      }
       if (x) fprintf(file, " ");
       fprintf(file, "%s", buff);
       I++;
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/formatVTK.c teem-1.11.0-src/src/nrrd/formatVTK.c
--- teem-1.11.0-src.orig/src/nrrd/formatVTK.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/formatVTK.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -90,10 +90,10 @@
 _nrrdFormatVTK_read(FILE *file, Nrrd *nrrd, NrrdIoState *nio) {
   static const char me[]="_nrrdReadVTK";
   char *three[3];
-  int sx, sy, sz, ret, N;
+  int ret;
   double xm=0.0, ym=0.0, zm=0.0, xs=1.0, ys=1.0, zs=1.0;
   airArray *mop;
-  unsigned int llen;
+  unsigned int sx, sy, sz, llen, N;
 
   if (!_nrrdFormatVTK_contentStartsLike(nio)) {
     biffAddf(NRRD, "%s: this doesn't look like a %s file", me,
@@ -136,7 +136,7 @@
   }
   GETLINE(DIMENSIONS); airToUpper(nio->line);
   if (!strstr(nio->line, "DIMENSIONS")
-      || 3 != sscanf(nio->line, "DIMENSIONS %d %d %d", &sx, &sy, &sz)) {
+      || 3 != sscanf(nio->line, "DIMENSIONS %u %u %u", &sx, &sy, &sz)) {
     biffAddf(NRRD, "%s: couldn't parse DIMENSIONS line (\"%s\")",
              me, nio->line);
     return 1;
@@ -173,7 +173,7 @@
   }
   if (N != sx*sy*sz) {
     biffAddf(NRRD,
-             "%s: product of sizes (%d*%d*%d == %d) != # elements (%d)",
+             "%s: product of sizes (%u*%u*%u == %u) != # elements (%d)",
              me, sx, sy, sz, sx*sy*sz, N);
     return 1;
   }
@@ -291,7 +291,8 @@
 int
 _nrrdFormatVTK_write(FILE *file, const Nrrd *_nrrd, NrrdIoState *nio) {
   static const char me[]="_nrrdFormatVTK_write";
-  int i, sx, sy, sz, sax;
+  int i, sax;
+  unsigned int sx, sy, sz;
   double xs, ys, zs, xm, ym, zm;
   char type[AIR_STRLEN_MED], name[AIR_STRLEN_SMALL];
   Nrrd *nrrd;
@@ -323,9 +324,9 @@
   if (!( AIR_EXISTS(xm) && AIR_EXISTS(ym) && AIR_EXISTS(zm) )) {
     xm = ym = zm = 0.0;
   }
-  sx = AIR_CAST(int, nrrd->axis[sax+0].size);
-  sy = AIR_CAST(int, nrrd->axis[sax+1].size);
-  sz = AIR_CAST(int, nrrd->axis[sax+2].size);
+  sx = AIR_UINT(nrrd->axis[sax+0].size);
+  sy = AIR_UINT(nrrd->axis[sax+1].size);
+  sz = AIR_UINT(nrrd->axis[sax+2].size);
 
   switch(nrrd->type) {
   case nrrdTypeUChar:
@@ -374,11 +375,11 @@
     fprintf(file, "ASCII\n");
   }
   fprintf(file, "DATASET STRUCTURED_POINTS\n");
-  fprintf(file, "DIMENSIONS %d %d %d\n", sx, sy, sz);
+  fprintf(file, "DIMENSIONS %u %u %u\n", sx, sy, sz);
   fprintf(file, "ORIGIN %g %g %g\n", xm, ym, zm);
   fprintf(file, "SPACING %g %g %g\n", xs, ys, zs);
-  fprintf(file, "POINT_DATA %d\n", sx*sy*sz);
-  airSrandMT(AIR_CAST(unsigned int, airTime()));
+  fprintf(file, "POINT_DATA %u\n", sx*sy*sz);
+  airSrandMT(AIR_UINT(airTime()));
   sprintf(name, "nrrd%05d", airRandInt(100000));
   if (3 == nrrd->dim) {
     fprintf(file, "SCALARS %s %s\n", name, type);
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/GNUmakefile teem-1.11.0-src/src/nrrd/GNUmakefile
--- teem-1.11.0-src.orig/src/nrrd/GNUmakefile	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/GNUmakefile	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -59,14 +59,14 @@
 	simple.o     subset.o     superset.o  tmfKernel.o      \
 	winKernel.o  bsplKernel.o  ccmethods.o  cc.o        range.o  \
         encoding.o   encodingRaw.o  encodingAscii.o  encodingHex.o \
-	encodingGzip.o   encodingBzip2.o  \
+	encodingGzip.o   encodingBzip2.o  encodingZRL.o \
 	format.o     formatNRRD.o     formatPNM.o      formatPNG.o \
 	formatVTK.o      formatText.o     formatEPS.o      \
 	keyvalue.o  resampleContext.o  fftNrrd.o
 $(L).TESTS = test/tread test/trand test/ax test/io test/strio test/texp \
 	test/minmax test/tkernel test/typestest test/tline test/genvol \
 	test/quadvol test/convo test/kv test/reuse test/histrad test/otsu \
-	test/dnorm test/morph
+	test/dnorm test/morph test/phrnd
 ####
 ####
 ####
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/gzio.c teem-1.11.0-src/src/nrrd/gzio.c
--- teem-1.11.0-src.orig/src/nrrd/gzio.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/gzio.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/hestNrrd.c teem-1.11.0-src/src/nrrd/hestNrrd.c
--- teem-1.11.0-src.orig/src/nrrd/hestNrrd.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/hestNrrd.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -35,7 +35,7 @@
 ** that is just fine
 */
 int
-_nrrdHestNrrdParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+_nrrdHestNrrdParse(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   char me[] = "_nrrdHestNrrdParse", *nerr;
   Nrrd **nrrdP;
   airArray *mop;
@@ -78,7 +78,8 @@
 /* ------------------------ NrrdKernelSpec -------------------------- */
 
 int
-_nrrdHestKernelSpecParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+_nrrdHestKernelSpecParse(void *ptr, const char *str,
+                         char err[AIR_STRLEN_HUGE]) {
   NrrdKernelSpec **ksP;
   char me[]="_nrrdHestKernelSpecParse", *nerr;
 
@@ -108,10 +109,45 @@
 hestCB *
 nrrdHestKernelSpec = &_nrrdHestKernelSpec;
 
+/* ------------------------ NrrdBoundarySpec -------------------------- */
+
+int
+_nrrdHestBoundarySpecParse(void *ptr, const char *str,
+                           char err[AIR_STRLEN_HUGE]) {
+  NrrdBoundarySpec **bsp;
+  char me[]="_nrrdHestBoundarySpecParse", *nerr;
+
+  if (!(ptr && str)) {
+    sprintf(err, "%s: got NULL pointer", me);
+    return 1;
+  }
+  bsp = (NrrdBoundarySpec **)ptr;
+  *bsp = nrrdBoundarySpecNew();
+  if (nrrdBoundarySpecParse(*bsp, str)) {
+    nerr = biffGetDone(NRRD);
+    airStrcpy(err, AIR_STRLEN_HUGE, nerr);
+    /* HEY: why not freeing bsp? */
+    free(nerr);
+    return 1;
+  }
+  return 0;
+}
+
+hestCB
+_nrrdHestBoundarySpec = {
+  sizeof(NrrdBoundarySpec*),
+  "boundary specification",
+  _nrrdHestBoundarySpecParse,
+  (airMopper)nrrdBoundarySpecNix
+};
+
+hestCB *
+nrrdHestBoundarySpec = &_nrrdHestBoundarySpec;
+
 /* --------------------------- NrrdIter ----------------------------- */
 
 int
-_nrrdLooksLikeANumber(char *str) {
+_nrrdLooksLikeANumber(const char *str) {
   /* 0: -+                (no restriction, but that's a little daft)
      1: 0123456789        n > 0
      2: .                 0 <= n <= 1
@@ -155,7 +191,7 @@
 }
 
 int
-_nrrdHestIterParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+_nrrdHestIterParse(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   char me[]="_nrrdHestIterParse", *nerr;
   Nrrd *nrrd;
   NrrdIter **iterP;
@@ -207,7 +243,8 @@
       ret = airSingleSscanf(str, "%lf", &val);
       if (_nrrdLooksLikeANumber(str)
           || (1 == ret && (!AIR_EXISTS(val)
-                           || AIR_ABS(AIR_PI - val) < 0.0001))) {
+                           || AIR_ABS(AIR_PI - val) < 0.0001
+                           || AIR_ABS(-AIR_PI - val) < 0.0001))) {
         /* either it patently looks like a number, or,
            it already parsed as a number and it is a special value */
         if (1 == ret) {
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/histogram.c teem-1.11.0-src/src/nrrd/histogram.c
--- teem-1.11.0-src.orig/src/nrrd/histogram.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/histogram.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -129,7 +129,7 @@
         continue;
       }
       if (AIR_IN_CL(min, val, max)) {
-        idx = airIndex(min, val, max+eps, AIR_CAST(unsigned int, bins));
+        idx = airIndex(min, val, max+eps, AIR_UINT(bins));
         /*
         printf("!%s: %d: index(%g, %g, %g, %d) = %d\n",
                me, (int)I, min, val, max, bins, idx);
@@ -243,7 +243,7 @@
   }
   nout->axis[1].min = usemaxhits;
   nout->axis[1].max = 0;
-  numticks = AIR_CAST(unsigned int, log10(usemaxhits + 1));
+  numticks = AIR_UINT(log10(usemaxhits + 1));
   mop = airMopNew();
   ticks = AIR_CALLOC(numticks, unsigned int);
   airMopMem(mop, &ticks, airMopAlways);
@@ -257,14 +257,14 @@
   }
   for (ki=0; ki<numticks; ki++) {
     ticks[ki] = airIndex(0, log10(pow(10,ki+1) + 1), log10(usemaxhits+1),
-                         AIR_CAST(unsigned int, sy));
+                         AIR_UINT(sy));
   }
   for (xi=0; xi<sx; xi++) {
     hits = nrrdDLookup[nin->type](nin->data, xi);
     linY[xi] = airIndex(0, hits, usemaxhits,
-                        AIR_CAST(unsigned int, sy));
+                        AIR_UINT(sy));
     logY[xi] = airIndex(0, log10(hits+1), log10(usemaxhits+1),
-                        AIR_CAST(unsigned int, sy));
+                        AIR_UINT(sy));
     /* printf("%d -> %d,%d", x, linY[x], logY[x]); */
   }
   for (yi=0; yi<sy; yi++) {
@@ -423,7 +423,7 @@
     /* get input nrrd value and compute its histogram index */
     val = nrrdDLookup[nin->type](nin->data, I);
     if (AIR_EXISTS(val) && AIR_IN_CL(range->min, val, range->max)) {
-      hidx = airIndex(range->min, val, range->max, AIR_CAST(unsigned int, bins));
+      hidx = airIndex(range->min, val, range->max, AIR_UINT(bins));
       memcpy(coordOut, coordIn, nin->dim*sizeof(size_t));
       coordOut[hax] = (unsigned int)hidx;
       NRRD_INDEX_GEN(hI, coordOut, szOut, nout->dim);
@@ -453,7 +453,8 @@
                int type, const int *clamp) {
   static const char me[]="nrrdHistoJoint", func[]="jhisto";
   int skip, hadContent;
-  double val, count, incr, (*lup)(const void *v, size_t I);
+  double val, count, incr, (*lup)(const void *v, size_t I),
+    rmin[NRRD_DIM_MAX], rmax[NRRD_DIM_MAX];
   size_t Iin, Iout, numEl, coord[NRRD_DIM_MAX], totalContentStrlen;
   airArray *mop;
   NrrdRange **range;
@@ -462,7 +463,9 @@
   /* error checking */
   /* nwght can be NULL -> weighting is constant 1.0 */
   if (!(nout && nin && bins && clamp)) {
-    biffAddf(NRRD, "%s: got NULL pointer", me);
+    biffAddf(NRRD, "%s: got NULL pointer (%p, %p, %p, %p)", me,
+             AIR_VOIDP(nout), AIR_CVOIDP(nin),
+             AIR_CVOIDP(bins), AIR_CVOIDP(clamp));
     return 1;
   }
   if (!(numNin >= 1)) {
@@ -524,6 +527,7 @@
 
   /* check nwght */
   if (nwght) {
+    char stmp1[AIR_STRLEN_SMALL], stmp2[AIR_STRLEN_SMALL];
     if (nout==nwght) {
       biffAddf(NRRD, "%s: nout==nwght disallowed", me);
       return 1;
@@ -533,8 +537,10 @@
                airEnumStr(nrrdType, nrrdTypeBlock));
       return 1;
     }
-    if (!nrrdSameSize(nin[0], nwght, AIR_TRUE)) {
-      biffAddf(NRRD, "%s: nwght size mismatch with nin[0]", me);
+    if (nrrdElementNumber(nin[0]) != nrrdElementNumber(nwght)) {
+      biffAddf(NRRD, "%s: element # in nwght %s != nin[0] %s", me,
+               airSprintSize_t(stmp2, nrrdElementNumber(nin[0])),
+               airSprintSize_t(stmp1, nrrdElementNumber(nwght)));
       return 1;
     }
     lup = nrrdDLookup[nwght->type];
@@ -581,6 +587,15 @@
   }
 
   /* the skinny */
+  for (ai=0; ai<numNin; ai++) {
+    if (range[ai]->min <= range[ai]->max) {
+      rmin[ai] = range[ai]->min;
+      rmax[ai] = range[ai]->max;
+    } else {
+      rmin[ai] = range[ai]->max;
+      rmax[ai] = range[ai]->min;
+    }
+  }
   numEl = nrrdElementNumber(nin[0]);
   for (Iin=0; Iin<numEl; Iin++) {
     skip = 0;
@@ -592,9 +607,9 @@
         skip = 1;
         break;
       }
-      if (!AIR_IN_CL(range[ai]->min, val, range[ai]->max)) {
+      if (!AIR_IN_CL(rmin[ai], val, rmax[ai])) {
         if (clamp[ai]) {
-          val = AIR_CLAMP(range[ai]->min, val, range[ai]->max);
+          val = AIR_CLAMP(rmin[ai], val, rmax[ai]);
         } else {
           skip = 1;
           break;
@@ -604,7 +619,6 @@
                                                     val,
                                                     range[ai]->max,
                                                     bins[ai]));
-      /* printf(" -> coord = %d; ", coord[d]); fflush(stdout); */
     }
     if (skip) {
       continue;
@@ -679,7 +693,7 @@
   hist = AIR_CAST(double*, nhist->data);
   bvar = AIR_CAST(double*, nbvar->data);
 
-  histLen = AIR_CAST(unsigned int, nhist->axis[0].size);
+  histLen = AIR_UINT(nhist->axis[0].size);
   num1 = mean1 = 0;
   for (histIdx=0; histIdx<histLen; histIdx++) {
     num1 += hist[histIdx];
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/iter.c teem-1.11.0-src/src/nrrd/iter.c
--- teem-1.11.0-src.orig/src/nrrd/iter.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/iter.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/kernel.c teem-1.11.0-src/src/nrrd/kernel.c
--- teem-1.11.0-src.orig/src/nrrd/kernel.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/kernel.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -25,6 +25,9 @@
 
 /*
 ** summary of information about how the kernel parameter vector is set:
+** Note that, annoyingly, nrrdKernelUsesScale (at end of this file)
+** has to be updated to record which kernels (including their derivatives)
+** use parm[0] for scale.
 
                                  numParm  parm[0]   parm[1]   parm[2]
                  nrrdKernelHann    2      scale    cut-off
@@ -60,6 +63,7 @@
 ** and the default is 1.0, when given in string form
 ** E.g. "tent" is understood as "tent:1",
 ** but "gauss:4" isn't complete and won't parse; while "gauss:1,4" is good
+** See note above about nrrdKernelUsesScale (at end of this file)
 */
 
 /* these functions replace what had been a lot of
@@ -133,7 +137,7 @@
 _nrrdZero1_f(float x, const double *parm) {
   float S;
 
-  S = AIR_CAST(float, parm[0]);
+  S = AIR_FLOAT(parm[0]);
   x = AIR_ABS(x)/S;
   return _ZERO(x)/S;
 }
@@ -156,7 +160,7 @@
   float t, S;
   size_t i;
 
-  S = AIR_CAST(float, parm[0]);
+  S = AIR_FLOAT(parm[0]);
   for (i=0; i<len; i++) {
     t = x[i]; t = AIR_ABS(t)/S;
     f[i] = _ZERO(t)/S;
@@ -199,9 +203,9 @@
 _nrrdBox1_f(float x, const double *parm) {
   float S;
 
-  S = AIR_CAST(float, parm[0]);
+  S = AIR_FLOAT(parm[0]);
   x = AIR_ABS(x)/S;
-  return AIR_CAST(float, _BOX(x)/S);
+  return AIR_FLOAT(_BOX(x)/S);
 }
 
 static void
@@ -222,10 +226,10 @@
   float t, S;
   size_t i;
 
-  S = AIR_CAST(float, parm[0]);
+  S = AIR_FLOAT(parm[0]);
   for (i=0; i<len; i++) {
     t = x[i]; t = AIR_ABS(t)/S;
-    f[i] = AIR_CAST(float, _BOX(t)/S);
+    f[i] = AIR_FLOAT(_BOX(t)/S);
   }
 }
 
@@ -257,7 +261,7 @@
 _nrrdBoxSD1_f(float x, const double *parm) {
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  return AIR_CAST(float, _BOX(x));
+  return AIR_FLOAT(_BOX(x));
 }
 
 static void
@@ -278,7 +282,7 @@
   for (i=0; i<len; i++) {
     float t;
     t = AIR_ABS(x[i]);
-    f[i] = AIR_CAST(float, _BOX(t));
+    f[i] = AIR_FLOAT(_BOX(t));
   }
 }
 
@@ -320,7 +324,7 @@
 _nrrdCos4SD1_f(float x, const double *parm) {
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  return AIR_CAST(float, COS4(x));
+  return AIR_FLOAT(COS4(x));
 }
 
 static void
@@ -341,7 +345,7 @@
   for (i=0; i<len; i++) {
     float t;
     t = AIR_ABS(x[i]);
-    f[i] = AIR_CAST(float, COS4(t));
+    f[i] = AIR_FLOAT(COS4(t));
   }
 }
 
@@ -379,7 +383,7 @@
   int sgn;
   AIR_UNUSED(parm);
   if (x < 0) { x = -x; sgn = -1; } else { sgn = 1; }
-  return AIR_CAST(float, sgn*DCOS4(x));
+  return AIR_FLOAT(sgn*DCOS4(x));
 }
 
 static void
@@ -404,7 +408,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    f[i] = AIR_CAST(float, sgn*DCOS4(t));
+    f[i] = AIR_FLOAT(sgn*DCOS4(t));
   }
 }
 
@@ -439,7 +443,7 @@
 _nrrdDDCos4SD1_f(float x, const double *parm) {
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  return AIR_CAST(float, DDCOS4(x));
+  return AIR_FLOAT(DDCOS4(x));
 }
 
 static void
@@ -460,7 +464,7 @@
   for (i=0; i<len; i++) {
     float t;
     t = AIR_ABS(x[i]);
-    f[i] = AIR_CAST(float, DDCOS4(t));
+    f[i] = AIR_FLOAT(DDCOS4(t));
   }
 }
 
@@ -497,7 +501,7 @@
   int sgn;
   AIR_UNUSED(parm);
   if (x < 0) { x = -x; sgn = -1; } else { sgn = 1; }
-  return AIR_CAST(float, sgn*DDDCOS4(x));
+  return AIR_FLOAT(sgn*DDDCOS4(x));
 }
 
 static void
@@ -522,7 +526,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    f[i] = AIR_CAST(float, sgn*DDDCOS4(t));
+    f[i] = AIR_FLOAT(sgn*DDDCOS4(t));
   }
 }
 
@@ -562,7 +566,7 @@
 static float
 _nrrdCheap1_f(float x, const double *parm) {
 
-  return AIR_CAST(float, _CHEAP(x)/parm[0]);
+  return AIR_FLOAT(_CHEAP(x)/parm[0]);
 }
 
 static void
@@ -583,7 +587,7 @@
 
   for (i=0; i<len; i++) {
     t = x[i];
-    f[i] = AIR_CAST(float, _CHEAP(t)/parm[0]);
+    f[i] = AIR_FLOAT(_CHEAP(t)/parm[0]);
   }
 }
 
@@ -621,7 +625,7 @@
 _nrrdTent1_f(float x, const double *parm) {
   float S;
 
-  S = AIR_CAST(float, parm[0]);
+  S = AIR_FLOAT(parm[0]);
   x = AIR_ABS(x)/S;
   return S ? _TENT(x)/S : x == 0;
 }
@@ -644,7 +648,7 @@
   float t, S;
   size_t i;
 
-  S = AIR_CAST(float, parm[0]);
+  S = AIR_FLOAT(parm[0]);
   for (i=0; i<len; i++) {
     t = x[i]; t = AIR_ABS(t)/S;
     f[i] = S ? _TENT(t)/S : t == 0;
@@ -723,9 +727,9 @@
 
 /* ------------------------------------------------------------ */
 
-#define _FORDIF(x) (x < -1 ?  0 :        \
-                   (x <  0 ?  1 :        \
-                   (x <  1 ? -1 : 0 )))
+#define _FORDIF(x) (x < -1 ?  0.0f :        \
+                   (x <  0 ?  1.0f :        \
+                   (x <  1 ? -1.0f : 0.0f )))
 
 static double
 _nrrdFDSup(const double *parm) {
@@ -737,26 +741,25 @@
 
 static double
 _nrrdFD1_d(double x, const double *parm) {
-  double S;
+  double t, S;
 
   S = parm[0];
-  x /= S;
-  return _FORDIF(x)/(S*S);
+  t = x/S;
+  return _FORDIF(t)/(S*S);
 }
 
 static float
 _nrrdFD1_f(float x, const double *parm) {
-  float S;
+  float t, S;
 
-  S = AIR_CAST(float, parm[0]);
-  x /= S;
-  return _FORDIF(x)/(S*S);
+  S = AIR_FLOAT(parm[0]);
+  t = x/S;
+  return _FORDIF(t)/(S*S);
 }
 
 static void
 _nrrdFDN_d(double *f, const double *x, size_t len, const double *parm) {
-  double S;
-  double t;
+  double t, S;
   size_t i;
 
   S = parm[0];
@@ -771,7 +774,7 @@
   float t, S;
   size_t i;
 
-  S = AIR_CAST(float, parm[0]);
+  S = AIR_FLOAT(parm[0]);
   for (i=0; i<len; i++) {
     t = x[i]/S;
     f[i] = _FORDIF(t)/(S*S);
@@ -815,9 +818,9 @@
 _nrrdCD1_f(float x, const double *parm) {
   float S;
 
-  S = AIR_CAST(float, parm[0]);
+  S = AIR_FLOAT(parm[0]);
   x /= S;
-  return AIR_CAST(float, _CENDIF(x)/(S*S));
+  return AIR_FLOAT(_CENDIF(x)/(S*S));
 }
 
 static void
@@ -838,10 +841,10 @@
   float t, S;
   size_t i;
 
-  S = AIR_CAST(float, parm[0]);
+  S = AIR_FLOAT(parm[0]);
   for (i=0; i<len; i++) {
     t = x[i]/S;
-    f[i] = AIR_CAST(float, _CENDIF(t)/(S*S));
+    f[i] = AIR_FLOAT(_CENDIF(t)/(S*S));
   }
 }
 
@@ -884,9 +887,9 @@
 _nrrdBC1_f(float x, const double *parm) {
   float B, C, S;
 
-  S = AIR_CAST(float, parm[0]);
-  B = AIR_CAST(float, parm[1]);
-  C = AIR_CAST(float, parm[2]);
+  S = AIR_FLOAT(parm[0]);
+  B = AIR_FLOAT(parm[1]);
+  C = AIR_FLOAT(parm[2]);
   x = AIR_ABS(x)/S;
   return _BCCUBIC(x, B, C)/S;
 }
@@ -910,9 +913,9 @@
   float S, t, B, C;
   size_t i;
 
-  S = AIR_CAST(float, parm[0]);
-  B = AIR_CAST(float, parm[1]);
-  C = AIR_CAST(float, parm[2]);
+  S = AIR_FLOAT(parm[0]);
+  B = AIR_FLOAT(parm[1]);
+  C = AIR_FLOAT(parm[2]);
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t)/S;
@@ -962,12 +965,12 @@
   float B, C, S;
   int sgn = 1;
 
-  S = AIR_CAST(float, parm[0]);
-  B = AIR_CAST(float, parm[1]);
-  C = AIR_CAST(float, parm[2]);
+  S = AIR_FLOAT(parm[0]);
+  B = AIR_FLOAT(parm[1]);
+  C = AIR_FLOAT(parm[2]);
   if (x < 0) { x = -x; sgn = -1; }
   x /= S;
-  return AIR_CAST(float, sgn*_DBCCUBIC(x, B, C)/(S*S));
+  return AIR_FLOAT(sgn*_DBCCUBIC(x, B, C)/(S*S));
 }
 
 static void
@@ -991,13 +994,13 @@
   int sgn;
   size_t i;
 
-  S = AIR_CAST(float, parm[0]);
-  B = AIR_CAST(float, parm[1]);
-  C = AIR_CAST(float, parm[2]);
+  S = AIR_FLOAT(parm[0]);
+  B = AIR_FLOAT(parm[1]);
+  C = AIR_FLOAT(parm[2]);
   for (i=0; i<len; i++) {
     t = x[i]/S;
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    f[i] = AIR_CAST(float, sgn*_DBCCUBIC(t, B, C)/(S*S));
+    f[i] = AIR_FLOAT(sgn*_DBCCUBIC(t, B, C)/(S*S));
   }
 }
 
@@ -1040,9 +1043,9 @@
 _nrrdDDBC1_f(float x, const double *parm) {
   float B, C, S;
 
-  S = AIR_CAST(float, parm[0]);
-  B = AIR_CAST(float, parm[1]);
-  C = AIR_CAST(float, parm[2]);
+  S = AIR_FLOAT(parm[0]);
+  B = AIR_FLOAT(parm[1]);
+  C = AIR_FLOAT(parm[2]);
   x = AIR_ABS(x)/S;
   return _DDBCCUBIC(x, B, C)/(S*S*S);
 }
@@ -1066,9 +1069,9 @@
   float S, t, B, C;
   size_t i;
 
-  S = AIR_CAST(float, parm[0]);
-  B = AIR_CAST(float, parm[1]);
-  C = AIR_CAST(float, parm[2]);
+  S = AIR_FLOAT(parm[0]);
+  B = AIR_FLOAT(parm[1]);
+  C = AIR_FLOAT(parm[2]);
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t)/S;
@@ -1101,7 +1104,7 @@
 _nrrdCTMR1_f(float x, const double *parm) {
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  return AIR_CAST(float, _CTMR(x));
+  return AIR_FLOAT(_CTMR(x));
 }
 
 static void
@@ -1124,7 +1127,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t);
-    f[i] = AIR_CAST(float, _CTMR(t));
+    f[i] = AIR_FLOAT(_CTMR(t));
   }
 }
 
@@ -1171,7 +1174,7 @@
   int sgn;
   AIR_UNUSED(parm);
   if (x < 0) { x = -x; sgn = -1; } else { sgn = 1; }
-  return AIR_CAST(float, sgn*_DCTMR(x));
+  return AIR_FLOAT(sgn*_DCTMR(x));
 }
 
 static void
@@ -1196,7 +1199,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    f[i] = AIR_CAST(float, sgn*_DCTMR(t));
+    f[i] = AIR_FLOAT(sgn*_DCTMR(t));
   }
 }
 
@@ -1234,7 +1237,7 @@
 _nrrdDDCTMR1_f(float x, const double *parm) {
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  return AIR_CAST(float, _DDCTMR(x));
+  return AIR_FLOAT(_DDCTMR(x));
 }
 
 static void
@@ -1257,7 +1260,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t);
-    f[i] = AIR_CAST(float, _DDCTMR(t));
+    f[i] = AIR_FLOAT(_DDCTMR(t));
   }
 }
 
@@ -1312,9 +1315,9 @@
 _nrrdA41_f(float x, const double *parm) {
   float A, S;
 
-  S = AIR_CAST(float, parm[0]); A = AIR_CAST(float, parm[1]);
+  S = AIR_FLOAT(parm[0]); A = AIR_FLOAT(parm[1]);
   x = AIR_ABS(x)/S;
-  return AIR_CAST(float, _AQUARTIC(x, A)/S);
+  return AIR_FLOAT(_AQUARTIC(x, A)/S);
 }
 
 static void
@@ -1336,11 +1339,11 @@
   float S, t, A;
   size_t i;
 
-  S = AIR_CAST(float, parm[0]); A = AIR_CAST(float, parm[1]);
+  S = AIR_FLOAT(parm[0]); A = AIR_FLOAT(parm[1]);
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t)/S;
-    f[i] = AIR_CAST(float, _AQUARTIC(t, A)/S);
+    f[i] = AIR_FLOAT(_AQUARTIC(t, A)/S);
   }
 }
 
@@ -1388,10 +1391,10 @@
   float A, S;
   int sgn = 1;
 
-  S = AIR_CAST(float, parm[0]); A = AIR_CAST(float, parm[1]);
+  S = AIR_FLOAT(parm[0]); A = AIR_FLOAT(parm[1]);
   if (x < 0) { x = -x; sgn = -1; }
   x /= S;
-  return AIR_CAST(float, sgn*_DAQUARTIC(x, A)/(S*S));
+  return AIR_FLOAT(sgn*_DAQUARTIC(x, A)/(S*S));
 }
 
 static void
@@ -1415,11 +1418,11 @@
   size_t i;
   int sgn;
 
-  S = AIR_CAST(float, parm[0]); A = AIR_CAST(float, parm[1]);
+  S = AIR_FLOAT(parm[0]); A = AIR_FLOAT(parm[1]);
   for (i=0; i<len; i++) {
     t = x[i]/S;
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    f[i] = AIR_CAST(float, sgn*_DAQUARTIC(t, A)/(S*S));
+    f[i] = AIR_FLOAT(sgn*_DAQUARTIC(t, A)/(S*S));
   }
 }
 
@@ -1464,7 +1467,7 @@
 _nrrdDDA41_f(float x, const double *parm) {
   float S, A;
 
-  S = AIR_CAST(float, parm[0]); A = AIR_CAST(float, parm[1]);
+  S = AIR_FLOAT(parm[0]); A = AIR_FLOAT(parm[1]);
   x = AIR_ABS(x)/S;
   return _DDAQUARTIC(x, A)/(S*S*S);
 }
@@ -1488,7 +1491,7 @@
   float S, t, A;
   size_t i;
 
-  S = AIR_CAST(float, parm[0]); A = AIR_CAST(float, parm[1]);
+  S = AIR_FLOAT(parm[0]); A = AIR_FLOAT(parm[1]);
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t)/S;
@@ -1543,7 +1546,7 @@
 _c3quint1_f(float x, const double *parm) {
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  return AIR_CAST(float, _C3QUINTIC(x));
+  return AIR_FLOAT(_C3QUINTIC(x));
 }
 
 static void
@@ -1566,7 +1569,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t);
-    f[i] = AIR_CAST(float, _C3QUINTIC(t));
+    f[i] = AIR_FLOAT(_C3QUINTIC(t));
   }
 }
 
@@ -1600,7 +1603,7 @@
   int sgn = 1;
   AIR_UNUSED(parm);
   if (x < 0) { x = -x; sgn = -1; }
-  return AIR_CAST(float, sgn*_DC3QUINTIC(x));
+  return AIR_FLOAT(sgn*_DC3QUINTIC(x));
 }
 
 static void
@@ -1625,7 +1628,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    f[i] = AIR_CAST(float, sgn*_DC3QUINTIC(t));
+    f[i] = AIR_FLOAT(sgn*_DC3QUINTIC(t));
   }
 }
 
@@ -1657,7 +1660,7 @@
 _DDc3quint1_f(float x, const double *parm) {
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  return AIR_CAST(float, _DDC3QUINTIC(x));
+  return AIR_FLOAT(_DDC3QUINTIC(x));
 }
 
 static void
@@ -1680,7 +1683,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t);
-    f[i] = AIR_CAST(float, _DDC3QUINTIC(t));
+    f[i] = AIR_FLOAT(_DDC3QUINTIC(t));
   }
 }
 
@@ -1726,7 +1729,7 @@
 _c4hex1_f(float x, const double *parm) {
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  return AIR_CAST(float, _C4HEXIC(x));
+  return AIR_FLOAT(_C4HEXIC(x));
 }
 
 static void
@@ -1749,7 +1752,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t);
-    f[i] = AIR_CAST(float, _C4HEXIC(t));
+    f[i] = AIR_FLOAT(_C4HEXIC(t));
   }
 }
 
@@ -1786,7 +1789,7 @@
   int sgn = 1;
   AIR_UNUSED(parm);
   if (x < 0) { x = -x; sgn = -1; }
-  return AIR_CAST(float, sgn*_DC4HEXIC(x));
+  return AIR_FLOAT(sgn*_DC4HEXIC(x));
 }
 
 static void
@@ -1811,7 +1814,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    f[i] = AIR_CAST(float, sgn*_DC4HEXIC(t));
+    f[i] = AIR_FLOAT(sgn*_DC4HEXIC(t));
   }
 }
 
@@ -1846,7 +1849,7 @@
 _DDc4hex1_f(float x, const double *parm) {
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  return AIR_CAST(float, _DDC4HEXIC(x));
+  return AIR_FLOAT(_DDC4HEXIC(x));
 }
 
 static void
@@ -1869,7 +1872,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t);
-    f[i] = AIR_CAST(float, _DDC4HEXIC(t));
+    f[i] = AIR_FLOAT(_DDC4HEXIC(t));
   }
 }
 
@@ -1907,7 +1910,7 @@
   int sgn = 1;
   AIR_UNUSED(parm);
   if (x < 0) { x = -x; sgn = -1; }
-  return AIR_CAST(float, sgn*_DDDC4HEXIC(x));
+  return AIR_FLOAT(sgn*_DDDC4HEXIC(x));
 }
 
 static void
@@ -1932,7 +1935,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    f[i] = AIR_CAST(float, sgn*_DDDC4HEXIC(t));
+    f[i] = AIR_FLOAT(sgn*_DDDC4HEXIC(t));
   }
 }
 
@@ -1971,7 +1974,7 @@
 }
 
 #define C4HEX_ANI(ret, tmp, x)                  \
-  tmp = AIR_CAST(unsigned int, x+0.5);          \
+  tmp = AIR_UINT(x+0.5);          \
   if (tmp < 12) {                               \
     ret = _c4hex_ANI_kvals[tmp];                \
   } else {                                      \
@@ -1993,7 +1996,7 @@
   AIR_UNUSED(parm);
   ax = AIR_ABS(x);
   C4HEX_ANI(r, tmp, ax);
-  return AIR_CAST(float, r);
+  return AIR_FLOAT(r);
 }
 
 static void
@@ -2016,7 +2019,7 @@
   for (i=0; i<len; i++) {
     ax = x[i]; ax = AIR_ABS(ax);
     C4HEX_ANI(r, tmp, ax);
-    f[i] = AIR_CAST(float, r);
+    f[i] = AIR_FLOAT(r);
   }
 }
 
@@ -2055,7 +2058,7 @@
   unsigned int xi;
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  xi = AIR_CAST(unsigned int, x);
+  xi = AIR_UINT(x);
   x -= xi;
   return _C5SEPT(xi, x);
 }
@@ -2065,9 +2068,9 @@
   unsigned int xi;
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  xi = AIR_CAST(unsigned int, x);
-  x -= AIR_CAST(float, xi);
-  return AIR_CAST(float, _C5SEPT(xi, x));
+  xi = AIR_UINT(x);
+  x -= AIR_FLOAT(xi);
+  return AIR_FLOAT(_C5SEPT(xi, x));
 }
 
 static void
@@ -2079,7 +2082,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t);
-    ti = AIR_CAST(unsigned int, t);
+    ti = AIR_UINT(t);
     t -= ti;
     f[i] = _C5SEPT(ti, t);
   }
@@ -2094,9 +2097,9 @@
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t);
-    ti = AIR_CAST(unsigned int, t);
-    t -= AIR_CAST(float, ti);
-    f[i] = AIR_CAST(float, _C5SEPT(ti, t));
+    ti = AIR_UINT(t);
+    t -= AIR_FLOAT(ti);
+    f[i] = AIR_FLOAT(_C5SEPT(ti, t));
   }
 }
 
@@ -2126,7 +2129,7 @@
   int sgn = 1;
   AIR_UNUSED(parm);
   if (x < 0) { x = -x; sgn = -1; }
-  xi = AIR_CAST(unsigned int, x);
+  xi = AIR_UINT(x);
   x -= xi;
   return sgn*_DC5SEPT(xi, x);
 }
@@ -2137,9 +2140,9 @@
   int sgn = 1;
   AIR_UNUSED(parm);
   if (x < 0) { x = -x; sgn = -1; }
-  xi = AIR_CAST(unsigned int, x);
-  x -= AIR_CAST(float, xi);
-  return AIR_CAST(float, sgn*_DC5SEPT(xi, x));
+  xi = AIR_UINT(x);
+  x -= AIR_FLOAT(xi);
+  return AIR_FLOAT(sgn*_DC5SEPT(xi, x));
 }
 
 static void
@@ -2152,7 +2155,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    ti = AIR_CAST(unsigned int, t);
+    ti = AIR_UINT(t);
     t -= ti;
     f[i] = sgn*_DC5SEPT(ti, t);
   }
@@ -2168,9 +2171,9 @@
   for (i=0; i<len; i++) {
     t = x[i];
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    ti = AIR_CAST(unsigned int, t);
-    t -= AIR_CAST(float, ti);
-    f[i] = AIR_CAST(float, sgn*_DC5SEPT(ti, t));
+    ti = AIR_UINT(t);
+    t -= AIR_FLOAT(ti);
+    f[i] = AIR_FLOAT(sgn*_DC5SEPT(ti, t));
   }
 }
 
@@ -2199,7 +2202,7 @@
   unsigned int xi;
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  xi = AIR_CAST(unsigned int, x);
+  xi = AIR_UINT(x);
   x -= xi;
   return _DDC5SEPT(xi, x);
 }
@@ -2209,9 +2212,9 @@
   unsigned int xi;
   AIR_UNUSED(parm);
   x = AIR_ABS(x);
-  xi = AIR_CAST(unsigned int, x);
-  x -= AIR_CAST(float, xi);
-  return AIR_CAST(float, _DDC5SEPT(xi, x));
+  xi = AIR_UINT(x);
+  x -= AIR_FLOAT(xi);
+  return AIR_FLOAT(_DDC5SEPT(xi, x));
 }
 
 static void
@@ -2223,7 +2226,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t);
-    ti = AIR_CAST(unsigned int, t);
+    ti = AIR_UINT(t);
     t -= ti;
     f[i] = _DDC5SEPT(ti, t);
   }
@@ -2238,9 +2241,9 @@
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t);
-    ti = AIR_CAST(unsigned int, t);
-    t -= AIR_CAST(float, ti);
-    f[i] = AIR_CAST(float, _DDC5SEPT(ti, t));
+    ti = AIR_UINT(t);
+    t -= AIR_FLOAT(ti);
+    f[i] = AIR_FLOAT(_DDC5SEPT(ti, t));
   }
 }
 
@@ -2270,7 +2273,7 @@
   int sgn = 1;
   AIR_UNUSED(parm);
   if (x < 0) { x = -x; sgn = -1; }
-  xi = AIR_CAST(unsigned int, x);
+  xi = AIR_UINT(x);
   x -= xi;
   return sgn*_DDDC5SEPT(xi, x);
 }
@@ -2281,9 +2284,9 @@
   int sgn = 1;
   AIR_UNUSED(parm);
   if (x < 0) { x = -x; sgn = -1; }
-  xi = AIR_CAST(unsigned int, x);
-  x -= AIR_CAST(float, xi);
-  return AIR_CAST(float, sgn*_DDDC5SEPT(xi, x));
+  xi = AIR_UINT(x);
+  x -= AIR_FLOAT(xi);
+  return AIR_FLOAT(sgn*_DDDC5SEPT(xi, x));
 }
 
 static void
@@ -2296,7 +2299,7 @@
   for (i=0; i<len; i++) {
     t = x[i];
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    ti = AIR_CAST(unsigned int, t);
+    ti = AIR_UINT(t);
     t -= ti;
     f[i] = sgn*_DDDC5SEPT(ti, t);
   }
@@ -2312,9 +2315,9 @@
   for (i=0; i<len; i++) {
     t = x[i];
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    ti = AIR_CAST(unsigned int, t);
-    t -= AIR_CAST(float, ti);
-    f[i] = AIR_CAST(float, sgn*_DDDC5SEPT(ti, t));
+    ti = AIR_UINT(t);
+    t -= AIR_FLOAT(ti);
+    f[i] = AIR_FLOAT(sgn*_DDDC5SEPT(ti, t));
   }
 }
 
@@ -2375,7 +2378,7 @@
 }
 
 #define C5SEPT_ANI(ret, tmp, x)                  \
-  tmp = AIR_CAST(unsigned int, x+0.5);           \
+  tmp = AIR_UINT(x+0.5);           \
   if (tmp < C5SEPT_AI_LEN) {                     \
     ret = _c5sept_ANI_kvals[tmp];                \
   } else {                                       \
@@ -2399,7 +2402,7 @@
 
   ax = AIR_ABS(x);
   C5SEPT_ANI(r, tmp, ax);
-  return AIR_CAST(float, r);
+  return AIR_FLOAT(r);
 }
 
 static void
@@ -2424,7 +2427,7 @@
   for (i=0; i<len; i++) {
     ax = x[i]; ax = AIR_ABS(ax);
     C5SEPT_ANI(r, tmp, ax);
-    f[i] = AIR_CAST(float, r);
+    f[i] = AIR_FLOAT(r);
   }
 }
 
@@ -2475,10 +2478,10 @@
 _nrrdG1_f(float x, const double *parm) {
   float sig, cut;
 
-  sig = AIR_CAST(float, parm[0]);
-  cut = AIR_CAST(float, parm[1]);
+  sig = AIR_FLOAT(parm[0]);
+  cut = AIR_FLOAT(parm[1]);
   x = AIR_ABS(x);
-  return AIR_CAST(float, _GAUSS(x, sig, cut));
+  return AIR_FLOAT(_GAUSS(x, sig, cut));
 }
 
 static void
@@ -2500,12 +2503,12 @@
   float sig, cut, t;
   size_t i;
 
-  sig = AIR_CAST(float, parm[0]);
-  cut = AIR_CAST(float, parm[1]);
+  sig = AIR_FLOAT(parm[0]);
+  cut = AIR_FLOAT(parm[1]);
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t);
-    f[i] = AIR_CAST(float, _GAUSS(t, sig, cut));
+    f[i] = AIR_FLOAT(_GAUSS(t, sig, cut));
   }
 }
 
@@ -2524,12 +2527,19 @@
   (sig > 0                                                      \
    ? (xx > abscut                                               \
       ? 0                                                       \
-      : airBesselInExpScaled(AIR_CAST(int, xx + 0.5), sig*sig)) \
+      : airBesselInExpScaled(AIR_INT(xx + 0.5), sig*sig))       \
    : xx <= 0.5)
 
+/* the last line used to be AIR_MAX(0.5, (ret)), but the problem was
+   that even for reasonable cutoffs, like sigma=6, there would be a
+   sudden change in the non-zero values at the edge of the kernel with
+   slowly increasing sigma. The real solution is to have a smarter way
+   of determining where to cut-off this particular kernel, the
+   discrete gaussian, when the values are at the low level one would
+   expect with "sigma=6" when talking about a continuous Gaussian */
 #define _DGABSCUT(ret, sig, cut) \
   (ret) = 0.5 + ceil((sig)*(cut));  \
-  (ret) = AIR_MAX(0.5, (ret))
+  (ret) = AIR_MAX(2.5, (ret))
 
 static double
 _nrrdDiscGaussianSup(const double *parm) {
@@ -2559,7 +2569,7 @@
   int ii, supp;
 
   _DGABSCUT(cut, parm[0], parm[1]);
-  supp = AIR_CAST(int, cut);
+  supp = AIR_INT(cut);
   sum = 0.0;
   for (ii=-supp; ii<=supp; ii++) {
     sum += _nrrdDiscGaussian1_d(ii, parm);
@@ -2574,7 +2584,7 @@
   sig = parm[0];
   _DGABSCUT(cut, sig, parm[1]);
   xx = AIR_ABS(xx);
-  return AIR_CAST(float, _DISCRETEGAUSS(xx, sig, cut));
+  return AIR_FLOAT(_DISCRETEGAUSS(xx, sig, cut));
 }
 
 static void
@@ -2600,7 +2610,7 @@
   _DGABSCUT(cut, sig, parm[1]);
   for (ii=0; ii<len; ii++) {
     tt = AIR_ABS(x[ii]);
-    f[ii] = AIR_CAST(float, _DISCRETEGAUSS(tt, sig, cut));
+    f[ii] = AIR_FLOAT(_DISCRETEGAUSS(tt, sig, cut));
   }
 }
 
@@ -2614,6 +2624,17 @@
 NrrdKernel *const
 nrrdKernelDiscreteGaussian = &_nrrdKernelDiscreteGaussian;
 
+/* The current implementation of nrrdKernelDiscreteGaussian, with the current
+   implementation of airBesselInExpScaled, has problems for large
+   sigma. Until those are fixed, this is a suggested limit on how big sigma
+   (kparm[0]) can be and still have an accurate blurring kernel.  This
+   problem can be avoided completely by doing the blurring in frequency
+   space, which is implemented in teem/src/gage/stackBlur.c's
+   _stackBlurDiscreteGaussFFT(), although that has its own problem: in places
+   where a signal really should zero, the FFT can produce some very
+   low-amplitude noise (and hence new extrema) */
+const double nrrdKernelDiscreteGaussianGoodSigmaMax = 6.0;
+
 /* ------------------------------------------------------------ */
 
 #define _DGAUSS(x, sig, cut) (                                               \
@@ -2651,10 +2672,10 @@
   float sig, cut;
   int sgn = 1;
 
-  sig = AIR_CAST(float, parm[0]);
-  cut = AIR_CAST(float, parm[1]);
+  sig = AIR_FLOAT(parm[0]);
+  cut = AIR_FLOAT(parm[1]);
   if (x < 0) { x = -x; sgn = -1; }
-  return AIR_CAST(float, sgn*_DGAUSS(x, sig, cut));
+  return AIR_FLOAT(sgn*_DGAUSS(x, sig, cut));
 }
 
 static void
@@ -2678,12 +2699,12 @@
   size_t i;
   int sgn;
 
-  sig = AIR_CAST(float, parm[0]);
-  cut = AIR_CAST(float, parm[1]);
+  sig = AIR_FLOAT(parm[0]);
+  cut = AIR_FLOAT(parm[1]);
   for (i=0; i<len; i++) {
     t = x[i];
     if (t < 0) { t = -t; sgn = -1; } else { sgn = 1; }
-    f[i] = AIR_CAST(float, sgn*_DGAUSS(t, sig, cut));
+    f[i] = AIR_FLOAT(sgn*_DGAUSS(t, sig, cut));
   }
 }
 
@@ -2735,10 +2756,10 @@
 _nrrdDDG1_f(float x, const double *parm) {
   float sig, cut;
 
-  sig = AIR_CAST(float, parm[0]);
-  cut = AIR_CAST(float, parm[1]);
+  sig = AIR_FLOAT(parm[0]);
+  cut = AIR_FLOAT(parm[1]);
   x = AIR_ABS(x);
-  return AIR_CAST(float, _DDGAUSS(x, sig, cut));
+  return AIR_FLOAT(_DDGAUSS(x, sig, cut));
 }
 
 static void
@@ -2760,12 +2781,12 @@
   float sig, cut, t;
   size_t i;
 
-  sig = AIR_CAST(float, parm[0]);
-  cut = AIR_CAST(float, parm[1]);
+  sig = AIR_FLOAT(parm[0]);
+  cut = AIR_FLOAT(parm[1]);
   for (i=0; i<len; i++) {
     t = x[i];
     t = AIR_ABS(t);
-    f[i] = AIR_CAST(float, _DDGAUSS(t, sig, cut));
+    f[i] = AIR_FLOAT(_DDGAUSS(t, sig, cut));
   }
 }
 
@@ -2991,7 +3012,7 @@
       airMopAdd(mop, tmfStr[2], airFree, airMopAlways);
       airMopAdd(mop, tmfStr[3], airFree, airMopAlways);
       /* a TMF with a parameter: D,C,A,a */
-      if (1 != sscanf(tmfStr[3], "%lg", parm)) {
+      if (1 != airSingleSscanf(tmfStr[3], "%lg", parm)) {
         biffAddf(NRRD, "%s: couldn't parse TMF parameter \"%s\" as double",
                  me, tmfStr[3]);
         airMopError(mop); return 1;
@@ -3073,7 +3094,7 @@
     for (haveParm=0; haveParm<(*kernelP)->numParm; haveParm++) {
       if (!pstr)
         break;
-      if (1 != sscanf(pstr, "%lg", parm+haveParm)) {
+      if (1 != airSingleSscanf(pstr, "%lg", parm+haveParm)) {
         biffAddf(NRRD, "%s: trouble parsing \"%s\" as double (in \"%s\")",
                  me, _pstr, _str);
         airMopError(mop); return 1;
@@ -3211,6 +3232,10 @@
   return 0;
 }
 
+/*
+** This DOES make an effort to set *differ based on "ordering" (-1 or +1)
+** but HEY that's very contrived; why bother?
+*/
 int
 nrrdKernelCompare(const NrrdKernel *kernA,
                   const double parmA[NRRD_KERNEL_PARMS_NUM],
@@ -3240,7 +3265,7 @@
   }
   if (!(parmA && parmB)) {
     biffAddf(NRRD, "%s: kernel %s needs %u parms but got NULL parm vectors",
-             me, kernA->name ? kernA->name : "(unnamed)", pnum);
+             me, kernA->name, pnum);
     return 0;
   }
   for (pidx=0; pidx<pnum; pidx++) {
@@ -3260,9 +3285,76 @@
 }
 
 /*
+** This DOES NOT make an effort to set *differ based on "ordering";
+*/
+int
+nrrdKernelSpecCompare(const NrrdKernelSpec *aa,
+                      const NrrdKernelSpec *bb,
+                      int *differ, char explain[AIR_STRLEN_LARGE]) {
+  static const char me[]="nrrdKernelSpecCompare";
+  char subexplain[AIR_STRLEN_LARGE];
+
+  if (!( differ )) {
+    biffAddf(NRRD, "%s: got NULL differ", me);
+    return 1;
+  }
+  if (!!aa != !!bb) {
+    if (explain) {
+      sprintf(explain, "different NULL-ities of kspec itself %s != %s",
+              aa ? "non-NULL" : "NULL",
+              bb ? "non-NULL" : "NULL");
+    }
+    *differ = 1; return 0;
+  }
+  if (!aa) {
+    /* got two NULL kernel specs ==> equal */
+    *differ = 0; return 0;
+  }
+  if (!!aa->kernel != !!bb->kernel) {
+    if (explain) {
+      sprintf(explain, "different NULL-ities of kspec->kernel %s != %s",
+              aa->kernel ? "non-NULL" : "NULL",
+              bb->kernel ? "non-NULL" : "NULL");
+    }
+    *differ = 1; return 0;
+  }
+  if (!aa->kernel) {
+    /* both kernels NULL, can't do anything informative with parms */
+    *differ = 0; return 0;
+  }
+  if (nrrdKernelCompare(aa->kernel, aa->parm,
+                        bb->kernel, bb->parm,
+                        differ, subexplain)) {
+    biffAddf(NRRD, "%s: trouble comparing kernels", me);
+    return 1;
+  }
+  if (*differ) {
+    if (explain) {
+      sprintf(explain, "kern/parm pairs differ: %s", subexplain);
+    }
+    *differ = 1; /* losing ordering info (of dubious value) */
+    return 0;
+  }
+  *differ = 0;
+  return 0;
+}
+
+/*
 ******** nrrdKernelCheck
 **
 ** Makes sure a given kernel is behaving as expected
+**
+** Tests:
+** nrrdKernelSprint
+** nrrdKernelParse
+** nrrdKernelCompare
+** nrrdKernelSpecNew
+** nrrdKernelSpecNix
+** nrrdKernelSpecSet
+** nrrdKernelSpecSprint
+** nrrdKernelSpecParse
+** and also exercises all the ways of evaluating the kernel and
+** makes sure they all agree, and agree with the integral kernel, if given
 */
 int
 nrrdKernelCheck(const NrrdKernel *kern,
@@ -3275,49 +3367,72 @@
   const NrrdKernel *parsedkern;
   double parsedparm[NRRD_KERNEL_PARMS_NUM], supp, integral;
   static const char me[]="nrrdKernelCheck";
-  char kstr[AIR_STRLEN_LARGE], explain[AIR_STRLEN_LARGE],
-    stmp[AIR_STRLEN_SMALL];
+  char kstr[AIR_STRLEN_LARGE], kspstr[AIR_STRLEN_LARGE],
+    explain[AIR_STRLEN_LARGE], stmp[AIR_STRLEN_SMALL];
   int differ;
   size_t evalIdx;
   double *dom_d, *ran_d, wee;
   float *dom_f, *ran_f;
   unsigned int diffOkEvalNum, diffOkIntglNum;
+  NrrdKernelSpec *kspA, *kspB;
   airArray *mop;
 
+  mop = airMopNew();
   if (!kern) {
     biffAddf(NRRD, "%s: got NULL kernel", me);
-    return 1;
+    airMopError(mop); return 1;
   }
   if (!(evalNum > 20)) {
     biffAddf(NRRD, "%s: need evalNum > 20", me);
-    return 1;
+    airMopError(mop); return 1;
   }
-  if (!(kern->name && kern->support && kern->integral
+  if (!(kern->support && kern->integral
         && kern->eval1_f && kern->evalN_f
         && kern->eval1_d && kern->evalN_d)) {
-    biffAddf(NRRD, "%s: kernel has NULL fields (%d,%d,%d,%d,%d,%d,%d)", me,
-             !!(kern->name), !!(kern->support), !!(kern->integral),
+    biffAddf(NRRD, "%s: kernel has NULL fields (%d,%d,%d,%d,%d,%d)", me,
+             !!(kern->support), !!(kern->integral),
              !!(kern->eval1_f), !!(kern->evalN_f),
              !!(kern->eval1_d), !!(kern->evalN_d));
-    return 0;
+    airMopError(mop); return 1;
   }
-  if (nrrdKernelSprint(kstr, kern, parm)) {
+  kspA = nrrdKernelSpecNew();
+  airMopAdd(mop, kspA, (airMopper)nrrdKernelSpecNix, airMopAlways);
+  kspB = nrrdKernelSpecNew();
+  airMopAdd(mop, kspB, (airMopper)nrrdKernelSpecNix, airMopAlways);
+  nrrdKernelSpecSet(kspA, kern, parm);
+  if (nrrdKernelSprint(kstr, kern, parm)
+      || nrrdKernelSpecSprint(kspstr, kspA)) {
     biffAddf(NRRD, "%s: trouble", me);
-    return 1;
+    airMopError(mop); return 1;
   }
-  if (nrrdKernelParse(&parsedkern, parsedparm, kstr)) {
-    biffAddf(NRRD, "%s: trouble parsing |%s| back to kern/parm pair",
+  if (strcmp(kstr, kspstr)) {
+    biffAddf(NRRD, "%s: sprinted kernel |%s| != kspec |%s|", me, kstr, kspstr);
+    airMopError(mop); return 1;
+  }
+  if (nrrdKernelParse(&parsedkern, parsedparm, kstr)
+      || nrrdKernelSpecParse(kspB, kstr)) {
+    biffAddf(NRRD, "%s: trouble parsing |%s| back to kern/parm pair or kspec",
              me, kstr);
-    return 1;
+    airMopError(mop); return 1;
   }
   if (nrrdKernelCompare(kern, parm, parsedkern, parsedparm,
                         &differ, explain)) {
-    biffAddf(NRRD, "%s: trouble comparing", me);
-    return 1;
+    biffAddf(NRRD, "%s: trouble comparing kern/parm pairs", me);
+    airMopError(mop); return 1;
   }
   if (differ) {
     biffAddf(NRRD, "%s: given and re-parsed kernels differ: %s", me, explain);
-    return 1;
+    airMopError(mop); return 1;
+  }
+  if (nrrdKernelCompare(kspA->kernel, kspA->parm,
+                        kspB->kernel, kspB->parm,
+                        &differ, explain)) {
+    biffAddf(NRRD, "%s: trouble comparing kspecs", me);
+    airMopError(mop); return 1;
+  }
+  if (differ) {
+    biffAddf(NRRD, "%s: given and re-parsed kspecs differ: %s", me, explain);
+    airMopError(mop); return 1;
   }
 
   supp = kern->support(parm);
@@ -3333,10 +3448,9 @@
       /* the "cheap" kernel alone gets a pass on reporting its support */
       biffAddf(NRRD, "%s: kern %s is non-zero outside support %g",
                me, kstr, supp);
-      return 1;
+      airMopError(mop); return 1;
     }
   }
-  mop = airMopNew();
   /* allocate domain and range for both float and double */
   dom_d = AIR_CALLOC(evalNum, double);
   airMopAdd(mop, dom_d, airFree, airMopAlways);
@@ -3355,14 +3469,14 @@
     dom_d[evalIdx] = AIR_AFFINE(-0.5, evalIdx,
                                 AIR_CAST(double, evalNum)-0.5,
                                 -supp, supp);
-    dom_f[evalIdx] = AIR_CAST(float, dom_d[evalIdx]);
+    dom_f[evalIdx] = AIR_FLOAT(dom_d[evalIdx]);
   }
   /* do the vector evaluations */
   kern->evalN_f(ran_f, dom_f, evalNum, parm);
   kern->evalN_d(ran_d, dom_d, evalNum, parm);
   /*
   for (evalIdx=0; evalIdx<evalNum; evalIdx++) {
-    fprintf(stderr, "%u %g --> %g\n", AIR_CAST(unsigned int, evalIdx),
+    fprintf(stderr, "%u %g --> %g\n", AIR_UINT(evalIdx),
             dom_d[evalIdx], ran_d[evalIdx]);
   }
   */
@@ -3377,11 +3491,41 @@
     single_d = kern->eval1_d(dom_d[evalIdx], parm);
     integral += single_d;
     /* single float vs vector float */
-    if (single_f != ran_f[evalIdx]) {
-      biffAddf(NRRD, "%s: %s (eval1_f(%.17g)=%.17g) != (evalN_f(%.17g)=%.17g)",
-               me, kstr, dom_f[evalIdx], single_f,
-               dom_f[evalIdx], ran_f[evalIdx]);
-      airMopError(mop); return 1;
+    if (nrrdKernelForwDiff == kern
+        || nrrdKernelBCCubic == kern
+        || nrrdKernelBCCubicDD == kern
+        || nrrdKernelAQuarticDD == kern) {
+      /* HEY this is crazy: need a special epsilon for these kernels;
+         WHY WHY do these kernels evaluate to different things in the
+         single versus the vector case? */
+      float specEps;
+      if (nrrdKernelForwDiff == kern) {
+        specEps = 5e-9f;
+      } else if (nrrdKernelBCCubic == kern) {
+        specEps = 5e-8f;
+      } else if (nrrdKernelBCCubicDD == kern) {
+        specEps = 5e-8f;
+      } else if (nrrdKernelAQuarticDD == kern) {
+        specEps = 5e-8f;
+      } else {
+        specEps = 0.0;
+      }
+      if (fabs(single_f - ran_f[evalIdx]) > specEps) {
+        biffAddf(NRRD, "%s: %s (eval1_f(%.17g)=%.17g) != "
+                 "(evalN_f(%.17g)=%.17g) by %.17g > %.17g",
+                 me, kstr, dom_f[evalIdx], single_f,
+                 dom_f[evalIdx], ran_f[evalIdx],
+                 fabs(single_f - ran_f[evalIdx]), specEps);
+        airMopError(mop); return 1;
+      }
+    } else {
+      if (single_f != ran_f[evalIdx]) {
+        biffAddf(NRRD, "%s: %s (eval1_f(%.17g)=%.17g) != "
+                 "(evalN_f(%.17g)=%.17g)",
+                 me, kstr, dom_f[evalIdx], single_f,
+                 dom_f[evalIdx], ran_f[evalIdx]);
+        airMopError(mop); return 1;
+      }
     }
     /* single double vs vector double */
     if (single_d != ran_d[evalIdx]) {
@@ -3444,3 +3588,38 @@
   airMopOkay(mop);
   return 0;
 }
+
+int
+nrrdKernelParm0IsScale(const NrrdKernel *kern) {
+  int ret;
+
+  if (!kern) {
+    ret = 0;
+  } else if (nrrdKernelHann == kern ||
+             nrrdKernelHannD == kern ||
+             nrrdKernelHannDD == kern ||
+             nrrdKernelBlackman == kern ||
+             nrrdKernelBlackmanD == kern ||
+             nrrdKernelBlackmanDD == kern ||
+             nrrdKernelZero == kern ||
+             nrrdKernelBox == kern ||
+             nrrdKernelCheap == kern ||
+             nrrdKernelTent == kern ||
+             nrrdKernelForwDiff == kern ||
+             nrrdKernelCentDiff == kern ||
+             nrrdKernelBCCubic == kern ||
+             nrrdKernelBCCubicD == kern ||
+             nrrdKernelBCCubicDD == kern ||
+             nrrdKernelAQuartic == kern ||
+             nrrdKernelAQuarticD == kern ||
+             nrrdKernelAQuarticDD == kern ||
+             nrrdKernelGaussian == kern ||
+             nrrdKernelGaussianD == kern ||
+             nrrdKernelGaussianDD == kern ||
+             nrrdKernelDiscreteGaussian == kern) {
+    ret = 1;
+  } else {
+    ret = 0;
+  }
+  return ret;
+}
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/keyvalue.c teem-1.11.0-src/src/nrrd/keyvalue.c
--- teem-1.11.0-src.orig/src/nrrd/keyvalue.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/keyvalue.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/map.c teem-1.11.0-src/src/nrrd/map.c
--- teem-1.11.0-src.orig/src/nrrd/map.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/map.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -134,8 +134,9 @@
 */
 
 static int
-clampConvert(Nrrd *nout, const Nrrd *nin, int type, int doClamp) {
-  static const char me[]="clampConvert";
+clampRoundConvert(Nrrd *nout, const Nrrd *nin, int type,
+                  int doClamp, int roundDir) {
+  static const char me[]="clampRoundConvert";
   char typeS[AIR_STRLEN_SMALL];
   size_t num, size[NRRD_DIM_MAX];
 
@@ -191,7 +192,10 @@
 
     /* call the appropriate converter */
     num = nrrdElementNumber(nin);
-    if (doClamp) {
+    if (roundDir) {
+      _nrrdCastClampRound[nout->type][nin->type](nout->data, nin->data, num,
+                                                 doClamp, roundDir);
+    } else if (doClamp) {
       _nrrdClampConv[nout->type][nin->type](nout->data, nin->data, num);
     } else {
       _nrrdConv[nout->type][nin->type](nout->data, nin->data, num);
@@ -236,7 +240,9 @@
 nrrdConvert(Nrrd *nout, const Nrrd *nin, int type) {
   static const char me[]="nrrdConvert";
 
-  if (clampConvert(nout, nin, type, AIR_FALSE)) {
+  if (clampRoundConvert(nout, nin, type,
+                        AIR_FALSE /* clamp */,
+                        0 /* round */)) {
     biffAddf(NRRD, "%s: trouble", me);
     return 1;
   }
@@ -256,7 +262,37 @@
 nrrdClampConvert(Nrrd *nout, const Nrrd *nin, int type) {
   static const char me[]="nrrdClampConvert";
 
-  if (clampConvert(nout, nin, type, AIR_TRUE)) {
+  if (clampRoundConvert(nout, nin, type,
+                        AIR_TRUE  /* clamp */,
+                        0 /* round */)) {
+    biffAddf(NRRD, "%s: trouble", me);
+    return 1;
+  }
+  return 0;
+}
+
+/*
+******** nrrdCastClampRound()
+**
+** For (maybe) doing rounding to integer, then (maybe) clamping
+** and then casting.  The maybe-ness of rounding and clamping
+** in this function is inconsistent with the certainty of clamping
+** nrrdClampConvert, so this function name may be regretted.
+**
+** NOTE! Rounding is not performed when outType is for float
+** or double!  That logic is implemented here.
+**
+** And warning same as above:
+** HEY: WARNING: may have loss of data when processing long long
+** (either signed or unsigned)
+*/
+int
+nrrdCastClampRound(Nrrd *nout, const Nrrd *nin, int outType,
+                   int doClamp, int roundDir) {
+  static const char me[]="nrrdCastClampRound";
+
+  if (clampRoundConvert(nout, nin, outType, doClamp,
+                        nrrdTypeIsIntegral[outType] ? roundDir : 0)) {
     biffAddf(NRRD, "%s: trouble", me);
     return 1;
   }
@@ -344,24 +380,20 @@
   case 8:
     for (I=0; I<num; I++) {
       valIn = nrrdDLookup[nin->type](nin->data, I);
-      valIn = AIR_CLAMP(minIn, valIn, maxIn);
-      outUC[I] = airIndex(minIn, valIn, maxIn+eps, 1 << 8);
+      outUC[I] = AIR_UCHAR(airIndexClamp(minIn, valIn, maxIn+eps, 1 << 8));
     }
     break;
   case 16:
     for (I=0; I<num; I++) {
       valIn = nrrdDLookup[nin->type](nin->data, I);
-      valIn = AIR_CLAMP(minIn, valIn, maxIn);
-      outUS[I] = airIndex(minIn, valIn, maxIn+eps, 1 << 16);
+      outUS[I] = AIR_USHORT(airIndexClamp(minIn, valIn, maxIn+eps, 1 << 16));
     }
     break;
   case 32:
     for (I=0; I<num; I++) {
       valIn = nrrdDLookup[nin->type](nin->data, I);
-      valIn = AIR_CLAMP(minIn, valIn, maxIn);
-      outUI[I] = AIR_CAST(unsigned int,
-                          airIndexULL(minIn, valIn, maxIn+eps,
-                                      AIR_ULLONG(1) << 32));
+      outUI[I] = AIR_UINT(airIndexClampULL(minIn, valIn, maxIn+eps,
+                                           AIR_ULLONG(1) << 32));
     }
     break;
   }
@@ -500,8 +532,7 @@
   case nrrdTypeFloat:
     for (II=0; II<NN; II++) {
       valIn = minIn + nrrdDLookup[nin->type](nin->data, II);
-      outF[II] = AIR_CAST(float,
-                          NRRD_CELL_POS(minOut, maxOut, numValIn, valIn));
+      outF[II] = AIR_FLOAT(NRRD_CELL_POS(minOut, maxOut, numValIn, valIn));
     }
     break;
   case nrrdTypeDouble:
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/measure.c teem-1.11.0-src/src/nrrd/measure.c
--- teem-1.11.0-src.orig/src/nrrd/measure.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/measure.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -323,7 +323,7 @@
   nrrdDStore[ansType](ans, S);
 }
 
-#define L2_BODY                                  \
+#define L2_BODY(FOUR)                            \
   AIR_UNUSED(axmin);                             \
   AIR_UNUSED(axmax);                             \
   lup = nrrdDLookup[lineType];                   \
@@ -332,7 +332,7 @@
     count = len;                                 \
     for (ii=0; ii<len; ii++) {                   \
       val = lup(line, ii);                       \
-      S += val*val;                              \
+      S += (FOUR) ? val*val*val*val : val*val;   \
     }                                            \
   } else {                                       \
     S = AIR_NAN;                                 \
@@ -343,12 +343,12 @@
     if (AIR_EXISTS(S)) {                         \
       /* there's at least one existing value */  \
       count = 1;                                 \
-      S *= S;                                    \
+      S *= (FOUR) ? S*S*S : S ;                  \
       for (; ii<len; ii++) {                     \
         val = lup(line, ii);                     \
         if (AIR_EXISTS(val)) {                   \
           count++;                               \
-          S += val*val;                          \
+          S += (FOUR) ? val*val*val*val : val*val; \
         }                                        \
       }                                          \
     }                                            \
@@ -361,7 +361,7 @@
   double val, S, aa, (*lup)(const void*, size_t);
   size_t ii, count;
 
-  L2_BODY;
+  L2_BODY(AIR_FALSE);
   if (AIR_EXISTS(S)) {
     aa = sqrt(S);
   } else {
@@ -371,13 +371,29 @@
 }
 
 void
+_nrrdMeasureL4(void *ans, int ansType,
+               const void *line, int lineType, size_t len,
+               double axmin, double axmax) {
+  double val, S, aa, (*lup)(const void*, size_t);
+  size_t ii, count;
+
+  L2_BODY(AIR_TRUE);
+  if (AIR_EXISTS(S)) {
+    aa = sqrt(sqrt(S));
+  } else {
+    aa = AIR_NAN;
+  }
+  nrrdDStore[ansType](ans, aa);
+}
+
+void
 _nrrdMeasureNormalizedL2(void *ans, int ansType,
                          const void *line, int lineType, size_t len,
                          double axmin, double axmax) {
   double val, S, aa, (*lup)(const void*, size_t);
   size_t ii, count;
 
-  L2_BODY;
+  L2_BODY(AIR_FALSE);
   if (AIR_EXISTS(S)) {
     aa = sqrt(S)/count;
   } else {
@@ -393,7 +409,7 @@
   double val, S, aa, (*lup)(const void*, size_t);
   size_t ii, count;
 
-  L2_BODY;
+  L2_BODY(AIR_FALSE);
   if (AIR_EXISTS(S)) {
     aa = sqrt(S/count);
   } else {
@@ -437,6 +453,11 @@
   nrrdDStore[ansType](ans, M);
 }
 
+/* ========================================================== */
+#if 0 /* two variance functions:
+         0 for new two-pass (more accurate)
+         1 for old single-pass */
+
 void
 _nrrdMeasureVariance(void *ans, int ansType,
                      const void *line, int lineType, size_t len,
@@ -480,6 +501,57 @@
   nrrdDStore[ansType](ans, AIR_MAX(0.0, SS - S*S));
 }
 
+#else /* ========================================================== */
+
+void
+_nrrdMeasureVariance(void *ans, int ansType,
+                     const void *line, int lineType, size_t len,
+                     double axmin, double axmax) {
+  double vari, mean, val, (*lup)(const void*, size_t);
+  size_t ii, count;
+
+  AIR_UNUSED(axmin);
+  AIR_UNUSED(axmax);
+  mean = vari = 0.0;
+  lup = nrrdDLookup[lineType];
+  if (nrrdTypeIsIntegral[lineType]) {
+    for (ii=0; ii<len; ii++) {
+      mean += lup(line, ii);
+    }
+    mean /= len;
+    for (ii=0; ii<len; ii++) {
+      val = lup(line, ii);
+      vari += (val-mean)*(val-mean);
+    }
+    vari /= len;
+  } else {
+    count = 0;
+    for (ii=0; ii<len; ii++) {
+      val = lup(line, ii);
+      if (AIR_EXISTS(val)) {
+        count++;
+        mean += val;
+      }
+    }
+    if (count) {
+      mean /= count;
+      for (ii=0; ii<len; ii++) {
+        val = lup(line, ii);
+        if (AIR_EXISTS(val)) {
+          vari += (val-mean)*(val-mean);
+        }
+      }
+      vari /= count;
+    } else {
+      vari = AIR_NAN;
+    }
+  }
+  nrrdDStore[ansType](ans, vari);
+}
+
+#endif
+/* ========================================================== */
+
 void
 _nrrdMeasureSD(void *ans, int ansType,
                const void *line, int lineType, size_t len,
@@ -752,7 +824,9 @@
   max = -DBL_MAX;
   for (ii=0; ii<len; ii++) {
     val = lup(line, ii);
-    max = AIR_MAX(max, val);
+    if (AIR_EXISTS(val)) {
+      max = AIR_MAX(max, val);
+    }
   }
   if (-DBL_MAX == max) {
     nrrdDStore[ansType](ans, AIR_NAN);
@@ -774,6 +848,11 @@
       idxsum += ii;
     }
   }
+  if (max == 0 && len == idxcount) {
+    /* entire histogram was zeros => empty distribution => no mode */
+    nrrdDStore[ansType](ans, AIR_NAN);
+    return;
+  }
   ansD = idxsum/idxcount;
   /*
   printf("idxsum = %g; idxcount = %d --> ansD = %g --> ",
@@ -1003,6 +1082,7 @@
   _nrrdMeasureSum,
   _nrrdMeasureL1,
   _nrrdMeasureL2,
+  _nrrdMeasureL4,
   _nrrdMeasureNormalizedL2,
   _nrrdMeasureRootMeanSquare,
   _nrrdMeasureLinf,
@@ -1049,6 +1129,7 @@
   case nrrdMeasureSum:
   case nrrdMeasureL1:
   case nrrdMeasureL2:
+  case nrrdMeasureL4:
   case nrrdMeasureNormalizedL2:
   case nrrdMeasureRootMeanSquare:
   case nrrdMeasureLinf:
@@ -1078,7 +1159,7 @@
     type = nrrdStateMeasureHistoType;
     break;
   default:
-    fprintf(stderr, "%s: PANIC: type %d not handled\n", me, type);
+    fprintf(stderr, "%s: PANIC: measr %d not handled\n", me, measr);
     exit(1);
   }
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/methodsNrrd.c teem-1.11.0-src/src/nrrd/methodsNrrd.c
--- teem-1.11.0-src.orig/src/nrrd/methodsNrrd.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/methodsNrrd.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -58,10 +58,191 @@
 /* ---- BEGIN non-NrrdIO */
 const int
 nrrdPresent = 42;
-/* ---- END non-NrrdIO */
 
 /* ------------------------------------------------------------ */
 
+NrrdBoundarySpec *
+nrrdBoundarySpecNew(void) {
+  NrrdBoundarySpec *ret;
+
+  ret = AIR_CALLOC(1, NrrdBoundarySpec);
+  if (ret) {
+    ret->boundary = nrrdBoundaryUnknown;
+    ret->padValue = AIR_NAN;
+  }
+  return ret;
+}
+
+NrrdBoundarySpec *
+nrrdBoundarySpecNix(NrrdBoundarySpec *bspec) {
+
+  return airFree(bspec);
+}
+
+/* NOTE: this doesn't do a validity check! */
+NrrdBoundarySpec *
+nrrdBoundarySpecCopy(const NrrdBoundarySpec *bspec) {
+  NrrdBoundarySpec *ret;
+
+  if (bspec) {
+    ret = nrrdBoundarySpecNew();
+    ret->boundary = bspec->boundary;
+    ret->padValue = bspec->padValue;
+  } else {
+    ret = NULL;
+  }
+  return ret;
+}
+
+int
+nrrdBoundarySpecCheck(const NrrdBoundarySpec *bspec) {
+  static const char me[]="nrrdBoundarySpecCheck";
+
+  if (!bspec) {
+    biffAddf(NRRD, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (airEnumValCheck(nrrdBoundary, bspec->boundary)) {
+    biffAddf(NRRD, "%s: %d is not a valid %s value", me,
+             bspec->boundary, nrrdBoundary->name);
+    return 1;
+  }
+  if (nrrdBoundaryPad == bspec->boundary) {
+    if (!AIR_EXISTS(bspec->padValue)) {
+      biffAddf(NRRD, "%s: need existing pad value (not %g) with %s %s",
+               me, bspec->padValue, nrrdBoundary->name,
+               airEnumStr(nrrdBoundary, nrrdBoundaryPad));
+      return 1;
+    }
+  }
+  return 0;
+}
+
+int
+nrrdBoundarySpecParse(NrrdBoundarySpec *bspec, const char *_str) {
+  static const char me[]="nrrdBoundarySpecParse";
+  char *str, *parm;
+  airArray *mop;
+
+  if (!(bspec && _str)) {
+    biffAddf(NRRD, "%s: got NULL pointer", me);
+    return 1;
+  }
+  str = airStrdup(_str);
+  if (!str) {
+    biffAddf(NRRD, "%s: couldn't copy string", me);
+    return 1;
+  }
+  mop = airMopNew();
+  airMopAdd(mop, str, airFree, airMopAlways);
+  parm = strchr(str, ':');
+  if (parm) {
+    *parm = '\0';
+    parm++;
+  }
+  bspec->boundary = airEnumVal(nrrdBoundary, str);
+  if (nrrdBoundaryUnknown == bspec->boundary) {
+    biffAddf(NRRD, "%s: couldn't parse %s as a %s", me,
+             str, nrrdBoundary->name);
+    airMopError(mop); return 1;
+  }
+  if (parm) {
+    if (nrrdBoundaryPad != bspec->boundary) {
+      biffAddf(NRRD, "%s: can only have parms for %s (not %s)", me,
+               airEnumStr(nrrdBoundary, nrrdBoundaryPad),
+               airEnumStr(nrrdBoundary, bspec->boundary));
+      airMopError(mop); return 1;
+    }
+    if (1 != sscanf(parm, "%lg", &(bspec->padValue))) {
+      biffAddf(NRRD, "%s: couldn't parse \"%s\" as double", me, parm);
+      airMopError(mop); return 1;
+    }
+    if (!AIR_EXISTS(bspec->padValue)) {
+      biffAddf(NRRD, "%s: need existant pad value (not %g)", me,
+               bspec->padValue);
+      airMopError(mop); return 1;
+    }
+  } else {
+    if (nrrdBoundaryPad == bspec->boundary) {
+      biffAddf(NRRD, "%s: need padValue parm for %s", me,
+               airEnumStr(nrrdBoundary, nrrdBoundaryPad));
+      airMopError(mop); return 1;
+    }
+    bspec->padValue = AIR_NAN;
+  }
+  airMopOkay(mop);
+  return 0;
+}
+
+int
+nrrdBoundarySpecSprint(char str[AIR_STRLEN_LARGE],
+                       const NrrdBoundarySpec *bspec) {
+  static const char me[]="nrrdBoundarySpecSprint";
+  char *out;
+
+  if (!( str && bspec )) {
+    biffAddf(NRRD, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (nrrdBoundarySpecCheck(bspec)) {
+    biffAddf(NRRD, "%s: problem", me);
+    return 1;
+  }
+  out = str;
+  sprintf(out, "%s", airEnumStr(nrrdBoundary, bspec->boundary));
+  out += strlen(out);
+  if (nrrdBoundaryPad == bspec->boundary) {
+    sprintf(out, ":%.17g", bspec->padValue);
+  }
+  return 0;
+}
+
+int
+nrrdBoundarySpecCompare(const NrrdBoundarySpec *aa,
+                        const NrrdBoundarySpec *bb,
+                        int *differ, char explain[AIR_STRLEN_LARGE]) {
+  static const char me[]="nrrdBoundarySpecEqual";
+
+  if (!differ) {
+    biffAddf(NRRD, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (!!aa != !!bb) {
+    if (explain) {
+      sprintf(explain, "NULL-ities differ: %s != %s",
+              aa ? "non-NULL" : "NULL",
+              bb ? "non-NULL" : "NULL");
+    }
+    *differ = 1; return 0;
+  }
+  if (!aa) {
+    /* got two NULL boundary specs ==> equal */
+    *differ = 0; return 0;
+  }
+  if (aa->boundary != bb->boundary) {
+    if (explain) {
+      sprintf(explain, "boundaries differ: %s != %s",
+              airEnumStr(nrrdBoundary, aa->boundary),
+              airEnumStr(nrrdBoundary, bb->boundary));
+    }
+    *differ = 1; return 0;
+  }
+  if (nrrdBoundaryPad == aa->boundary) {
+    if (aa->padValue != bb->padValue) {
+      if (explain) {
+        sprintf(explain, "padValue differ: %.17g != %.17g",
+                aa->padValue, bb->padValue);
+      }
+      *differ = 1; return 0;
+    }
+  }
+  *differ = 0;
+  return 0;
+}
+
+/* ---- END non-NrrdIO */
+/* ------------------------------------------------------------ */
+
 void
 nrrdIoStateInit(NrrdIoState *nio) {
 
@@ -74,6 +255,7 @@
     nio->headerStringRead = NULL;
     nio->headerStringWrite = NULL;
     airArrayLenSet(nio->dataFNArr, 0);
+    airArrayLenSet(nio->dataFSkipArr, 0);
     /* closing this is always someone else's responsibility */
     nio->headerFile = NULL;
     nio->dataFile = NULL;
@@ -92,6 +274,7 @@
     memset(nio->seen, 0, (NRRD_FIELD_MAX+1)*sizeof(int));
     nio->detachedHeader = AIR_FALSE;
     nio->bareText = nrrdDefaultWriteBareText;
+    nio->moreThanFloatInText = nrrdDefaultWriteMoreThanFloatInText;
     nio->charsPerLine = nrrdDefaultWriteCharsPerLine;
     nio->valsPerLine = nrrdDefaultWriteValsPerLine;
     nio->skipData = AIR_FALSE;
@@ -100,6 +283,11 @@
     nio->zlibLevel = -1;
     nio->zlibStrategy = nrrdZlibStrategyDefault;
     nio->bzip2BlockSize = -1;
+    /* ---- BEGIN non-NrrdIO */
+    nio->PNGsRGBIntentKnown = AIR_FALSE;
+    /* this is the most backwards-compatible */
+    nio->PNGsRGBIntent = nrrdFormatPNGsRGBIntentNone;
+    /* ---- END non-NrrdIO */
     nio->learningHeaderStrlen = AIR_FALSE;
     nio->oldData = NULL;
     nio->oldDataSize = 0;
@@ -128,6 +316,10 @@
     nio->dataFNArr = airArrayNew(appu.v, NULL,
                                  sizeof(char *), NRRD_FILENAME_INCR);
     airArrayPointerCB(nio->dataFNArr, airNull, airFree);
+    nio->dataFSkip = NULL;
+    appu.li = &(nio->dataFSkip);
+    nio->dataFSkipArr = airArrayNew(appu.v, NULL,
+                                    sizeof(long int), NRRD_FILENAME_INCR);
     nio->format = nrrdFormatUnknown;
     nio->encoding = nrrdEncodingUnknown;
     nrrdIoStateInit(nio);
@@ -143,6 +335,7 @@
   nio->line = (char *)airFree(nio->line);
   nio->dataFNFormat = (char *)airFree(nio->dataFNFormat);
   nio->dataFNArr = airArrayNuke(nio->dataFNArr);
+  nio->dataFSkipArr = airArrayNuke(nio->dataFSkipArr);
   /* the NrrdIoState never owned nio->oldData; we don't free it */
   airFree(nio);  /* no NULL assignment, else compile warnings */
   return NULL;
@@ -726,7 +919,7 @@
   } else {
     /* someone is trying to copy structs without data, fine fine fine */
     if (nrrdWrap_nva(nout, NULL, nin->type, nin->dim, size)) {
-      biffAddf(NRRD, "%s: couldn't allocate data", me);
+      biffAddf(NRRD, "%s: couldn't wrap NULL data", me);
       return 1;
     }
   }
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/nrrdDefines.h teem-1.11.0-src/src/nrrd/nrrdDefines.h
--- teem-1.11.0-src.orig/src/nrrd/nrrdDefines.h	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/nrrdDefines.h	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -84,6 +84,7 @@
 #define NRRD_COMMENT_INCR 16
 #define NRRD_KEYVALUE_INCR 32
 #define NRRD_LIST_FLAG "LIST"
+#define NRRD_SKIPLIST_FLAG "SKIPLIST"
 #define NRRD_PNM_COMMENT "# NRRD>"    /* this is designed to be robust against
                                          the mungling that xv does, but no
                                          promises for any other image
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/nrrdEnums.h teem-1.11.0-src/src/nrrd/nrrdEnums.h
--- teem-1.11.0-src.orig/src/nrrd/nrrdEnums.h	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/nrrdEnums.h	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -41,11 +41,15 @@
 **
 ** the various things it makes sense to get and set in nrrdIoState struct
 ** via nrrdIoStateGet and nrrdIoStateSet
+** BUT HEY are those functions actually used (as opposed to directly reading
+** or setting fields in the nio)?  GLK honestly forgot about those functions
+** until working on adding nio->moreThanFloatInText
 */
 enum {
   nrrdIoStateUnknown,
   nrrdIoStateDetachedHeader,
   nrrdIoStateBareText,
+  nrrdIoStateMoreThanFloatInText,
   nrrdIoStateCharsPerLine,
   nrrdIoStateValsPerLine,
   nrrdIoStateSkipData,
@@ -68,7 +72,10 @@
   nrrdFormatTypePNM,    /* 2: PNM image */
   nrrdFormatTypePNG,    /* 3: PNG image */
   nrrdFormatTypeVTK,    /* 4: VTK Structured Points datasets (v1.0 and 2.0) */
-  nrrdFormatTypeText,   /* 5: bare ASCII text for 2D arrays */
+  nrrdFormatTypeText,   /* 5: ASCII text for 2D arrays, which may or may
+                              not be bare (i.e. just numbers, no header
+                              lines that start with "#") according
+                              to NrrdIoState->bareText */
   nrrdFormatTypeEPS,    /* 6: Encapsulated PostScript (write-only) */
   nrrdFormatTypeLast
 };
@@ -139,9 +146,10 @@
   nrrdEncodingTypeHex,      /* 3: hexidecimal (two chars per byte) */
   nrrdEncodingTypeGzip,     /* 4: gzip'ed raw data */
   nrrdEncodingTypeBzip2,    /* 5: bzip2'ed raw data */
+  nrrdEncodingTypeZRL,      /* 6: zero run-length compresion */
   nrrdEncodingTypeLast
 };
-#define NRRD_ENCODING_TYPE_MAX 5
+#define NRRD_ENCODING_TYPE_MAX 6
 
 /*
 ******** nrrdZlibStrategy enum
@@ -457,21 +465,25 @@
 */
 enum {
   nrrdSpaceUnknown,
-  nrrdSpaceRightAnteriorSuperior,     /*  1: NIFTI-1 (right-handed) */
-  nrrdSpaceLeftAnteriorSuperior,      /*  2: standard Analyze (left-handed) */
-  nrrdSpaceLeftPosteriorSuperior,     /*  3: DICOM 3.0 (right-handed) */
-  nrrdSpaceRightAnteriorSuperiorTime, /*  4: */
-  nrrdSpaceLeftAnteriorSuperiorTime,  /*  5: */
-  nrrdSpaceLeftPosteriorSuperiorTime, /*  6: */
-  nrrdSpaceScannerXYZ,                /*  7: ACR/NEMA 2.0 (pre-DICOM 3.0) */
-  nrrdSpaceScannerXYZTime,            /*  8: */
-  nrrdSpace3DRightHanded,             /*  9: */
-  nrrdSpace3DLeftHanded,              /* 10: */
-  nrrdSpace3DRightHandedTime,         /* 11: */
-  nrrdSpace3DLeftHandedTime,          /* 12: */
+  nrrdSpaceRightUp,                   /*  1: 2-D, oriented like upper right
+                                          Cartesian quadrant, number I */
+  nrrdSpaceRightDown,                 /*  2: 2-D, oriented like raster
+                                          coordinates */
+  nrrdSpaceRightAnteriorSuperior,     /*  3: NIFTI-1 (right-handed) */
+  nrrdSpaceLeftAnteriorSuperior,      /*  4: standard Analyze (left-handed) */
+  nrrdSpaceLeftPosteriorSuperior,     /*  5: DICOM 3.0 (right-handed) */
+  nrrdSpaceRightAnteriorSuperiorTime, /*  6: */
+  nrrdSpaceLeftAnteriorSuperiorTime,  /*  7: */
+  nrrdSpaceLeftPosteriorSuperiorTime, /*  8: */
+  nrrdSpaceScannerXYZ,                /*  9: ACR/NEMA 2.0 (pre-DICOM 3.0) */
+  nrrdSpaceScannerXYZTime,            /* 10: */
+  nrrdSpace3DRightHanded,             /* 11: */
+  nrrdSpace3DLeftHanded,              /* 12: */
+  nrrdSpace3DRightHandedTime,         /* 13: */
+  nrrdSpace3DLeftHandedTime,          /* 14: */
   nrrdSpaceLast
 };
-#define NRRD_SPACE_MAX                   12
+#define NRRD_SPACE_MAX                   14
 
 /*
 ******** nrrdSpacingStatus* enum
@@ -514,6 +526,45 @@
 /* ---- BEGIN non-NrrdIO */
 
 /*
+******** nrrdFormatPNGsRGBIntent* enum
+**
+** indicates values of PNG_sRGB_INTENT_, for the sRGB chunk of PNG,
+** or indicates not knowing it. This is unusual because the unknown
+** value is -1, not 0, and the #define is for NUM, not MAX. The 0,1,2,3
+** values of the intents copy how they're represented in ICC profiles,
+** which apparently png.h copies in turn; see
+** http://www.libpng.org/pub/png/book/chapter10.html
+*/
+enum {
+  nrrdFormatPNGsRGBIntentUnknown=-1, /* -1: nobody knows */
+  nrrdFormatPNGsRGBIntentPerceptual,  /* 0: PNG_sRGB_INTENT_PERCEPTUAL */
+  nrrdFormatPNGsRGBIntentRelative,    /* 1: PNG_sRGB_INTENT_RELATIVE */
+  nrrdFormatPNGsRGBIntentSaturation,  /* 2: PNG_sRGB_INTENT_SATURATION */
+  nrrdFormatPNGsRGBIntentAbsolute,    /* 3: PNG_sRGB_INTENT_ABSOLUTE */
+  nrrdFormatPNGsRGBIntentNone,        /* 4: do not indicate intent */
+  nrrdFormatPNGsRGBIntentLast
+};
+#define NRRD_FORMAT_PNG_SRGB_INTENT_NUM  5
+
+/*
+******** nrrdOrientationHave* enum
+**
+** ways of describing how much information about the orientation
+** we have
+*/
+enum {
+  nrrdOrientationHaveUnknown,          /* 0 */
+  nrrdOrientationHaveNothing,          /* 1 */
+  nrrdOrientationHaveSpacing,          /* 2 */
+  nrrdOrientationHaveMinSpacing,       /* 3 */
+  nrrdOrientationHaveMinMax,           /* 4 */
+  nrrdOrientationHaveDirections,       /* 5 */
+  nrrdOrientationHaveOriginDirections, /* 6 */
+  nrrdOrientationHaveLast
+};
+#define NRRD_ORIENTATION_HAVE_MAX         6
+
+/*
 ******** nrrdMeasure enum
 **
 ** ways to "measure" some portion of the array
@@ -532,43 +583,44 @@
   nrrdMeasureSum,            /* 7: sum of all values */
   nrrdMeasureL1,             /* 8 */
   nrrdMeasureL2,             /* 9 */
-  nrrdMeasureNormalizedL2,   /* 10 */
-  nrrdMeasureRootMeanSquare, /* 11 */
-  nrrdMeasureLinf,           /* 12 */
-  nrrdMeasureVariance,       /* 13 */
-  nrrdMeasureSD,             /* 14: standard deviation */
-  nrrdMeasureCoV,            /* 15: coefficient of variation */
-  nrrdMeasureSkew,           /* 16: skew */
-  nrrdMeasureLineSlope,      /* 17: slope of line of best fit */
-  nrrdMeasureLineIntercept,  /* 18: y-intercept of line of best fit */
-  nrrdMeasureLineError,      /* 19: error of line fitting */
+  nrrdMeasureL4,             /* 10 */
+  nrrdMeasureNormalizedL2,   /* 11 */
+  nrrdMeasureRootMeanSquare, /* 12 */
+  nrrdMeasureLinf,           /* 13 */
+  nrrdMeasureVariance,       /* 14 */
+  nrrdMeasureSD,             /* 15: standard deviation */
+  nrrdMeasureCoV,            /* 16: coefficient of variation */
+  nrrdMeasureSkew,           /* 17: skew */
+  nrrdMeasureLineSlope,      /* 18: slope of line of best fit */
+  nrrdMeasureLineIntercept,  /* 19: y-intercept of line of best fit */
+  nrrdMeasureLineError,      /* 20: error of line fitting */
   /*
   ** the nrrduMeasureHisto* measures interpret the array as a
   ** histogram of some implied value distribution
   */
-  nrrdMeasureHistoMin,       /* 20 */
-  nrrdMeasureHistoMax,       /* 21 */
-  nrrdMeasureHistoMean,      /* 22 */
-  nrrdMeasureHistoMedian,    /* 23 */
-  nrrdMeasureHistoMode,      /* 24 */
-  nrrdMeasureHistoProduct,   /* 25 */
-  nrrdMeasureHistoSum,       /* 26 */
-  nrrdMeasureHistoL2,        /* 27 */
-  nrrdMeasureHistoVariance,  /* 28 */
-  nrrdMeasureHistoSD,        /* 29 */
+  nrrdMeasureHistoMin,       /* 21 */
+  nrrdMeasureHistoMax,       /* 22 */
+  nrrdMeasureHistoMean,      /* 23 */
+  nrrdMeasureHistoMedian,    /* 24 */
+  nrrdMeasureHistoMode,      /* 25 */
+  nrrdMeasureHistoProduct,   /* 26 */
+  nrrdMeasureHistoSum,       /* 27 */
+  nrrdMeasureHistoL2,        /* 28 */
+  nrrdMeasureHistoVariance,  /* 29 */
+  nrrdMeasureHistoSD,        /* 30 */
   nrrdMeasureLast
 };
-#define NRRD_MEASURE_MAX        29
+#define NRRD_MEASURE_MAX        30
 #define NRRD_MEASURE_DESC \
    "Possibilities include:\n " \
    "\b\bo \"min\", \"max\", \"mean\", \"median\", \"mode\", \"variance\", " \
-     "\"skew\": (self-explanatory)\n " \
+     "\"skew\", \"sum\", \"product\", : (self-explanatory)\n " \
    "\b\bo \"intc\", \"slope\", \"error\": " \
      "intercept, slope, and error from line fitting\n " \
    "\b\bo \"stdv\": standard deviation\n " \
    "\b\bo \"cov\": coefficient of variation\n " \
    "\b\bo \"product\", \"sum\": product or sum of all values\n " \
-   "\b\bo \"L1\", \"L2\", \"NL2\", \"RMS\", \"Linf\": different norms\n " \
+   "\b\bo \"L1\", \"L2\", \"L4\", \"NL2\", \"RMS\", \"Linf\": vector norms\n " \
    "\b\bo \"histo-min\", \"histo-max\", \"histo-mean\"," \
      "\"histo-median\", \"histo-mode\", \"histo-product\", \"histo-l2\", " \
      "\"histo-sum\", \"histo-variance\", \"histo-sd\": same measures, " \
@@ -630,9 +682,11 @@
   nrrdUnaryOpIf,         /* 28 */
   nrrdUnaryOpZero,       /* 29 */
   nrrdUnaryOpOne,        /* 30 */
+  nrrdUnaryOpTauOfSigma, /* 31 */
+  nrrdUnaryOpSigmaOfTau, /* 32 */
   nrrdUnaryOpLast
 };
-#define NRRD_UNARY_OP_MAX   30
+#define NRRD_UNARY_OP_MAX   32
 
 /*
 ******** nrrdBinaryOp enum
@@ -664,9 +718,16 @@
   nrrdBinaryOpIf,         /* 21 */
   nrrdBinaryOpNormalRandScaleAdd, /* 22 */
   nrrdBinaryOpRicianRand, /* 23 */
+  /* Adding these is a bit of a hack- whether or not to clamp to the
+     representational range of an output integer type should really be an
+     argument to the arithmetic functions, but this allows it be done
+     without any API change */
+  nrrdBinaryOpAddClamp,   /* 24 */
+  nrrdBinaryOpSubtractClamp, /* 25 */
+  nrrdBinaryOpMultiplyClamp, /* 26 */
   nrrdBinaryOpLast
 };
-#define NRRD_BINARY_OP_MAX   23
+#define NRRD_BINARY_OP_MAX   26
 
 /*
 ******** nrrdTernaryOp
@@ -724,6 +785,18 @@
 };
 #define NRRD_RESAMPLE_NON_EXISTENT_MAX    3
 
+/*
+******** nrrdMetaDataCanonicalVersion
+**
+** different strategies for putting meta-data into a canonical form
+*/
+enum {
+  nrrdMetaDataCanonicalVersionUnknown,
+  nrrdMetaDataCanonicalVersionAlpha,       /* 1 */
+  nrrdMetaDataCanonicalVersionLast
+};
+#define NRRD_META_DATA_CANONICAL_VERSION_MAX  1
+
 /* ---- END non-NrrdIO */
 
 #ifdef __cplusplus
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/nrrd.h teem-1.11.0-src/src/nrrd/nrrd.h
--- teem-1.11.0-src.orig/src/nrrd/nrrd.h	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/nrrd.h	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -358,6 +358,13 @@
   long int byteSkip;        /* exactly like lineSkip, but bytes
                                instead of lines.  First the lines are
                                skipped, then the bytes */
+  long int *dataFSkip;      /* skip per-data-file line from a NRRD0006 "data
+                               file: SKIPLIST" specification; THIS OVERRIDES
+                               the single byteSkip above. The non-NULL-ity of
+                               this indicates there is a per-file byte skip.
+                               Line skip still precedes per-file byte skip. */
+  airArray *dataFSkipArr;   /* for managing the above */
+
   /* Note that the NRRD0004 and NRRD0005 file formats indicate that a numbered
      sequence of data filenames should be indexed via a "%d" format
      specification, and that the format doc says nothing about the "min" and
@@ -387,6 +394,10 @@
     bareText,               /* when writing a plain text file, is there any
                                effort made to record the nrrd struct
                                info in the text file */
+    moreThanFloatInText,    /* when writing a plain text file, instead of the
+                               usual behavior of silently converting to float,
+                               explicitly record the type, and also ensure
+                               that the ascii encoding is lossless */
     skipData,               /* if non-zero (all formats):
                                ON READ: don't allocate memory for, and don't
                                read in, the data portion of the file (but we
@@ -416,6 +427,15 @@
     bzip2BlockSize,         /* block size used for compression,
                                roughly equivalent to better but slower
                                (1-9, -1 for default[9]). */
+    /* ---- BEGIN non-NrrdIO */
+    /* seems odd to have contents of NrrdIoState differ between full Teem
+       and NrrdIO, but these fields can't be meaningfully set or read if
+       the nrrdFormatPNGsRGBIntent is not available */
+    PNGsRGBIntentKnown,     /* ON READ+WRITE: for array being read from or
+                               written to PNG, we know an sRGB intent */
+    PNGsRGBIntent,          /* ON READ+WRITE: iff sRGBIntentKnown, the intent
+                               itself, from nrrdFormatPNGsRGBIntent* enum */
+    /* ---- END non-NrrdIO */
     learningHeaderStrlen;   /* ON WRITE, for nrrds, learn and save the total
                                length of header into headerStrlen. This is
                                used to allocate a buffer for header */
@@ -647,12 +667,27 @@
   double (*load)(const void*); /* how to get a value out of "data" */
 } NrrdIter;
 
+/*
+******** NrrdBoundarySpec
+**
+** In its present state, this is almost not worth having, but it nicely
+** addresses the repeated annoyance of sometimes needing both a nrrdBoundary
+** enum value and a pad value in a single place.  There may later be need for
+** other kinds of parameterized boundary behaviors (such as padding with
+** vector values, or some kind of parameterized high-order continuation)
+*/
+typedef struct {
+  int boundary;                /* from nrrdBoundary enum */
+  double padValue;             /* padding value, if needed */
+} NrrdBoundarySpec;
+
 /* ---- END non-NrrdIO */
 
 /******** defaults (nrrdDefault..) and state (nrrdState..) */
 /* defaultsNrrd.c */
 NRRD_EXPORT int nrrdDefaultWriteEncodingType;
 NRRD_EXPORT int nrrdDefaultWriteBareText;
+NRRD_EXPORT int nrrdDefaultWriteMoreThanFloatInText;
 NRRD_EXPORT unsigned int nrrdDefaultWriteCharsPerLine;
 NRRD_EXPORT unsigned int nrrdDefaultWriteValsPerLine;
 /* ---- BEGIN non-NrrdIO */
@@ -687,6 +722,7 @@
 NRRD_EXPORT const char *const nrrdEnvVarDefaultWriteEncodingType;
 NRRD_EXPORT const char *const nrrdEnvVarDefaultWriteBareText;
 NRRD_EXPORT const char *const nrrdEnvVarDefaultWriteBareTextOld;
+NRRD_EXPORT const char *const nrrdEnvVarDefaultWriteMoreThanFloatInText;
 NRRD_EXPORT const char *const nrrdEnvVarDefaultCenter;
 NRRD_EXPORT const char *const nrrdEnvVarDefaultCenterOld;
 NRRD_EXPORT const char *const nrrdEnvVarDefaultWriteCharsPerLine;
@@ -713,6 +749,7 @@
                                const char *envVar);
 NRRD_EXPORT int nrrdGetenvDouble(double *val, char **envStr,
                                  const char *envVar);
+NRRD_EXPORT int nrrdGetenvString(char **envStr, const char *envVar);
 NRRD_EXPORT void nrrdDefaultGetenv(void);
 NRRD_EXPORT void nrrdStateGetenv(void);
 /* ---- END non-NrrdIO */
@@ -733,6 +770,8 @@
 NRRD_EXPORT const airEnum *const nrrdSpace;
 NRRD_EXPORT const airEnum *const nrrdSpacingStatus;
 /* ---- BEGIN non-NrrdIO */
+NRRD_EXPORT const airEnum *const nrrdFormatPNGsRGBIntent;
+NRRD_EXPORT const airEnum *const nrrdOrientationHave;
 NRRD_EXPORT const airEnum *const nrrdBoundary;
 NRRD_EXPORT const airEnum *const nrrdMeasure;
 NRRD_EXPORT const airEnum *const nrrdUnaryOp;
@@ -740,6 +779,7 @@
 NRRD_EXPORT const airEnum *const nrrdTernaryOp;
 NRRD_EXPORT const airEnum *const nrrdFFTWPlanRigor;
 NRRD_EXPORT const airEnum *const nrrdResampleNonExistent;
+NRRD_EXPORT const airEnum *const nrrdMetaDataCanonicalVersion;
 /* ---- END non-NrrdIO */
 
 /******** arrays of things (poor-man's functions/predicates) */
@@ -755,6 +795,19 @@
 /* methodsNrrd.c */
 /* ---- BEGIN non-NrrdIO */
 NRRD_EXPORT const int nrrdPresent;
+NRRD_EXPORT NrrdBoundarySpec *nrrdBoundarySpecNew(void);
+NRRD_EXPORT NrrdBoundarySpec *nrrdBoundarySpecNix(NrrdBoundarySpec *bspec);
+NRRD_EXPORT NrrdBoundarySpec *nrrdBoundarySpecCopy(const
+                                                   NrrdBoundarySpec *bsp);
+NRRD_EXPORT int nrrdBoundarySpecCheck(const NrrdBoundarySpec *bspec);
+NRRD_EXPORT int nrrdBoundarySpecParse(NrrdBoundarySpec *bspec,
+                                      const char *str);
+NRRD_EXPORT int nrrdBoundarySpecSprint(char str[AIR_STRLEN_LARGE],
+                                       const NrrdBoundarySpec *bspec);
+NRRD_EXPORT int nrrdBoundarySpecCompare(const NrrdBoundarySpec *bspecA,
+                                        const NrrdBoundarySpec *bspecB,
+                                        int *differ,
+                                        char explain[AIR_STRLEN_LARGE]);
 /* ---- END non-NrrdIO */
 NRRD_EXPORT NrrdIoState *nrrdIoStateNew(void);
 NRRD_EXPORT void nrrdIoStateInit(NrrdIoState *nio);
@@ -846,6 +899,15 @@
                                      double vector[NRRD_SPACE_DIM_MAX]);
 NRRD_EXPORT int nrrdOrientationReduce(Nrrd *nout, const Nrrd *nin,
                                       int setMinsFromOrigin);
+/* ---- BEGIN non-NrrdIO */
+NRRD_EXPORT int nrrdMetaDataNormalize(Nrrd *nout, const Nrrd *nin,
+                                      int version,
+                                      int trivialOrient,
+                                      int permuteComponentAxisFastest,
+                                      int recenterGrid,
+                                      double sampleSpacing,
+                                      int *lostMeasurementFrame);
+/* ---- END non-NrrdIO */
 
 /******** simple things */
 /* simple.c */
@@ -883,12 +945,13 @@
 NRRD_EXPORT double nrrdSpaceVecNorm(unsigned int sdim,
                                     const double vec[NRRD_SPACE_DIM_MAX]);
 NRRD_EXPORT int nrrdSpaceVecExists(unsigned int sdim,
-                                   double vec[NRRD_SPACE_DIM_MAX]);
+                                   const double vec[NRRD_SPACE_DIM_MAX]);
 NRRD_EXPORT void nrrdSpaceVecSetNaN(double vec[NRRD_SPACE_DIM_MAX]);
 /* ---- BEGIN non-NrrdIO */
 NRRD_EXPORT void nrrdSanityOrDie(const char *me);
 NRRD_EXPORT void nrrdSpaceVecSetZero(double vec[NRRD_SPACE_DIM_MAX]);
 NRRD_EXPORT void nrrdZeroSet(Nrrd *nout);
+NRRD_EXPORT void nrrdNaNSet(Nrrd *nout);
 /* ---- END non-NrrdIO */
 
 /******** comments related */
@@ -933,6 +996,7 @@
 NRRD_EXPORT const NrrdEncoding *const nrrdEncodingHex;
 NRRD_EXPORT const NrrdEncoding *const nrrdEncodingGzip;
 NRRD_EXPORT const NrrdEncoding *const nrrdEncodingBzip2;
+NRRD_EXPORT const NrrdEncoding *const nrrdEncodingZRL;
 /* encoding.c */
 NRRD_EXPORT const NrrdEncoding *const nrrdEncodingUnknown;
 NRRD_EXPORT const NrrdEncoding *
@@ -948,6 +1012,13 @@
 NRRD_EXPORT unsigned int _nrrdDataFNNumber(NrrdIoState *nio);
 NRRD_EXPORT int _nrrdContainsPercentThisAndMore(const char *str, char thss);
 NRRD_EXPORT int _nrrdDataFNCheck(NrrdIoState *nio, Nrrd *nrrd, int useBiff);
+/* ---- BEGIN non-NrrdIO */
+NRRD_EXPORT int nrrdSpaceVectorParse(double dir[NRRD_SPACE_DIM_MAX],
+                                     const char *str, unsigned int spaceDim,
+                                     int useBiff);
+/* ---- END non-NrrdIO */
+NRRD_EXPORT size_t (*const nrrdStringValsParse[NRRD_TYPE_MAX+1])
+                    (void *out, const char *s, const char *sep, size_t n);
 
 /* read.c */
 NRRD_EXPORT int _nrrdOneLine(unsigned int *lenP, NrrdIoState *nio, FILE *file);
@@ -1061,6 +1132,7 @@
 /* hestNrrd.c */
 NRRD_EXPORT hestCB *nrrdHestNrrd;
 NRRD_EXPORT hestCB *nrrdHestKernelSpec;
+NRRD_EXPORT hestCB *nrrdHestBoundarySpec;
 NRRD_EXPORT hestCB *nrrdHestIter;
 
 /******** nrrd value iterator gadget */
@@ -1102,6 +1174,8 @@
 NRRD_EXPORT double (*nrrdDClamp[NRRD_TYPE_MAX+1])(double);
 NRRD_EXPORT int nrrdConvert(Nrrd *nout, const Nrrd *nin, int type);
 NRRD_EXPORT int nrrdClampConvert(Nrrd *nout, const Nrrd *nin, int type);
+NRRD_EXPORT int nrrdCastClampRound(Nrrd *nout, const Nrrd *nin, int type,
+                                   int doClamp, int roundDir);
 NRRD_EXPORT int nrrdQuantize(Nrrd *nout, const Nrrd *nin,
                              const NrrdRange *range, unsigned int bits);
 NRRD_EXPORT int nrrdUnquantize(Nrrd *nout, const Nrrd *nin, int type);
@@ -1217,8 +1291,12 @@
 
 /******** arithmetic and math on nrrds */
 /* arith.c */
+NRRD_EXPORT double nrrdSRGBGamma(double val);
+NRRD_EXPORT double nrrdSRGBGammaInverse(double val);
 NRRD_EXPORT int nrrdArithGamma(Nrrd *nout, const Nrrd *nin,
                                const NrrdRange *range, double gamma);
+NRRD_EXPORT int nrrdArithSRGBGamma(Nrrd *nout, const Nrrd *nin,
+                                   const NrrdRange *range, int forward);
 NRRD_EXPORT int nrrdArithUnaryOp(Nrrd *nout, int op, const Nrrd *nin);
 NRRD_EXPORT int nrrdArithBinaryOp(Nrrd *nout, int op,
                                   const Nrrd *ninA, const Nrrd *ninB);
@@ -1331,7 +1409,8 @@
 ** float versus double.  Actually, the difference between float and
 ** double is not exposed in any functions or objects declared in this
 ** header; it is entirely internal to the operation of
-** nrrdSpatialResample().
+** nrrdSpatialResample() and nrrdResampleExecute() and things
+** based on those.
 **
 ** Choose by setting "#if" arg to 1 (for float) or 0 (for double)
 */
@@ -1375,6 +1454,8 @@
                                         int boundary);
 NRRD_EXPORT int nrrdResamplePadValueSet(NrrdResampleContext *rsmc,
                                         double padValue);
+NRRD_EXPORT int nrrdResampleBoundarySpecSet(NrrdResampleContext *rsmc,
+                                            const NrrdBoundarySpec *bspec);
 NRRD_EXPORT int nrrdResampleTypeOutSet(NrrdResampleContext *rsmc,
                                        int typeOut);
 NRRD_EXPORT int nrrdResampleRenormalizeSet(NrrdResampleContext *rsmc,
@@ -1528,8 +1609,9 @@
   *const nrrdKernelGaussian,     /* Gaussian */
   *const nrrdKernelGaussianD,    /* 1st derivative of Gaussian */
   *const nrrdKernelGaussianDD,   /* 2nd derivative of Gaussian */
-  *const nrrdKernelDiscreteGaussian; /* Discrete Gaussian-like kernel for
-                                        scale-space analysis */
+  *const nrrdKernelDiscreteGaussian; /* Lindeberg's discrete Gaussian-like
+                                        kernel for scale-space analysis */
+NRRD_EXPORT const double nrrdKernelDiscreteGaussianGoodSigmaMax;
 NRRD_EXPORT int nrrdKernelParse(const NrrdKernel **kernelP,
                                 double *parm,
                                 const char *str);
@@ -1545,6 +1627,10 @@
                                   const double parmB[NRRD_KERNEL_PARMS_NUM],
                                   int *differ,
                                   char explain[AIR_STRLEN_LARGE]);
+NRRD_EXPORT int nrrdKernelSpecCompare(const NrrdKernelSpec *aa,
+                                      const NrrdKernelSpec *bb,
+                                      int *differ,
+                                      char explain[AIR_STRLEN_LARGE]);
 NRRD_EXPORT int nrrdKernelCheck(const NrrdKernel *kern,
                                 const double parm[NRRD_KERNEL_PARMS_NUM],
                                 size_t evalNum, double epsilon,
@@ -1552,6 +1638,7 @@
                                 unsigned int diffOkIntglMax,
                                 const NrrdKernel *dkern,
                                 const double dparm[NRRD_KERNEL_PARMS_NUM]);
+NRRD_EXPORT int nrrdKernelParm0IsScale(const NrrdKernel *kern);
 
 /* ---- END non-NrrdIO */
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/nrrdMacros.h teem-1.11.0-src/src/nrrd/nrrdMacros.h
--- teem-1.11.0-src.orig/src/nrrd/nrrdMacros.h	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/nrrdMacros.h	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/parseNrrd.c teem-1.11.0-src/src/nrrd/parseNrrd.c
--- teem-1.11.0-src.orig/src/nrrd/parseNrrd.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/parseNrrd.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -87,7 +87,7 @@
 
     /* skip whitespace prior to start of first field descriptor */
     next += strspn(next, _nrrdFieldSep);
-    nio->pos = AIR_CAST(int, next - nio->line);
+    nio->pos = AIR_INT(next - nio->line);
 
     ret = fld;
   }
@@ -204,7 +204,7 @@
 }
 
 #define _PARSE_ONE_VAL(FIELD, CONV, TYPE)                         \
-  if (1 != sscanf(info, CONV, &(FIELD))) {                        \
+  if (1 != airSingleSscanf(info, CONV, &(FIELD))) {               \
     biffMaybeAddf(useBiff, NRRD, "%s: couldn't parse " TYPE       \
                   " from \"%s\"", me, info);                      \
     return 1;                                                     \
@@ -410,7 +410,7 @@
   return 0;
 }
 
-int
+static int
 _nrrdSpaceVectorParse(double val[NRRD_SPACE_DIM_MAX],
                       char **hhP, unsigned int spaceDim, int useBiff) {
   static const char me[]="_nrrdSpaceVectorParse";
@@ -524,6 +524,38 @@
   return 0;
 }
 
+/* ---- BEGIN non-NrrdIO */
+/*
+** public version of _nrrdSpaceVectorParse, which might not really be
+** needed, but given how _nrrdSpaceVectorParse currently wants a
+** char**, so it can move the pointer to point to the next space
+** vector to parse in a non-const string, this seems like a sane and
+** minimal effort option
+*/
+int
+nrrdSpaceVectorParse(double dir[NRRD_SPACE_DIM_MAX],
+                     const char *_str, unsigned int spaceDim, int useBiff) {
+  static const char me[]="nrrdSpaceVectorParse";
+  airArray *mop;
+  char *str;
+
+  mop = airMopNew();
+  str = airStrdup(_str);
+  airMopAdd(mop, str, airFree, airMopAlways);
+  if (!(dir && _str)) {
+    biffMaybeAddf(useBiff, NRRD, "%s: got NULL pointer", me);
+    airMopError(mop); return 1;
+  }
+  if (_nrrdSpaceVectorParse(dir, &str, spaceDim, useBiff)) {
+    biffMaybeAddf(useBiff, NRRD, "%s: trouble parsing", me);
+    airMopError(mop); return 1;
+  }
+
+  airMopOkay(mop);
+  return 0;
+}
+/* ---- END non-NrrdIO */
+
 static int
 _nrrdReadNrrdParse_space_directions(FILE *file, Nrrd *nrrd,
                                     NrrdIoState *nio, int useBiff) {
@@ -1338,18 +1370,23 @@
                     "%s: trouble with number of datafiles", me);
       airMopError(mop); return 1;
     }
-  } else if (!strncmp(info, NRRD_LIST_FLAG, strlen(NRRD_LIST_FLAG))) {
+  } else if (!strncmp(info, NRRD_LIST_FLAG, strlen(NRRD_LIST_FLAG)) ||
+             !strncmp(info, NRRD_SKIPLIST_FLAG, strlen(NRRD_SKIPLIST_FLAG))) {
+    int skiplist;
+    unsigned int lineidx;
     /* ---------------------------------------------------------- */
-    /* ------------------------- LIST --------------------------- */
+    /* -------------------- LIST or SKIPLIST -------------------- */
     /* ---------------------------------------------------------- */
     _CHECK_HAVE_DIM;
+    skiplist = !strncmp(info, NRRD_SKIPLIST_FLAG, strlen(NRRD_SKIPLIST_FLAG));
     if (_nrrdHeaderCheck(nrrd, nio, AIR_TRUE)) {
-      biffMaybeAddf(useBiff, NRRD, "%s: NRRD header is incomplete. \""
-                    NRRD_LIST_FLAG "\" data file specification must be "
-                    "contiguous with end of header!", me);
+      biffMaybeAddf(useBiff, NRRD, "%s: NRRD header is incomplete. "
+                    "\"%s\" data file specification must be "
+                    "contiguous with end of header!", me,
+                    skiplist ? NRRD_SKIPLIST_FLAG : NRRD_LIST_FLAG);
       airMopError(mop); return 1;
     }
-    info += strlen(NRRD_LIST_FLAG);
+    info += strlen(skiplist ? NRRD_SKIPLIST_FLAG : NRRD_LIST_FLAG);
     if (info[0]) {
       if (1 == sscanf(info, "%u", &(nio->dataFileDim))) {
         if (!AIR_IN_CL(1, nio->dataFileDim, nrrd->dim)) {
@@ -1359,27 +1396,59 @@
           airMopError(mop); return 1;
         }
       } else {
-        biffMaybeAddf(useBiff, NRRD, "%s: couldn't parse info after \""
-                      NRRD_LIST_FLAG "\" as an int", me);
+        biffMaybeAddf(useBiff, NRRD, "%s: couldn't parse info after "
+                      "\"%s\" as an int", me,
+                      skiplist ? NRRD_SKIPLIST_FLAG : NRRD_LIST_FLAG);
         airMopError(mop); return 1;
       }
     } else {
-      /* nothing after NRRD_LIST_FLAG, so dataFileDim is implicit */
+      /* nothing after NRRD_LIST_FLAG or NRRD_SKIPLIST_FLAG,
+         so dataFileDim is implicit */
       nio->dataFileDim = nrrd->dim-1;
     }
     /* read in all the datafile names */
+    lineidx = 0;
     do {
       /* yes, nio->line is re-used/over-written here, but I don't
          think that's a problem */
       if (_nrrdOneLine(&linelen, nio, ffile)) {
         biffMaybeAddf(useBiff, NRRD,
-                      "%s: trouble getting file name line", me);
+                      "%s: trouble getting file name line %u", me, lineidx);
         airMopError(mop); return 1;
       }
       if (linelen > 0) {
-        tmp = airArrayLenIncr(nio->dataFNArr, 1);
-        nio->dataFN[tmp] = airStrdup(nio->line);
+        /* we got a non-empty line */
+        if (skiplist) {
+          char *lhere;
+          long int oneskip;
+          if (1 != airSingleSscanf(nio->line, "%ld", &oneskip)) {
+            biffMaybeAddf(useBiff, NRRD,
+                          "%s: couldn't parse skip on list line %u",
+                          me, lineidx);
+            airMopError(mop); return 1;
+          }
+          lhere = strchr(nio->line, ' ');
+          if (!lhere) {
+            biffMaybeAddf(useBiff, NRRD, "%s: didn't see space after "
+                          "skip on list line %u", me, lineidx);
+            airMopError(mop); return 1;
+          }
+          lhere++;
+          if (!(lhere[0])) {
+            biffMaybeAddf(useBiff, NRRD, "%s: didn't see filename after "
+                          "skip and space on list line %u", me, lineidx);
+            airMopError(mop); return 1;
+          }
+          airArrayLenIncr(nio->dataFSkipArr, 1);
+          nio->dataFSkip[lineidx] = oneskip;
+          airArrayLenIncr(nio->dataFNArr, 1);
+          nio->dataFN[lineidx] = airStrdup(lhere);
+        } else {
+          airArrayLenIncr(nio->dataFNArr, 1);
+          nio->dataFN[lineidx] = airStrdup(nio->line);
+        }
       }
+      ++lineidx;
     } while (linelen > 0);
     if (_nrrdDataFNCheck(nio, nrrd, useBiff)) {
       biffMaybeAddf(useBiff, NRRD,
@@ -1445,3 +1514,73 @@
 
 /* kernel parsing is all in kernel.c */
 
+/* nrrdStringValsParse[]: parse N values of given type from string
+   NB: based on air/parseAir.c
+*/
+#define P_ARGS (void *_out, const char *_s, const char *sep, size_t n)
+#define P_BODY(type, ntype)                               \
+  size_t i;                                               \
+  char *tmp, *s, *last;                                   \
+  const char *format;                                     \
+  type *out;                                              \
+                                                          \
+  /* if we got NULL, there's nothing to do */             \
+  if (!(_out && _s && sep))                               \
+    return 0;                                             \
+  format = nrrdTypePrintfStr[ntype];                      \
+  out = (type*)_out;                                      \
+  /* copy the input so that we don't change it */         \
+  s = airStrdup(_s);                                      \
+                                                          \
+  /* keep calling airStrtok() until we have everything */ \
+  for (i=0; i<n; i++) {                                   \
+    tmp = airStrtok(i ? NULL : s, sep, &last);            \
+    if (!tmp) {                                           \
+      free(s);                                            \
+      return i;                                           \
+    }                                                     \
+    if (1 != airSingleSscanf(tmp, format, out+i)) {       \
+      free(s);                                            \
+      return i;                                           \
+    }                                                     \
+  }                                                       \
+  free(s);                                                \
+  return n
+
+static size_t   _parseChar P_ARGS { P_BODY(          char,   nrrdTypeChar); }
+static size_t  _parseUChar P_ARGS { P_BODY( unsigned char,  nrrdTypeUChar); }
+static size_t  _parseShort P_ARGS { P_BODY(         short,  nrrdTypeShort); }
+static size_t _parseUShort P_ARGS { P_BODY(unsigned short, nrrdTypeUShort); }
+static size_t    _parseInt P_ARGS { P_BODY(           int,    nrrdTypeInt); }
+static size_t   _parseUInt P_ARGS { P_BODY(  unsigned int,   nrrdTypeUInt); }
+static size_t  _parseLLong P_ARGS { P_BODY(      airLLong,  nrrdTypeLLong); }
+static size_t _parseULLong P_ARGS { P_BODY(     airULLong, nrrdTypeULLong); }
+static size_t  _parseFloat P_ARGS { P_BODY(         float,  nrrdTypeFloat); }
+static size_t _parseDouble P_ARGS { P_BODY(        double, nrrdTypeDouble); }
+static size_t _parseNoop(void *out, const char *s, const char *sep, size_t n) {
+  AIR_UNUSED(out);
+  AIR_UNUSED(s);
+  AIR_UNUSED(sep);
+  AIR_UNUSED(n);
+  return 0;
+}
+#undef P_ARGS
+#undef P_BODY
+
+size_t
+(*const nrrdStringValsParse[NRRD_TYPE_MAX+1])(void *out, const char *s,
+                                              const char *sep, size_t n)
+= {
+   _parseNoop, /* 0 = unknown */
+   _parseChar,
+   _parseUChar,
+   _parseShort,
+   _parseUShort,
+   _parseInt,
+   _parseUInt,
+   _parseLLong,
+   _parseULLong,
+   _parseFloat,
+   _parseDouble,
+   _parseNoop /* block */
+};
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/privateNrrd.h teem-1.11.0-src/src/nrrd/privateNrrd.h
--- teem-1.11.0-src.orig/src/nrrd/privateNrrd.h	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/privateNrrd.h	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -111,8 +111,11 @@
 extern const NrrdEncoding _nrrdEncodingHex;
 extern const NrrdEncoding _nrrdEncodingGzip;
 extern const NrrdEncoding _nrrdEncodingBzip2;
+extern const NrrdEncoding _nrrdEncodingZRL;
 
 /* read.c */
+extern int _nrrdByteSkipSkip(FILE *dataFile, Nrrd *nrrd, NrrdIoState *nio,
+                             long int byteSkip);
 extern int _nrrdCalloc(Nrrd *nrrd, NrrdIoState *nio, FILE *file);
 extern char _nrrdFieldSep[];
 
@@ -144,11 +147,14 @@
 extern int _nrrdCenter2(int center, int def);
 /* ---- BEGIN non-NrrdIO */
 extern int _nrrdDblcmp(double aa, double bb);
-/* ---- END non-NrrdIO */
 
-/* convert.c */
+/* convertNrrd.c */
 extern void (*_nrrdConv[][NRRD_TYPE_MAX+1])(void *, const void *, size_t);
 extern void (*_nrrdClampConv[][NRRD_TYPE_MAX+1])(void *, const void *, size_t);
+extern void (*_nrrdCastClampRound[][NRRD_TYPE_MAX+1])(void *, const void *,
+                                                      size_t, int doClamp,
+                                                      int roundd);
+/* ---- END non-NrrdIO */
 
 /* read.c */
 extern char _nrrdFieldStr[NRRD_FIELD_MAX+1][AIR_STRLEN_SMALL];
@@ -166,13 +172,10 @@
                                  int field);
 extern void _nrrdSprintFieldInfo(char **strP, const char *prefix,
                                  const Nrrd *nrrd, NrrdIoState *nio,
-                                 int field);
+                                 int field, int dropAxis0);
 extern void _nrrdFprintFieldInfo(FILE *file, const char *prefix,
                                  const Nrrd *nrrd, NrrdIoState *nio,
-                                 int field);
-/* ---- BEGIN non-NrrdIO */
-extern int _nrrdReshapeDownGrayscale(Nrrd *nimg);
-/* ---- END non-NrrdIO */
+                                 int field, int dropAxis0);
 
 /* parseNrrd.c */
 extern int _nrrdReadNrrdParseField(NrrdIoState *nio, int useBiff);
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/range.c teem-1.11.0-src/src/nrrd/range.c
--- teem-1.11.0-src.orig/src/nrrd/range.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/range.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -184,7 +184,6 @@
     range->min = (minPerc > 0
                   ? minval
                   : 2*allmin - minval);
-    /* fprintf(stderr, "!%s: %g-%% min = %g\n", me, min, minval); */
   }
   if (maxPerc) {
     maxval = AIR_NAN;
@@ -207,7 +206,6 @@
     range->max = (maxPerc > 0
                   ? maxval
                   : 2*allmax - maxval);
-    /* fprintf(stderr, "!%s: %g-%% max = %g\n", me, max, maxval); */
   }
 
   airMopOkay(mop);
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/read.c teem-1.11.0-src/src/nrrd/read.c
--- teem-1.11.0-src.orig/src/nrrd/read.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/read.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -42,8 +42,7 @@
 unsigned int
 _nrrdHeaderStringOneLineStrlen(NrrdIoState *nio) {
 
-  return AIR_CAST(unsigned int,
-                  strcspn(nio->headerStringRead + nio->headerStrpos, _nrrdLineSep));
+  return AIR_UINT(strcspn(nio->headerStringRead + nio->headerStrpos, _nrrdLineSep));
 }
 
 /*
@@ -57,8 +56,7 @@
   strncpy(nio->line, nio->headerStringRead + nio->headerStrpos, len1);
   nio->line[len1] = '\0';
   nio->headerStrpos += len1;
-  len2 = AIR_CAST(unsigned int,
-                  strspn(nio->headerStringRead + nio->headerStrpos, _nrrdLineSep));
+  len2 = AIR_UINT(strspn(nio->headerStringRead + nio->headerStrpos, _nrrdLineSep));
   nio->headerStrpos += len2;
   return len1;
 }
@@ -86,8 +84,8 @@
 
   if (!( lenP && nio && (file || nio->headerStringRead))) {
     biffAddf(NRRD, "%s: got NULL pointer (%p, %p, %p/%p)", me,
-             AIR_CAST(void*, lenP), AIR_CAST(void*, nio),
-             AIR_CAST(void*, file), nio->headerStringRead);
+             AIR_VOIDP(lenP), AIR_VOIDP(nio), AIR_VOIDP(file),
+             AIR_CVOIDP(nio->headerStringRead));
     return 1;
   }
   if (0 == nio->lineLen) {
@@ -263,16 +261,9 @@
   return 0;
 }
 
-/*
-******** nrrdByteSkip
-**
-** public for the sake of things like "unu make"
-** uses nio for information about how much data should actually be skipped
-** with negative byteSkip
-*/
 int
-nrrdByteSkip(FILE *dataFile, Nrrd *nrrd, NrrdIoState *nio) {
-  static const char me[]="nrrdByteSkip";
+_nrrdByteSkipSkip(FILE *dataFile, Nrrd *nrrd, NrrdIoState *nio, long int byteSkip) {
+  static const char me[]="nrrdByteSkipSkip";
   int skipRet;
   size_t bsize;
 
@@ -285,7 +276,7 @@
              "encoding %s", me, nio->encoding->name);
     return 1;
   }
-  if (nio->byteSkip < 0) {
+  if (byteSkip < 0) {
     long backwards;
     if (nrrdEncodingRaw != nio->encoding) {
       biffAddf(NRRD, "%s: this function can do backwards byte skip only "
@@ -300,7 +291,7 @@
     bsize = nrrdElementNumber(nrrd)/_nrrdDataFNNumber(nio);
     bsize *= nrrdElementSize(nrrd);
     /* backwards is (positive) number of bytes AFTER data that we ignore */
-    backwards = -nio->byteSkip - 1;
+    backwards = -byteSkip - 1;
     /* HEY what if bsize fits in size_t but not in (signed) long? */
     if (fseek(dataFile, -AIR_CAST(long, bsize) - backwards, SEEK_END)) {
       char stmp[AIR_STRLEN_SMALL];
@@ -313,15 +304,15 @@
               me, (int)ftell(dataFile));
     }
   } else {
-    if ((stdin == dataFile) || (-1==fseek(dataFile, nio->byteSkip, SEEK_CUR))) {
+    if ((stdin == dataFile) || (-1==fseek(dataFile, byteSkip, SEEK_CUR))) {
       long skipi;
       /* fseek failed, perhaps because we're reading stdin, so
          we revert to consuming the input one byte at a time */
-      for (skipi=0; skipi<nio->byteSkip; skipi++) {
+      for (skipi=0; skipi<byteSkip; skipi++) {
         skipRet = fgetc(dataFile);
         if (EOF == skipRet) {
           biffAddf(NRRD, "%s: hit EOF skipping byte %ld of %ld",
-                   me, skipi, nio->byteSkip);
+                   me, skipi, byteSkip);
           return 1;
         }
       }
@@ -330,6 +321,31 @@
   return 0;
 }
 
+/*
+******** nrrdByteSkip
+**
+** public for the sake of things like "unu make"
+** uses nio for information about how much data should actually be skipped
+** with negative byteSkip
+*/
+int
+nrrdByteSkip(FILE *dataFile, Nrrd *nrrd, NrrdIoState *nio) {
+  static const char me[]="nrrdByteSkip";
+
+  if (!( dataFile && nrrd && nio )) {
+    biffAddf(NRRD, "%s: got NULL pointer", me);
+    return 1;
+  }
+  /* HEY: with the advent of NRRD0006 per-file skips, maybe this is
+     the function that should be public */
+  if (_nrrdByteSkipSkip(dataFile, nrrd, nio, nio->byteSkip)) {
+    biffAddf(NRRD, "%s: trouble", me);
+    return 1;
+  }
+
+  return 0;
+}
+
 /*
 ** _nrrdRead()
 **
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/reorder.c teem-1.11.0-src/src/nrrd/reorder.c
--- teem-1.11.0-src.orig/src/nrrd/reorder.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/reorder.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -341,7 +341,7 @@
              me, axis, nin->dim-1);
     return 1;
   }
-  len = AIR_CAST(unsigned int, nin->axis[axis].size);
+  len = AIR_UINT(nin->axis[axis].size);
   for (ai=0; ai<len; ai++) {
     if (!( perm[ai] < len )) {
       char stmp[AIR_STRLEN_SMALL];
@@ -1499,5 +1499,23 @@
   return 0;
 }
 
+#if 0
+int
+nrrdShift(Nrrd *nout, const Nrrd *nin, const ptrdiff_t *offset,
+          int boundary, double padValue) {
+  static const char me[]="nrrdShift", func[] = "shift";
+
+  if (!(nout && nin && offset)) {
+    biffAddf(NRRD, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (nout == nin) {
+    biffAddf(NRRD, "%s: nout==nin disallowed", me);
+    return 1;
+  }
+
+  return 0;
+}
+#endif
 
 /* ---- END non-NrrdIO */
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/resampleContext.c teem-1.11.0-src/src/nrrd/resampleContext.c
--- teem-1.11.0-src.orig/src/nrrd/resampleContext.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/resampleContext.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -99,12 +99,12 @@
     rsmc->nonExistent = nrrdDefaultResampleNonExistent;
     rsmc->padValue = nrrdDefaultResamplePadValue;
     rsmc->dim = 0;
-    rsmc->passNum = AIR_CAST(unsigned int, -1); /* 4294967295 */
-    rsmc->topRax = AIR_CAST(unsigned int, -1);
-    rsmc->botRax = AIR_CAST(unsigned int, -1);
+    rsmc->passNum = AIR_UINT(-1); /* 4294967295 */
+    rsmc->topRax = AIR_UINT(-1);
+    rsmc->botRax = AIR_UINT(-1);
     for (axIdx=0; axIdx<NRRD_DIM_MAX; axIdx++) {
-      rsmc->permute[axIdx] = AIR_CAST(unsigned int, -1);
-      rsmc->passAxis[axIdx] = AIR_CAST(unsigned int, -1);
+      rsmc->permute[axIdx] = AIR_UINT(-1);
+      rsmc->passAxis[axIdx] = AIR_UINT(-1);
     }
     for (axIdx=0; axIdx<NRRD_DIM_MAX+1; axIdx++) {
       axis = rsmc->axis + axIdx;
@@ -114,15 +114,15 @@
         axis->kparm[kpIdx] = AIR_NAN;
       }
       axis->min = axis->max = AIR_NAN;
-      axis->samples = AIR_CAST(unsigned int, -1);
+      axis->samples = AIR_UINT(-1);
       axis->overrideCenter = nrrdCenterUnknown;
       axis->center = nrrdCenterUnknown;
-      axis->sizeIn = AIR_CAST(unsigned int, -1);
+      axis->sizeIn = AIR_UINT(-1);
       axis->axIdx = axIdx;                         /* never changes */
-      axis->passIdx = AIR_CAST(unsigned int, -1);
+      axis->passIdx = AIR_UINT(-1);
       for (axJdx=0; axJdx<NRRD_DIM_MAX; axJdx++) {
         axis->sizePerm[axJdx] = AIR_CAST(size_t, -1);
-        axis->axisPerm[axJdx] = AIR_CAST(unsigned int, -1);
+        axis->axisPerm[axJdx] = AIR_UINT(-1);
       }
       axis->ratio = AIR_NAN;
       axis->nrsmp = NULL;    /* these are nrrdNew()'d as needed */
@@ -323,8 +323,8 @@
   if (rsmc->axis[axIdx].samples != samples) {
     if (rsmc->verbose) {
       fprintf(stderr, "%s: axis %u samples %u --> %u\n", me, axIdx,
-              AIR_CAST(unsigned int, rsmc->axis[axIdx].samples),
-              AIR_CAST(unsigned int, samples));
+              AIR_UINT(rsmc->axis[axIdx].samples),
+              AIR_UINT(samples));
     }
     rsmc->axis[axIdx].samples = samples;
     rsmc->flag[flagSamples] = AIR_TRUE;
@@ -456,6 +456,28 @@
 }
 
 int
+nrrdResampleBoundarySpecSet(NrrdResampleContext *rsmc,
+                            const NrrdBoundarySpec *bspec) {
+  static const char me[]="nrrdResampleBoundarySpecSet";
+
+  if (!(rsmc && bspec)) {
+    biffAddf(NRRD, "%s: got NULL pointer", me);
+    return 1;
+  }
+
+  if (rsmc->boundary != bspec->boundary) {
+    rsmc->boundary = bspec->boundary;
+    rsmc->flag[flagBoundary] = AIR_TRUE;
+  }
+  if (rsmc->padValue != bspec->padValue) {
+    rsmc->padValue = bspec->padValue;
+    rsmc->flag[flagPadValue] = AIR_TRUE;
+  }
+
+  return 0;
+}
+
+int
 nrrdResampleRenormalizeSet(NrrdResampleContext *rsmc,
                            int renormalize) {
   static const char me[]="nrrdResampleRenormalizeSet";
@@ -650,7 +672,7 @@
       if (!( axis->samples >= minSamples )) {
         biffAddf(NRRD, "%s: need at least %u output samples (not %u) for "
                  "%s-centered sampling along axis %u", me, minSamples,
-                 AIR_CAST(unsigned int, axis->samples),
+                 AIR_UINT(axis->samples),
                  airEnumStr(nrrdCenter, axis->center), axIdx);
         return 1;
       }
@@ -748,7 +770,7 @@
       /* calculate sample locations and do first pass on indices */
       indexData = (int *)axis->nindex->data;
       weightData = (nrrdResample_t *)axis->nweight->data;
-      dotLen = AIR_CAST(unsigned int, axis->nweight->axis[0].size);
+      dotLen = AIR_UINT(axis->nweight->axis[0].size);
       halfLen = dotLen/2;
       for (smpIdx=0; smpIdx<axis->samples; smpIdx++) {
         idx = AIR_CAST(nrrdResample_t,
@@ -785,16 +807,16 @@
           switch(rsmc->boundary) {
           case nrrdBoundaryPad:
           case nrrdBoundaryWeight:  /* this will be further handled later */
-            rawIdx = AIR_CAST(int, axis->sizeIn);
+            rawIdx = AIR_INT(axis->sizeIn);
             break;
           case nrrdBoundaryBleed:
-            rawIdx = AIR_CLAMP(0, rawIdx, AIR_CAST(int, axis->sizeIn)-1);
+            rawIdx = AIR_CLAMP(0, rawIdx, AIR_INT(axis->sizeIn)-1);
             break;
           case nrrdBoundaryWrap:
-            rawIdx = AIR_MOD(rawIdx, AIR_CAST(int, axis->sizeIn));
+            rawIdx = AIR_MOD(rawIdx, AIR_INT(axis->sizeIn));
             break;
           case nrrdBoundaryMirror:
-            rawIdx = _nrrdMirror_32(AIR_CAST(unsigned int, axis->sizeIn), rawIdx);
+            rawIdx = _nrrdMirror_32(AIR_UINT(axis->sizeIn), rawIdx);
             break;
           default:
             biffAddf(NRRD, "%s: boundary behavior %d unknown/unimplemented",
@@ -805,40 +827,69 @@
         }
       }
 
-      /* run the sample locations through the chosen kernel.  We play a
-         sneaky trick on the kernel parameter 0 in case of downsampling
-         to create the blurring of the old index space */
-      kparm[0] = (axis->ratio < 1
-                  ? axis->kparm[0] / axis->ratio
-                  : axis->kparm[0]);
-      for (kpIdx=1; kpIdx<NRRD_KERNEL_PARMS_NUM; kpIdx++) {
-        kparm[kpIdx] = axis->kparm[kpIdx];
-      }
-      axis->kernel->EVALN(weightData, weightData, dotLen*axis->samples, kparm);
+      /* Wow - there is a big rift here between old conventions for how
+         NrrdKernels were defined, versus the newer practice of creating
+         parameter-free kernels. The "sneaky trick" code below for changing
+         parm[0] only works if the kernel actually looks at parm[0]!  So at
+         least for the parameter-free kernels (and maybe other kernels, but
+         there's no principled way of knowing! HEY actually there is now; it
+         is called nrrdKernelParm0IsScale()) we have to do what we probably
+         should have been done all along: simulating the kernel scaling by
+         pre-processing the evaluation locations and post-processing the
+         kernel weights */
+      if (0 == axis->kernel->numParm) {
+        size_t nn, ii;
+        double ratio;
+        nn = dotLen*axis->samples;
+        ratio = axis->ratio;
+        if (ratio < 1) {
+          for (ii=0; ii<nn; ii++) {
+            weightData[ii] *= ratio;
+          }
+        }
+        axis->kernel->EVALN(weightData, weightData, nn, axis->kparm);
+        if (ratio < 1) {
+          for (ii=0; ii<nn; ii++) {
+            weightData[ii] *= ratio;
+          }
+        }
+      } else {
+        /* run the sample locations through the chosen kernel.  We play a
+           sneaky trick on the kernel parameter 0 in case of downsampling
+           to create the blurring of the old index space */
+        kparm[0] = (axis->ratio < 1
+                    ? axis->kparm[0] / axis->ratio
+                    : axis->kparm[0]);
+        for (kpIdx=1; kpIdx<NRRD_KERNEL_PARMS_NUM; kpIdx++) {
+          kparm[kpIdx] = axis->kparm[kpIdx];
+        }
+        axis->kernel->EVALN(weightData, weightData,
+                            dotLen*axis->samples, kparm);
 
-      /* special handling of "cheap" kernel */
-      if (nrrdKernelCheap == axis->kernel) {
-        for (smpIdx=0; smpIdx<axis->samples; smpIdx++) {
-          nrrdResample_t dist, minDist;
-          int minIdx, minSet;
-          minIdx = indexData[0 + dotLen*smpIdx];
-          minDist = weightData[0 + dotLen*smpIdx];
-          /* find sample closest to origin */
-          for (dotIdx=1; dotIdx<dotLen; dotIdx++) {
-            dist = weightData[dotIdx + dotLen*smpIdx];
-            if (dist < minDist) {
-              minDist = dist;
-              minIdx = indexData[dotIdx + dotLen*smpIdx];
+        /* special handling of "cheap" kernel */
+        if (nrrdKernelCheap == axis->kernel) {
+          for (smpIdx=0; smpIdx<axis->samples; smpIdx++) {
+            nrrdResample_t dist, minDist;
+            int minIdx, minSet;
+            minIdx = indexData[0 + dotLen*smpIdx];
+            minDist = weightData[0 + dotLen*smpIdx];
+            /* find sample closest to origin */
+            for (dotIdx=1; dotIdx<dotLen; dotIdx++) {
+              dist = weightData[dotIdx + dotLen*smpIdx];
+              if (dist < minDist) {
+                minDist = dist;
+                minIdx = indexData[dotIdx + dotLen*smpIdx];
+              }
             }
-          }
-          /* set kernel weights to select sample closest to origin */
-          minSet = AIR_FALSE;
-          for (dotIdx=0; dotIdx<dotLen; dotIdx++) {
-            if (minIdx == indexData[dotIdx + dotLen*smpIdx] && !minSet) {
-              weightData[dotIdx + dotLen*smpIdx] = 1.0;
-              minSet = AIR_TRUE;
-            } else {
-              weightData[dotIdx + dotLen*smpIdx] = 0.0;
+            /* set kernel weights to select sample closest to origin */
+            minSet = AIR_FALSE;
+            for (dotIdx=0; dotIdx<dotLen; dotIdx++) {
+              if (minIdx == indexData[dotIdx + dotLen*smpIdx] && !minSet) {
+                weightData[dotIdx + dotLen*smpIdx] = 1.0;
+                minSet = AIR_TRUE;
+              } else {
+                weightData[dotIdx + dotLen*smpIdx] = 0.0;
+              }
             }
           }
         }
@@ -866,13 +917,13 @@
           for (smpIdx=0; smpIdx<axis->samples; smpIdx++) {
             nrrdResample_t wght = 0;
             for (dotIdx=0; dotIdx<dotLen; dotIdx++) {
-              if (AIR_CAST(int, axis->sizeIn)
+              if (AIR_INT(axis->sizeIn)
                   != indexData[dotIdx + dotLen*smpIdx]) {
                 wght += weightData[dotIdx + dotLen*smpIdx];
               }
             }
             for (dotIdx=0; dotIdx<dotLen; dotIdx++) {
-              if (AIR_CAST(int, axis->sizeIn)
+              if (AIR_INT(axis->sizeIn)
                   != indexData[dotIdx + dotLen*smpIdx]) {
                 weightData[dotIdx + dotLen*smpIdx] *= integral/wght;
               } else {
@@ -939,10 +990,10 @@
       || rsmc->flag[flagKernels]
       || rsmc->flag[flagSamples]) {
 
-    rsmc->topRax = rsmc->botRax = AIR_CAST(unsigned int, -1);
+    rsmc->topRax = rsmc->botRax = AIR_UINT(-1);
     for (axIdx=0; axIdx<rsmc->dim; axIdx++) {
       if (rsmc->axis[axIdx].kernel) {
-        if (AIR_CAST(unsigned int, -1) == rsmc->topRax) {
+        if (AIR_UINT(-1) == rsmc->topRax) {
           rsmc->topRax = axIdx;
         }
         rsmc->botRax = axIdx;
@@ -950,8 +1001,8 @@
     }
     if (rsmc->verbose) {
       fprintf(stderr, "%s: topRax = %u (%d); botRax = %u (%d)\n", me,
-              rsmc->topRax, AIR_CAST(int, rsmc->topRax),
-              rsmc->botRax, AIR_CAST(int, rsmc->botRax));
+              rsmc->topRax, AIR_INT(rsmc->topRax),
+              rsmc->botRax, AIR_INT(rsmc->botRax));
     }
 
     /* figure out total number of passes needed, and construct the
@@ -964,19 +1015,19 @@
     for (axIdx=0; axIdx<rsmc->dim; axIdx++) {
       if (rsmc->axis[axIdx].kernel) {
         do {
-          bi = AIR_MOD(bi+1, AIR_CAST(int, rsmc->dim));
+          bi = AIR_MOD(bi+1, AIR_INT(rsmc->dim));
         } while (!rsmc->axis[bi].kernel);
         rsmc->permute[bi] = axIdx;
         rsmc->passNum += 1;
       } else {
         rsmc->permute[axIdx] = axIdx;
-        bi += bi == AIR_CAST(int, axIdx);
+        bi += bi == AIR_INT(axIdx);
       }
     }
     rsmc->permute[rsmc->dim] = rsmc->dim;  /* HEY: what is this for? */
 
     if (rsmc->passNum) {
-      toTop = AIR_CAST(unsigned int, -1);
+      toTop = AIR_UINT(-1);
       for (axIdx=0; axIdx<rsmc->dim; axIdx++) {
         /* this will always "break" somewhere */
         if (rsmc->topRax == rsmc->permute[axIdx]) {
@@ -1047,7 +1098,7 @@
           fprintf(stderr, "     sizes: ");
           for (axIdx=0; axIdx<rsmc->dim; axIdx++) {
             fprintf(stderr, "%3u ",
-                    AIR_CAST(unsigned int, axis->sizePerm[axIdx]));
+                    AIR_UINT(axis->sizePerm[axIdx]));
           }
           fprintf(stderr, "\n");
         }
@@ -1155,7 +1206,7 @@
       char stmp1[AIR_STRLEN_SMALL], stmp2[AIR_STRLEN_SMALL];
       fprintf(stderr, "%s(%u): lineNum = %s\n", me, passIdx,
               airSprintSize_t(stmp1, lineNum));
-      fprintf(stderr, "%s(%u): strideIn = %s, stridOut = %s\n", me, passIdx,
+      fprintf(stderr, "%s(%u): strideIn = %s, strideOut = %s\n", me, passIdx,
               airSprintSize_t(stmp1, strideIn),
               airSprintSize_t(stmp2, strideOut));
     }
@@ -1174,8 +1225,8 @@
       if (rsmc->verbose) {
         fprintf(stderr, "%s: allocated pass %u/%u output nrrd @ %p/%p "
                 "(on axis %u)\n", me, passIdx, axisIn->passIdx,
-                AIR_CAST(void*, axisOut->nrsmp),
-                AIR_CAST(void*, axisOut->nrsmp->data), axisOut->axIdx);
+                AIR_VOIDP(axisOut->nrsmp),
+                AIR_VOIDP(axisOut->nrsmp->data), axisOut->axIdx);
       }
     } else {
       if (nrrdMaybeAlloc_nva(nout, typeOut, rsmc->dim, axisOut->sizePerm)) {
@@ -1184,9 +1235,7 @@
       }
       if (rsmc->verbose) {
         fprintf(stderr, "%s: allocated final pass %u output nrrd @ %p/%p\n",
-                me, passIdx,
-                AIR_CAST(void*, nout),
-                AIR_CAST(void*, nout->data));
+                me, passIdx, AIR_VOIDP(nout), AIR_VOIDP(nout->data));
       }
     }
 
@@ -1209,6 +1258,13 @@
     line = (nrrdResample_t *)(axisIn->nline->data);
     indx = (int *)(axisIn->nindex->data);
     weight = (nrrdResample_t *)(axisIn->nweight->data);
+    if (rsmc->verbose) {
+      fprintf(stderr, "%s: {rsmp,data}In = %p/%p; {rsmp,data}Out = %p/%p\n",
+              me, (void*)rsmpIn, (const void*)dataIn,
+              (void*)rsmpOut, (void*)dataOut);
+      fprintf(stderr, "%s: line = %p; indx = %p; weight = %p\n",
+              me, (void*)line, (void*)indx, (void*)weight);
+    }
 
     /* the skinny */
     for (axIdx=0; axIdx<rsmc->dim; axIdx++) {
@@ -1233,7 +1289,6 @@
           line[smpIdx] = rsmpIn[smpIdx*strideIn + indexIn];
         }
       }
-
       /* do the bloody convolution and save the output value */
       dotLen = axisIn->nweight->axis[0].size;
       for (smpIdx=0; smpIdx<axisIn->samples; smpIdx++) {
@@ -1302,7 +1357,7 @@
     if (axisIn->nrsmp) {
       if (rsmc->verbose) {
         fprintf(stderr, "%s: nrrdNuke(%p) pass %u input (on axis %u)\n",
-                me, AIR_CAST(void*, axisIn->nrsmp), axisIn->passIdx,
+                me, AIR_VOIDP(axisIn->nrsmp), axisIn->passIdx,
                 axisIn->axIdx);
       }
       axisIn->nrsmp = nrrdNuke(axisIn->nrsmp);
@@ -1498,7 +1553,7 @@
       || _nrrdResampleVectorFillUpdate(rsmc)
       || _nrrdResamplePermutationUpdate(rsmc)
       || _nrrdResampleOutputUpdate(rsmc, nout, func)) {
-    biffAddf(NRRD, "%s: trouble", me);
+    biffAddf(NRRD, "%s: trouble resampling", me);
     return 1;
   }
   rsmc->time = airTime() - time0;
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/resampleNrrd.c teem-1.11.0-src/src/nrrd/resampleNrrd.c
--- teem-1.11.0-src.orig/src/nrrd/resampleNrrd.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/resampleNrrd.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/simple.c teem-1.11.0-src/src/nrrd/simple.c
--- teem-1.11.0-src.orig/src/nrrd/simple.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/simple.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -50,6 +50,10 @@
     return 0;
   }
   switch (space) {
+  case nrrdSpaceRightUp:
+  case nrrdSpaceRightDown:
+    ret = 2;
+    break;
   case nrrdSpaceRightAnteriorSuperior:
   case nrrdSpaceLeftAnteriorSuperior:
   case nrrdSpaceLeftPosteriorSuperior:
@@ -580,7 +584,7 @@
 }
 
 int
-nrrdSpaceVecExists(unsigned int sdim, double vec[NRRD_SPACE_DIM_MAX]) {
+nrrdSpaceVecExists(unsigned int sdim, const double vec[NRRD_SPACE_DIM_MAX]) {
   int exists;
   unsigned int ii;
 
@@ -1477,26 +1481,26 @@
     biffAddf(NRRD, "%s: sizeof() for nrrd types has problem: "
              "expected (%u,%u,%u,%u,%u,%u,%u,%u,%u,%u) "
              "but got (%u,%u,%u,%u,%u,%u,%u,%u,%u,%u)", me,
-             AIR_CAST(unsigned int, nrrdTypeSize[nrrdTypeChar]),
-             AIR_CAST(unsigned int, nrrdTypeSize[nrrdTypeUChar]),
-             AIR_CAST(unsigned int, nrrdTypeSize[nrrdTypeShort]),
-             AIR_CAST(unsigned int, nrrdTypeSize[nrrdTypeUShort]),
-             AIR_CAST(unsigned int, nrrdTypeSize[nrrdTypeInt]),
-             AIR_CAST(unsigned int, nrrdTypeSize[nrrdTypeUInt]),
-             AIR_CAST(unsigned int, nrrdTypeSize[nrrdTypeLLong]),
-             AIR_CAST(unsigned int, nrrdTypeSize[nrrdTypeULLong]),
-             AIR_CAST(unsigned int, nrrdTypeSize[nrrdTypeFloat]),
-             AIR_CAST(unsigned int, nrrdTypeSize[nrrdTypeDouble]),
-             AIR_CAST(unsigned int, sizeof(char)),
-             AIR_CAST(unsigned int, sizeof(unsigned char)),
-             AIR_CAST(unsigned int, sizeof(short)),
-             AIR_CAST(unsigned int, sizeof(unsigned short)),
-             AIR_CAST(unsigned int, sizeof(int)),
-             AIR_CAST(unsigned int, sizeof(unsigned int)),
-             AIR_CAST(unsigned int, sizeof(airLLong)),
-             AIR_CAST(unsigned int, sizeof(airULLong)),
-             AIR_CAST(unsigned int, sizeof(float)),
-             AIR_CAST(unsigned int, sizeof(double)));
+             AIR_UINT(nrrdTypeSize[nrrdTypeChar]),
+             AIR_UINT(nrrdTypeSize[nrrdTypeUChar]),
+             AIR_UINT(nrrdTypeSize[nrrdTypeShort]),
+             AIR_UINT(nrrdTypeSize[nrrdTypeUShort]),
+             AIR_UINT(nrrdTypeSize[nrrdTypeInt]),
+             AIR_UINT(nrrdTypeSize[nrrdTypeUInt]),
+             AIR_UINT(nrrdTypeSize[nrrdTypeLLong]),
+             AIR_UINT(nrrdTypeSize[nrrdTypeULLong]),
+             AIR_UINT(nrrdTypeSize[nrrdTypeFloat]),
+             AIR_UINT(nrrdTypeSize[nrrdTypeDouble]),
+             AIR_UINT(sizeof(char)),
+             AIR_UINT(sizeof(unsigned char)),
+             AIR_UINT(sizeof(short)),
+             AIR_UINT(sizeof(unsigned short)),
+             AIR_UINT(sizeof(int)),
+             AIR_UINT(sizeof(unsigned int)),
+             AIR_UINT(sizeof(airLLong)),
+             AIR_UINT(sizeof(airULLong)),
+             AIR_UINT(sizeof(float)),
+             AIR_UINT(sizeof(double)));
     return 0;
   }
 
@@ -1508,7 +1512,7 @@
   if (maxsize != NRRD_TYPE_SIZE_MAX) {
     biffAddf(NRRD,
              "%s: actual max type size is %u != %u == NRRD_TYPE_SIZE_MAX",
-             me, AIR_CAST(unsigned int, maxsize), NRRD_TYPE_SIZE_MAX);
+             me, AIR_UINT(maxsize), NRRD_TYPE_SIZE_MAX);
     return 0;
   }
 
@@ -1516,8 +1520,8 @@
   if (maxsize != sizeof(NRRD_TYPE_BIGGEST)) {
     biffAddf(NRRD, "%s: actual max type size is %u != "
              "%u == sizeof(NRRD_TYPE_BIGGEST)",
-             me, AIR_CAST(unsigned int, maxsize),
-             AIR_CAST(unsigned int, sizeof(NRRD_TYPE_BIGGEST)));
+             me, AIR_UINT(maxsize),
+             AIR_UINT(sizeof(NRRD_TYPE_BIGGEST)));
     return 0;
   }
 
@@ -1608,4 +1612,28 @@
   }
   return;
 }
+
+void
+nrrdNaNSet(Nrrd *nout) {
+  size_t II, NN;
+
+  if (_nrrdCheck(nout, AIR_TRUE, AIR_FALSE)) {
+    /* bad nrrd, oh well */
+    return;
+  }
+  /* HEY if Half is ever added we'll have to check for it here */
+  NN = nrrdElementNumber(nout);
+  if (nrrdTypeFloat == nout->type) {
+    float *ff = AIR_CAST(float *, nout->data);
+    for (II=0; II<NN; II++) {
+      ff[II] = AIR_NAN;
+    }
+  } else if (nrrdTypeDouble == nout->type) {
+    double *dd = AIR_CAST(double *, nout->data);
+    for (II=0; II<NN; II++) {
+      dd[II] = AIR_NAN;
+    }
+  }
+  return;
+}
 /* ---- END non-NrrdIO */
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/sources.cmake teem-1.11.0-src/src/nrrd/sources.cmake
--- teem-1.11.0-src.orig/src/nrrd/sources.cmake	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,62 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(NRRD_SOURCES
-  accessors.c
-  apply1D.c
-  apply2D.c
-  arith.c
-  arraysNrrd.c
-  axis.c
-  cc.c
-  ccmethods.c
-  comment.c
-  convertNrrd.c
-  defaultsNrrd.c
-  deringNrrd.c
-  encoding.c
-  encodingAscii.c
-  encodingBzip2.c
-  encodingGzip.c
-  encodingHex.c
-  encodingRaw.c
-  endianNrrd.c
-  enumsNrrd.c
-  filt.c
-  format.c
-  formatEPS.c
-  formatNRRD.c
-  formatPNG.c
-  formatPNM.c
-  formatText.c
-  formatVTK.c
-  gzio.c
-  hestNrrd.c
-  histogram.c
-  iter.c
-  kernel.c
-  keyvalue.c
-  map.c
-  measure.c
-  methodsNrrd.c
-  nrrd.h
-  nrrdDefines.h
-  nrrdEnums.h
-  nrrdMacros.h
-  parseNrrd.c
-  privateNrrd.h
-  range.c
-  read.c
-  reorder.c
-  resampleContext.c
-  fftNrrd.c
-  resampleNrrd.c
-  simple.c
-  subset.c
-  superset.c
-  tmfKernel.c
-  winKernel.c
-  bsplKernel.c
-  write.c
-  )
-
-ADD_TEEM_LIBRARY(nrrd ${NRRD_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/subset.c teem-1.11.0-src/src/nrrd/subset.c
--- teem-1.11.0-src.orig/src/nrrd/subset.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/subset.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -388,14 +388,15 @@
                 unsigned int saxi, Nrrd *_nline, double thresh) {
   static const char me[]="nrrdSliceSelect";
   airArray *mop;
-  Nrrd *nline, *nslice;
+  Nrrd *nline, *nslice, *noutPrep[2] /* pre-axes-permute */, *nout[2];
   NrrdRange *rng;
   double *line;
   size_t II, LL, numAbove, numBelow, stride,
-    sizeAbove[NRRD_DIM_MAX], sizeBelow[NRRD_DIM_MAX];
-  unsigned int aa, bb;
-  int axmap[NRRD_DIM_MAX];
-  char *above, *below, stmp[2][AIR_STRLEN_SMALL];
+    size[2 /* 0=above 1=below */][NRRD_DIM_MAX];
+  unsigned int aa, bb, oi,
+    axperm[NRRD_DIM_MAX]; /* for doing the axis permute to final out */
+  int axmap[NRRD_DIM_MAX]; /* for copying axis info from nin to outputs */
+  char *ABdata[2], stmp[2][AIR_STRLEN_SMALL];
 
   if (!( (noutAbove || noutBelow) && nin && _nline )) {
     biffAddf(NRRD, "%s: got NULL pointer", me);
@@ -415,8 +416,8 @@
     return 1;
   }
   if (nrrdTypeBlock == nin->type) {
-    /* no good reason for this except that GLK forgets out to
-       set the blocksize in output */
+    /* no good reason for this except that GLK currently forgets how
+       to set the blocksize in output */
     biffAddf(NRRD, "%s: sorry, can't handle type %s input", me,
              airEnumStr(nrrdType, nrrdTypeBlock));
     return 1;
@@ -434,8 +435,8 @@
     return 1;
   }
   if (1 == nin->dim) {
-    biffAddf(NRRD, "%s: sorry, slice-based implementation requires input "
-             "dimension > 1", me);
+    biffAddf(NRRD, "%s: sorry, current slice-based implementation "
+             "requires input dimension > 1", me);
     return 1;
   }
 
@@ -448,6 +449,7 @@
   }
 
   nslice = nrrdNew();
+  /* NB: nix, not nuke, because of the pointer games involved */
   airMopAdd(mop, nslice, (airMopper)nrrdNix, airMopAlways);
   nline = nrrdNew();
   airMopAdd(mop, nline, (airMopper)nrrdNuke, airMopAlways);
@@ -466,110 +468,114 @@
       numBelow++;
     }
   }
-  if (noutAbove && !numAbove) {
-    biffAddf(NRRD, "%s: want slices for val >= thresh %g, "
-             "but highest value is %g < %g\n", me, thresh,
-             rng->max, thresh);
-    airMopError(mop); return 1;
+  if (noutAbove) {
+    if (!numAbove) {
+      biffAddf(NRRD, "%s: want slices for val >= thresh %g, "
+               "but highest value is %g < %g\n", me, thresh,
+               rng->max, thresh);
+      airMopError(mop); return 1;
+    }
+    noutPrep[0] = nrrdNew();
+    airMopAdd(mop, noutPrep[0], (airMopper)nrrdNuke, airMopAlways);
+    nout[0] = noutAbove;
+  } else {
+    noutPrep[0] = nout[0] = NULL;
   }
-  if (noutBelow && !numBelow) {
-    biffAddf(NRRD, "%s: want slices for val < thresh %g, "
-             "but lowest value is %g >= %g\n", me, thresh,
-             rng->min, thresh);
-    airMopError(mop); return 1;
+  if (noutBelow) {
+    if (!numBelow) {
+      biffAddf(NRRD, "%s: want slices for val < thresh %g, "
+               "but lowest value is %g >= %g\n", me, thresh,
+               rng->min, thresh);
+      airMopError(mop); return 1;
+    }
+    noutPrep[1] = nrrdNew();
+    airMopAdd(mop, noutPrep[1], (airMopper)nrrdNuke, airMopAlways);
+    nout[1] = noutBelow;
+  } else {
+    noutPrep[1] = nout[1] = NULL;
   }
 
+  /* the way this works is a little subtle: we can select (and thus slice)
+     along any axis, but the output is created by concatenating the selected
+     slices on only the SLOWEST axis. This is accomplished by slicing into
+     nslice, which is carefully set up here to point to some part of one or
+     other of the outputs.  This also means that we have to permute initial
+     pre-axis-permute ("Prep") output so that the real output axes are ordered
+     the same as in the input.  The initial step here is just to do the
+     arithmetic about axes, sizes, and how input axes are mapped to (final,
+     post-axis-permute) output. "stride" is stride between slices in the
+     initial (Prep) output */
   nslice->dim = nin->dim-1;
   nslice->type = nin->type;
   bb = 0;
   stride = nrrdElementSize(nin);
   for (aa=0; aa<nin->dim; aa++) {
-    sizeAbove[aa] = sizeBelow[aa] = nin->axis[aa].size;
     if (aa != saxi) {
-      axmap[aa] = aa;
-      nslice->axis[bb].size = nin->axis[aa].size;
-      if (aa < saxi) {
-        stride *= nin->axis[aa].size;
-      }
+      size_t ssz = nin->axis[aa].size;
+      stride *= ssz;
+      axmap[aa] = aa; /* for nrrdAxisInfoCopy */
+      axperm[aa] = bb; /* for nrrdAxesPermute */
+      size[0][bb] = size[1][bb] = ssz;
+      nslice->axis[bb].size = ssz;
       bb++;
-    } else {
-      axmap[aa] = -1;
     }
   }
-  sizeAbove[saxi] = numAbove;
-  sizeBelow[saxi] = numBelow;
-  if ((noutAbove
-       && nrrdMaybeAlloc_nva(noutAbove, nin->type, nin->dim, sizeAbove))
-      ||
-      (noutBelow
-       && nrrdMaybeAlloc_nva(noutBelow, nin->type, nin->dim, sizeBelow))) {
-    biffAddf(NRRD, "%s: trouble allocating output", me);
-    airMopError(mop); return 1;
-  }
-  if (noutAbove) {
-    above = AIR_CAST(char *, noutAbove->data);
-  } else {
-    above = NULL;
-  }
-  if (noutBelow) {
-    below = AIR_CAST(char *, noutBelow->data);
-  } else {
-    below = NULL;
+  axmap[saxi] = -1;
+  axperm[saxi] = nin->dim-1;
+  size[0][nin->dim-1] = numAbove;
+  size[1][nin->dim-1] = numBelow;
+
+  /* allocate pre-permutation outputs */
+  for (oi=0; oi<=1; oi++) {
+    if (nout[oi]) /* noutAbove or noutBelow */ {
+      if (nrrdMaybeAlloc_nva(noutPrep[oi], nin->type, nin->dim, size[oi])) {
+        biffAddf(NRRD, "%s: trouble allocating output for slices %s",
+                 me, !oi ? "above" : "below");
+        airMopError(mop); return 1;
+      }
+      ABdata[oi] = AIR_CAST(char *, noutPrep[oi]->data);
+    } else {
+      ABdata[oi] = NULL;
+    }
   }
 
-  /* the skinny */
+  /* slice and concat */
   for (II=0; II<LL; II++) {
-    if (line[II] >= thresh) {
-      if (noutAbove) {
-        nslice->data = above;
-        if (nrrdSlice(nslice, nin, saxi, II)) {
-          biffAddf(NRRD, "%s: trouble slicing (above) at %s", me,
-                   airSprintSize_t(stmp[0], II));
-          airMopError(mop); return 1;
-        }
-        above += stride;
-      }
-    } else {
-      if (noutBelow) {
-        nslice->data = below;
+    int test[2];
+    test[0] = (line[II] >= thresh);
+    test[1] = !test[0];
+    for (oi=0; oi<=1; oi++) {
+      if (test[oi] && nout[oi] /* noutAbove or noutBelow */)  {
+        nslice->data = ABdata[oi];
         if (nrrdSlice(nslice, nin, saxi, II)) {
-          biffAddf(NRRD, "%s: trouble slicing (below) at %s", me,
-                   airSprintSize_t(stmp[0], II));
+          biffAddf(NRRD, "%s: trouble slicing (%s) at %s", me,
+                   !oi ? "above" : "below", airSprintSize_t(stmp[0], II));
           airMopError(mop); return 1;
         }
-        below += stride;
+        ABdata[oi] += stride;
       }
     }
   }
 
-  if (noutAbove) {
-    nrrdAxisInfoCopy(noutAbove, nin, axmap, NRRD_AXIS_INFO_NONE);
-    if (nrrdBasicInfoCopy(noutAbove, nin,
-                          NRRD_BASIC_INFO_DATA_BIT
-                          | NRRD_BASIC_INFO_TYPE_BIT
-                          | NRRD_BASIC_INFO_DIMENSION_BIT
-                          | NRRD_BASIC_INFO_CONTENT_BIT
-                          | NRRD_BASIC_INFO_COMMENTS_BIT
-                          | (nrrdStateKeyValuePairsPropagate
-                             ? 0
-                             : NRRD_BASIC_INFO_KEYVALUEPAIRS_BIT))) {
-      biffAddf(NRRD, "%s:", me);
-      return 1;
-    }
-  }
-  if (noutBelow) {
-    nrrdAxisInfoCopy(noutBelow, nin, axmap, NRRD_AXIS_INFO_NONE);
-    if (nrrdBasicInfoCopy(noutBelow, nin,
-                          NRRD_BASIC_INFO_DATA_BIT
-                          | NRRD_BASIC_INFO_TYPE_BIT
-                          | NRRD_BASIC_INFO_DIMENSION_BIT
-                          | NRRD_BASIC_INFO_CONTENT_BIT
-                          | NRRD_BASIC_INFO_COMMENTS_BIT
-                          | (nrrdStateKeyValuePairsPropagate
-                             ? 0
-                             : NRRD_BASIC_INFO_KEYVALUEPAIRS_BIT))) {
-      biffAddf(NRRD, "%s:", me);
-      return 1;
+  /* now do permute */
+  for (oi=0; oi<=1; oi++) {
+    if (nout[oi]) /* noutAbove or noutBelow */ {
+      if (nrrdAxesPermute(nout[oi], noutPrep[oi], axperm)
+          /* nrrdAxisInfoCopy doesn't use biff but does have error returns */
+          || nrrdAxisInfoCopy(nout[oi], nin, axmap, NRRD_AXIS_INFO_NONE)
+          || nrrdBasicInfoCopy(nout[oi], nin,
+                               NRRD_BASIC_INFO_DATA_BIT
+                               | NRRD_BASIC_INFO_TYPE_BIT
+                               | NRRD_BASIC_INFO_DIMENSION_BIT
+                               | NRRD_BASIC_INFO_CONTENT_BIT
+                               | NRRD_BASIC_INFO_COMMENTS_BIT
+                               | (nrrdStateKeyValuePairsPropagate
+                                  ? 0
+                                  : NRRD_BASIC_INFO_KEYVALUEPAIRS_BIT))) {
+        biffAddf(NRRD, "%s: trouble with %s output", me,
+                 !oi ? "above" : "below");
+        return 1;
+      }
     }
   }
 
@@ -781,8 +787,8 @@
     }
     /*
     fprintf(stderr, "!%s: axis %u [%u,%u] --> ", me, axi,
-            AIR_CAST(unsigned int, min[axi]),
-            AIR_CAST(unsigned int, max[axi]));
+            AIR_UINT(min[axi]),
+            AIR_UINT(max[axi]));
     */
     /* adjust based on offset */
     if (offset > 0) {
@@ -797,8 +803,8 @@
     }
     /*
     fprintf(stderr, "[%u,%u]\n",
-            AIR_CAST(unsigned int, min[axi]),
-            AIR_CAST(unsigned int, max[axi]));
+            AIR_UINT(min[axi]),
+            AIR_UINT(max[axi]));
     */
   }
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/superset.c teem-1.11.0-src/src/nrrd/superset.c
--- teem-1.11.0-src.orig/src/nrrd/superset.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/superset.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -90,10 +90,16 @@
     }
   }
   for (ai=0; ai<nslice->dim; ai++) {
-    if (!( nin->axis[ai + (ai >= axis)].size == nslice->axis[ai].size )) {
-      biffAddf(NRRD, "%s: input ax %d size (%s) != slices ax %d size (%s)",
-               me, ai + (ai >= axis),
-               airSprintSize_t(stmp[0], nin->axis[ai + (ai >= axis)].size), ai,
+    const unsigned int indexOffset = (ai >= axis);
+    unsigned int foundExitCondition = 0;
+    if(indexOffset){
+      if( nin->axis[ai + 1].size != nslice ->axis[ai].size ) foundExitCondition = 1;
+    }
+    else if( nin->axis[ai].size != nslice ->axis[ai].size ) foundExitCondition = 1;
+    if ( foundExitCondition ) {
+      biffAddf(NRRD, "%s: input ax %u size (%s) != slices ax %u size (%s)",
+               me, ai + indexOffset,
+               airSprintSize_t(stmp[0], nin->axis[ai + indexOffset].size), ai,
                airSprintSize_t(stmp[1], nslice->axis[ai].size));
       return 1;
     }
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/ax.c teem-1.11.0-src/src/nrrd/test/ax.c
--- teem-1.11.0-src.orig/src/nrrd/test/ax.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/ax.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -26,7 +26,7 @@
 #include "../nrrd.h"
 
 float frand(float min, float max) {
-  return (min + airDrandMT() * (max - min));
+  return AIR_FLOAT(min + airDrandMT() * (max - min));
 }
 
 int
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/convo.c teem-1.11.0-src/src/nrrd/test/convo.c
--- teem-1.11.0-src.orig/src/nrrd/test/convo.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/convo.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -24,7 +24,8 @@
 #include <math.h>
 #include "../nrrd.h"
 
-char *convoInfo = ("Good for convolution of two 2-D nrrd, and nothing else.");
+const char *convoInfo = ("Good for convolution of two 2-D nrrd, "
+                         "and nothing else.");
 
 #define CONVO "convo"
 
@@ -35,6 +36,7 @@
   airArray *mop;
   int E;
   unsigned int i;
+  /* HEY unsigned? */
   int x, y,
     ix, iy,         /* image coordinates */
     isx, isy,       /* input image size */
@@ -47,10 +49,10 @@
   ptrdiff_t pmin[2], pmax[2]; /* cropping bounds */
   float *ohere, *idata, *mdata, *odata, sum;
 
-  isx = _nimg->axis[0].size;
-  isy = _nimg->axis[1].size;
-  msx = _nmask->axis[0].size;
-  msy = _nmask->axis[1].size;
+  isx = AIR_INT(_nimg->axis[0].size);
+  isy = AIR_INT(_nimg->axis[1].size);
+  msx = AIR_INT(_nmask->axis[0].size);
+  msy = AIR_INT(_nmask->axis[1].size);
   lox = (msx-1)/2;
   hix = msx/2;
   loy = (msy-1)/2;
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/dnorm.c teem-1.11.0-src/src/nrrd/test/dnorm.c
--- teem-1.11.0-src.orig/src/nrrd/test/dnorm.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/dnorm.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/genvol.c teem-1.11.0-src/src/nrrd/test/genvol.c
--- teem-1.11.0-src.orig/src/nrrd/test/genvol.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/genvol.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -24,8 +24,8 @@
 #include <math.h>
 #include "../nrrd.h"
 
-char *genvolInfo = ("generates test volumes.  Not very flexible as long as "
-                    "the \"funk\" library doesn't exist");
+const char *genvolInfo = ("generates test volumes.  Not very flexible as long as "
+                          "the \"funk\" library doesn't exist");
 
 double
 rho(double r) {
@@ -42,26 +42,26 @@
   R2 = sqrt(x*x + y*y);
   phi = atan2(y+0.001,x+0.001) + z*1.2;
   w = pow((1+cos(3*phi))/2, R2*R2*90);
-  return w*mask;
+  ret = w*mask;
 
-#if 0
-  /* ridge surface is a Mobius aka Moebius strip */
-  Rbig = sqrt(x*x + y*y);
-  Rlit = sqrt(z*z + (Rbig-0.5)*(Rbig-0.5));
-  phi = atan2(Rbig-0.5, z) - atan2(x, y)/2;
-  a = Rlit*cos(phi);
-  b = Rlit*sin(phi);
-  /*
-    ret = airGaussian(a, 0, sig0)*airGaussian(b, 0, sig1);
-  */
-  a = (a > sig0
-       ? a - sig0
-       : (a < -sig0
-          ? a + sig0
-          : 0));
-  ret = airGaussian(a, 0, sig1)*airGaussian(b, 0, sig1);
+  if (0) {
+    /* ridge surface is a Mobius aka Moebius strip */
+    Rbig = sqrt(x*x + y*y);
+    Rlit = sqrt(z*z + (Rbig-0.5)*(Rbig-0.5));
+    phi = atan2(Rbig-0.5, z) - atan2(x, y)/2;
+    a = Rlit*cos(phi);
+    b = Rlit*sin(phi);
+    /*
+      ret = airGaussian(a, 0, sig0)*airGaussian(b, 0, sig1);
+    */
+    a = (a > sig0
+         ? a - sig0
+         : (a < -sig0
+            ? a + sig0
+            : 0));
+    ret = airGaussian(a, 0, sig1)*airGaussian(b, 0, sig1);
+  }
   return ret;
-#endif
 
   /*
   double A, B;
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/histrad.c teem-1.11.0-src/src/nrrd/test/histrad.c
--- teem-1.11.0-src.orig/src/nrrd/test/histrad.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/histrad.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +23,7 @@
 
 #include "../nrrd.h"
 
-char *histradInfo = ("like unu histax, but for circles");
+const char *histradInfo = ("like unu histax, but for circles");
 
 int
 main(int argc, const char *argv[]) {
@@ -92,8 +92,8 @@
 
 #define DIST(x0, y0, x1, y1) (sqrt((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1)))
 
-  sx = nin->axis[0].size;
-  sy = nin->axis[1].size;
+  sx = AIR_INT(nin->axis[0].size); /* HEY unsigned? */
+  sy = AIR_INT(nin->axis[1].size);
   if (!AIR_EXISTS(rmax)) {
     rmax = 0;
     rmax = AIR_MAX(rmax, DIST(cent[0], cent[1], 0, 0));
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/io.c teem-1.11.0-src/src/nrrd/test/io.c
--- teem-1.11.0-src.orig/src/nrrd/test/io.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/io.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/kv.c teem-1.11.0-src/src/nrrd/test/kv.c
--- teem-1.11.0-src.orig/src/nrrd/test/kv.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/kv.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -33,7 +33,8 @@
 
 int
 main(int argc, char **argv) {
-  char *me, *err, *key="strong bad", *value;
+  char *me, *err, *value;
+  const char *key="strong bad";
   Nrrd *nrrd;
   NrrdIoState *io;
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/minmax.c teem-1.11.0-src/src/nrrd/test/minmax.c
--- teem-1.11.0-src.orig/src/nrrd/test/minmax.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/minmax.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/morph.c teem-1.11.0-src/src/nrrd/test/morph.c
--- teem-1.11.0-src.orig/src/nrrd/test/morph.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/morph.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +23,7 @@
 
 #include "../nrrd.h"
 
-char *morphInfo = ("testing. ");
+const char *morphInfo = ("testing. ");
 
 int
 morph(Nrrd *nout, Nrrd *_nin, Nrrd *_nkern, float scl) {
@@ -61,10 +61,10 @@
   in = AIR_CAST(float *, nin->data);
   out = AIR_CAST(float *, nout->data);
   kern = AIR_CAST(float *, nkern->data);
-  sx = AIR_CAST(int, nin->axis[0].size);
-  sy = AIR_CAST(int, nin->axis[1].size);
-  sz = AIR_CAST(int, nin->axis[2].size);
-  kd = AIR_CAST(int, nkern->axis[0].size);
+  sx = AIR_INT(nin->axis[0].size); /* HEY unsigned */
+  sy = AIR_INT(nin->axis[1].size);
+  sz = AIR_INT(nin->axis[2].size);
+  kd = AIR_INT(nkern->axis[0].size);
   kr = kd/2; /* 5 -> 2 */
 
   /* min_i (f(x+i)- k(i)) */
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/otsu.c teem-1.11.0-src/src/nrrd/test/otsu.c
--- teem-1.11.0-src.orig/src/nrrd/test/otsu.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/otsu.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +23,7 @@
 
 #include "../nrrd.h"
 
-char *otsuInfo = ("demonstrates nrrd's Otsu thresholding");
+const char *otsuInfo = ("demonstrates nrrd's Otsu thresholding");
 
 int
 main(int argc, const char *argv[]) {
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/phrnd.c teem-1.11.0-src/src/nrrd/test/phrnd.c
--- teem-1.11.0-src.orig/src/nrrd/test/phrnd.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/phrnd.c	2021-02-18 15:42:32.000000000 +0800
@@ -0,0 +1,294 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "../nrrd.h"
+
+#define NRRDNEW(X)                                              \
+  (X) = nrrdNew();                                              \
+  airMopAdd(mop, (X), (airMopper)nrrdNuke, airMopAlways)
+
+const char *phrndInfo = ("randomizes phase of a real-valued array "
+                         "while preserving the spectrum");
+
+int
+main(int argc, const char *argv[]) {
+  const char *me;
+  hestOpt *hopt;
+  hestParm *hparm;
+  airArray *mop;
+
+  int rigor;
+  char *err, *outS, *imagOutS, *wispath, *seedS;
+  Nrrd *ntmp, *ntmp2, /* tmp */
+    *njarg[2], /* arguments to join */
+    *nrin,   /* given real-valued input */
+    *nrdin,  /* given real-valued input, as double */
+    *ncin,   /* (padded) complex-valued input */
+    *ncfin,  /* complex-valued transform of input */
+    *nR,     /* real part of something */
+    *nI,     /* imag part of something */
+    *nP,     /* phase */
+    *nM,     /* mag */
+    *nlut,   /* phase look-up table */
+    *ncfout, /* complex-valued transform of output */
+    *ncdout,  /* double complex-valued output */
+    *ncout,  /* complex-valued output, as input type */
+    *niout,  /* imaginary output */
+    *nrout;  /* real output */
+  double howrand, *lut, *P;
+  unsigned int len, axi, seed;
+  size_t II, NN, minInset[NRRD_DIM_MAX];
+  FILE *fwise;
+  unsigned int axes[NRRD_DIM_MAX];
+  ptrdiff_t minPad[NRRD_DIM_MAX], maxPad[NRRD_DIM_MAX];
+
+  me = argv[0];
+  mop = airMopNew();
+  hparm = hestParmNew();
+  hopt = NULL;
+  airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);
+  hestOptAdd(&hopt, "i", "nin", airTypeOther, 1, 1, &nrin, NULL,
+             "input array", NULL, NULL, nrrdHestNrrd);
+  hestOptAdd(&hopt, "n", "len", airTypeUInt, 1, 1, &len, "65536",
+             "length (must be EVEN) of phase look-up table, used "
+             "enable being dumb (rather than clever) in asserting "
+             "the phase symmetries arising from real input");
+  hestOptAdd(&hopt, "r", "howrandom", airTypeDouble, 1, 1, &howrand, "1.0",
+             "how much to randomize input phase; 0.0 means "
+             "that output should be same as input");
+  hestOptAdd(&hopt, "pr,planrigor", "pr", airTypeEnum, 1, 1, &rigor, "est",
+             "rigor with which fftw plan is constructed. Options include:\n "
+             "\b\bo \"e\", \"est\", \"estimate\": only an estimate\n "
+             "\b\bo \"m\", \"meas\", \"measure\": standard amount of "
+             "measurements of system properties\n "
+             "\b\bo \"p\", \"pat\", \"patient\": slower, more measurements\n "
+             "\b\bo \"x\", \"ex\", \"exhaustive\": slowest, most measurements",
+             NULL, nrrdFFTWPlanRigor);
+  hestOptAdd(&hopt, "w,wisdom", "filename", airTypeString, 1, 1, &wispath, "",
+             "A filename here is used to read in fftw wisdom (if the file "
+             "exists already), and is used to save out updated wisdom "
+             "after the transform.  By default (not using this option), "
+             "no wisdom is read or saved. Note: no wisdom is gained "
+             "(that is, learned by FFTW) with planning rigor \"estimate\".");
+  hestOptAdd(&hopt, "s,seed", "seed", airTypeString, 1, 1, &seedS, "",
+             "seed value for RNG for rand and nrand, so that you "
+             "can get repeatable results between runs, or, "
+             "by not using this option, the RNG seeding will be "
+             "based on the current time");
+  hestOptAdd(&hopt, "io", "filename", airTypeString, 1, 1, &imagOutS, "",
+             "if a filename is given with this option, the imaginary "
+             "component of the transformed output is saved here, to "
+             "permit confirming that it doesn't carry significant info");
+  hestOptAdd(&hopt, "o", "filename", airTypeString, 1, 1, &outS, NULL,
+             "file to write output nrrd to");
+  hestParseOrDie(hopt, argc-1, argv+1, hparm,
+                 me, phrndInfo, AIR_TRUE, AIR_TRUE, AIR_TRUE);
+  airMopAdd(mop, hopt, (airMopper)hestOptFree, airMopAlways);
+  airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);
+
+  if (0 != len % 2) {
+    fprintf(stderr, "%s: given length %u is not even\n", me, len);
+    airMopError(mop);
+    return 1;
+  }
+  if (airStrlen(seedS)) {
+    if (1 != sscanf(seedS, "%u", &seed)) {
+      fprintf(stderr, "%s: couldn't parse seed \"%s\" as uint\n", me, seedS);
+      airMopError(mop);
+      return 1;
+    } else {
+      airSrandMT(seed);
+    }
+  } else {
+    /* got no request for specific seed */
+    airSrandMT(AIR_UINT(airTime()));
+  }
+  for (axi=0; axi<NRRD_DIM_MAX; axi++) {
+    minInset[axi] = 0;
+  }
+  /* pointless to set content */
+  nrrdStateDisableContent = AIR_TRUE;
+
+  /* ============== pad real input nrin to complex-valued input ncin */
+  minPad[0] = 0;
+  maxPad[0] = 1;
+  for (axi=0; axi<nrin->dim; axi++) {
+    minPad[axi+1] = 0;
+    maxPad[axi+1] = AIR_CAST(ptrdiff_t, nrin->axis[axi].size-1);
+  }
+  NRRDNEW(nrdin);
+  NRRDNEW(ntmp);
+  NRRDNEW(ncin);
+  if (nrrdConvert(nrdin, nrin, nrrdTypeDouble)
+      || nrrdAxesInsert(ntmp, nrdin, 0)
+      || nrrdPad_nva(ncin, ntmp, minPad, maxPad, nrrdBoundaryPad, 0.0)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error creating complex input:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+
+  /* ============== learn possible wisdom */
+  if (airStrlen(wispath) && nrrdFFTWEnabled) {
+    fwise = fopen(wispath, "r");
+    if (fwise) {
+      if (nrrdFFTWWisdomRead(fwise)) {
+        airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+        fprintf(stderr, "%s: error with fft wisdom:\n%s", me, err);
+        airMopError(mop);
+        return 1;
+      }
+      fclose(fwise);
+    } else {
+      fprintf(stderr, "%s: (\"%s\" couldn't be opened, will try to save "
+              "wisdom afterwards)", me, wispath);
+    }
+  }
+
+  /* ============== transform input to phase and magnitude */
+  for (axi=0; axi<nrin->dim; axi++) {
+    axes[axi] = axi+1;
+  }
+  NRRDNEW(ncfin);
+  NRRDNEW(nR);
+  NRRDNEW(nI);
+  NRRDNEW(nP);
+  NRRDNEW(nM);
+  if (nrrdFFT(ncfin, ncin, axes, nrin->dim, +1, AIR_TRUE, rigor)
+      || nrrdSlice(nR, ncfin, 0, 0)
+      || nrrdSlice(nI, ncfin, 0, 1)
+      || nrrdArithBinaryOp(nP, nrrdBinaryOpAtan2, nI, nR)
+      || nrrdProject(nM, ncfin, 0, nrrdMeasureL2, nrrdTypeDefault)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error processing input:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+
+  /* ============== randomize phase */
+  NRRDNEW(nlut);
+  if (nrrdMaybeAlloc_va(nlut, nrrdTypeDouble, 1, AIR_CAST(size_t, len))) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error making lut:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+  lut = AIR_CAST(double *, nlut->data);
+  for (II=0; II<len; II++) {
+    /* random phase */
+    if (II < len/2) {
+      lut[II] = AIR_AFFINE(0, airDrandMT(), 1, -AIR_PI, AIR_PI);
+    } else {
+      lut[II] = -lut[len-1-II];
+    }
+  }
+  NN = nrrdElementNumber(nP);
+  P = AIR_CAST(double *, nP->data);
+  for (II=0; II<NN; II++) {
+    /* pp is the original input phase */
+    double pp = P[II];
+    /* pi is the index for the input phase */
+    unsigned int pi = airIndex(-AIR_PI, pp, AIR_PI, len);
+    /* lin is the best approximation (up to len tables) of original value */
+    /* double lin = AIR_AFFINE(-0.5, pi, len-0.5, -AIR_PI, AIR_PI); */
+    /* printf("%g %u %g %g\n", P[II], pi, lut[pi], lin); */
+    /* lut[pi] is the randomized phase */
+    P[II] = AIR_LERP(howrand, pp, lut[pi]);
+  }
+
+  /* ============== transform (new) phase and magnitude to output */
+  njarg[0] = nR;
+  njarg[1] = nI;
+  NRRDNEW(ncfout);
+  NRRDNEW(ncdout);
+  NRRDNEW(ncout);
+  NRRDNEW(ntmp2);
+  if (nrrdArithUnaryOp(nR, nrrdUnaryOpCos, nP)
+      || nrrdArithBinaryOp(nR, nrrdBinaryOpMultiply, nR, nM)
+      || nrrdArithUnaryOp(nI, nrrdUnaryOpSin, nP)
+      || nrrdArithBinaryOp(nI, nrrdBinaryOpMultiply, nI, nM)
+      || nrrdJoin(ncfout, AIR_CAST(const Nrrd*const*, njarg), 2, 0, AIR_TRUE)
+      || nrrdFFT(ncdout, ncfout, axes, nrin->dim, -1, AIR_TRUE, rigor)
+      || nrrdConvert(ntmp, ncdout, nrin->type)
+      || nrrdConvert(ntmp2, ncin, nrin->type)
+      || nrrdInset(ncout, ntmp2, ntmp, minInset)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error creating output\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+  /*
+  if (nrrdSave("cfin.nrrd", ncfin, NULL) ||
+      nrrdSave("cout.nrrd", ncout, NULL) ||
+      nrrdSave("cin.nrrd", ncin, NULL) ||
+      nrrdSave("tmp.nrrd", ntmp, NULL) ||
+      nrrdSave("R.nrrd", nR, NULL) ||
+      nrrdSave("I.nrrd", nI, NULL) ||
+      nrrdSave("P.nrrd", nP, NULL) ||
+      nrrdSave("M.nrrd", nM, NULL)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error saving tmps:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+  */
+
+  /* ============== DONE. saving things to save */
+  if (airStrlen(wispath) && nrrdFFTWEnabled) {
+    if (!(fwise = fopen(wispath, "w"))) {
+      fprintf(stderr, "%s: couldn't open %s for writing: %s\n",
+              me, wispath, strerror(errno));
+      airMopError(mop);
+      return 1;
+    }
+    if (nrrdFFTWWisdomWrite(fwise)) {
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: error with fft wisdom:\n%s", me, err);
+      airMopError(mop);
+      return 1;
+    }
+    fclose(fwise);
+  }
+  if (airStrlen(imagOutS)) {
+    NRRDNEW(niout);
+    if (nrrdSlice(niout, ncout, 0, 1)
+        || nrrdSave(imagOutS, niout, NULL)) {
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: error slicing/saving imaginary output:\n%s",
+              me, err);
+      airMopError(mop);
+      return 1;
+    }
+  }
+  NRRDNEW(nrout);
+  if (nrrdSlice(nrout, ncout, 0, 0)
+      || nrrdSave(outS, nrout, NULL)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: problem slicing/saving real output:\n%s\n",
+            me, err);
+    airMopError(mop); return 1;
+  }
+
+  airMopOkay(mop);
+  exit(0);
+}
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/quadvol.c teem-1.11.0-src/src/nrrd/test/quadvol.c
--- teem-1.11.0-src.orig/src/nrrd/test/quadvol.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/quadvol.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -24,8 +24,8 @@
 #include <math.h>
 #include "../nrrd.h"
 
-char *quadInfo = ("generates quadratic test volumes, with isosurfaces "
-                    "which should resemble z = A*x^2 + B*y^2");
+const char *quadInfo = ("generates quadratic test volumes, with isosurfaces "
+                        "which should resemble z = A*x^2 + B*y^2");
 
 float
 quadFunc(float x, float y, float z, float A, float B, float off) {
@@ -79,11 +79,11 @@
 
   data = (float *)nout->data;
   for (zi=0; zi<size[2]; zi++) {
-    z = AIR_AFFINE(0, zi, size[2]-1, min[2], max[2]);
+    z = AIR_FLOAT(AIR_AFFINE(0, zi, size[2]-1, min[2], max[2]));
     for (yi=0; yi<size[1]; yi++) {
-      y = AIR_AFFINE(0, yi, size[1]-1, min[1], max[1]);
+      y = AIR_FLOAT(AIR_AFFINE(0, yi, size[1]-1, min[1], max[1]));
       for (xi=0; xi<size[0]; xi++) {
-        x = AIR_AFFINE(0, xi, size[0]-1, min[0], max[0]);
+        x = AIR_FLOAT(AIR_AFFINE(0, xi, size[0]-1, min[0], max[0]));
         *data = quadFunc(x,y,z, AB[0], AB[1], off);
         data += 1;
       }
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/reuse.c teem-1.11.0-src/src/nrrd/test/reuse.c
--- teem-1.11.0-src.orig/src/nrrd/test/reuse.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/reuse.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/strio.c teem-1.11.0-src/src/nrrd/test/strio.c
--- teem-1.11.0-src.orig/src/nrrd/test/strio.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/strio.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/texp.c teem-1.11.0-src/src/nrrd/test/texp.c
--- teem-1.11.0-src.orig/src/nrrd/test/texp.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/texp.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/tkernel.c teem-1.11.0-src/src/nrrd/test/tkernel.c
--- teem-1.11.0-src.orig/src/nrrd/test/tkernel.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/tkernel.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/tline.c teem-1.11.0-src/src/nrrd/test/tline.c
--- teem-1.11.0-src.orig/src/nrrd/test/tline.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/tline.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/trand.c teem-1.11.0-src/src/nrrd/test/trand.c
--- teem-1.11.0-src.orig/src/nrrd/test/trand.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/trand.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/tread.c teem-1.11.0-src/src/nrrd/test/tread.c
--- teem-1.11.0-src.orig/src/nrrd/test/tread.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/tread.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/test/typestest.c teem-1.11.0-src/src/nrrd/test/typestest.c
--- teem-1.11.0-src.orig/src/nrrd/test/typestest.c	2012-12-20 22:09:53.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/test/typestest.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/tmf/fix1.pl teem-1.11.0-src/src/nrrd/tmf/fix1.pl
--- teem-1.11.0-src.orig/src/nrrd/tmf/fix1.pl	2012-12-20 22:10:02.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/tmf/fix1.pl	2021-02-18 15:42:33.000000000 +0800
@@ -1,7 +1,7 @@
-#!/usr/bin/perl 
+#!/usr/bin/perl
 #
 # Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -28,13 +28,13 @@
 
     # nix carraige returns
     s///g;
-    
+
     # nix pragmas
     s/\#pragma warning.+$//g;
 
     if (/w[pm][0-9][a-z] = /) {
 	chomp;         # nix newline
-	s/ //g;        # nix spaces 
+	s/ //g;        # nix spaces
 	s/;$//g;       # nix last semicolon
 	foreach $pair (split /;/) {
 	    ($var, $val) = split /=/, $pair;
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/tmf/fix2.pl teem-1.11.0-src/src/nrrd/tmf/fix2.pl
--- teem-1.11.0-src.orig/src/nrrd/tmf/fix2.pl	2012-12-20 22:10:02.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/tmf/fix2.pl	2021-02-18 15:42:33.000000000 +0800
@@ -1,7 +1,7 @@
 #!/usr/bin/perl -w
 #
 # Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -129,7 +129,7 @@
 	    s/case ([0-9]): +result *= *(.+); +break;$/\(i == $1 ? $2 : \\/g;
 	    $n = $1;
 	    $sup = ($n + 1)/2;
-	    
+
 	    # when we've reached the end of the switch cases
 	    if (/default: result = 0;/) {
 		# the default case
@@ -139,10 +139,10 @@
 		for ($i=0; $i <= $n; $i++) {
 		    print ")";
 		}
-		
+
 		# and one more end paren to finish the #define
 		print ")\n\n";
-		
+
 		# remember what the support is
 		$support{$kern} = $sup;
 		last;
@@ -276,9 +276,9 @@
 	     . "  _nrrd_${kern}_1_f,  _nrrd_${kern}_N_f,\n"
 	     . "  _nrrd_${kern}_1_d,  _nrrd_${kern}_N_d\n"
 	     . "};\n\n");
-    ($integral 
-     . $support 
-     . $_1_d 
+    ($integral
+     . $support
+     . $_1_d
      . $_1_f
      . $_N_d
      . $_N_f
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/tmf/fix3.pl teem-1.11.0-src/src/nrrd/tmf/fix3.pl
--- teem-1.11.0-src.orig/src/nrrd/tmf/fix3.pl	2012-12-20 22:10:02.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/tmf/fix3.pl	2021-02-18 15:42:33.000000000 +0800
@@ -1,7 +1,7 @@
 #!/usr/bin/perl -w
 #
 # Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/tmf/tmFilters_raw.c teem-1.11.0-src/src/nrrd/tmf/tmFilters_raw.c
--- teem-1.11.0-src.orig/src/nrrd/tmf/tmFilters_raw.c	2012-12-20 22:10:02.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/tmf/tmFilters_raw.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
-  Teem: Tools to process and visualize scientific data and images              
-  Copyright (C) 2011, 2010, 2009  University of Chicago
+  Teem: Tools to process and visualize scientific data and images
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -24,7 +24,7 @@
 /*
 ### Written by Torsten Moeller
 ### sometime in March 1998
-### email me if you find any errors 
+### email me if you find any errors
 ###
 ### March 2003 - modified to remove coeff part
 */
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/tmfKernel.c teem-1.11.0-src/src/nrrd/tmfKernel.c
--- teem-1.11.0-src.orig/src/nrrd/tmfKernel.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/tmfKernel.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/TODO.txt teem-1.11.0-src/src/nrrd/TODO.txt
--- teem-1.11.0-src.orig/src/nrrd/TODO.txt	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/TODO.txt	2021-02-18 15:42:33.000000000 +0800
@@ -1,7 +1,6 @@
-
-nrrdCheckSum and "unu cksum" to provide equivalent of "unu data | cksum"
-
 all IO-related things:
+* why on earth is code in, say, formatText.c looking at nrrdStateVerboseIO,
+  instead of a field for verbosity in the NrrdIoState?
 * get back verbose IO messages about fread-vs-directIO
 * enable imagemagick-style format flagging on filenames ("PNM:-"),
 thereby obviating "unu save -f pnm" steps in pipes to standard out
@@ -65,8 +64,6 @@
 
 add one-line descriptions to function declarations in nrrd.h
 
-2D rmaps
-
 see if the use of airSinglePrintf in accessors.c, with %.8g or whatever,
 is really the right thing to do in the most general case
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/winKernel.c teem-1.11.0-src/src/nrrd/winKernel.c
--- teem-1.11.0-src.orig/src/nrrd/winKernel.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/winKernel.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -59,9 +59,9 @@
 _nrrd##name##_1_f(float x, const double *parm) {              \
   float R, S;                                                 \
                                                               \
-  S = AIR_CAST(float, parm[0]); R = AIR_CAST(float, parm[1]); \
+  S = AIR_FLOAT(parm[0]); R = AIR_FLOAT(parm[1]);             \
   x /= S;                                                     \
-  return AIR_CAST(float, mac(x, R)/spow(S));                  \
+  return AIR_FLOAT(mac(x, R)/spow(S));                        \
 }
 
 #define WS_N_F(name, mac, spow)                                     \
@@ -71,10 +71,10 @@
   float S, R, t;                                                    \
   size_t i;                                                         \
                                                                     \
-  S = AIR_CAST(float, parm[0]); R = AIR_CAST(float, parm[1]);       \
+  S = AIR_FLOAT(parm[0]); R = AIR_FLOAT(parm[1]);                   \
   for (i=0; i<len; i++) {                                           \
     t = x[i]/S;                                                     \
-    f[i] = AIR_CAST(float, mac(t, R)/spow(S));                      \
+    f[i] = AIR_FLOAT(mac(t, R)/spow(S));                            \
   }                                                                 \
 }
 
diff --color -ruN teem-1.11.0-src.orig/src/nrrd/write.c teem-1.11.0-src/src/nrrd/write.c
--- teem-1.11.0-src.orig/src/nrrd/write.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/nrrd/write.c	2021-02-18 15:42:32.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -49,13 +49,16 @@
   case nrrdIoStateBareText:
     nio->bareText = !!value;
     break;
+  case nrrdIoStateMoreThanFloatInText:
+    nio->moreThanFloatInText = !!value;
+    break;
   case nrrdIoStateCharsPerLine:
     if (value < 40) {
       biffAddf(NRRD, "%s: %d charsPerLine is awfully small", me, value);
       return 1;
     }
     /* cast won't lose info because "value" must be positive */
-    nio->charsPerLine = AIR_CAST(unsigned int, value);
+    nio->charsPerLine = AIR_UINT(value);
     break;
   case nrrdIoStateValsPerLine:
     if (value < 4) {
@@ -63,7 +66,7 @@
       return 1;
     }
     /* cast won't lose info because "value" must be positive */
-    nio->valsPerLine = AIR_CAST(unsigned int, value);
+    nio->valsPerLine = AIR_UINT(value);
     break;
   case nrrdIoStateSkipData:
     nio->skipData = !!value;
@@ -164,6 +167,9 @@
   case nrrdIoStateBareText:
     value = !!nio->bareText;
     break;
+  case nrrdIoStateMoreThanFloatInText:
+    value = !!nio->moreThanFloatInText;
+    break;
   case nrrdIoStateCharsPerLine:
     /* HEY: this cast is a bad because nio->charsPerLine is unsigned */
     value = AIR_CAST(int, nio->charsPerLine);
@@ -404,7 +410,8 @@
 */
 void
 _nrrdSprintFieldInfo(char **strP, const char *prefix,
-                     const Nrrd *nrrd, NrrdIoState *nio, int field) {
+                     const Nrrd *nrrd, NrrdIoState *nio, int field,
+                     int dropAxis0) {
   static const char me[]="_nrrdSprintFieldInfo";
   char buff[AIR_STRLEN_MED], *fnb, stmp[AIR_STRLEN_SMALL],
     *strtmp=NULL;
@@ -484,7 +491,7 @@
   case nrrdField_sizes:
     *strP = AIR_CALLOC(fslen + nrrd->dim*(size_tStrlen + 1), char);
     sprintf(*strP, "%s%s:", prefix, fs);
-    for (ii=0; ii<nrrd->dim; ii++) {
+    for (ii=!!dropAxis0; ii<nrrd->dim; ii++) {
       sprintf(buff, " %s", airSprintSize_t(stmp, nrrd->axis[ii].size));
       strcat(*strP, buff);
     }
@@ -492,7 +499,7 @@
   case nrrdField_spacings:
     *strP = AIR_CALLOC(fslen + nrrd->dim*(doubleStrlen + 1), char);
     sprintf(*strP, "%s%s:", prefix, fs);
-    for (ii=0; ii<nrrd->dim; ii++) {
+    for (ii=!!dropAxis0; ii<nrrd->dim; ii++) {
       airSinglePrintf(NULL, buff, " %.17g", nrrd->axis[ii].spacing);
       strcat(*strP, buff);
     }
@@ -500,7 +507,7 @@
   case nrrdField_thicknesses:
     *strP = AIR_CALLOC(fslen + nrrd->dim*(doubleStrlen + 1), char);
     sprintf(*strP, "%s%s:", prefix, fs);
-    for (ii=0; ii<nrrd->dim; ii++) {
+    for (ii=!!dropAxis0; ii<nrrd->dim; ii++) {
       airSinglePrintf(NULL, buff, " %.17g", nrrd->axis[ii].thickness);
       strcat(*strP, buff);
     }
@@ -508,7 +515,7 @@
   case nrrdField_axis_mins:
     *strP = AIR_CALLOC(fslen + nrrd->dim*(doubleStrlen + 1), char);
     sprintf(*strP, "%s%s:", prefix, fs);
-    for (ii=0; ii<nrrd->dim; ii++) {
+    for (ii=!!dropAxis0; ii<nrrd->dim; ii++) {
       airSinglePrintf(NULL, buff, " %.17g", nrrd->axis[ii].min);
       strcat(*strP, buff);
     }
@@ -516,7 +523,7 @@
   case nrrdField_axis_maxs:
     *strP = AIR_CALLOC(fslen + nrrd->dim*(doubleStrlen + 1), char);
     sprintf(*strP, "%s%s:", prefix, fs);
-    for (ii=0; ii<nrrd->dim; ii++) {
+    for (ii=!!dropAxis0; ii<nrrd->dim; ii++) {
       airSinglePrintf(NULL, buff, " %.17g", nrrd->axis[ii].max);
       strcat(*strP, buff);
     }
@@ -526,7 +533,7 @@
                        + nrrd->dim*nrrd->spaceDim*(doubleStrlen
                                                    + strlen("(,) ")), char);
     sprintf(*strP, "%s%s: ", prefix, fs);
-    for (ii=0; ii<nrrd->dim; ii++) {
+    for (ii=!!dropAxis0; ii<nrrd->dim; ii++) {
       _nrrdStrcatSpaceVector(*strP, nrrd->spaceDim,
                              nrrd->axis[ii].spaceDirection);
       if (ii < nrrd->dim-1) {
@@ -536,14 +543,14 @@
     break;
   case nrrdField_centers:
     fdlen = 0;
-    for (ii=0; ii<nrrd->dim; ii++) {
+    for (ii=!!dropAxis0; ii<nrrd->dim; ii++) {
       fdlen += 1 + airStrlen(nrrd->axis[ii].center
                              ? airEnumStr(nrrdCenter, nrrd->axis[ii].center)
                              : NRRD_UNKNOWN);
     }
     *strP = AIR_CALLOC(fslen + fdlen, char);
     sprintf(*strP, "%s%s:", prefix, fs);
-    for (ii=0; ii<nrrd->dim; ii++) {
+    for (ii=!!dropAxis0; ii<nrrd->dim; ii++) {
       sprintf(buff, " %s",
               (nrrd->axis[ii].center
                ? airEnumStr(nrrdCenter, nrrd->axis[ii].center)
@@ -553,14 +560,14 @@
     break;
   case nrrdField_kinds:
     fdlen = 0;
-    for (ii=0; ii<nrrd->dim; ii++) {
+    for (ii=!!dropAxis0; ii<nrrd->dim; ii++) {
       fdlen += 1 + airStrlen(nrrd->axis[ii].kind
                              ? airEnumStr(nrrdKind, nrrd->axis[ii].kind)
                              : NRRD_UNKNOWN);
     }
     *strP = AIR_CALLOC(fslen + fdlen, char);
     sprintf(*strP, "%s%s:", prefix, fs);
-    for (ii=0; ii<nrrd->dim; ii++) {
+    for (ii=!!dropAxis0; ii<nrrd->dim; ii++) {
       sprintf(buff, " %s",
               (nrrd->axis[ii].kind
                ? airEnumStr(nrrdKind, nrrd->axis[ii].kind)
@@ -574,7 +581,7 @@
                         ? nrrd->axis[ii].label \
                         : nrrd->axis[ii].units)
     fdlen = 0;
-    for (ii=0; ii<nrrd->dim; ii++) {
+    for (ii=!!dropAxis0; ii<nrrd->dim; ii++) {
       /* The "2*" is because at worst every character needs escaping.
          The "+ 3" for the |" "| between each part */
       fdlen += 2*airStrlen(LABEL_OR_UNITS) + 3;
@@ -582,9 +589,11 @@
     fdlen += 1; /* for '\0' */
     *strP = AIR_CALLOC(fslen + fdlen, char);
     sprintf(*strP, "%s%s:", prefix, fs);
-    for (ii=0; ii<nrrd->dim; ii++) {
+    for (ii=!!dropAxis0; ii<nrrd->dim; ii++) {
       strcat(*strP, " \"");
-      if (airStrlen(nrrd->axis[ii].label)) {
+      if (nrrdField_labels == field
+          ? airStrlen(nrrd->axis[ii].label)
+          : airStrlen(nrrd->axis[ii].units)) {
         _nrrdWriteEscaped(NULL, *strP, LABEL_OR_UNITS,
                           "\"", _NRRD_WHITESPACE_NOTAB);
       }
@@ -756,10 +765,11 @@
 */
 void
 _nrrdFprintFieldInfo(FILE *file, const char *prefix,
-                     const Nrrd *nrrd, NrrdIoState *nio, int field) {
+                     const Nrrd *nrrd, NrrdIoState *nio, int field,
+                     int dropAxis0) {
   char *line=NULL;
 
-  _nrrdSprintFieldInfo(&line, prefix, nrrd, nio, field);
+  _nrrdSprintFieldInfo(&line, prefix, nrrd, nio, field, dropAxis0);
   if (line) {
     fprintf(file, "%s\n", line);
     free(line);
diff --color -ruN teem-1.11.0-src.orig/src/preamble.c teem-1.11.0-src/src/preamble.c
--- teem-1.11.0-src.orig/src/preamble.c	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/preamble.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/preamble.mk teem-1.11.0-src/src/preamble.mk
--- teem-1.11.0-src.orig/src/preamble.mk	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/preamble.mk	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images             .
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2020  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/pull/actionPull.c teem-1.11.0-src/src/pull/actionPull.c
--- teem-1.11.0-src.orig/src/pull/actionPull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/actionPull.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -32,6 +32,8 @@
 ** how are force/energy along scale handled differently than in space?
 */
 
+#define __IF_DEBUG if (0)
+
 static double
 _pointDistSqrd(pullContext *pctx, pullPoint *AA, pullPoint *BB) {
   double diff[4];
@@ -554,14 +556,37 @@
   if (point->neighInterNum) {
     point->neighDistMean /= point->neighInterNum;
     if (pullProcessModeNeighLearn == task->processMode) {
-      double Css, trc;
-      ELL_10V_SCALE(point->neighCovar, 1.0f/point->neighInterNum,
-                    point->neighCovar);
-      Css = point->neighCovar[9];
-      trc = CTRACE(point->neighCovar);
-      point->stability = AIR_CAST(float, (trc
-                                          ? (task->pctx->targetDim * Css)/trc
-                                          : 0.0));
+      float ncs[4], ncsLen, *cov, sxx=0, syy=0, scl;
+      cov = point->neighCovar;
+      ELL_10V_SCALE(cov, 1.0f/point->neighInterNum, cov);
+      /* Stability is related to the angle between S=(0,0,0,1) and the
+         projection of S onto the tangent surface; we approximate that
+         by finding the product neighCovar*S == last column of neighCovar*/
+      ELL_4V_SET(ncs, cov[3], cov[6], cov[8], cov[9]);
+      ELL_4V_NORM_TT(ncs, float, ncs, ncsLen);
+      if (ncsLen) {
+        syy = ncs[3];
+        scl = AIR_FLOAT((task->pctx->flag.scaleIsTau
+                         ? gageSigOfTau(point->pos[3])
+                         : point->pos[3]));
+        if (scl) {
+          sxx = AIR_FLOAT(ELL_3V_LEN(ncs))/scl;
+          point->stability = AIR_FLOAT(atan2(syy, sxx)/(AIR_PI/2));
+        } else {
+          point->stability = 0;
+        }
+      } else {
+        /* HEY: probably bug that we can have *zero* last column in covar,
+           and yet have non-zero point->neighInterNum, right? */
+        point->stability = 0;
+      }
+      if (!AIR_EXISTS(point->stability)) {
+        fprintf(stderr, "!%s(%u): bad stability %g\n", me,
+                point->idtag, point->stability);
+        fprintf(stderr, "%g  %g  %g  %g\n", cov[3], cov[6], cov[8], cov[9]);
+        fprintf(stderr, "%g  %g  %g  %g\n", ncs[0], ncs[1], ncs[2], ncs[3]);
+        fprintf(stderr, "sxx %g syy %g\n", sxx, syy);
+      }
 #if PULL_TANCOVAR
       /* using 1 + # neigh because this includes tan1 of point itself */
       ELL_6V_SCALE(point->neighTanCovar, 1.0f/(1 + point->neighInterNum),
@@ -581,7 +606,7 @@
                  /* output */
                  double egradSum[4]) {
   static const char me[]="_energyFromImage";
-  double energy, grad3[3], gamma;
+  double energy, grad3[3], _gamma;
   int probed;
 
   /* not sure I have the logic for this right
@@ -599,6 +624,8 @@
   */
   probed = AIR_FALSE;
 
+  /* a better name for this would be
+     "probe only if you haven't already probed" */
 #define MAYBEPROBE \
   if (!probed) { \
     if (pullProbe(task, point)) { \
@@ -607,7 +634,7 @@
     probed = AIR_TRUE; \
   }
 
-  gamma = task->pctx->sysParm.gamma;
+  _gamma = task->pctx->sysParm.gamma;
   energy = 0;
   if (egradSum) {
     ELL_4V_SET(egradSum, 0, 0, 0, 0);
@@ -621,26 +648,26 @@
       MAYBEPROBE;
       enr = pullPointScalar(task->pctx, point, pullInfoStrength,
                             NULL, NULL);
-      energy += -gamma*enr;
+      energy += -_gamma*enr;
     } else {
       /* need strength and its gradient */
       /* randomize choice between forward and backward difference */
       /* NOTE: since you only need one bit of random, you could re-used
          a random int and look through its bits to determine forw vs
          back differences, but this is probably not the bottleneck */
-      sign = 2*AIR_CAST(int, airRandInt_r(task->rng, 2)) - 1;
+      sign = 2*AIR_INT(airRandInt_r(task->rng, 2)) - 1;
       deltaScale = task->pctx->bboxMax[3] - task->pctx->bboxMin[3];
       deltaScale *= sign*_PULL_STRENGTH_ENERGY_DELTA_SCALE;
       scl1 = (point->pos[3] += deltaScale);
-      pullProbe(task, point);
+      pullProbe(task, point);  /* *not* MAYBEPROBE */
       str1 = pullPointScalar(task->pctx, point, pullInfoStrength,
                              NULL, NULL);
       scl0 = (point->pos[3] -= deltaScale);
       MAYBEPROBE;
       str0 = pullPointScalar(task->pctx, point, pullInfoStrength,
                              NULL, NULL);
-      energy += -gamma*str0;
-      egradSum[3] += -gamma*(str1 - str0)/(scl1 - scl0);
+      energy += -_gamma*str0;
+      egradSum[3] += -_gamma*(str1 - str0)/(scl1 - scl0);
       /*
       if (1560 < task->pctx->iter && 2350 == point->idtag) {
         printf("%s(%u): egrad[3] = %g*((%g-%g)/(%g-%g) = %g/%g = %g)"
@@ -833,7 +860,10 @@
   if (!ELL_4V_DOT(force, force)) {
     /* this particle has no reason to go anywhere; BUT we still have to
        enforce constraint if we have one */
-    int constrFail;
+    int constrFail = 0;
+    __IF_DEBUG {
+      fprintf(stderr, "!%s: point %u unforced ...\n", me, point->idtag);
+    }
     if (task->pctx->constraint) {
       if (_pullConstraintSatisfy(task, point,
                                  100.0*_PULL_CONSTRAINT_TRAVEL_MAX,
@@ -848,7 +878,8 @@
                me, point->idtag, airEnumStr(pullConstraintFail, constrFail));
       return 1;
       */
-      fprintf(stderr, "%s: *** no constr sat on unfrced %u: %s (si# %u;%u)\n",
+      fprintf(stderr, "%s: *** constr sat fail on unfrced %u: "
+              "%s (si# %u;%u)\n",
               me, point->idtag, airEnumStr(pullConstraintFail, constrFail),
               point->stuckIterNum, task->pctx->iterParm.stuckMax);
       point->status |= PULL_STATUS_STUCK_BIT;
@@ -919,7 +950,7 @@
   point->status &= ~PULL_STATUS_STUCK_BIT;
   ELL_4V_COPY(posOld, point->pos);
   _pullPointHistInit(point);
-  _pullPointHistAdd(point, pullCondOld);
+  _pullPointHistAdd(point, pullCondOld, AIR_NAN);
   /* try steps along force until we succcessfully lower energy */
   hailMary = AIR_FALSE;
   do {
@@ -942,7 +973,7 @@
                                 task->pctx->bboxMax[3]);
     }
     task->pctx->count[pullCountTestStep] += 1;
-    _pullPointHistAdd(point, pullCondEnergyTry);
+    _pullPointHistAdd(point, pullCondEnergyTry, AIR_NAN);
     if (task->pctx->constraint) {
       if (_pullConstraintSatisfy(task, point,
                                  _PULL_CONSTRAINT_TRAVEL_MAX,
@@ -978,9 +1009,9 @@
     if (stepBad) {
       point->stepEnergy *= task->pctx->sysParm.backStepScale;
       if (constrFail) {
-        _pullPointHistAdd(point, pullCondConstraintFail);
+        _pullPointHistAdd(point, pullCondConstraintFail, AIR_NAN);
       } else {
-        _pullPointHistAdd(point, pullCondEnergyBad);
+        _pullPointHistAdd(point, pullCondEnergyBad, AIR_NAN);
       }
       /* you have a problem if you had a non-trivial force, but you can't
          ever seem to take a small enough step to reduce energy */
@@ -1047,7 +1078,7 @@
            point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
   }
   */
-  _pullPointHistAdd(point, pullCondNew);
+  _pullPointHistAdd(point, pullCondNew, AIR_NAN);
   ELL_4V_COPY(point->force, force);
 
   /* not recorded for the sake of this function, but for system accounting */
@@ -1076,11 +1107,16 @@
   static const char me[]="_pullPointProcess";
   int E;
 
+  /*
+  fprintf(stderr, "!%s(%u,%u) mode %s\n", me, point->idtag, task->pctx->iter,
+          airEnumStr(pullProcessMode, task->processMode));
+  */
   E = 0;
   switch (task->processMode) {
   case pullProcessModeDescent:
     E = _pullPointProcessDescent(task, bin, point,
-                                 !task->pctx->haveScale /* ignoreImage */);
+                                 AIR_FALSE
+                                 /* !task->pctx->haveScale ignoreImage */);
     break;
   case pullProcessModeNeighLearn:
     E = _pullPointProcessNeighLearn(task, bin, point);
@@ -1102,6 +1138,9 @@
     biffAddf(PULL, "%s: trouble", me);
     return 1;
   }
+  if (task->pctx->flag.zeroZ) {
+    point->pos[2] = 0;
+  }
   return 0;
 }
 
@@ -1118,7 +1157,8 @@
   myBin = task->pctx->bin + myBinIdx;
   for (myPointIdx=0; myPointIdx<myBin->pointNum; myPointIdx++) {
     pullPoint *point;
-    if (task->pctx->pointNum > _PULL_PROGRESS_POINT_NUM_MIN
+    if (task->pctx->verbose > 1
+        && task->pctx->pointNum > _PULL_PROGRESS_POINT_NUM_MIN
         && !task->pctx->flag.binSingle
         && task->pctx->progressBinMod
         && 0 == myBinIdx % task->pctx->progressBinMod) {
diff --color -ruN teem-1.11.0-src.orig/src/pull/binningPull.c teem-1.11.0-src/src/pull/binningPull.c
--- teem-1.11.0-src.orig/src/pull/binningPull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/binningPull.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -192,7 +192,7 @@
   }
   if (!( bin = _pullBinLocate(pctx, point->pos) )) {
     biffAddf(PULL, "%s: can't locate point %p %u",
-             me, AIR_CAST(void*, point), point->idtag);
+             me, AIR_VOIDP(point), point->idtag);
     return 1;
   }
   if (binP) {
@@ -200,7 +200,7 @@
   }
   if (_pullBinPointAdd(pctx, bin, point)) {
     biffAddf(PULL, "%s: trouble adding point %p %u",
-             me, AIR_CAST(void*, point), point->idtag);
+             me, AIR_VOIDP(point), point->idtag);
     return 1;
   }
   return 0;
@@ -224,7 +224,7 @@
   }
   if (!( bin = _pullBinLocate(pctx, point->pos) )) {
     biffAddf(PULL, "%s: can't locate point %p %u",
-             me, AIR_CAST(void*, point), point->idtag);
+             me, AIR_VOIDP(point), point->idtag);
     return 1;
   }
   if (binP) {
@@ -246,7 +246,7 @@
     if (okay) {
       if (_pullBinPointAdd(pctx, bin, point)) {
         biffAddf(PULL, "%s: trouble adding point %p %u",
-                 me, AIR_CAST(void*, point), point->idtag);
+                 me, AIR_VOIDP(point), point->idtag);
         return 1;
       }
       *added = AIR_TRUE;
@@ -256,7 +256,7 @@
   } else {
     if (_pullBinPointAdd(pctx, bin, point)) {
       biffAddf(PULL, "%s: trouble adding point %p %u",
-               me, AIR_CAST(void*, point), point->idtag);
+               me, AIR_VOIDP(point), point->idtag);
       return 1;
     }
     *added = AIR_TRUE;
@@ -303,17 +303,13 @@
       printf("%s: volEdge = %g %g %g %g\n", me,
              volEdge[0], volEdge[1], volEdge[2], volEdge[3]);
     }
-    pctx->binsEdge[0] = AIR_CAST(unsigned int,
-                                 floor(volEdge[0]/pctx->maxDistSpace));
+    pctx->binsEdge[0] = AIR_UINT(floor(volEdge[0]/pctx->maxDistSpace));
     pctx->binsEdge[0] = pctx->binsEdge[0] ? pctx->binsEdge[0] : 1;
-    pctx->binsEdge[1] = AIR_CAST(unsigned int,
-                                 floor(volEdge[1]/pctx->maxDistSpace));
+    pctx->binsEdge[1] = AIR_UINT(floor(volEdge[1]/pctx->maxDistSpace));
     pctx->binsEdge[1] = pctx->binsEdge[1] ? pctx->binsEdge[1] : 1;
-    pctx->binsEdge[2] = AIR_CAST(unsigned int,
-                                 floor(volEdge[2]/pctx->maxDistSpace));
+    pctx->binsEdge[2] = AIR_UINT(floor(volEdge[2]/pctx->maxDistSpace));
     pctx->binsEdge[2] = pctx->binsEdge[2] ? pctx->binsEdge[2] : 1;
-    pctx->binsEdge[3] = AIR_CAST(unsigned int,
-                                 floor(volEdge[3]/pctx->maxDistScale));
+    pctx->binsEdge[3] = AIR_UINT(floor(volEdge[3]/pctx->maxDistScale));
     pctx->binsEdge[3] = pctx->binsEdge[3] ? pctx->binsEdge[3] : 1;
     /* hack to observe things at bin boundaries
     ELL_3V_SET(pctx->binsEdge, 3, 3, 3);
@@ -385,8 +381,9 @@
 _pullIterFinishDescent(pullContext *pctx) {
   static const char me[]="_pullIterFinishDescent";
   unsigned int oldBinIdx, pointIdx, taskIdx, runIdx, pointNum;
-  pullBin *oldBin, *newBin;
+  pullBin *oldBin;
   pullPoint *point;
+  int added;
 
   _pullNixTheNixed(pctx);
 
@@ -438,16 +435,32 @@
       _pullDebugSanity(pctx->task[0], point);
     }
     */
-    newBin = _pullBinLocate(pctx, point->pos);
-    if (!newBin) {
-      biffAddf(PULL, "%s: can't locate point %p %u",
-               me, AIR_CAST(void*, point), point->idtag);
-      return 1;
-    }
-    if (_pullBinPointAdd(pctx, newBin, point)) {
-      biffAddf(PULL, "%s: trouble adding point %p %u",
-               me, AIR_CAST(void*, point), point->idtag);
-      return 1;
+    /* Sun Jul 14 01:30:41 CDT 2013: the previous code was basically
+       just pullBinsPointAdd(). But when working with codim-3
+       constraints (like finding spatial maxima with maximal strength
+       along scale), its easy for many points to start piling on top
+       of each other; that is the problem that
+       pullFlagRestrictiveAddToBins was designed to solve. */
+    if (pctx->constraint && 0 == pctx->constraintDim) {
+      if (pullBinsPointMaybeAdd(pctx, point, NULL, &added)) {
+        biffAddf(PULL, "%s: trouble binning? point %u", me, point->idtag);
+        return 1;
+      }
+      if (!added) {
+        /* the point wasn't owned by any bin, and now it turns out
+           no bin wanted to own it, so we have to remove it */
+        /* in the case of point maxima searching; this mainly happened
+           because two points at the same spatial positition slowly
+           descended along scale towards each other at the scale of
+           maximal strength */
+        point = pullPointNix(point);
+      }
+    } else {
+      if (pullBinsPointAdd(pctx, point, NULL)) {
+        biffAddf(PULL, "%s: trouble binning point %u", me, point->idtag);
+        return 1;
+      }
+      point = NULL;
     }
     pctx->tmpPointPtr[pctx->tmpPointPerm[pointIdx]] = NULL;
   }
diff --color -ruN teem-1.11.0-src.orig/src/pull/ccPull.c teem-1.11.0-src/src/pull/ccPull.c
--- teem-1.11.0-src.orig/src/pull/ccPull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/ccPull.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/pull/CMakeLists.txt teem-1.11.0-src/src/pull/CMakeLists.txt
--- teem-1.11.0-src.orig/src/pull/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/pull/CMakeLists.txt	2021-02-18 15:42:34.000000000 +0800
@@ -0,0 +1,27 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(PULL_SOURCES
+  actionPull.c
+  binningPull.c
+  constraints.c
+  contextPull.c
+  parmPull.c
+  initPull.c
+  corePull.c
+  defaultsPull.c
+  energy.c
+  infoPull.c
+  pointPull.c
+  privatePull.h
+  pull.h
+  taskPull.c
+  volumePull.c
+  popcntl.c
+  ccPull.c
+  enumsPull.c
+  trace.c
+  )
+
+target_sources(teem PRIVATE ${PULL_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( pull FILES ${PULL_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/pull/constraints.c teem-1.11.0-src/src/pull/constraints.c
--- teem-1.11.0-src.orig/src/pull/constraints.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/constraints.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -25,7 +25,8 @@
 #include "pull.h"
 #include "privatePull.h"
 
-#define PRAYING 0
+#define DEBUG (0)
+/* #define DEBUG (12 == point->idtag) */
 
 /*
 typedef struct {
@@ -39,7 +40,7 @@
   static const char me[]="probeIso";
 
   ELL_3V_COPY(point->pos, pos);  / * NB: not touching point->pos[3] * /
-  _pullPointHistAdd(point, cond);
+  _pullPointHistAdd(point, cond, AIR_NAN);
   if (pullProbe(task, point)) {
     biffAddf(PULL, "%s: on iter %u", me, iter);
     return 1;
@@ -54,6 +55,7 @@
 
 /* NOTE: this assumes variables "iter" (uint) and "me" (char*) */
 #define NORMALIZE_ERR(dir, grad, len)                                    \
+  if (task->pctx->flag.zeroZ) grad[2]=0;                                 \
   ELL_3V_NORM((dir), (grad), (len));                                     \
   if (!(len)) {                                                          \
     biffAddf(PULL, "%s: got zero grad at (%g,%g,%g,%g) on iter %u\n", me,\
@@ -63,6 +65,7 @@
   }
 
 #define NORMALIZE(dir, grad, len)                                        \
+  if (task->pctx->flag.zeroZ) grad[2]=0;                                 \
   ELL_3V_NORM((dir), (grad), (len));                                     \
   if (!(len)) {                                                          \
     ELL_3V_SET((dir), 0, 0, 0) ;                                         \
@@ -93,7 +96,8 @@
 
 static int
 constraintSatIso(pullTask *task, pullPoint *point,
-                 double stepMax, unsigned int iterMax,
+                 double stepMax, double constrEps,
+                 unsigned int iterMax,
                  /* output */
                  int *constrFailP) {
   static const char me[]="constraintSatIso";
@@ -120,10 +124,10 @@
     step = -val/len; /* the newton-raphson step */
     step = step > 0 ? AIR_MIN(stepMax, step) : AIR_MAX(-stepMax, step);
     ELL_3V_SCALE_INCR(point->pos, hack*step, dir);
-    _pullPointHistAdd(point, pullCondConstraintSatA);
     PROBE(val, aval, grad);
+    _pullPointHistAdd(point, pullCondConstraintSatA, val);
     if (aval <= state[0]) {  /* we're no further from the root */
-      if (AIR_ABS(step) < stepMax*task->pctx->sysParm.constraintStepMin) {
+      if (AIR_ABS(step) < stepMax*constrEps) { /* HEY stepMax*constrEps vs constrEps */
         /* we have converged! */
         break;
       }
@@ -164,7 +168,8 @@
 
 static int
 constraintSatLapl(pullTask *task, pullPoint *point,
-                  double stepMax, unsigned int iterMax,
+                  double stepMax, double constrEps,
+                  unsigned int iterMax,
                   /* output */
                   int *constrFailP) {
   static const char me[]="constraintSatLapl";
@@ -192,8 +197,8 @@
     ELL_3V_COPY(posOld, point->pos);
     sgn = airSgn(val); /* lapl < 0 => downhill; lapl > 0 => uphill */
     ELL_3V_SCALE_INCR(point->pos, sgn*step, dir);
-    _pullPointHistAdd(point, pullCondConstraintSatA);
     PROBEG(val, grad);
+    _pullPointHistAdd(point, pullCondConstraintSatA, val);
     if (val*valLast < 0) {
       /* laplacian has changed sign; stop looking */
       break;
@@ -218,8 +223,8 @@
   for (iter=1; iter<=iterMax; iter++) {
     s = AIR_AFFINE(fa, 0, fb, a, b);
     ELL_3V_LERP(point->pos, s, posOld, posNew);
-    _pullPointHistAdd(point, pullCondConstraintSatB);
     PROBE(fs);
+    _pullPointHistAdd(point, pullCondConstraintSatB, 0.0);
     if (0 == fs) {
       /* exactly nailed the zero, we're done. This actually happens! */
       printf("!%s: b lapl == 0!\n", me);
@@ -242,7 +247,7 @@
       side = -1;
     }
     diff = (b - a)*len;
-    if (AIR_ABS(diff) < stepMax*task->pctx->sysParm.constraintStepMin) {
+    if (AIR_ABS(diff) < stepMax*constrEps) { /* HEY stepMax*constrEps vs constrEps */
       /* converged! */
       break;
     }
@@ -277,13 +282,14 @@
 /*
 ** creaseProj
 **
-** eigenvectors (with non-zero eigenvalues) of output posproj are
-** tangents to the directions along which particle is allowed to move
-** *downward* (in height) for constraint satisfaction (according to
-** tangent 1 or tangents 1&2)
+** column-space of output posproj spans the directions along which
+** particle is allowed to move *downward* (in height) for constraint
+** satisfaction (according to tangent 1 or tangents 1&2); for seeking
+** minima where 2nd deriv is positive
 **
 ** negproj is the same, but for points moving upwards (according to
-** negativetangent1 or negativetangent 1&2)
+** negativetangent1 or negativetangent 1&2); for seeking
+** maxima where 2nd deriv is negative
 */
 static void
 creaseProj(pullTask *task, pullPoint *point,
@@ -291,18 +297,16 @@
            int negtang1Use, int negtang2Use,
            /* output */
            double posproj[9], double negproj[9]) {
-#if PRAYING
   static const char me[]="creaseProj";
-#endif
   double pp[9];
   double *tng;
 
   ELL_3M_ZERO_SET(posproj);
   if (tang1Use) {
     tng = point->info + task->pctx->infoIdx[pullInfoTangent1];
-#if PRAYING
-    fprintf(stderr, "!%s: tng1 = %g %g %g\n", me, tng[0], tng[1], tng[2]);
-#endif
+    if (DEBUG) {
+      fprintf(stderr, "!%s: tng1 = %g %g %g\n", me, tng[0], tng[1], tng[2]);
+    }
     ELL_3MV_OUTER(pp, tng, tng);
     ELL_3M_ADD2(posproj, posproj, pp);
   }
@@ -356,19 +360,17 @@
   ELL_3M_COPY(posproj, state + 1 + 3 + 9);                          \
   ELL_3M_COPY(negproj, state + 1 + 3 + 9 + 9);                      \
   ELL_3V_COPY(pos,     state + 1 + 3 + 9 + 9 + 9)
-#define POSNORM(d1, d2, pdir, plen, pgrad, grad, hess, posproj)       \
+#define DNORM(d1, d2, pdir, plen, pgrad, grad, hess, posproj)       \
   ELL_3MV_MUL(pgrad, posproj, grad);                                  \
+  if (task->pctx->flag.zeroZ) pgrad[2]=0;                             \
   ELL_3V_NORM(pdir, pgrad, plen);                                     \
   d1 = ELL_3V_DOT(grad, pdir);                                        \
   d2 = ELL_3MV_CONTR(hess, pdir)
-#define NEGNORM(d1, d2, pdir, plen, pgrad, grad, hess, negproj)       \
-  ELL_3MV_MUL(pgrad, negproj, grad);                                  \
-  ELL_3V_NORM(pdir, pgrad, plen);                                     \
-  d1 = -ELL_3V_DOT(grad, pdir);                                       \
-  d2 = -ELL_3MV_CONTR(hess, pdir)
 #define PRINT(prefix)                                                   \
-  fprintf(stderr, "-------------- probe results %s:\n-- val = %g\n",    \
-          prefix, val);                                                 \
+  fprintf(stderr, "-------------- probe results %s (%u @ %g,%g,%g,%g):\n", \
+          prefix, point->idtag, point->pos[0], point->pos[1],           \
+          point->pos[2], point->pos[3]);                                \
+  fprintf(stderr, "-- val = %g\n", val);                                \
   fprintf(stderr, "-- grad = %g %g %g\n", grad[0], grad[1], grad[2]);   \
   fprintf(stderr,"-- hess = %g %g %g;  %g %g %g;  %g %g %g\n",          \
           hess[0], hess[1], hess[2],                                    \
@@ -387,27 +389,26 @@
 constraintSatHght(pullTask *task, pullPoint *point,
                   int tang1Use, int tang2Use,
                   int negtang1Use, int negtang2Use,
-                  double stepMax, unsigned int iterMax,
+                  double stepMax, double constrEps, unsigned int iterMax,
                   int *constrFailP) {
   static const char me[]="constraintSatHght";
   double val, grad[3], hess[9], posproj[9], negproj[9],
     state[1+3+9+9+9+3], hack, step,
     d1, d2, pdir[3], plen, pgrad[3];
-#if PRAYING
   double _tmpv[3]={0,0,0};
-#endif
-  int havePos, haveNeg, haveNada;
+  /* #endif */
+  int havePos, haveNeg, haveNada, zeroGmagOkay;
   unsigned int iter = 0;  /* 0: initial probe, 1..iterMax: probes in loop */
   /* http://en.wikipedia.org/wiki/Newton%27s_method_in_optimization */
 
+  zeroGmagOkay = (1 < task->pctx->iter && 0 == task->pctx->constraintDim);
   havePos = tang1Use || tang2Use;
   haveNeg = negtang1Use || negtang2Use;
   haveNada = !havePos && !haveNeg;
-#if PRAYING
-  {
+  if (DEBUG) {
     double stpmin;
     /* HEY: shouldn't stpmin also be used later in this function? */
-    stpmin = task->pctx->voxelSizeSpace*task->pctx->sysParm.constraintStepMin;
+    stpmin = task->pctx->voxelSizeSpace*constrEps;
     fprintf(stderr, "!%s(%u): starting at %g %g %g %g\n", me, point->idtag,
             point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
     fprintf(stderr, "!%s: pt %d %d nt %d %d (nada %d) "
@@ -415,43 +416,58 @@
             tang1Use, tang2Use, negtang1Use, negtang2Use, haveNada,
             stepMax, iterMax);
     fprintf(stderr, "!%s: stpmin = %g = voxsize %g * parm.stepmin %g\n", me,
-            stpmin, task->pctx->voxelSizeSpace,
-            task->pctx->sysParm.constraintStepMin);
+            stpmin, task->pctx->voxelSizeSpace, constrEps);
   }
-#endif
-  _pullPointHistAdd(point, pullCondOld);
   PROBE(val, grad, hess, posproj, negproj);
-#if PRAYING
-  PRINT("initial probe");
-#endif
+  _pullPointHistAdd(point, pullCondOld, val);
+  if (DEBUG) {
+    PRINT("initial probe");
+  }
   SAVE(state, val, grad, hess, posproj, negproj, point->pos);
   hack = 1;
   for (iter=1; iter<=iterMax; iter++) {
-#if PRAYING
-    fprintf(stderr, "!%s: =============== begin iter %u\n", me, iter);
-#endif
+    if (DEBUG) {
+      fprintf(stderr, "!%s: =-============= begin iter %u\n", me, iter);
+    }
     /* HEY: no opportunistic increase of hack? */
     if (havePos || haveNada) {
-      POSNORM(d1, d2, pdir, plen, pgrad, grad, hess, posproj);
+      DNORM(d1, d2, pdir, plen, pgrad, grad, hess, posproj);
+      if (!ELL_3M_FROB(hess)) {
+        *constrFailP = pullConstraintFailHessZeroA;
+        return 0;
+      }
       if (!plen) {
+        if (zeroGmagOkay) {
+          /* getting to actual zero gradient is possible when looking for
+             point extrema (or saddles), and its not a problem, so as a
+             lousy hack we set step=0 and skip to the convergence test */
+          step = 0;
+          goto convtestA;
+        }
         /* this use to be a biff error, which got to be annoying */
         *constrFailP = pullConstraintFailProjGradZeroA;
         return 0;
+      } else if (!AIR_EXISTS(plen)) {
+        /* this use to be a biff error, which also got to be annoying */
+        *constrFailP = pullConstraintFailProjLenNonExist;
+        return 0;
+      }
+      step = (d2 > 0 ? -d1/d2 : -plen);
+      if (DEBUG) {
+        fprintf(stderr, "!%s: (+) iter %u step = (%g > 0 ? %g=-%g/%g : %g) --> %g\n",
+                me, iter, d2, -d1/d2, d1, d2, -plen, step);
       }
-      step = (d2 <= 0 ? -plen : -d1/d2);
-#if PRAYING
-      fprintf(stderr, "!%s: (+) iter %u step = (%g <= 0 ? %g : %g) --> %g\n",
-              me, iter, d2, -plen, -d1/d2, step);
-#endif
       step = step > 0 ? AIR_MIN(stepMax, step) : AIR_MAX(-stepMax, step);
-      if (AIR_ABS(step) < stepMax*task->pctx->sysParm.constraintStepMin) {
-        /* no further iteration needed; we're converged */
-#if PRAYING
-        fprintf(stderr, "     |step| %g < %g*%g = %g ==> converged!\n",
-                AIR_ABS(step),
-                stepMax, task->pctx->sysParm.constraintStepMin,
-                stepMax*task->pctx->sysParm.constraintStepMin);
-#endif
+    convtestA:
+      if (d2 > 0 && AIR_ABS(step) < constrEps) { /* HEY stepMax*constrEps vs constrEps */
+        /* we're converged because its concave up here
+           and we're close enough to the bottom */
+        if (DEBUG) {
+          fprintf(stderr, "     |step| %g < %g*%g = %g ==> converged!\n",
+                  AIR_ABS(step),
+                  stepMax, constrEps,
+                  stepMax*constrEps);
+        }
         if (!haveNeg) {
           break;
         } else {
@@ -459,122 +475,152 @@
         }
       }
       /* else we have to take a significant step */
-#if PRAYING
-      fprintf(stderr, "       -> step %g, |pdir| = %g\n",
-              step, ELL_3V_LEN(pdir));
-      ELL_3V_COPY(_tmpv, point->pos);
-      fprintf(stderr, "       ->  pos (%g,%g,%g,%g) += %g * %g * (%g,%g,%g)\n",
-              point->pos[0], point->pos[1], point->pos[2], point->pos[3],
-              hack, step, pdir[0], pdir[1], pdir[2]);
-#endif
+      if (DEBUG) {
+        fprintf(stderr, "       -> step %g, |pdir| = %g\n",
+                step, ELL_3V_LEN(pdir));
+        ELL_3V_COPY(_tmpv, point->pos);
+        fprintf(stderr, "       ->  pos (%g,%g,%g,%g) += "
+                "%g * %g * (%g,%g,%g)\n",
+                point->pos[0], point->pos[1], point->pos[2], point->pos[3],
+                hack, step, pdir[0], pdir[1], pdir[2]);
+      }
       ELL_3V_SCALE_INCR(point->pos, hack*step, pdir);
-#if PRAYING
-      ELL_3V_SUB(_tmpv, _tmpv, point->pos);
-      fprintf(stderr, "       -> moved to %g %g %g %g\n",
-              point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
-      fprintf(stderr, "       (moved %g)\n", ELL_3V_LEN(_tmpv));
-#endif
-      _pullPointHistAdd(point, pullCondConstraintSatA);
+      if (!ELL_4V_EXISTS(point->pos)) {
+        biffAddf(PULL, "%s: pos proj iter %u: pnt %u bad pos (%g,%g,%g,%g); "
+                 "hack %g, step %g",
+                 me, iter, point->idtag, point->pos[0], point->pos[1],
+                 point->pos[2], point->pos[3], hack, step);
+        return 1;
+      }
+      if (DEBUG) {
+        ELL_3V_SUB(_tmpv, _tmpv, point->pos);
+        fprintf(stderr, "       -> moved to %g %g %g %g\n",
+                point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
+        fprintf(stderr, "       (moved %g)\n", ELL_3V_LEN(_tmpv));
+      }
       PROBE(val, grad, hess, posproj, negproj);
-#if PRAYING
-      fprintf(stderr, "  (+) probed at (%g,%g,%g,%g)\n",
-              point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
-      PRINT("after move");
-      fprintf(stderr, "  val(%g,%g,%g,%g)=%g %s state[0]=%g\n",
-              point->pos[0], point->pos[1], point->pos[2], point->pos[3],
-              val, val <= state[0] ? "<=" : ">", state[0]);
-#endif
+      _pullPointHistAdd(point, pullCondConstraintSatA, val);
+      if (DEBUG) {
+        fprintf(stderr, "  (+) probed at (%g,%g,%g,%g)\n",
+                point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
+        PRINT("after move");
+        fprintf(stderr, "  val(%g,%g,%g,%g)=%g %s state[0]=%g\n",
+                point->pos[0], point->pos[1], point->pos[2], point->pos[3],
+                val, val <= state[0] ? "<=" : ">", state[0]);
+      }
       if (val <= state[0]) {
         /* we made progress */
-#if PRAYING
-        fprintf(stderr, "  (+) progress!\n");
-#endif
+        if (DEBUG) {
+          fprintf(stderr, "  (+) progress!\n");
+        }
         SAVE(state, val, grad, hess, posproj, negproj, point->pos);
         hack = 1;
       } else {
         /* oops, we went uphill instead of down; try again */
-#if PRAYING
-        fprintf(stderr, "  val *increased*; backing hack from %g to %g\n",
-                hack, hack*task->pctx->sysParm.backStepScale);
-#endif
+        if (DEBUG) {
+          fprintf(stderr, "  (+) val *increased* (up from %.17g by %.17g); "
+                  "backing hack from %g to %g\n",
+                  state[0], val - state[0],
+                  hack, hack*task->pctx->sysParm.backStepScale);
+        }
         hack *= task->pctx->sysParm.backStepScale;
         RESTORE(val, grad, hess, posproj, negproj, point->pos, state);
-#if PRAYING
-        fprintf(stderr, "  restored to pos (%g,%g,%g,%g)\n",
-                point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
-#endif
+        if (DEBUG) {
+          fprintf(stderr, "  restored to pos (%g,%g,%g,%g)\n",
+                  point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
+        }
       }
     }
   nextstep:
     if (haveNeg) {
-      /* HEY: copy and paste from above, minus fluff */
-      NEGNORM(d1, d2, pdir, plen, pgrad, grad, hess, negproj);
-      if (!plen && !haveNeg) {
-        /* this use to be a biff error, which got to be annoying */
-        *constrFailP = pullConstraintFailProjGradZeroA;
+      /* HEY: copy and paste from above, minus fluff, and with A->B */
+      DNORM(d1, d2, pdir, plen, pgrad, grad, hess, negproj);
+      if (!ELL_3M_FROB(hess)) {
+        *constrFailP = pullConstraintFailHessZeroB;
         return 0;
       }
-      step = (d2 <= 0 ? -plen : -d1/d2);
-#if PRAYING
-      fprintf(stderr, "!%s: -+) iter %u step = (%g <= 0 ? %g : %g) --> %g\n",
-              me, iter, d2, -plen, -d1/d2, step);
-#endif
+      if (!plen) {
+        if (zeroGmagOkay) {
+          step = 0;
+          goto convtestB;
+        }
+        *constrFailP = pullConstraintFailProjGradZeroB;
+        return 0;
+      }
+      step = (d2 < 0 ? -d1/d2 : plen);
+      if (DEBUG) {
+        fprintf(stderr, "!%s: -+) iter %u step = (%g < 0 ? %g : %g) --> %g\n",
+                me, iter, d2, -d1/d2, plen, step);
+      }
       step = step > 0 ? AIR_MIN(stepMax, step) : AIR_MAX(-stepMax, step);
-      if (AIR_ABS(step) < stepMax*task->pctx->sysParm.constraintStepMin) {
-#if PRAYING
-        fprintf(stderr, "     |step| %g < %g*%g = %g ==> converged!\n",
-                AIR_ABS(step),
-                stepMax, task->pctx->sysParm.constraintStepMin,
-                stepMax*task->pctx->sysParm.constraintStepMin);
-#endif
+    convtestB:
+      if (d2 < 0 && AIR_ABS(step) < constrEps) { /* HEY stepMax*constrEps vs constrEps */
+        /* we're converged because its concave down here
+           and we're close enough to the top */
+        if (DEBUG) {
+          fprintf(stderr, "     |step| %g < %g*%g = %g ==> converged!\n",
+                  AIR_ABS(step),
+                  stepMax, constrEps,
+                  stepMax*constrEps);
+        }
         /* no further iteration needed; we're converged */
         break;
       }
       /* else we have to take a significant step */
-#if PRAYING
-      fprintf(stderr, "       -> step %g, |pdir| = %g\n",
-              step, ELL_3V_LEN(pdir));
-      ELL_3V_COPY(_tmpv, point->pos);
-      fprintf(stderr, "       ->  pos (%g,%g,%g,%g) += %g * %g * (%g,%g,%g)\n",
-              point->pos[0], point->pos[1], point->pos[2], point->pos[3],
-              hack, step, pdir[0], pdir[1], pdir[2]);
-#endif
+      if (DEBUG) {
+        fprintf(stderr, "       -> step %g, |pdir| = %g\n",
+                step, ELL_3V_LEN(pdir));
+        ELL_3V_COPY(_tmpv, point->pos);
+        fprintf(stderr, "       ->  pos (%g,%g,%g,%g) += "
+                "%g * %g * (%g,%g,%g)\n",
+                point->pos[0], point->pos[1], point->pos[2], point->pos[3],
+                hack, step, pdir[0], pdir[1], pdir[2]);
+      }
       ELL_3V_SCALE_INCR(point->pos, hack*step, pdir);
-#if PRAYING
-      ELL_3V_SUB(_tmpv, _tmpv, point->pos);
-      fprintf(stderr, "       -> moved to %g %g %g %g\n",
-              point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
-      fprintf(stderr, "       (moved %g)\n", ELL_3V_LEN(_tmpv));
-#endif
-      _pullPointHistAdd(point, pullCondConstraintSatA);
+      if (!ELL_4V_EXISTS(point->pos)) {
+        biffAddf(PULL, "%s: neg proj iter %u: pnt %u bad pos (%g,%g,%g,%g); "
+                 "hack %g, step %g",
+                 me, iter, point->idtag, point->pos[0], point->pos[1],
+                 point->pos[2], point->pos[3], hack, step);
+        return 1;
+      }
+      if (DEBUG) {
+        ELL_3V_SUB(_tmpv, _tmpv, point->pos);
+        fprintf(stderr, "       -> moved to %g %g %g %g\n",
+                point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
+        fprintf(stderr, "       (moved %g)\n", ELL_3V_LEN(_tmpv));
+      }
       PROBE(val, grad, hess, posproj, negproj);
-#if PRAYING
-      fprintf(stderr, "  (-) probed at (%g,%g,%g,%g)\n",
-              point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
-      PRINT("after move");
-      fprintf(stderr, "  val(%g,%g,%g,%g)=%g %s state[0]=%g\n",
-              point->pos[0], point->pos[1], point->pos[2], point->pos[3],
-              val, val >= state[0] ? ">=" : "<", state[0]);
-#endif
+      _pullPointHistAdd(point, pullCondConstraintSatB, val);
+      if (DEBUG) {
+        fprintf(stderr, "  (-) probed at (%g,%g,%g,%g)\n",
+                point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
+        PRINT("after move");
+        fprintf(stderr, "  val(%g,%g,%g,%g)=%g %s state[0]=%g\n",
+                point->pos[0], point->pos[1], point->pos[2], point->pos[3],
+                val, val >= state[0] ? ">=" : "<", state[0]);
+      }
       if (val >= state[0]) {
         /* we made progress */
-#if PRAYING
-        fprintf(stderr, "  (-) progress!\n");
-#endif
+        if (DEBUG) {
+          fprintf(stderr, "  (-) progress!\n");
+        }
         SAVE(state, val, grad, hess, posproj, negproj, point->pos);
         hack = 1;
       } else {
-        /* oops, we went uphill instead of down; try again */
-#if PRAYING
-        fprintf(stderr, "  val *increased*; backing hack from %g to %g\n",
-                hack, hack*task->pctx->sysParm.backStepScale);
-#endif
+        /* oops, we went downhill instead of up; try again */
+        if (DEBUG) {
+          fprintf(stderr, "  (-) val *decreased* (down from %.17g by %.17g); "
+                  "backing hack from %g to %g\n",
+                  state[0], state[0] - val,
+                  hack, hack*task->pctx->sysParm.backStepScale);
+        }
         hack *= task->pctx->sysParm.backStepScale;
         RESTORE(val, grad, hess, posproj, negproj, point->pos, state);
-#if PRAYING
-        fprintf(stderr, "  restored to pos (%g,%g,%g,%g)\n",
-                point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
-#endif
+        if (DEBUG) {
+          fprintf(stderr, "  restored to pos (%g,%g,%g,%g)\n",
+                  point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
+        }
       }
     }
   }
@@ -583,21 +629,37 @@
   } else {
     *constrFailP = AIR_FALSE;
   }
-  /*
-  printf("!%s: %d %s\n", me, *constrFailP,
-         *constrFailP ? "FAILED!" : "ok");
-          */
+  _pullPointHistAdd(point, (*constrFailP
+                            ? pullCondConstraintFail
+                            : pullCondConstraintSuccess), AIR_NAN);
+  if (DEBUG) {
+    printf("!%s: Finished %s: %s (%d)\n", me,
+           *constrFailP ? "with failure" : "OK",
+           *constrFailP ? airEnumStr(pullConstraintFail, *constrFailP) : "",
+           *constrFailP);
+  }
   return 0;
 }
 #undef PROBE
-#undef POSNORM
-#undef NEGNORM
+#undef DNORM
 #undef SAVE
 #undef RESTORE
 
+double
+_pullSigma(const pullContext *pctx, const double pos[4]) {
+  double ret=0;
+
+  if (pos && pos[3]) {
+    ret = (pctx->flag.scaleIsTau
+           ? gageSigOfTau(pos[3])
+           : pos[3]);
+  }
+  return ret;
+}
+
 /* ------------------------------------------- */
 
-/* HEY: have to make sure that scale position point->pos[3]
+/* have to make sure that scale position point->pos[3]
 ** is not modified anywhere in here: constraints are ONLY spatial
 **
 ** This uses biff, but only for showstopper problems
@@ -608,34 +670,33 @@
                        /* output */
                        int *constrFailP) {
   static const char me[]="_pullConstraintSatisfy";
-  double stepMax;
+  double stepMax, constrEps;
   unsigned int iterMax;
   double pos3Orig[3], pos3Diff[3], travel;
 
   ELL_3V_COPY(pos3Orig, point->pos);
-  stepMax = task->pctx->voxelSizeSpace;
+  /* HEY the "10*" is based on isolated experiments; what's the principle? */
+  stepMax = 10*task->pctx->voxelSizeSpace;
   iterMax = task->pctx->iterParm.constraintMax;
-  /*
-  dlim = _pullDistLimit(task, point);
-  if (iterMax*stepMax > dlim) {
-    stepMax = dlim/iterMax;
-  }
-  */
-  /*
-  fprintf(stderr, "!%s(%d): hi ==== %g %g %g, stepMax = %g, iterMax = %u\n",
-          me, point->idtag, point->pos[0], point->pos[1], point->pos[2],
-          stepMax, iterMax);
-  */
+  constrEps = task->pctx->voxelSizeSpace*task->pctx->sysParm.constraintStepMin;
+  /*           * (1 + 0.2*_pullSigma(task->pctx, point->pos)); */
+  if (DEBUG) {
+    fprintf(stderr, "!%s(%d): hi ==== %g %g %g, stepMax = %g, iterMax = %u\n",
+            me, point->idtag, point->pos[0], point->pos[1], point->pos[2],
+            stepMax, iterMax);
+  }
   task->pctx->count[pullCountConstraintSatisfy] += 1;
   switch (task->pctx->constraint) {
   case pullInfoHeightLaplacian: /* zero-crossing edges */
-    if (constraintSatLapl(task, point, stepMax/4, 4*iterMax, constrFailP)) {
+    if (constraintSatLapl(task, point, stepMax/4, constrEps,
+                          4*iterMax, constrFailP)) {
       biffAddf(PULL, "%s: trouble", me);
       return 1;
     }
     break;
   case pullInfoIsovalue:
-    if (constraintSatIso(task, point, stepMax, iterMax, constrFailP)) {
+    if (constraintSatIso(task, point, stepMax, constrEps,
+                         iterMax, constrFailP)) {
       biffAddf(PULL, "%s: trouble", me);
       return 1;
     }
@@ -646,7 +707,7 @@
                           !!task->pctx->ispec[pullInfoTangent2],
                           !!task->pctx->ispec[pullInfoNegativeTangent1],
                           !!task->pctx->ispec[pullInfoNegativeTangent2],
-                          stepMax, iterMax, constrFailP)) {
+                          stepMax, constrEps, iterMax, constrFailP)) {
       biffAddf(PULL, "%s: trouble", me);
       return 1;
     }
@@ -657,20 +718,47 @@
             task->pctx->constraint);
   }
   ELL_3V_SUB(pos3Diff, pos3Orig, point->pos);
-  travel = ELL_3V_LEN(pos3Diff)/task->pctx->voxelSizeSpace;
-  if (travel > travelMax) {
-    *constrFailP = pullConstraintFailTravel;
-  }
-  /*
-  fprintf(stderr, "!%s(%u) %s @ (%g,%g,%g) = (%g,%g,%g) + (%g,%g,%g)\n", me,
-          point->idtag,
-          (*constrFailP
-           ? airEnumStr(pullConstraintFail, *constrFailP)
-           : "#GOOD#"),
-          point->pos[0], point->pos[1], point->pos[2],
-          pos3Diff[0], pos3Diff[1], pos3Diff[2],
-          pos3Orig[0], pos3Orig[1], pos3Orig[2]);
-  */
+  if (travelMax) {
+    travel = ELL_3V_LEN(pos3Diff)/task->pctx->voxelSizeSpace;
+    if (travel > travelMax) {
+      *constrFailP = pullConstraintFailTravel;
+      if (DEBUG) {
+        fprintf(stderr, "!%s: travel %g > travelMax %g\n", me,
+                travel, travelMax);
+      }
+    }
+  }
+  if (DEBUG) {
+    fprintf(stderr, "!%s(%u) %s @ (%g,%g,%g) = (%g,%g,%g) + (%g,%g,%g)\n", me,
+            point->idtag,
+            (*constrFailP
+             ? airEnumStr(pullConstraintFail, *constrFailP)
+             : "#GOOD#"),
+            point->pos[0], point->pos[1], point->pos[2],
+            pos3Diff[0], pos3Diff[1], pos3Diff[2],
+            pos3Orig[0], pos3Orig[1], pos3Orig[2]);
+#if PULL_PHIST
+    if (1) {
+      Nrrd *nhist;
+      FILE *fhist;
+      char fname[AIR_STRLEN_LARGE];
+      nhist = nrrdNew();
+      sprintf(fname, "%04u-%04u-phist.nrrd", task->pctx->iter, point->idtag);
+      if (pullPositionHistoryNrrdGet(nhist, task->pctx, point)) {
+        biffAddf(PULL, "%s: trouble", me);
+        return 1;
+      }
+      if ((fhist = fopen(fname, "w"))) {
+        if (nrrdSave(fname, nhist, NULL)) {
+          biffMovef(PULL, NRRD, "%s: trouble", me);
+          return 1;
+        }
+        fclose(fhist);
+      }
+      nrrdNuke(nhist);
+    }
+#endif
+  }
   return 0;
 }
 
@@ -730,6 +818,8 @@
 ** 0 for points
 ** 1 for lines
 ** 2 for surfaces
+** This is nontrivial because of the different ways that constraints
+** can be expressed, combined with the possibility of pctx->flag.zeroZ
 **
 ** a -1 return value represents a biff-able error
 */
@@ -740,10 +830,10 @@
 
   switch (pctx->constraint) {
   case pullInfoHeightLaplacian: /* zero-crossing edges */
-    ret = 2;
+    ret = (pctx->flag.zeroZ ? 1 : 2);
     break;
   case pullInfoIsovalue:
-    ret = 2;
+    ret = (pctx->flag.zeroZ ? 1 : 2);
     break;
   case pullInfoHeight:
     t1 = !!pctx->ispec[pullInfoTangent1];
@@ -752,14 +842,25 @@
     nt2 = !!pctx->ispec[pullInfoNegativeTangent2];
     switch (t1 + t2 + nt1 + nt2) {
     case 0:
+      ret = 0;
+      break;
     case 3:
+      if (pctx->flag.zeroZ) {
+        biffAddf(PULL, "%s: can't have three of (%s,%s,%s,%s) tangents with "
+                 "2-D data (pctx->flag.zeroZ)", me,
+                 airEnumStr(pullInfo, pullInfoTangent1),
+                 airEnumStr(pullInfo, pullInfoTangent2),
+                 airEnumStr(pullInfo, pullInfoNegativeTangent1),
+                 airEnumStr(pullInfo, pullInfoNegativeTangent2));
+        return -1;
+      } /* else we're in 3D; 3 constraints -> point features */
       ret = 0;
       break;
     case 1:
-      ret = 2;
+      ret = (pctx->flag.zeroZ ? 1 : 2);
       break;
     case 2:
-      ret = 1;
+      ret = (pctx->flag.zeroZ ? 0 : 1);
       break;
     default:
       biffAddf(PULL, "%s: can't simultaneously use all tangents "
diff --color -ruN teem-1.11.0-src.orig/src/pull/contextPull.c teem-1.11.0-src/src/pull/contextPull.c
--- teem-1.11.0-src.orig/src/pull/contextPull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/contextPull.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -701,7 +701,7 @@
         break;
       case pullPropStuck:
         out_uc[outIdx] = ((point->status & PULL_STATUS_STUCK_BIT)
-                          ? point->stuckIterNum
+                          ? AIR_UCHAR(AIR_MIN(255, point->stuckIterNum))
                           : 0);
         break;
       case pullPropPosition:
@@ -784,9 +784,85 @@
   return 0;
 }
 
+/*
+** extract history as single array, possibly specific to only a single point0
+*/
 int
-pullPositionHistoryGet(limnPolyData *pld, pullContext *pctx) {
-  static const char me[]="pullPositionHistoryGet";
+pullPositionHistoryNrrdGet(Nrrd *nhist, pullContext *pctx, pullPoint *point0) {
+  static const char me[]="pullPositionHistoryNrrdGet";
+#if PULL_PHIST
+  pullBin *bin;
+  unsigned int binIdx, pointIdx, stepNum, stepIdx, phistIdx, phistNum, ii;
+  double *hist;
+
+  if (!(nhist && pctx)) {
+    biffAddf(PULL, "%s: got NULL pointer", me);
+    return 1;
+  }
+
+  if (!point0) {
+    stepNum = 0;
+    for (binIdx=0; binIdx<pctx->binNum; binIdx++) {
+      bin = pctx->bin + binIdx;
+      for (pointIdx=0; pointIdx<bin->pointNum; pointIdx++) {
+        pullPoint *point;
+        point = bin->point[pointIdx];
+        stepNum += point->phistArr->len;
+      }
+    }
+  } else {
+    stepNum = point0->phistArr->len;
+  }
+  if (nrrdMaybeAlloc_va(nhist, nrrdTypeDouble, 2,
+                        AIR_CAST(size_t, 1 + _PHN),
+                        AIR_CAST(size_t, stepNum))) {
+    biffMovef(PULL, NRRD, "%s: couldn't allocate output", me);
+    return 1;
+  }
+  hist = AIR_CAST(double *, nhist->data);
+  stepIdx = 0;
+  if (!point0) {
+    for (binIdx=0; binIdx<pctx->binNum; binIdx++) {
+      bin = pctx->bin + binIdx;
+      for (pointIdx=0; pointIdx<bin->pointNum; pointIdx++) {
+        pullPoint *point;
+        point = bin->point[pointIdx];
+        phistNum = point->phistArr->len;
+        for (phistIdx=0; phistIdx<phistNum; phistIdx++) {
+          double *hh;
+          hh = hist + stepIdx*(1 + _PHN);
+          hh[0] = AIR_CAST(double, point->idtag);
+          for (ii=0; ii<_PHN; ii++) {
+            hh[ii+1] = (point->phist + _PHN*phistIdx)[ii];
+          }
+          stepIdx++;
+        }
+      }
+    }
+  } else {
+    for (stepIdx=0; stepIdx<stepNum; stepIdx++) {
+      double *hh;
+      hh = hist + stepIdx*(1 + _PHN);
+      hh[0] = AIR_CAST(double, point0->idtag);
+      for (ii=0; ii<_PHN; ii++) {
+        hh[ii+1] = (point0->phist + _PHN*stepIdx)[ii];
+      }
+    }
+  }
+
+  return 0;
+#else
+  AIR_UNUSED(nhist);
+  AIR_UNUSED(pctx);
+  AIR_UNUSED(point0);
+  biffAddf(PULL, "%s: sorry, not compiled with PULL_PHIST", me);
+  return 1;
+#endif
+}
+
+int
+pullPositionHistoryPolydataGet(limnPolyData *pld, pullContext *pctx) {
+  static const char me[]="pullPositionHistoryPolydataGet";
 #if PULL_PHIST
   pullBin *bin;
   pullPoint *point;
@@ -826,7 +902,7 @@
         ELL_3V_SET(rgb, 0, 0, 0);
         ELL_3V_COPY(pld->xyzw + 4*vertIdx, point->phist + 5*phistIdx);
         (pld->xyzw + 4*vertIdx)[3] = 1;
-        cond = AIR_CAST(int, (point->phist + 5*phistIdx)[4]);
+        cond = AIR_INT((point->phist + 5*phistIdx)[4]);
         switch (cond) {
         case pullCondOld:
           ELL_3V_SET(rgb, 128, 128, 128);
@@ -860,7 +936,6 @@
     }
   }
 
-
   return 0;
 #else
   AIR_UNUSED(pld);
diff --color -ruN teem-1.11.0-src.orig/src/pull/corePull.c teem-1.11.0-src/src/pull/corePull.c
--- teem-1.11.0-src.orig/src/pull/corePull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/corePull.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -378,6 +378,8 @@
          ||
          ((!pctx->iterParm.max || pctx->iter < pctx->iterParm.max)
           && !converged)) {
+    /* this per iteration init had been missing for a very long time */
+    pctx->addNum = pctx->nixNum = 0;
     if (pctx->iterParm.snap && !(pctx->iter % pctx->iterParm.snap)) {
       npos = nrrdNew();
       sprintf(poutS, "snap.%06d.pos.nrrd", pctx->iter);
@@ -454,14 +456,17 @@
     }
     pctx->iter += 1;
     enrLast = enrNew;
-    converged = ((!pctx->iterParm.popCntlPeriod
-                  || (!pctx->addNum && !pctx->nixNum))
-                 && AIR_IN_OP(0, enrDecreaseAvg,
+    converged = ((pctx->flag.convergenceIgnoresPopCntl
+                  || (!pctx->iterParm.popCntlPeriod
+                      || (!pctx->addNum && !pctx->nixNum)))
+                 && AIR_IN_CL(0, enrDecreaseAvg,
                               pctx->sysParm.energyDecreaseMin));
     if (pctx->verbose) {
-      fprintf(stderr, "%s: converged %d = (%d || (%d && %d)) "
-              "&& (0 < %g < %g)=%d\n",
-              me, converged, !pctx->iterParm.popCntlPeriod,
+      fprintf(stderr, "%s: converged %d = (%d || (%d || (%d && %d))) "
+              "&& (0 <= %g <= %g)=%d\n",
+              me, converged,
+              pctx->flag.convergenceIgnoresPopCntl,
+              !pctx->iterParm.popCntlPeriod,
               !pctx->addNum, !pctx->nixNum,
               enrDecreaseAvg, pctx->sysParm.energyDecreaseMin,
               AIR_IN_OP(0, enrDecreaseAvg, pctx->sysParm.energyDecreaseMin));
@@ -489,6 +494,13 @@
   pctx->timeRun += time1 - time0;
   pctx->energy = enrNew;
 
+  /* we do one final neighbor-learn iteration, to set the fields
+     (like stability) that are only learned then */
+  if (_pullIterate(pctx, pullProcessModeNeighLearn)) {
+    biffAddf(PULL, "%s: trouble after-final iter", me);
+    return 1;
+  }
+
   if (0) {
     /* probe inter-particle energy function */
     unsigned int szimg=300, ri, si;
diff --color -ruN teem-1.11.0-src.orig/src/pull/defaultsPull.c teem-1.11.0-src/src/pull/defaultsPull.c
--- teem-1.11.0-src.orig/src/pull/defaultsPull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/defaultsPull.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/pull/energy.c teem-1.11.0-src/src/pull/energy.c
--- teem-1.11.0-src.orig/src/pull/energy.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/energy.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -304,7 +304,7 @@
   int n;
   double cut, denom, enr;
 
-  n = AIR_CAST(int, parm[0]);
+  n = AIR_INT(parm[0]);
   cut = parm[1];
   denom = 1 + airIntPow(x/cut, 2*n);
   enr = 1/denom;
@@ -806,7 +806,7 @@
 }
 
 int
-_pullHestEnergyParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+_pullHestEnergyParse(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   static const char me[]="_pullHestForceParse";
   pullEnergySpec **enspP;
   char *perr;
diff --color -ruN teem-1.11.0-src.orig/src/pull/enumsPull.c teem-1.11.0-src/src/pull/enumsPull.c
--- teem-1.11.0-src.orig/src/pull/enumsPull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/enumsPull.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -237,7 +237,9 @@
   "constrfail",
   "bounds",
   "length",
-  "stub"
+  "stub",
+  "voledge",
+  "orientconstrfail"
 };
 
 const airEnum
@@ -254,6 +256,28 @@
 /* --------------------------------------------------------- */
 
 const char *
+_pullInitMethodStr[] = {
+  "(unknown_init_method)",
+  "random",
+  "halton",
+  "ppv",
+  "given"
+};
+
+const airEnum
+_pullInitMethod = {
+  "init method",
+  PULL_INIT_METHOD_MAX,
+  _pullInitMethodStr,  NULL,
+  NULL, NULL, NULL,
+  AIR_FALSE
+};
+const airEnum *const
+pullInitMethod = &_pullInitMethod;
+
+/* --------------------------------------------------------- */
+
+const char *
 _pullCountStr[] = {
   "(unknown_countable)",
   "descent",
@@ -288,10 +312,13 @@
 const char *
 _pullConstraintFailStr[PULL_CONSTRAINT_FAIL_MAX+1] = {
   "(unknown or no contraint fail)",
+  "needed Hessian 0 (A)",
+  "needed Hessian 0 (B)",
   "projected gradient 0 (A)",
   "projected gradient 0 (B)",
   "iter max exceeded",
-  "travel exceeded"
+  "travel exceeded",
+  "plen doesn't exist"
 };
 
 const airEnum
diff --color -ruN teem-1.11.0-src.orig/src/pull/GNUmakefile teem-1.11.0-src/src/pull/GNUmakefile
--- teem-1.11.0-src.orig/src/pull/GNUmakefile	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/GNUmakefile	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/pull/infoPull.c teem-1.11.0-src/src/pull/infoPull.c
--- teem-1.11.0-src.orig/src/pull/infoPull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/infoPull.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/pull/initPull.c teem-1.11.0-src/src/pull/initPull.c
--- teem-1.11.0-src.orig/src/pull/initPull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/initPull.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -74,7 +74,7 @@
                airEnumStr(nrrdType, nrrdTypeFloat),
                airEnumStr(nrrdType, nrrdTypeDouble),
                iparm->npos->dim,
-               AIR_CAST(unsigned int, iparm->npos->axis[0].size),
+               AIR_UINT(iparm->npos->axis[0].size),
                airEnumStr(nrrdType, iparm->npos->type));
       return 1;
     }
diff --color -ruN teem-1.11.0-src.orig/src/pull/parmPull.c teem-1.11.0-src/src/pull/parmPull.c
--- teem-1.11.0-src.orig/src/pull/parmPull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/parmPull.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -49,7 +49,6 @@
   sysParm->beta = 0.5;
   sysParm->gamma = 1;
   sysParm->separableGammaLearnRescale = 8;
-  sysParm->theta = 0.0;
   sysParm->wall = 1;
   sysParm->radiusSpace = 1;
   sysParm->radiusScale = 1;
@@ -76,13 +75,19 @@
   flag->restrictiveAddToBins = AIR_TRUE;
   flag->energyFromStrength = AIR_FALSE;
   flag->nixAtVolumeEdgeSpace = AIR_FALSE;
+  flag->nixAtVolumeEdgeSpaceInitRorH = AIR_FALSE;
   flag->constraintBeforeSeedThresh = AIR_FALSE;
   flag->noAdd = AIR_FALSE;
   flag->popCntlEnoughTest = AIR_TRUE; /* really needs to be true by default */
+  flag->convergenceIgnoresPopCntl = AIR_FALSE; /* false by default for
+                                                  backwards compatibility,
+                                                  even thought this was
+                                                  probably a mistake */
   flag->binSingle = AIR_FALSE;
   flag->allowCodimension3Constraints = AIR_FALSE;
   flag->scaleIsTau = AIR_FALSE;
   flag->startSkipsPoints = AIR_FALSE; /* must be false by default */
+  flag->zeroZ = AIR_FALSE;
   return;
 }
 
@@ -167,7 +172,6 @@
   CHECK(alpha, 0.0, 1.0);
   CHECK(beta, 0.0, 1.0);
   /* HEY: no check on gamma? */
-  /* no check on theta */
   CHECK(wall, 0.0, 100.0);
   CHECK(radiusSpace, 0.000001, 80.0);
   CHECK(radiusScale, 0.000001, 80.0);
@@ -216,9 +220,6 @@
   case pullSysParmSeparableGammaLearnRescale:
     pctx->sysParm.separableGammaLearnRescale = pval;
     break;
-  case pullSysParmTheta:
-    pctx->sysParm.theta = pval;
-    break;
   case pullSysParmStepInitial:
     pctx->sysParm.stepInitial = pval;
     break;
@@ -304,6 +305,9 @@
   case pullFlagNixAtVolumeEdgeSpace:
     pctx->flag.nixAtVolumeEdgeSpace = flag;
     break;
+  case pullFlagNixAtVolumeEdgeSpaceInitRorH:
+    pctx->flag.nixAtVolumeEdgeSpaceInitRorH = flag;
+    break;
   case pullFlagConstraintBeforeSeedThresh:
     pctx->flag.constraintBeforeSeedThresh = flag;
     break;
@@ -313,6 +317,9 @@
   case pullFlagPopCntlEnoughTest:
     pctx->flag.popCntlEnoughTest = flag;
     break;
+  case pullFlagConvergenceIgnoresPopCntl:
+    pctx->flag.convergenceIgnoresPopCntl = flag;
+    break;
   case pullFlagBinSingle:
     pctx->flag.binSingle = flag;
     break;
@@ -325,6 +332,9 @@
   case pullFlagStartSkipsPoints:
     pctx->flag.startSkipsPoints = flag;
     break;
+  case pullFlagZeroZ:
+    pctx->flag.zeroZ = flag;
+    break;
   default:
     biffAddf(me, "%s: sorry, flag %d valid but not handled?", me, which);
     return 1;
diff --color -ruN teem-1.11.0-src.orig/src/pull/pointPull.c teem-1.11.0-src/src/pull/pointPull.c
--- teem-1.11.0-src.orig/src/pull/pointPull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/pointPull.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -25,6 +25,8 @@
 #include "pull.h"
 #include "privatePull.h"
 
+#define DEBUG 1
+
 /*
 ** HEY: this has to be threadsafe, at least threadsafe when there
 ** are no errors, because this can now be called from multiple
@@ -78,7 +80,7 @@
   pnt->phistNum = 0;
   pnt->phistArr = airArrayNew(AIR_CAST(void**, &(pnt->phist)),
                               &(pnt->phistNum),
-                              5*sizeof(double), 32);
+                              _PHN*sizeof(double), 32);
 #endif
   pnt->status = 0;
   ELL_4V_SET(pnt->pos, AIR_NAN, AIR_NAN, AIR_NAN, AIR_NAN);
@@ -112,13 +114,19 @@
 }
 
 void
-_pullPointHistAdd(pullPoint *point, int cond) {
+_pullPointHistAdd(pullPoint *point, int cond, double val) {
+  static const char me[]="_pullPointHistAdd";
   unsigned int phistIdx;
 
   phistIdx = airArrayLenIncr(point->phistArr, 1);
-  ELL_4V_COPY(point->phist + 5*phistIdx, point->pos);
-  (point->phist + 5*phistIdx)[3] = 1.0;
-  (point->phist + 5*phistIdx)[4] = cond;
+  ELL_4V_COPY(point->phist + _PHN*phistIdx, point->pos);
+
+  fprintf(stderr, "!%s: point %p pos = %.17g  %.17g  %.17g  %.17g (%g)\n", me,
+          point, point->pos[0], point->pos[1], point->pos[2], point->pos[3],
+          val);
+
+  (point->phist + _PHN*phistIdx)[4] = cond;
+  (point->phist + _PHN*phistIdx)[5] = val;
   return;
 }
 #endif
@@ -241,8 +249,6 @@
 /*
 ** convenience function for learning a scalar AND its gradient or hessian
 **
-** NOTE: this is where pullInfoSeedThresh and pullInfoLiveThresh are
-** adjusted according to sysParm.theta (kind of a hack)
 */
 double
 pullPointScalar(const pullContext *pctx, const pullPoint *point, int sclInfo,
@@ -309,24 +315,18 @@
      of the scalar.  this is getting confusing ... */
   scl = point->info[infoIdx[sclInfo]];
   scl = (scl - ispec->zero)*ispec->scale;
+  /* if (289 == pctx->iter) {
+    fprintf(stderr, "!%s(%04u,%s)@(%g,%g): (%g - %g)*%g == %g\n",
+            me, point->idtag, airEnumStr(pullInfo, sclInfo),
+            point->pos[0], point->pos[1],
+            point->info[infoIdx[sclInfo]], ispec->zero, ispec->scale, scl);
+  } */
   if (0 && _pullVerbose) {
     if (pullInfoSeedThresh == sclInfo) {
       printf("!%s: seed thresh (%g - %g)*%g == %g\n", me,
              point->info[infoIdx[sclInfo]], ispec->zero, ispec->scale, scl);
     }
   }
-  /* HEY: this logic is confused and the implementation is confused;
-     this should be removed before release */
-  if (pullInfoLiveThresh == sclInfo
-      || pullInfoSeedThresh == sclInfo) {
-    scl -= (pctx->sysParm.theta)*(point->pos[3])*(point->pos[3]);
-  }
-  if (0 && _pullVerbose) {
-    if (pullInfoSeedThresh == sclInfo) {
-      printf("!%s:  ---> w/ theta %g -> %g\n", me,
-             pctx->sysParm.theta, scl);
-    }
-  }
   /*
     learned: this wasn't thought through: the idea was that the height
     *laplacian* answer should be transformed by the *height* zero and
@@ -343,13 +343,13 @@
   }
   */
   /*
-  printf("%s = (%g - %g)*%g = %g*%g = %g = %g\n",
-         airEnumStr(pullInfo, sclInfo),
-         point->info[infoIdx[sclInfo]],
-         ispec->zero, ispec->scale,
-         point->info[infoIdx[sclInfo]] - ispec->zero, ispec->scale,
-         (point->info[infoIdx[sclInfo]] - ispec->zero)*ispec->scale,
-         scl);
+  fprintf(stderr, "!%s: %s = (%g - %g)*%g = %g*%g = %g = %g\n", me,
+          airEnumStr(pullInfo, sclInfo),
+          point->info[infoIdx[sclInfo]],
+          ispec->zero, ispec->scale,
+          point->info[infoIdx[sclInfo]] - ispec->zero, ispec->scale,
+          (point->info[infoIdx[sclInfo]] - ispec->zero)*ispec->scale,
+          scl);
   */
   if (grad && gradInfo[sclInfo]) {
     const double *ptr = point->info + infoIdx[gradInfo[sclInfo]];
@@ -376,6 +376,9 @@
   static FILE *flog;
 #endif
 
+  /*
+  fprintf(stderr, "%s(%u,%u): A volNum = %u\n", me, task->pctx->iter, point->idtag,task->pctx->volNum);
+  */
 #if 0
   static int logIdx=0, logDone=AIR_FALSE, logStarted=AIR_FALSE;
   static Nrrd *nlog;
@@ -398,7 +401,7 @@
     fprintf(stderr, "%s: pnt %u non-exist pos (%g,%g,%g,%g)\n\n!!!\n\n\n",
             me, point->idtag, point->pos[0], point->pos[1],
             point->pos[2], point->pos[3]);
-    biffAddf(PULL, "%s: pnt %u non-exist pos (%g,%g,%g,%g)\n\n!!!\n\n\n",
+    biffAddf(PULL, "%s: pnt %u non-exist pos (%g,%g,%g,%g)",
              me, point->idtag, point->pos[0], point->pos[1],
              point->pos[2], point->pos[3]);
     return 1;
@@ -414,6 +417,9 @@
   }
   edge = AIR_FALSE;
   task->pctx->count[pullCountProbe] += 1;
+  /*
+  fprintf(stderr, "%s(%u,%u): B volNum = %u\n", me, task->pctx->iter, point->idtag,task->pctx->volNum);
+  */
   for (ii=0; ii<task->pctx->volNum; ii++) {
     pullVolume *vol;
     vol = task->vol[ii];
@@ -429,12 +435,6 @@
     }
     /* HEY should task->vol[ii]->scaleNum be the using-scale-space test? */
     if (!task->vol[ii]->ninScale) {
-      /*
-        if (81 == point->idtag) {
-        printf("%s: probing vol[%u] @ %g %g %g\n", me, ii,
-        point->pos[0], point->pos[1], point->pos[2]);
-        }
-      */
       gret = gageProbeSpace(task->vol[ii]->gctx,
                             point->pos[0], point->pos[1], point->pos[2],
                             AIR_FALSE /* index-space */,
@@ -501,6 +501,14 @@
       aidx = task->pctx->infoIdx[ii];
       if (pullSourceGage == ispec->source) {
         _pullInfoCopy[alen](point->info + aidx, task->ans[ii]);
+        /* if (289 == task->pctx->iter) {
+          fprintf(stderr, "!%s(%u): copied info %u (%s) len %u\n", me, point->idtag,
+                  ii, airEnumStr(pullInfo, ii), alen);
+          if (1 == alen) {
+            fprintf(stderr, "!%s(%u): (point->info + %u)[0] = %g\n", me, point->idtag,
+                    aidx, (point->info + aidx)[0]);
+          }
+        } */
         /*
         if (81 == point->idtag) {
           pullVolume *vol;
@@ -690,6 +698,9 @@
     iPos[k] = vidx[k] + pctx->initParm.jitter*(airDrandMT_r(rng)-0.5);
   }
   gageShapeItoW(seedShape, point->pos, iPos);
+  if (pctx->flag.zeroZ) {
+    point->pos[2] = 0.0;
+  }
 
   if (0 && _pullVerbose) {
     printf("!%s: pointIdx %u -> vidx %u %u %u (%u)\n"
@@ -825,8 +836,10 @@
     wrld[3] = 0.0;
   }
   /*
-  fprintf(stderr, "!%s: (%g,%g,%g,%g) --> (%g,%g,%g,%g)\n", me,
+  fprintf(stderr, "!%s: (%g,%g,%g,%g) -- [%g,%g]x[%g,%g]x[%g,%g]--> (%g,%g,%g,%g)\n", me,
           unit[0], unit[1], unit[2], unit[3],
+          pctx->bboxMin[0], pctx->bboxMin[1], pctx->bboxMin[2],
+          pctx->bboxMax[0], pctx->bboxMax[1], pctx->bboxMax[2],
           wrld[0], wrld[1], wrld[2], wrld[3]);
   */
   return;
@@ -839,17 +852,19 @@
   static const char me[]="pullPointInitializeRandomOrHalton";
   int reject, verbo;
   airRandMTState *rng;
-  unsigned int threshFailCount = 0, spthreshFailCount = 0,
+  unsigned int tryCount = 0, threshFailCount = 0, spthreshFailCount = 0,
     constrFailCount = 0;
   rng = pctx->task[0]->rng;
 
   do {
     double rpos[4];
-
+    /* fprintf(stderr, "!%s: starting doooo (tryCount %u)!\n", me, tryCount); */
+    tryCount++;
     reject = AIR_FALSE;
     _pullPointHistInit(point);
     /* Populate tentative random point */
     if (pullInitMethodHalton == pctx->initParm.method) {
+      /* we generate all 4 coordinates, even if we don't need them all */
       airHalton(rpos, (pointIdx + threshFailCount + constrFailCount
                        + pctx->haltonOffset + pctx->initParm.haltonStartIndex),
                 airPrimeList, 4);
@@ -862,17 +877,25 @@
               pctx->haltonOffset, pctx->initParm.haltonStartIndex,
               rpos[0], rpos[1], rpos[2], rpos[3]);
       */
-                    /*
+      /*
       fprintf(stderr, "%g %g %g %g ",
               rpos[0], rpos[1], rpos[2], rpos[3]);
-              */
+      */
+      if (!pctx->haveScale) {
+        rpos[3] = 0;
+      }
     } else {
       ELL_3V_SET(rpos, airDrandMT_r(rng), airDrandMT_r(rng), airDrandMT_r(rng));
       if (pctx->haveScale) {
         rpos[3] = airDrandMT_r(rng);
+      } else {
+        rpos[3] = 0;
       }
     }
     _pullUnitToWorld(pctx, scaleVol, point->pos, rpos);
+    if (pctx->flag.zeroZ) {
+      point->pos[2] = 0.0;
+    }
     /*
     verbo = (AIR_ABS(-0.246015 - point->pos[0]) < 0.1 &&
              AIR_ABS(-144.78 - point->pos[0]) < 0.1 &&
@@ -884,7 +907,7 @@
               point->idtag, point->pos[0], point->pos[1],
               point->pos[2], point->pos[3]);
     }
-    _pullPointHistAdd(point, pullCondOld);
+    _pullPointHistAdd(point, pullCondOld, AIR_NAN);
 
     /* HEY copy and paste */
     if (pctx->ispec[pullInfoSeedPreThresh]) {
@@ -913,6 +936,9 @@
       reject = AIR_TRUE; \
       goto reckoning; \
     }
+    /* fprintf(stderr, "!%s: bi ngo 0 (%d) %d %p\n", me,
+            !pctx->flag.constraintBeforeSeedThresh,
+            pctx->initParm.liveThreshUse, pctx->ispec[pullInfoLiveThresh]); */
     if (!pctx->flag.constraintBeforeSeedThresh) {
       THRESH_TEST(pullInfoSeedThresh);
       if (pctx->initParm.liveThreshUse) {
@@ -921,20 +947,45 @@
         THRESH_TEST(pullInfoLiveThresh3);
       }
     }
+    /* fprintf(stderr, "!%s: bi ngo 1\n", me); */
 
     if (pctx->constraint) {
       int constrFail;
+      /* fprintf(stderr, "!%s: calling _pullConstraintSatisfy(%u)\n", me, pointIdx); */
       if (_pullConstraintSatisfy(pctx->task[0], point,
                                  _PULL_CONSTRAINT_TRAVEL_MAX,
                                  &constrFail)) {
         biffAddf(PULL, "%s: trying constraint on point %u", me, pointIdx);
         return 1;
       }
+#if PULL_PHIST
+      if (DEBUG) {
+        Nrrd *nhist;
+        FILE *fhist;
+        char fname[AIR_STRLEN_SMALL];
+        nhist = nrrdNew();
+        if (pullPositionHistoryNrrdGet(nhist, pctx, point)) {
+          biffAddf(PULL, "%s: trouble", me);
+          return 1;
+        }
+        sprintf(fname, "%04u-%04u-%04u-phist.nrrd", pctx->iter,
+                point->idtag, tryCount);
+        if ((fhist = fopen(fname, "w"))) {
+          if (nrrdSave(fname, nhist, NULL)) {
+            biffMovef(PULL, NRRD, "%s: trouble", me);
+            return 1;
+          }
+          fclose(fhist);
+        }
+        nrrdNuke(nhist);
+      }
+#endif
       if (constrFail) {
         constrFailCount++;
         reject = AIR_TRUE;
         goto reckoning;
       }
+      /* fprintf(stderr, "!%s: bi ngo 2\n", me); */
       /* post constraint-satisfaction, we certainly have to assert thresholds */
       THRESH_TEST(pullInfoSeedThresh);
       if (pctx->initParm.liveThreshUse) {
@@ -942,6 +993,7 @@
         THRESH_TEST(pullInfoLiveThresh2);
         THRESH_TEST(pullInfoLiveThresh3);
       }
+      /* fprintf(stderr, "!%s: bi ngo 3 (reject=%d)\n", me, reject); */
     }
 
   reckoning:
@@ -976,6 +1028,9 @@
 
   /* Copy nrrd point into pullPoint */
   ELL_4V_COPY(point->pos, posData + 4*pointIdx);
+  if (pctx->flag.zeroZ) {
+    point->pos[2] = 0.0;
+  }
 
   /*
   if (AIR_ABS(247.828 - point->pos[0]) < 0.1 &&
@@ -1037,7 +1092,7 @@
 _pullPointSetup(pullContext *pctx) {
   static const char me[]="_pullPointSetup";
   char doneStr[AIR_STRLEN_SMALL];
-  unsigned int pointIdx, binIdx, tick, pn;
+  unsigned int pointIdx, binIdx, tick, pn, initRorHack;
   pullPoint *point;
   pullBin *bin;
   int createFail,added;
@@ -1055,11 +1110,12 @@
      tempting to set this value high, to more aggressively limit the
      number of points added, but that's really the job of population
      control, and we can't always guarantee that constraint manifolds
-     will be well-sampled (with respect to pctx->radiusSpace) to start
-     with */
+     will be well-sampled (with respect to pctx->radiusSpace and
+     pctx->radiusScale) to start with */
 
   if (pctx->verbose) {
-    printf("%s: beginning . . . ", me);
+    printf("%s: beginning (%s). . . ", me,
+           airEnumStr(pullInitMethod, pctx->initParm.method));
     fflush(stdout);
   }
   mop = airMopNew();
@@ -1078,7 +1134,7 @@
              "and pointPerVoxel (%d)\n", me, pctx->initParm.numInitial,
              pctx->initParm.pointPerVoxel);
     }
-    totalNumPoints = AIR_CAST(unsigned int, npos->axis[1].size);
+    totalNumPoints = AIR_UINT(npos->axis[1].size);
     break;
   case pullInitMethodPointPerVoxel:
     npos = NULL;
@@ -1125,9 +1181,9 @@
     if (pctx->haveScale) {
       unsigned int sasn;
       sasn = pctx->initParm.samplesAlongScaleNum;
-      totalNumPoints = AIR_CAST(unsigned int, voxNum * factor * sasn);
+      totalNumPoints = AIR_UINT(voxNum * factor * sasn);
     } else {
-      totalNumPoints = AIR_CAST(unsigned int, voxNum * factor);
+      totalNumPoints = AIR_UINT(voxNum * factor);
     }
     break;
   case pullInitMethodRandom:
@@ -1143,7 +1199,7 @@
     break;
   }
   if (pctx->verbose) {
-    printf("%s: initializing/seeding . . .       ", me);
+    printf("%s: initializing/seeding %u pts. . .       ", me, totalNumPoints);
     fflush(stdout);
   }
 
@@ -1160,17 +1216,24 @@
   /* Start adding points */
   tick = totalNumPoints/1000;
   point = NULL;
-  for (pointIdx = 0; pointIdx < totalNumPoints; pointIdx++) {
+  initRorHack = 0;
+  /* This loop would normally be:
+     for (pointIdx = 0; pointIdx < totalNumPoints; pointIdx++) {
+     but because of pctx->flag.nixAtVolumeEdgeSpaceInitRorH we
+     need to be able to decrement pointIdx to force another redo,
+     even if pointIdx==0. So loop index is actually one greater
+     than the index value actually used */
+  for (pointIdx = 1; pointIdx <= totalNumPoints; pointIdx++) {
     int E;
     if (pctx->verbose) {
-      if (tick < 100 || 0 == pointIdx % tick) {
-        printf("%s", airDoneStr(0, pointIdx, totalNumPoints, doneStr));
+      if (tick < 100 || 0 == (pointIdx-1) % tick) {
+        printf("%s", airDoneStr(0, pointIdx-1, totalNumPoints, doneStr));
         fflush(stdout);
       }
     }
     if (pctx->verbose > 5) {
       printf("\n%s: setting up point = %u/%u\n", me,
-             pointIdx, totalNumPoints);
+             pointIdx-1, totalNumPoints);
     }
     /* Create point */
     if (!point) {
@@ -1181,21 +1244,41 @@
     switch(pctx->initParm.method) {
     case pullInitMethodRandom:
     case pullInitMethodHalton:
-      E = pullPointInitializeRandomOrHalton(pctx, pointIdx, point, scaleVol);
-      createFail = AIR_FALSE;
+      /* point index passed here always increments, even if
+         we failed last time because of being at edge */
+      E = pullPointInitializeRandomOrHalton(pctx, pointIdx-1 + initRorHack,
+                                            point, scaleVol);
+      if (pctx->flag.nixAtVolumeEdgeSpaceInitRorH) {
+        createFail = !!(point->status & PULL_STATUS_EDGE_BIT);
+        if (createFail) {
+          initRorHack++;
+          if (initRorHack > 10*totalNumPoints) {
+            biffAddf(PULL, "%s: (point %u) handling nixAtVolumeEdgeSpaceInitRorH, "
+                     "have failed so often (%u > 10*#pnts = %u); something "
+                     "must be wrong", me, point->idtag, initRorHack,
+                     totalNumPoints);
+            airMopError(mop); return 1;
+          }
+          /* this is a for-loop, post-body increment will always happen;
+             we need to subvert it. */
+          pointIdx--;
+        }
+      } else {
+        createFail = AIR_FALSE;
+      }
       break;
     case pullInitMethodPointPerVoxel:
-      E = pullPointInitializePerVoxel(pctx, pointIdx, point, scaleVol,
+      E = pullPointInitializePerVoxel(pctx, pointIdx-1, point, scaleVol,
                                       &createFail);
       break;
     case pullInitMethodGivenPos:
-      E = pullPointInitializeGivenPos(pctx, posData, pointIdx, point,
+      E = pullPointInitializeGivenPos(pctx, posData, pointIdx-1, point,
                                       &createFail);
       break;
     }
     if (E) {
       biffAddf(PULL, "%s: trouble trying point %u (id %u)", me,
-               pointIdx, point->idtag);
+               pointIdx-1, point->idtag);
       airMopError(mop); return 1;
     }
     if (createFail) {
@@ -1228,40 +1311,53 @@
     }
   } /* Done looping through total number of points */
   if (pctx->verbose) {
-    printf("%s\n", airDoneStr(0, pointIdx, totalNumPoints,
+    printf("%s\n", airDoneStr(0, pointIdx-1, totalNumPoints,
                               doneStr));
   }
   if (point) {
     /* we created a new test point, but it was never placed in the volume */
     /* so, HACK: undo pullPointNew . . . */
     point = pullPointNix(point);
-    pctx->idtagNext -= 1;
+    /* pctx->idtagNext -= 1; */
   }
 
   /* Final check: do we have any points? */
   pn = pullPointNumber(pctx);
   if (!pn) {
+    char stmp1[AIR_STRLEN_MED], stmp2[AIR_STRLEN_MED];
+    int guess=AIR_FALSE;
+    sprintf(stmp1, "%s: seeded 0 points", me);
     if (pctx->ispec[pullInfoSeedThresh]) {
-      biffAddf(PULL, "%s: zero points: seeding failed (bad seedthresh? %g)",
-               me, pctx->ispec[pullInfoSeedThresh]->zero);
-    } else {
-      biffAddf(PULL, "%s: zero points: seeding failed", me);
+      guess=AIR_TRUE;
+      sprintf(stmp2, " (? bad seedthresh %g ?)",
+              pctx->ispec[pullInfoSeedThresh]->zero);
+      strcat(stmp1, stmp2);
+    }
+    if (pctx->flag.nixAtVolumeEdgeSpace) {
+      guess=AIR_TRUE;
+      sprintf(stmp2, " (? flag.nixAtVolumeEdgeSpace true ?)");
+      strcat(stmp1, stmp2);
+    }
+    if (!guess) {
+      sprintf(stmp2, " (no guess as to why)");
+      strcat(stmp1, stmp2);
     }
+    biffAddf(PULL, "%s", stmp1);
     airMopError(mop); return 1;
   }
   if (pctx->verbose) {
     fprintf(stderr, "%s: initialized to %u points (idtagNext = %u)\n",
             me, pn, pctx->idtagNext);
   }
-  /*
-  if (1) {
+  /* */
+  if (0) {
     Nrrd *ntmp;
     ntmp = nrrdNew();
     pullOutputGet(ntmp, NULL, NULL, NULL, 0.0, pctx);
-    nrrdSave("pos-in.nrrd", ntmp, NULL);
+    nrrdSave("pos-init.nrrd", ntmp, NULL);
     nrrdNuke(ntmp);
   }
-  */
+  /* */
   pctx->tmpPointPtr = AIR_CAST(pullPoint **,
                                calloc(pn, sizeof(pullPoint*)));
   pctx->tmpPointPerm = AIR_CAST(unsigned int *,
diff --color -ruN teem-1.11.0-src.orig/src/pull/popcntl.c teem-1.11.0-src/src/pull/popcntl.c
--- teem-1.11.0-src.orig/src/pull/popcntl.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/popcntl.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -67,21 +67,25 @@
   int E;
 
   task->pctx->count[pullCountAdding] += 1;
-
   if (point->neighPointNum && task->pctx->targetDim
       && task->pctx->flag.popCntlEnoughTest) {
-    unsigned int plenty;
-    plenty = (1 == task->pctx->targetDim
+    unsigned int plenty, tardim;
+    tardim = task->pctx->targetDim;
+    if (task->pctx->flag.zeroZ && tardim > 1) {
+      /* GLK unsure of tardim == 1 logic here */
+      tardim -= 1;
+    }
+    plenty = (1 == tardim
               ? 3
-              : (2 == task->pctx->targetDim
+              : (2 == tardim
                  ? 7
-                 : (3 == task->pctx->targetDim
+                 : (3 == tardim
                     ? 13 /* = 1 + 12
                             = 1 + coordination number of 3D sphere packing */
                     : 0 /* shouldn't get here */)));
     /*
     if (0 == (point->idtag % 100)) {
-      printf("%s: #num %d >?= plenty %d\n", me, point->neighPointNum, plenty);
+      printf("!%s: #num %d >?= plenty %d\n", me, point->neighPointNum, plenty);
     }
     */
     if (point->neighPointNum >= plenty) {
@@ -89,6 +93,16 @@
       return 0;
     }
   }
+  /*
+  printf("!%s: point->pos = (%g,%g,%g,%g)\n", me,
+         point->pos[0], point->pos[1], point->pos[2], point->pos[3]);
+  printf("!%s: point->neighPointNum = %u\n", me,
+         point->neighPointNum);
+  printf("!%s: task->pctx->targetDim = %u\n", me,
+         task->pctx->targetDim);
+  printf("!%s: task->pctx->flag.popCntlEnoughTest = %d\n", me,
+         task->pctx->flag.popCntlEnoughTest);
+  */
   ELL_4V_SET(noffavg, 0, 0, 0, 0);
   for (npi=0; npi<point->neighPointNum; npi++) {
     double off[4];
@@ -126,6 +140,9 @@
     /* we had no neighbors, have to pretend like we did */
     airNormalRand_r(noffavg + 0, noffavg + 1, task->rng);
     airNormalRand_r(noffavg + 2, noffavg + 3, task->rng);
+    if (!task->pctx->flag.zeroZ) {
+      noffavg[2] = 0;
+    }
     if (!task->pctx->haveScale) {
       noffavg[3] = 0;
     }
@@ -142,6 +159,10 @@
   ELL_4V_SCALE(noffavg, newSpcDist, noffavg);
   /* set new point location */
   ELL_4V_ADD2(npos, noffavg, point->pos);
+  /*
+  printf("!%s: new test pos @ (%g,%g,%g,%g)\n", me,
+         npos[0], npos[1], npos[2], npos[3]);
+  */
   if (!_pullInsideBBox(task->pctx, npos)) {
     if (task->pctx->verbose > 2) {
       printf("%s: new pnt would start (%g,%g,%g,%g) outside bbox, nope\n",
@@ -186,6 +207,10 @@
       return 0;
     }
   }
+  /*
+  printf("!%s: new test pos @ (%g,%g,%g,%g)\n", me,
+         newpnt->pos[0], newpnt->pos[1], newpnt->pos[2], newpnt->pos[3]);
+  */
   /* do some descent, on this point only, which (HACK!) we do by
      changing the per-task process mode . . . */
   task->processMode = pullProcessModeDescent;
@@ -233,6 +258,15 @@
     /* still okay to continue descending */
     newpnt->stepEnergy *= task->pctx->sysParm.opporStepScale;
   }
+  /*
+  printf("!%s: new test pos @ (%g,%g,%g,%g)\n", me,
+         newpnt->pos[0], newpnt->pos[1], newpnt->pos[2], newpnt->pos[3]);
+  {
+    double posdiff[4];
+    ELL_4V_SUB(posdiff, newpnt->pos, point->pos);
+    printf("!%s:      at dist %g\n", me, ELL_4V_LEN(posdiff));
+  }
+  */
   /* now that newbie point is final test location, see if it meets
      the live thresh, if there is one */
   if (task->pctx->ispec[pullInfoLiveThresh]
@@ -313,10 +347,18 @@
 
 int
 _pullPointProcessNixing(pullTask *task, pullBin *bin, pullPoint *point) {
+  static const char me[]="_pullPointProcessNixing";
   double enrWith, enrNeigh, enrWithout, fracNixed;
 
   task->pctx->count[pullCountNixing] += 1;
 
+  if (0 && 289 == task->pctx->iter) {
+    fprintf(stderr, "!%s(%04u): hello lthr %p -> %g %g %g\n", me, point->idtag,
+            (void*)task->pctx->ispec[pullInfoLiveThresh],
+            pullPointScalar(task->pctx, point, pullInfoLiveThresh, NULL, NULL),
+            point->pos[0], point->pos[1]
+            );
+  }
   /* if there's a live thresh, do we meet it? */
   if (task->pctx->ispec[pullInfoLiveThresh]
       && 0 > pullPointScalar(task->pctx, point, pullInfoLiveThresh,
diff --color -ruN teem-1.11.0-src.orig/src/pull/privatePull.h teem-1.11.0-src/src/pull/privatePull.h
--- teem-1.11.0-src.orig/src/pull/privatePull.h	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/privatePull.h	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -25,6 +25,8 @@
 extern "C" {
 #endif
 
+#define _PHN PULL_PHIST_NUM    /* short-cut */
+
 /*
 ** These heuristics/parameters have been adjusted, and don't seem to need
 ** any further tweaking in order to work for all the datasets used so far
@@ -106,7 +108,8 @@
 extern void _pullFlagInit(pullFlag *flag);
 
 /* volumePull.c */
-extern pullVolume *_pullVolumeCopy(const pullVolume *pvol);
+extern pullVolume *_pullVolumeCopy(const pullContext *pctx,
+                                   const pullVolume *pvol);
 extern int _pullVolumeSetup(pullContext *pctx);
 extern int _pullInsideBBox(pullContext *pctx, double pos[4]);
 extern unsigned int _pullVolumeIndex(const pullContext *pctx,
@@ -145,6 +148,7 @@
                                        double egrad[4]);
 
 /* constraints.c */
+extern double _pullSigma(const pullContext *pctx, const double pos[4]);
 extern int _pullConstraintSatisfy(pullTask *task, pullPoint *point,
                                   double travelMax,
                                   int *constrFailP);
@@ -155,10 +159,10 @@
 /* pointPull.c */
 #if PULL_PHIST
 extern void _pullPointHistInit(pullPoint *point);
-extern void _pullPointHistAdd(pullPoint *point, int cond);
+extern void _pullPointHistAdd(pullPoint *point, int cond, double val);
 #else
-#define _pullPointHistInit(p)    /* no-op */
-#define _pullPointHistAdd(p, c)  /* no-op */
+#define _pullPointHistInit(p)       /* no-op */
+#define _pullPointHistAdd(p, c, v)  /* no-op */
 #endif
 extern double _pullStepInterAverage(const pullContext *pctx);
 extern double _pullStepConstrAverage(const pullContext *pctx);
diff --color -ruN teem-1.11.0-src.orig/src/pull/pull.h teem-1.11.0-src/src/pull/pull.h
--- teem-1.11.0-src.orig/src/pull/pull.h	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/pull.h	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -70,7 +70,15 @@
 #define PULL_VOLUME_MAXNUM 4
 #define PULL_POINT_NEIGH_INCR 16
 #define PULL_BIN_MAXNUM 40000000 /* sanity check on max number bins */
-#define PULL_PHIST 0
+#define PULL_PHIST 0             /* can compile history of positions,
+                                    with tuples of length PULL_PHIST_NUM */
+#define PULL_PHIST_NUM 6         /* doubles saved per history point:
+                                    0  1  2  3   4    5
+                                    X  Y  Z Scl cond val
+                                    where Scl is just scale coordinate,
+                                    cond is from pullCond* enum,
+                                    and val is anything the caller wanted to
+                                    remember at that point */
 #define PULL_HINTER 0
 #define PULL_TANCOVAR 1
 
@@ -138,7 +146,7 @@
 ** descriptions of a particle, its neighborhood of particles in the
 ** system, and the current state of system computation.  As of revision
 ** 5080, these may refer to information *computed* from the per-particle
-** info, but which may not itself be saved as a field in pullPoint.
+** info, but which may not itself be saved as a field of the pullPoint.
 **
 ** consider adding: dot between normalized directions of force and movmt
 */
@@ -260,8 +268,9 @@
   pullCondConstraintSatB,     /* 3 */
   pullCondEnergyTry,          /* 4 */
   pullCondConstraintFail,     /* 5 */
-  pullCondEnergyBad,          /* 6 */
-  pullCondNew,                /* 7 */
+  pullCondConstraintSuccess,  /* 6 */
+  pullCondEnergyBad,          /* 7 */
+  pullCondNew,                /* 8 */
   pullCondLast
 };
 
@@ -307,15 +316,17 @@
 ** reasons for pullTraceSet to stop (or go nowhere)
 */
 enum {
-  pullTraceStopUnknown,         /* 0 */
-  pullTraceStopSpeeding,        /* 1 */
-  pullTraceStopConstrFail,      /* 2 */
-  pullTraceStopBounds,          /* 3 */
-  pullTraceStopLength,          /* 4 */
-  pullTraceStopStub,            /* 5 */
+  pullTraceStopUnknown,          /* 0 */
+  pullTraceStopSpeeding,         /* 1 */
+  pullTraceStopConstrFail,       /* 2 */
+  pullTraceStopBounds,           /* 3 */
+  pullTraceStopLength,           /* 4 */
+  pullTraceStopStub,             /* 5 */
+  pullTraceStopVolumeEdge,       /* 6 */
+  pullTraceStopOrientConstrFail, /* 7 */
   pullTraceStopLast
 };
-#define PULL_TRACE_STOP_MAX        5
+#define PULL_TRACE_STOP_MAX         7
 
 /*
 ** Defines how par-particle information can be learned.  This is
@@ -521,6 +532,7 @@
   pullInitMethodGivenPos,      /* 4 */
   pullInitMethodLast
 };
+#define PULL_INIT_METHOD_MAX      4
 
 /*
 ******** pullInitParm
@@ -646,13 +658,6 @@
      along scale that might exist by the separable phi construction. */
   pullSysParmSeparableGammaLearnRescale,
 
-  /* to be more selective for pullInfoSeedThresh and
-     pullInfoLiveThresh at higher scales, set theta > 0, and the
-     effective threshold will be base threshold + theta*scale.
-     HOWEVER, the way this is implemented is a hack:
-     the probed strength value is decremented by theta*scale */
-  pullSysParmTheta,
-
   /* initial (time) step for dynamics */
   pullSysParmStepInitial,
 
@@ -712,7 +717,7 @@
 };
 
 typedef struct {
-  double alpha, beta, gamma, separableGammaLearnRescale, theta, wall,
+  double alpha, beta, gamma, separableGammaLearnRescale, wall,
     radiusSpace, radiusScale, binWidthSpace,
     neighborTrueProb, probeProb,
     stepInitial, opporStepScale, backStepScale, constraintStepMin,
@@ -729,13 +734,16 @@
 */
 enum {
   pullConstraintFailUnknown,        /* 0 */
-  pullConstraintFailProjGradZeroA,  /* 1 */
-  pullConstraintFailProjGradZeroB,  /* 2 */
-  pullConstraintFailIterMaxed,      /* 3 */
-  pullConstraintFailTravel,         /* 4 */
+  pullConstraintFailHessZeroA,      /* 1 */
+  pullConstraintFailHessZeroB,      /* 2 */
+  pullConstraintFailProjGradZeroA,  /* 3 */
+  pullConstraintFailProjGradZeroB,  /* 4 */
+  pullConstraintFailIterMaxed,      /* 5 */
+  pullConstraintFailTravel,         /* 6 */
+  pullConstraintFailProjLenNonExist,/* 7 */
   pullConstraintFailLast
 };
-#define PULL_CONSTRAINT_FAIL_MAX       4
+#define PULL_CONSTRAINT_FAIL_MAX       7
 
 /*
 ******** pullFlag* enum
@@ -773,6 +781,14 @@
      that gage had to invent values for the kernel support */
   pullFlagNixAtVolumeEdgeSpace,
 
+  /* The point setup for pullInitMethodRandom and pullInitMethodHalton
+     doesn't actually respect pullFlagNixAtVolumeEdgeSpace, which means
+     that an axis-aligned bounding box is filled with the points, no
+     matter if they are inside any volume.  If this is non-zero, then
+     then _pullPointSetup requires points be inside i.e. (the
+     PULL_STATUS_EDGE_BIT can't be set in point->status) */
+  pullFlagNixAtVolumeEdgeSpaceInitRorH,
+
   /* if non-zero, during initialization, try constraint satisfaction
      (if there is a constraint) before testing whether the seedThresh
      is met.  Doing the constraint will take longer, but a point is
@@ -789,6 +805,12 @@
      that are normally used (like cwell:0.66,x or qwell:0.64) */
   pullFlagPopCntlEnoughTest,
 
+  /* if this is true, then the convergence test ignores whether or
+     not there have been adds or nixes with the last round of pop cntl;
+     otherwise (the default, for backwards compatibility), any adds or
+     nixes would prevent convergence */
+  pullFlagConvergenceIgnoresPopCntl,
+
   /* no binning: all particles can potentially interact (for debugging) */
   pullFlagBinSingle,
 
@@ -802,6 +824,10 @@
   /* pullStart should skip initializing the points */
   pullFlagStartSkipsPoints,
 
+  /* constrain the third world-space coordinate ("z") to be zero, at all
+     times, so that pull can be used to process 2D images */
+  pullFlagZeroZ,
+
   pullFlagLast
 };
 
@@ -812,13 +838,16 @@
     restrictiveAddToBins,
     energyFromStrength,
     nixAtVolumeEdgeSpace,
+    nixAtVolumeEdgeSpaceInitRorH,
     constraintBeforeSeedThresh,
     popCntlEnoughTest,
+    convergenceIgnoresPopCntl,
     noAdd,
     binSingle,
     allowCodimension3Constraints,
     scaleIsTau,
-    startSkipsPoints;
+    startSkipsPoints,
+    zeroZ;
 } pullFlag;
 
 /*
@@ -956,7 +985,8 @@
     stuckNum,                      /* # stuck particles in last iter */
     pointNum,                      /* total # particles */
     CCNum,                         /* # connected components */
-    iter,                          /* how many iterations were needed */
+    iter,                          /* how many iterations were needed
+                                      (this is updated per iteration) */
   /* HEY: this should really be per-task, to be thread-safe!! */
     count[PULL_COUNT_MAX+1];       /* all possible kinds of counts */
 } pullContext;
@@ -967,13 +997,25 @@
 typedef struct {
   double seedPos[4];    /* where was the seed point */
   /* ------- output ------- */
-  Nrrd *nvert,          /* locations of tract vertices */
-    *nstrn,             /* if non-NULL, 1-D array of strengths */
-    *nvelo;             /* 1-D list of velocities */
+  Nrrd *nvert,          /* (x,y,z,s) locations of tract vertices */
+    *nstrn,             /* if nstrn->data non-NULL:
+                           1-D array of strengths */
+    *nstab,             /* 2-D (2-by-N) array of
+                           (spatial,orientation) stabilities;
+                           allocated as 2-by-N even for point features */
+    *norin;             /* if norin->data non-NULL:
+                           list of (x,y,z) orientation 3-vectors:
+                           tangents of 1-D features (regardless of
+                           flag.zeroZ), or normals of 2-D features */
   unsigned int seedIdx; /* which index in nvert is for seedpoint */
-  int whyStop[2],       /* why backward/forward (0/1) tracing stopped
+  int fdim,             /* dimension of the feature we're tracking:
+                           0 (points), 1 (curves), or 2 (surfaces) */
+    whyStop[2],         /* why backward/forward (0/1) tracing stopped
                            (from pullTraceStop* enum) */
-    whyNowhere;         /* why trace never started (from pullTraceStop*) */
+    whyStopCFail[2],    /* in case tracing stopped by pullTraceStopConstrFail,
+                           why (from pullConstraintFail* enum) */
+    whyNowhere,         /* why trace never started (from pullTraceStop*) */
+    whyNowhereCFail;    /* same */
 } pullTrace;
 
 /*
@@ -1094,6 +1136,7 @@
 PULL_EXPORT const airEnum *const pullProp;
 PULL_EXPORT const airEnum *const pullProcessMode;
 PULL_EXPORT const airEnum *const pullTraceStop;
+PULL_EXPORT const airEnum *const pullInitMethod;
 PULL_EXPORT const airEnum *const pullCount;
 PULL_EXPORT const airEnum *const pullConstraintFail;
 
@@ -1121,7 +1164,10 @@
                                     pullContext *pctx,
                                     unsigned int idtagMin,
                                     unsigned int idtagMax);
-PULL_EXPORT int pullPositionHistoryGet(limnPolyData *pld, pullContext *pctx);
+PULL_EXPORT int pullPositionHistoryPolydataGet(limnPolyData *pld,
+                                               pullContext *pctx);
+PULL_EXPORT int pullPositionHistoryNrrdGet(Nrrd *nhist, pullContext *pctx,
+                                           pullPoint *point);
 PULL_EXPORT int pullPropGet(Nrrd *nprop, int prop, pullContext *pctx);
 
 /* pointPull.c */
@@ -1162,10 +1208,19 @@
 PULL_EXPORT pullTrace *pullTraceNew(void);
 PULL_EXPORT pullTrace *pullTraceNix(pullTrace *pts);
 PULL_EXPORT size_t pullTraceMultiSizeof(const pullTraceMulti *mtrc);
+PULL_EXPORT void pullTraceStability(double *spcStab,
+                                    double *oriStab,
+                                    const double pos0[4],
+                                    const double pos1[4],
+                                    const double ori0[3],
+                                    const double ori1[3],
+                                    double sigma0,
+                                    const pullContext *pctx);
 PULL_EXPORT int pullTraceSet(pullContext *pctx, pullTrace *trc,
                              int recordStrength,
                              double scaleDelta, double halfScaleWin,
-                             double velocityMax, unsigned int arrIncr,
+                             double orientTestLen,
+                             unsigned int arrIncr,
                              const double seedPos[4]);
 PULL_EXPORT pullTraceMulti *pullTraceMultiNew(void);
 PULL_EXPORT pullTraceMulti *pullTraceMultiNix(pullTraceMulti *mtrc);
@@ -1176,9 +1231,12 @@
                                                 double winLenFrac);
 PULL_EXPORT int pullTraceMultiPlotAdd(Nrrd *nplot,
                                       const pullTraceMulti *mtrc,
-                                      const Nrrd *nfilt,
+                                      const Nrrd *nfilt, int strengthUse,
+                                      int smooth, int flatWght,
                                       unsigned int trcIdxMin,
-                                      unsigned int trcNum);
+                                      unsigned int trcNum,
+                                      Nrrd *nmaskedpos,
+                                      const Nrrd *nmask);
 PULL_EXPORT int pullTraceMultiWrite(FILE *file, const pullTraceMulti *mtrc);
 PULL_EXPORT int pullTraceMultiRead(pullTraceMulti *mtrc, FILE *file);
 
diff --color -ruN teem-1.11.0-src.orig/src/pull/sources.cmake teem-1.11.0-src/src/pull/sources.cmake
--- teem-1.11.0-src.orig/src/pull/sources.cmake	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,25 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(PULL_SOURCES
-  actionPull.c
-  binningPull.c
-  constraints.c
-  contextPull.c
-  parmPull.c
-  initPull.c
-  corePull.c
-  defaultsPull.c
-  energy.c
-  infoPull.c
-  pointPull.c
-  privatePull.h
-  pull.h
-  taskPull.c
-  volumePull.c
-  popcntl.c
-  ccPull.c
-  enumsPull.c
-  trace.c
-  )
-
-ADD_TEEM_LIBRARY(pull ${PULL_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/pull/taskPull.c teem-1.11.0-src/src/pull/taskPull.c
--- teem-1.11.0-src.orig/src/pull/taskPull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/taskPull.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -39,7 +39,7 @@
 
   task->pctx = pctx;
   for (ii=0; ii<pctx->volNum; ii++) {
-    if (!(task->vol[ii] = _pullVolumeCopy(pctx->vol[ii]))) {
+    if (!(task->vol[ii] = _pullVolumeCopy(pctx, pctx->vol[ii]))) {
       biffAddf(PULL, "%s: trouble copying vol %u/%u", me, ii, pctx->volNum);
       return NULL;
     }
diff --color -ruN teem-1.11.0-src.orig/src/pull/test/circ.c teem-1.11.0-src/src/pull/test/circ.c
--- teem-1.11.0-src.orig/src/pull/test/circ.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/pull/test/circ.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -26,7 +26,7 @@
 
 #define TOP_MARGIN 3
 
-char *info = ("Sees if \"adhoc\" is inefficient.");
+const char *info = ("Sees if \"adhoc\" is inefficient.");
 
 enum {
   stepStyleUnknown,        /* 0 */
diff --color -ruN teem-1.11.0-src.orig/src/pull/test/eparse.c teem-1.11.0-src/src/pull/test/eparse.c
--- teem-1.11.0-src.orig/src/pull/test/eparse.c	2012-12-20 22:10:15.000000000 +0800
+++ teem-1.11.0-src/src/pull/test/eparse.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -24,7 +24,7 @@
 
 #include "../pull.h"
 
-char *info = ("Tests parsing of energy, and its methods.");
+const char *info = ("Tests parsing of energy, and its methods.");
 
 int
 main(int argc, const char *argv[]) {
diff --color -ruN teem-1.11.0-src.orig/src/pull/TODO.txt teem-1.11.0-src/src/pull/TODO.txt
--- teem-1.11.0-src.orig/src/pull/TODO.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/pull/TODO.txt	2021-02-18 15:42:33.000000000 +0800
@@ -0,0 +1,69 @@
+
+==6235== Memcheck, a memory error detector
+==6235== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.
+==6235== Using Valgrind-3.8.0 and LibVEX; rerun with -h for copyright info
+==6235== Command: puller -v 0 -vol img.nrrd:scalar:V -info h-c:V:val:0:-1 hgvec:V:gvec hhess:V:hess tan1:V:hevec1 spthr:M:val:0.05:1 lthr:M:val:0.05:1 hgvec:V:gvec hhess:V:hess strn:VSN:hf:0:1 sthr:VSN:hf:0.01:1 lthr2:VSN:hf:0.01:1 h-c:V:val:0:-1 tan1:V:hevec2 -zz true -nave false -alpha 1 -efs false -ac3c true -irad 0.05 -int justr -enr bwell:0.66,-0.02 -pcp 5 -edpcmin 0.1 -eip 0.01 -eiphl 20 -k00 c4h -k11 c4hd -k22 c4hdd -rng 4000 -np 30 -ess 0.3 -oss 1.2 -maxi 300 -edmin 0.00001 -o xy.nrrd
+==6235== 
+puller: trouble with volumes or infos:
+[meet] meetPullInfoAddMulti: can't find volName "M" for minf[4]
+[meet] [pull] pullVolumeLookup: trouble looking up "M"
+[meet] [pull] _pullVolumeIndex: no volume has name "M"
+==6235== Invalid read of size 8
+==6235==    at 0x100008ABE: pullInfoSpecNix (infoPull.c:128)
+==6235==    by 0x10000DA91: pullContextNix (contextPull.c:125)
+==6235==    by 0x1000F8FE5: airMopError (mop.c:278)
+==6235==    by 0x100002C5A: main (puller.c:1145)
+==6235==  Address 0x1004fc488 is 8 bytes inside a block of size 48 free'd
+==6235==    at 0xDCB8: free (vg_replace_malloc.c:450)
+==6235==    by 0x1000F4E1D: airFree (miscAir.c:88)
+==6235==    by 0x100008ACE: pullInfoSpecNix (infoPull.c:129)
+==6235==    by 0x1000F8FE5: airMopError (mop.c:278)
+==6235==    by 0x1000059D0: meetPullInfoAddMulti (meetPull.c:738)
+==6235==    by 0x100002D07: main (puller.c:1169)
+==6235== 
+==6235== Invalid free() / delete / delete[] / realloc()
+==6235==    at 0xDCB8: free (vg_replace_malloc.c:450)
+==6235==    by 0x1000F4E1D: airFree (miscAir.c:88)
+==6235==    by 0x100008AC6: pullInfoSpecNix (infoPull.c:128)
+==6235==    by 0x10000DA91: pullContextNix (contextPull.c:125)
+==6235==    by 0x1000F8FE5: airMopError (mop.c:278)
+==6235==    by 0x100002C5A: main (puller.c:1145)
+==6235==  Address 0x1004fc620 is 0 bytes inside a block of size 2 free'd
+==6235==    at 0xDCB8: free (vg_replace_malloc.c:450)
+==6235==    by 0x1000F4E1D: airFree (miscAir.c:88)
+==6235==    by 0x100008AC6: pullInfoSpecNix (infoPull.c:128)
+==6235==    by 0x1000F8FE5: airMopError (mop.c:278)
+==6235==    by 0x1000059D0: meetPullInfoAddMulti (meetPull.c:738)
+==6235==    by 0x100002D07: main (puller.c:1169)
+==6235== 
+==6235== Invalid free() / delete / delete[] / realloc()
+==6235==    at 0xDCB8: free (vg_replace_malloc.c:450)
+==6235==    by 0x1000F4E1D: airFree (miscAir.c:88)
+==6235==    by 0x100008ACE: pullInfoSpecNix (infoPull.c:129)
+==6235==    by 0x10000DA91: pullContextNix (contextPull.c:125)
+==6235==    by 0x1000F8FE5: airMopError (mop.c:278)
+==6235==    by 0x100002C5A: main (puller.c:1145)
+==6235==  Address 0x1004fc480 is 0 bytes inside a block of size 48 free'd
+==6235==    at 0xDCB8: free (vg_replace_malloc.c:450)
+==6235==    by 0x1000F4E1D: airFree (miscAir.c:88)
+==6235==    by 0x100008ACE: pullInfoSpecNix (infoPull.c:129)
+==6235==    by 0x1000F8FE5: airMopError (mop.c:278)
+==6235==    by 0x1000059D0: meetPullInfoAddMulti (meetPull.c:738)
+==6235==    by 0x100002D07: main (puller.c:1169)
+==6235== 
+==6235== 
+==6235== HEAP SUMMARY:
+==6235==     in use at exit: 3,910 bytes in 51 blocks
+==6235==   total heap usage: 1,143 allocs, 1,100 frees, 3,153,805 bytes allocated
+==6235== 
+==6235== LEAK SUMMARY:
+==6235==    definitely lost: 0 bytes in 0 blocks
+==6235==    indirectly lost: 0 bytes in 0 blocks
+==6235==      possibly lost: 0 bytes in 0 blocks
+==6235==    still reachable: 3,910 bytes in 51 blocks
+==6235==         suppressed: 0 bytes in 0 blocks
+==6235== Rerun with --leak-check=full to see details of leaked memory
+==6235== 
+==6235== For counts of detected and suppressed errors, rerun with: -v
+==6235== ERROR SUMMARY: 12 errors from 3 contexts (suppressed: 0 from 0)
+[soba:sss-vis13/figs/ticks] gk% 
diff --color -ruN teem-1.11.0-src.orig/src/pull/trace.c teem-1.11.0-src/src/pull/trace.c
--- teem-1.11.0-src.orig/src/pull/trace.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/trace.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -35,10 +35,13 @@
     ret->seedPos[2] = ret->seedPos[3] = AIR_NAN;
     ret->nvert = nrrdNew();
     ret->nstrn = nrrdNew();
-    ret->nvelo = nrrdNew();
+    ret->nstab = nrrdNew();
+    ret->norin = nrrdNew();
     ret->seedIdx = 0;
     ret->whyStop[0] = ret->whyStop[1] = pullTraceStopUnknown;
+    ret->whyStopCFail[0] = ret->whyStopCFail[1] = pullConstraintFailUnknown;
     ret->whyNowhere = pullTraceStopUnknown;
+    ret->whyNowhereCFail = pullConstraintFailUnknown;
   }
   return ret;
 }
@@ -49,27 +52,208 @@
   if (pts) {
     nrrdNuke(pts->nvert);
     nrrdNuke(pts->nstrn);
-    nrrdNuke(pts->nvelo);
+    nrrdNuke(pts->nstab);
+    nrrdNuke(pts->norin);
     free(pts);
   }
   return NULL;
 }
 
+void
+pullTraceStability(double *spcStab,
+                   double *oriStab,
+                   const double pos0[4],
+                   const double pos1[4],
+                   const double ori0[3],
+                   const double ori1[3],
+                   double sigma0,
+                   const pullContext *pctx) {
+  double sc, stb, dx, ds, diff[4];
+
+  ELL_4V_SUB(diff, pos1, pos0);
+  dx = ELL_3V_LEN(diff)/(pctx->voxelSizeSpace);
+  sc = (pos0[3] + pos1[3])/2;
+  if (pctx->flag.scaleIsTau) {
+    sc = gageSigOfTau(sc);
+  }
+  sc += sigma0;
+  dx /= sc;
+  ds = diff[3];
+  stb = atan2(ds, dx)/(AIR_PI/2); /* [-1,1]: 0 means least stable */
+  stb = AIR_ABS(stb);      /* [0,1]: 0 means least stable */
+  *spcStab = AIR_CLAMP(0, stb, 1);
+  /*
+  static double maxvelo = 0;
+  if (1 && vv > maxvelo) {
+    char me[]="pullTraceStability";
+    printf("\n%s: [%g,%g,%g,%g] - [%g,%g,%g,%g] = [%g,%g,%g,%g]\n", me,
+           pos0[0], pos0[1], pos0[2], pos0[3],
+           pos1[0], pos1[1], pos1[2], pos1[3],
+           diff[0], diff[1], diff[2], diff[3]);
+    printf("%s: dx = %g -> %g; ds = %g\n", me, dx0, dx, ds);
+    printf("%s: vv = atan2(%g,%g)/pi = %g -> %g > %g\n", me, ds, dx, vv0, vv, maxvelo);
+    maxvelo = vv;
+  }
+  */
+  if (ori0 && ori1) {
+    /* dori = delta in orientation */
+    double dori = ell_3v_angle_d(ori0, ori1);
+    /* dori in [0,pi]; 0 and pi mean no change */
+    if (dori > AIR_PI/2) {
+      dori -= AIR_PI;
+    }
+    /* dori in [-pi/2,pi/2]; 0 means no change; +-pi/2 means most change */
+    dori = AIR_ABS(dori);
+    /* dori in [0,pi/2]; 0 means no change; pi/2 means most change */
+    *oriStab = atan2(ds, dori)/(AIR_PI/2);
+    /* *oriStab in [0,1]; 0 means stable, 1 means not stable */
+  } else {
+    *oriStab = 0;
+  }
+  return;
+}
+
+int
+_pullConstrTanSlap(pullContext *pctx, pullPoint *point,
+                   double tlen,
+                   /* input+output */ double toff[3],
+                   /* output */ int *constrFailP) {
+  static const char me[]="_pullConstrTanSlap";
+  double pos0[4], tt;
+
+  if (!(pctx && point && toff && constrFailP)) {
+    biffAddf(PULL, "%s: got NULL pointer", me);
+    return 1;
+  }
+  if (pctx->flag.zeroZ) {
+    toff[2] = 0;
+  }
+  ELL_3V_NORM(toff, toff, tt);
+  if (!(tlen > 0 && tt > 0)) {
+    biffAddf(PULL, "%s: tlen %g or |toff| %g not positive", me, tlen, tt);
+    return 1;
+  }
+  ELL_4V_COPY(pos0, point->pos); /* pos0[3] should stay put; will test at end */
+
+  ELL_3V_SCALE_ADD2(point->pos, 1, pos0, tlen, toff);
+  if (_pullConstraintSatisfy(pctx->task[0], point, 0 /* travmax */, constrFailP)) {
+    biffAddf(PULL, "%s: trouble", me);
+    ELL_4V_COPY(point->pos, pos0); return 1;
+  }
+  /* save offset to new position */
+  ELL_3V_SUB(toff, point->pos, pos0);
+
+  if (pos0[3] != point->pos[3]) {
+    biffAddf(PULL, "%s: point->pos[3] %g was changed (from %g)",
+             me, point->pos[3], pos0[3]);
+    ELL_4V_COPY(point->pos, pos0); return 1;
+  }
+  ELL_4V_COPY(point->pos, pos0);
+  return 0;
+}
 
 int
+_pullConstrOrientFind(pullContext *pctx, pullPoint *point,
+                      int normalfind, /* find normal two 2D surface,
+                                         else find tangent to 1D curve */
+                      double tlen,
+                      const double tdir0[3], /* if non-NULL, try using this direction */
+                      /* output */
+                      double dir[3],
+                      int *constrFailP) {
+  static const char me[]="_pullConstrOrientFind";
+  double tt;
+
+#define SLAP(LEN, DIR)                                                  \
+  /* fprintf(stderr, "!%s: SLAP %g %g %g -->", me, (DIR)[0], (DIR)[1], (DIR)[2]); */  \
+  if (_pullConstrTanSlap(pctx, point, (LEN), (DIR), constrFailP)) {     \
+    biffAddf(PULL, "%s: looking for tangent, starting with (%g,%g,%g)", \
+             me, (DIR)[0], (DIR)[1], (DIR)[2]);                         \
+    return 1;                                                           \
+  }                                                                     \
+  if (*constrFailP) {                                                   \
+    /* unsuccessful in finding tangent, but not a biff error */         \
+    return 0;                                                           \
+  }                                                                     \
+  /* fprintf(stderr, " %g %g %g\n", (DIR)[0], (DIR)[1], (DIR)[2]); */
+
+  if (!(pctx && point && constrFailP)) {
+    biffAddf(PULL, "%s: got NULL pointer", me);
+    return 1;
+  }
+  *constrFailP = pullConstraintFailUnknown;
+  if (normalfind) {
+    double tan0[3], tan1[3];
+    /* looking for a surface normal */
+    if (tdir0) { /* have something to start with */
+      ell_3v_perp_d(tan0, tdir0);
+      ELL_3V_CROSS(tan1, tan0, tdir0);
+      SLAP(tlen, tan1);
+      SLAP(tlen, tan0);
+      ELL_3V_CROSS(dir, tan1, tan0);
+    } else { /* have to start from scratch */
+      double tns[9] = {1,0,0,  0,1,0,  0,0,1};
+      SLAP(tlen, tns+0);
+      SLAP(tlen, tns+3);
+      SLAP(tlen, tns+6);
+      ell_3m_1d_nullspace_d(dir, tns);
+    }
+  } else {
+    /* looking for a curve tangent */
+    if (tdir0) { /* have something to start with */
+      ELL_3V_COPY(dir, tdir0);
+      SLAP(tlen, dir);
+      /* SLAP(tlen, dir);   (didn't have much effect, in one test) */
+    } else { /* have to start from scratch */
+      double tX[3] = {1,0,0}, tY[3] = {0,1,0}, tZ[3] = {0,0,1};
+      SLAP(tlen, tX);
+      SLAP(tlen, tY);
+      if (ELL_3V_DOT(tX, tY) < 0) { ELL_3V_SCALE(tY, -1, tY); }
+      if (pctx->flag.zeroZ) {
+        ELL_3V_SET(tZ, 0, 0, 0);
+      } else {
+        SLAP(tlen, tZ);
+        if (ELL_3V_DOT(tX, tZ) < 0) { ELL_3V_SCALE(tZ, -1, tZ); }
+        if (ELL_3V_DOT(tY, tZ) < 0) { ELL_3V_SCALE(tY, -1, tZ); }
+      }
+      ELL_3V_ADD3(dir, tX, tY, tZ);
+    }
+  }
+  ELL_3V_NORM(dir, dir, tt);
+  if (!(tt > 0)) {
+    biffAddf(PULL, "%s: computed direction is zero (%g)?", me, tt);
+    return 1;
+  }
+  return 0;
+}
+
+/*
+******** pullTraceSet
+**
+** computes a single trace, according to the given parameters,
+** and store it in the pullTrace
+int recordStrength: should strength be recorded along trace
+double scaleDelta: discrete step along scale
+double halfScaleWin: how far, along scale, trace should go in each direction
+unsigned int arrIncr: increment for storing position (maybe strength)
+const double _seedPos[4]: starting position
+*/
+int
 pullTraceSet(pullContext *pctx, pullTrace *pts,
              int recordStrength,
              double scaleDelta, double halfScaleWin,
-             double velocityMax, unsigned int arrIncr,
-             const double seedPos[4]) {
+             double orientTestLen,
+             unsigned int arrIncr,
+             const double _seedPos[4]) {
   static const char me[]="pullTraceSet";
   pullPoint *point;
-  airArray *mop, *trceArr[2], *hstrnArr[2];
-  double *trce[2], ssrange[2], *vert, *hstrn[2], *strn, *velo, travmax;
+  airArray *mop, *trceArr[2], *hstrnArr[2], *horinArr[2];
+  double *trce[2], ssrange[2], *vert, *hstrn[2], *horin[2], *strn, *orin, *stab,
+    seedPos[4], polen, porin[3];
   int constrFail;
   unsigned int dirIdx, lentmp, tidx, oidx, vertNum;
 
-  if (!( pctx && pts && seedPos )) {
+  if (!( pctx && pts && _seedPos )) {
     biffAddf(PULL, "%s: got NULL pointer", me);
     return 1;
   }
@@ -86,6 +270,29 @@
     biffAddf(PULL, "%s: given context doesn't have constraint set", me);
     return 1;
   }
+  pts->fdim = _pullConstraintDim(pctx);
+  if (0 > pts->fdim) {
+    biffAddf(PULL, "%s: couldn't learn dimension of feature", me);
+    return 1;
+  }
+  if (pts->fdim == 2 && pctx->flag.zeroZ) {
+    biffAddf(PULL, "%s: can't have feature dim 2 with zeroZ", me);
+    return 1;
+  }
+  if (!( AIR_EXISTS(orientTestLen) && orientTestLen >= 0 )) {
+    biffAddf(PULL, "%s: need non-negative orientTestLen (not %g)\n",
+             me, orientTestLen);
+    return 1;
+  }
+  if (pts->fdim && !orientTestLen) {
+    /* not really an error */
+    /*
+    fprintf(stderr, "\n\n%s: WARNING: have a %d-D feature, but not "
+            "measuring its orientation\n\n\n", me, pts->fdim);
+    */
+  }
+  /* The test for "should I measure orientation"
+     is "if (pts->fdim && orientTestLen)" */
   if (recordStrength && !pctx->ispec[pullInfoStrength]) {
     biffAddf(PULL, "%s: want to record strength but %s not set in context",
              me, airEnumStr(pullInfo, pullInfoStrength));
@@ -98,7 +305,15 @@
 
   /* re-initialize termination descriptions (in case of trace re-use) */
   pts->whyStop[0] = pts->whyStop[1] = pullTraceStopUnknown;
+  pts->whyStopCFail[0] = pts->whyStopCFail[1] = pullConstraintFailUnknown;
   pts->whyNowhere = pullTraceStopUnknown;
+  pts->whyNowhereCFail = pullConstraintFailUnknown;
+
+  /* enforce zeroZ */
+  ELL_4V_COPY(seedPos, _seedPos);
+  if (pctx->flag.zeroZ) {
+    seedPos[2] = 0.0;
+  }
 
   /* save seedPos in any case */
   ELL_4V_COPY(pts->seedPos, seedPos);
@@ -108,32 +323,86 @@
   airMopAdd(mop, point, (airMopper)pullPointNix, airMopAlways);
 
   ELL_4V_COPY(point->pos, seedPos);
-  if (_pullConstraintSatisfy(pctx->task[0], point, 2, &constrFail)) {
+  /*
+  if (pctx->verbose) {
+    fprintf(stderr, "%s: trying at seed=(%g,%g,%g,%g)\n", me,
+            seedPos[0], seedPos[1], seedPos[2], seedPos[3]);
+  }
+  */
+  /* The termination of the trace due to low stablity is handled here
+     (or could be), not by _pullConstraintSatisfy, so we set 0 for the
+     travelMax arg of _pullConstraintSatisfy (no travel limit) */
+  if (_pullConstraintSatisfy(pctx->task[0], point,
+                             0 /* travmax */, &constrFail)) {
     biffAddf(PULL, "%s: constraint sat on seed point", me);
     airMopError(mop);
     return 1;
   }
   /*
-  fprintf(stderr, "!%s: seed=(%g,%g,%g,%g) -> %s (%g,%g,%g,%g)\n", me,
-          seedPos[0], seedPos[1], seedPos[2], seedPos[3],
-          constrFail ? "!NO!" : "(yes)",
-          point->pos[0] - seedPos[0], point->pos[1] - seedPos[1],
-          point->pos[2] - seedPos[2], point->pos[3] - seedPos[3]);
+  if (pctx->verbose) {
+    fprintf(stderr, "%s: seed=(%g,%g,%g,%g) -> %s (%g,%g,%g,%g)\n", me,
+            seedPos[0], seedPos[1], seedPos[2], seedPos[3],
+            constrFail ? "!NO!" : "(yes)",
+            point->pos[0] - seedPos[0], point->pos[1] - seedPos[1],
+            point->pos[2] - seedPos[2], point->pos[3] - seedPos[3]);
+  }
   */
   if (constrFail) {
     pts->whyNowhere = pullTraceStopConstrFail;
     airMopOkay(mop);
-    pctx->idtagNext -= 1; /* HACK */
+    /* pctx->idtagNext -= 1; / * HACK * / */
     return 0;
   }
+  if (point->status & PULL_STATUS_EDGE_BIT) {
+    pts->whyNowhere = pullTraceStopVolumeEdge;
+    airMopOkay(mop);
+    /* pctx->idtagNext -= 1; / * HACK * / */
+    return 0;
+  }
+  if (pctx->flag.zeroZ && point->pos[2] != 0) {
+    biffAddf(PULL, "%s: zeroZ violated (a)", me);
+    airMopError(mop);
+    return 1;
+  }
 
   /* else constraint sat worked at seed point; we have work to do */
-  /* travmax is passed to _pullConstraintSatisfy; the intention is
-     that constraint satisfaction should not fail because the point
-     traveled too far (so make travmax large); the limiting of the
-     trace based on velocity is handled here, not by
-     _pullConstraintSatisfy */
-  travmax = 10.0*scaleDelta*velocityMax/pctx->voxelSizeSpace;
+  if (pts->fdim && orientTestLen) {
+    double pos0[4], dp[4];
+    int cf;
+    /* learn orientation at seed point */
+    polen = (orientTestLen
+             *pctx->voxelSizeSpace
+             /* if used, the effect of this this last (unprincipled) factor
+                is gradually increase the test distance with scale
+                *(1 + gageTauOfSig(_pullSigma(pctx, point->pos))) */ );
+    ELL_4V_COPY(pos0, point->pos);
+
+    if (_pullConstrOrientFind(pctx, point, pts->fdim == 2,
+                              polen, NULL /* no initial guess */, porin, &cf)) {
+      biffAddf(PULL, "%s: trying to find orientation at seed", me);
+      airMopError(mop);
+      return 1;
+    }
+    ELL_4V_SUB(dp, pos0, point->pos);
+    /*
+    fprintf(stderr, "!%s: cf = %d (%s)\n", me, cf, airEnumStr(pullConstraintFail, cf));
+    fprintf(stderr, "!%s: (fdim=%u) pos=[%g,%g,%g,%g] polen=%g porin=[%g,%g,%g] |%g|\n",
+            me, pts->fdim,
+            point->pos[0], point->pos[1], point->pos[2], point->pos[3],
+            polen, porin[0], porin[1], porin[2], ELL_4V_LEN(dp));
+    */
+    if (cf) {
+      pts->whyNowhere = pullTraceStopConstrFail;
+      pts->whyNowhereCFail = cf;
+      airMopOkay(mop);
+      /* pctx->idtagNext -= 1; / * HACK * / */
+      return 0;
+    }
+  } else {
+    /* either feature is 0D points, or don't care about orientation */
+    polen = AIR_NAN;
+    ELL_3V_SET(porin, AIR_NAN, AIR_NAN, AIR_NAN);
+  }
 
   for (dirIdx=0; dirIdx<2; dirIdx++) {
     trceArr[dirIdx] = airArrayNew((void**)(trce + dirIdx), NULL,
@@ -147,6 +416,14 @@
       hstrnArr[dirIdx] = NULL;
       hstrn[dirIdx] = NULL;
     }
+    if (pts->fdim && orientTestLen) {
+      horinArr[dirIdx] = airArrayNew((void**)(horin + dirIdx), NULL,
+                                     3*sizeof(double), arrIncr);
+      airMopAdd(mop, horinArr[dirIdx], (airMopper)airArrayNuke, airMopAlways);
+    } else {
+      horinArr[dirIdx] = NULL;
+      horin[dirIdx] = NULL;
+    }
   }
   for (dirIdx=0; dirIdx<2; dirIdx++) {
     unsigned int step;
@@ -157,17 +434,25 @@
       if (!step) {
         /* first step in both directions requires special tricks */
         if (0 == dirIdx) {
+          /* this is done once, at the very start */
           /* save constraint sat of seed point */
           tidx = airArrayLenIncr(trceArr[0], 1);
           ELL_4V_COPY(trce[0] + 4*tidx, point->pos);
           if (recordStrength) {
-            tidx = airArrayLenIncr(hstrnArr[0], 1);
+            airArrayLenIncr(hstrnArr[0], 1);
             hstrn[0][0] = pullPointScalar(pctx, point, pullInfoStrength,
                                           NULL, NULL);
           }
+          if (pts->fdim && orientTestLen) {
+            airArrayLenIncr(horinArr[0], 1);
+            ELL_3V_COPY(horin[0] + 3*0, porin);
+          }
         } else {
           /* re-set position from constraint sat of seed pos */
           ELL_4V_COPY(point->pos, trce[0] + 4*0);
+          if (pts->fdim && orientTestLen) {
+            ELL_3V_COPY(porin, horin[0] + 3*0);
+          }
         }
       }
       /* nudge position along scale */
@@ -190,45 +475,47 @@
               point->pos[2], point->pos[3]);
       */
       if (_pullConstraintSatisfy(pctx->task[0], point,
-                                 travmax, &constrFail)) {
+                                 0 /* travmax */, &constrFail)) {
         biffAddf(PULL, "%s: dir %u, step %u", me, dirIdx, step);
         airMopError(mop);
         return 1;
       }
       /*
-      fprintf(stderr, "%s(%u): ... %s(%d); pos = %g %g %g %g\n", me,
-              point->idtag,
-              constrFail ? "FAIL" : "(ok)",
-              constrFail, point->pos[0], point->pos[1],
-              point->pos[2], point->pos[3]);
+      if (pctx->verbose) {
+        fprintf(stderr, "%s(%u): ... %s(%d); pos = %g %g %g %g\n", me,
+                point->idtag,
+                constrFail ? "FAIL" : "(ok)",
+                constrFail, point->pos[0], point->pos[1],
+                point->pos[2], point->pos[3]);
+      }
       */
+      if (point->status & PULL_STATUS_EDGE_BIT) {
+        pts->whyStop[dirIdx] = pullTraceStopVolumeEdge;
+        break;
+      }
       if (constrFail) {
         /* constraint sat failed; no error, we're just done
            with stepping for this direction */
         pts->whyStop[dirIdx] = pullTraceStopConstrFail;
+        pts->whyStopCFail[dirIdx] = constrFail;
         break;
       }
+      if (pctx->flag.zeroZ && point->pos[2] != 0) {
+        biffAddf(PULL, "%s: zeroZ violated (b)", me);
+        airMopError(mop);
+        return 1;
+      }
+      if (pts->fdim && orientTestLen) {
+        if (_pullConstrOrientFind(pctx, point, pts->fdim == 2,
+                                  polen, porin, porin, &constrFail)) {
+          biffAddf(PULL, "%s: at dir %u, step %u", me, dirIdx, step);
+          airMopError(mop);
+          return 1;
+        }
+      }
       if (trceArr[dirIdx]->len >= 2) {
         /* see if we're moving too fast, by comparing with previous point */
-        double pos0[3], pos1[3], diff[3], vv;
-        unsigned int ii;
-
-        ii = trceArr[dirIdx]->len-2;
-        ELL_3V_COPY(pos0, trce[dirIdx] + 4*(ii+0));
-        ELL_3V_COPY(pos1, trce[dirIdx] + 4*(ii+1));
-        ELL_3V_SUB(diff, pos1, pos0);
-        vv = ELL_3V_LEN(diff)/scaleDelta;
-        /*
-        fprintf(stderr, "%s(%u): velo %g %s velocityMax %g => %s\n", me,
-                point->idtag, vv,
-                vv > velocityMax ? ">" : "<=",
-                velocityMax,
-                vv > velocityMax ? "FAIL" : "(ok)");
-        */
-        if (vv > velocityMax) {
-          pts->whyStop[dirIdx] = pullTraceStopSpeeding;
-          break;
-        }
+        /* actually, screw that */
       }
       /* else save new point on trace */
       tidx = airArrayLenIncr(trceArr[dirIdx], 1);
@@ -238,6 +525,10 @@
         hstrn[dirIdx][tidx] = pullPointScalar(pctx, point, pullInfoStrength,
                                               NULL, NULL);
       }
+      if (pts->fdim && orientTestLen) {
+        tidx = airArrayLenIncr(horinArr[dirIdx], 1);
+        ELL_3V_COPY(horin[dirIdx] + 3*tidx, porin);
+      }
       step++;
     }
   }
@@ -247,22 +538,34 @@
   if (0 == vertNum || 1 == vertNum || 2 == vertNum) {
     pts->whyNowhere = pullTraceStopStub;
     airMopOkay(mop);
-    pctx->idtagNext -= 1; /* HACK */
+    /* pctx->idtagNext -= 1; / * HACK * / */
     return 0;
   }
 
   if (nrrdMaybeAlloc_va(pts->nvert, nrrdTypeDouble, 2,
                         AIR_CAST(size_t, 4),
                         AIR_CAST(size_t, vertNum))
-      || nrrdMaybeAlloc_va(pts->nvelo, nrrdTypeDouble, 1,
+      || nrrdMaybeAlloc_va(pts->nstab, nrrdTypeDouble, 2,
+                           AIR_CAST(size_t, 2),
                            AIR_CAST(size_t, vertNum))) {
     biffMovef(PULL, NRRD, "%s: allocating output", me);
     airMopError(mop);
     return 1;
   }
   if (recordStrength) {
+    /* doing slicing is a simple form of allocation */
     if (nrrdSlice(pts->nstrn, pts->nvert, 0 /* axis */, 0 /* pos */)) {
-      biffMovef(PULL, NRRD, "%s: allocating output", me);
+      biffMovef(PULL, NRRD, "%s: allocating strength output", me);
+      airMopError(mop);
+      return 1;
+    }
+  }
+  if (pts->fdim && orientTestLen) {
+    /* cropping just to allocate */
+    size_t cmin[2] = {0, 0}, cmax[2];
+    ELL_2V_SET(cmax, 2, pts->nvert->axis[1].size-1);
+    if (nrrdCrop(pts->norin, pts->nvert, cmin, cmax)) {
+      biffMovef(PULL, NRRD, "%s: allocating orientation output", me);
       airMopError(mop);
       return 1;
     }
@@ -273,7 +576,12 @@
   } else {
     strn = NULL;
   }
-  velo = AIR_CAST(double *, pts->nvelo->data);
+  if (pts->fdim && orientTestLen) {
+    orin = AIR_CAST(double *, pts->norin->data);
+  } else {
+    orin = NULL;
+  }
+  stab = AIR_CAST(double *, pts->nstab->data);
   lentmp = trceArr[0]->len;
   oidx = 0;
   for (tidx=0; tidx<lentmp; tidx++) {
@@ -281,6 +589,9 @@
     if (strn) {
       strn[oidx] = hstrn[0][lentmp - 1 - tidx];
     }
+    if (orin) {
+      ELL_3V_COPY(orin + 3*oidx, horin[0] + 3*(lentmp - 1 - tidx));
+    }
     oidx++;
   }
   /* the last index written to (before oidx++) was the seed index */
@@ -291,38 +602,46 @@
     if (strn) {
       strn[oidx] = hstrn[1][tidx];
     }
+    if (orin) {
+      ELL_3V_COPY(orin + 3*oidx, horin[1] + 3*tidx);
+    }
     oidx++;
   }
-  lentmp = pts->nvelo->axis[0].size;
+  lentmp = AIR_UINT(pts->nstab->axis[1].size);
   if (1 == lentmp) {
-    velo[0] = 0.0;
+    stab[0 + 2*0] = 0.0;
+    stab[1 + 2*0] = 0.0;
   } else {
     for (tidx=0; tidx<lentmp; tidx++) {
-      double *p0, *p1, *p2, diff[3];
+      double *pA, *pB, *p0, *p1, *p2, *rA, *rB, *r0=NULL, *r1=NULL, *r2=NULL;
+      p0 = vert + 4*(tidx-1);
+      p1 = vert + 4*tidx;
+      p2 = vert + 4*(tidx+1);
+      if (orin) {
+        r0 = orin + 3*(tidx-1);
+        r1 = orin + 3*tidx;
+        r2 = orin + 3*(tidx+1);
+      }
       if (!tidx) {
         /* first */
-        p1 = vert + 4*tidx;
-        p2 = vert + 4*(tidx+1);
-        ELL_3V_SUB(diff, p2, p1);
-        velo[tidx] = ELL_3V_LEN(diff)/(p2[3]-p1[3]);
+        pA = p1; rA = r1;
+        pB = p2; rB = r2;
       } else if (tidx < lentmp-1) {
         /* middle */
-        p0 = vert + 4*(tidx-1);
-        p2 = vert + 4*(tidx+1);
-        ELL_3V_SUB(diff, p2, p0);
-        velo[tidx] = ELL_3V_LEN(diff)/(p2[3]-p0[3]);
+        pA = p0; rA = r0;
+        pB = p2; rB = r2;
       } else {
         /* last */
-        p0 = vert + 4*(tidx-1);
-        p1 = vert + 4*tidx;
-        ELL_3V_SUB(diff, p1, p0);
-        velo[tidx] = ELL_3V_LEN(diff)/(p1[3]-p0[3]);
+        pA = p0; rA = r0;
+        pB = p1; rB = r1;
       }
+      pullTraceStability(stab + 0 + 2*tidx, stab + 1 + 2*tidx,
+                         pA, pB, rA, rB, 0.5 /* sigma0 */, pctx);
     }
   }
 
   airMopOkay(mop);
-  pctx->idtagNext -= 1; /* HACK */
+  /* pctx->idtagNext -= 1; / * HACK * / */
   return 0;
 }
 
@@ -369,9 +688,9 @@
     *addedP = AIR_FALSE;
     return 0;
   }
-  if (!(trc->nvelo->data
-        && trc->nvelo->axis[0].size == trc->nvert->axis[1].size)) {
-    biffAddf(PULL, "%s: velo data inconsistent", me);
+  if (!(trc->nstab->data
+        && trc->nstab->axis[1].size == trc->nvert->axis[1].size)) {
+    biffAddf(PULL, "%s: stab data inconsistent", me);
     return 1;
   }
   *addedP = AIR_TRUE;
@@ -385,73 +704,21 @@
 }
 
 int
-pullTraceMultiFilterConcaveDown(Nrrd *nfilt, const pullTraceMulti *mtrc,
-                                double winLenFrac) {
-  static const char me[]="pullTraceMultiFilterConcaveDown";
-  unsigned int ti;
-  int *filt;
-
-  if (!(nfilt && mtrc)) {
-    biffAddf(PULL, "%s: got NULL pointer (%p %p)", me,
-             AIR_VOIDP(nfilt), AIR_CVOIDP(mtrc));
-    return 1;
-  }
-  if (!(AIR_EXISTS(winLenFrac) && AIR_IN_OP(0.0, winLenFrac, 1.0))) {
-    biffAddf(PULL, "%s: winLenFrac %g doesn't exist or not in [0,1]",
-             me, winLenFrac);
-    return 1;
-  }
-  if (nrrdMaybeAlloc_va(nfilt, nrrdTypeInt, 1, mtrc->traceNum)) {
-    biffMovef(PULL, NRRD, "%s: trouble creating output", me);
-    return 1;
-  }
-  filt = AIR_CAST(int *, nfilt->data);
-  for (ti=0; ti<mtrc->traceNum; ti++) {
-    unsigned winLen;
-    const pullTrace *trc;
-    const double *velo;
-    unsigned int schange, pidx, lentmp;
-    double dv, dv0=0.0, rdv, dv1;
-
-    trc = mtrc->trace[ti];
-    lentmp = trc->nvert->axis[1].size;
-    velo = AIR_CAST(const double *, trc->nvelo->data);
-    winLen = AIR_CAST(unsigned int, winLenFrac*lentmp);
-    if (winLen < 3) {
-      continue;
-    }
-    schange = 0;
-    rdv = 0.0;
-    for (pidx=0; pidx<lentmp-1; pidx++) {
-      /* normalizing by scaleDelta isn't needed for detecting sign changes */
-      dv = velo[pidx+1] - velo[pidx];
-      if (pidx < winLen) {
-        rdv += dv;
-      } else {
-        double tmp;
-        if (pidx == winLen) {
-          dv0 = rdv;
-        }
-        tmp = rdv;
-        rdv += dv;
-        rdv -= velo[pidx-winLen+1] - velo[pidx-winLen];
-        schange += (rdv*tmp < 0);
-      }
-    }
-    dv1 = rdv;
-    filt[ti] = (1 == schange) && dv0 < 0.0 && dv1 > 0.0;
-  }
-  return 0;
-}
-
-int
 pullTraceMultiPlotAdd(Nrrd *nplot, const pullTraceMulti *mtrc,
-                      const Nrrd *nfilt,
-                      unsigned int trcIdxMin,unsigned int trcNum) {
-  static const char me[]="pullTraceMultiPlot";
-  double ssRange[2], vRange[2], velHalf, *plot;
-  unsigned int sizeS, sizeV, trcIdx, trcIdxMax;
+                      const Nrrd *nfilt, int strengthUse,
+                      int smooth, int flatWght,
+                      unsigned int trcIdxMin, unsigned int trcNum,
+                      Nrrd *nmaskedpos,
+                      const Nrrd *nmask) {
+  static const char me[]="pullTraceMultiPlotAdd";
+  double ssRange[2], vRange[2], *plot;
+  unsigned int sizeS, sizeT, trcIdx, trcIdxMax;
   int *filt;
+  airArray *mop;
+  Nrrd *nsmst; /* smoothed stability */
+  airArray *mposArr;
+  double *mpos;
+  unsigned char *mask;
 
   if (!(nplot && mtrc)) {
     biffAddf(PULL, "%s: got NULL pointer", me);
@@ -494,6 +761,32 @@
   } else {
     trcIdxMax = mtrc->traceNum-1;
   }
+  if (nmaskedpos || nmask) {
+    if (!( nmaskedpos && nmask )) {
+      biffAddf(PULL, "%s: need either both or neither of nmaskedpos (%p)"
+               "and nmask (%p)", me, (void*)nmaskedpos, (const void*)nmask);
+      return 1;
+    }
+    if (!( 2 == nmask->dim
+           && nrrdTypeUChar == nmask->type
+           && nplot->axis[0].size == nmask->axis[0].size
+           && nplot->axis[1].size == nmask->axis[1].size )) {
+      biffAddf(PULL, "%s: got trace mask but wanted "
+               "2-D %s %u-by-%u (not %u-D %s %u-by-%u)\n", me,
+               airEnumStr(nrrdType, nrrdTypeUChar),
+               AIR_UINT(nplot->axis[0].size),
+               AIR_UINT(nplot->axis[1].size),
+               nmask->dim,
+               airEnumStr(nrrdType, nmask->type),
+               AIR_UINT(nmask->axis[0].size),
+               AIR_UINT(nmask->axis[1].size));
+      return 1;
+    }
+    mask = AIR_CAST(unsigned char *, nmask->data);
+  } else {
+    mask = NULL;
+  }
+
   ssRange[0] = nplot->axis[0].min;
   ssRange[1] = nplot->axis[0].max;
   vRange[0] = nplot->axis[1].min;
@@ -504,26 +797,36 @@
              ssRange[0], ssRange[1], vRange[0], vRange[1]);
     return 1;
   }
-  if (0 != vRange[0]) {
-    biffAddf(PULL, "%s: expected vRange[0] == 0 not %g", me, vRange[0]);
+  if (1 != vRange[0]) {
+    biffAddf(PULL, "%s: expected vRange[0] == 1 not %g", me, vRange[0]);
     return 1;
   }
-  /* HEY: this is a sneaky hack; the non-linear encoding of velocity along
-     this axis means that the max velocity is actually infinite, but this
-     seems like the least wrong way of storing this information in the place
-     where it belongs (in the output plot nrrd) instead of assuming it will
-     always be passed the same in successive calls */
-  velHalf = vRange[1]/2.0;
+  mop = airMopNew();
+
+  mpos = NULL;
+  if (nmaskedpos && nmask) {
+    nrrdEmpty(nmaskedpos);
+    mposArr = airArrayNew((void**)(&mpos), NULL,
+                          4*sizeof(double), 512 /* HEY */);
+  } else {
+    mposArr = NULL;
+  }
+
+  nsmst = nrrdNew();
+  airMopAdd(mop, nsmst, (airMopper)nrrdNuke, airMopAlways);
   plot = AIR_CAST(double *, nplot->data);
   filt = (nfilt
           ? AIR_CAST(int *, nfilt->data)
           : NULL);
-  sizeS = AIR_CAST(unsigned int, nplot->axis[0].size);
-  sizeV = AIR_CAST(unsigned int, nplot->axis[1].size);
+  sizeS = AIR_UINT(nplot->axis[0].size);
+  sizeT = AIR_UINT(nplot->axis[1].size);
   for (trcIdx=trcIdxMin; trcIdx<=trcIdxMax; trcIdx++) {
-    unsigned int pntIdx, pntNum;
+    int pntIdx, pntNum;
     const pullTrace *trc;
-    const double *vert, *velo;
+    const double *vert, *stab, *strn;
+    unsigned int maskInCount;
+    double maskInPos[4];
+
     if (filt && !filt[trcIdx]) {
       continue;
     }
@@ -531,26 +834,113 @@
     if (pullTraceStopStub == trc->whyNowhere) {
       continue;
     }
+    if (strengthUse && !(trc->nstrn && trc->nstrn->data)) {
+      biffAddf(PULL, "%s: requesting strength-based weighting, but don't have "
+               "strength info in trace %u", me, trcIdx);
+      airMopError(mop); return 1;
+    }
+    pntNum = AIR_INT(trc->nvert->axis[1].size);
     vert = AIR_CAST(double *, trc->nvert->data);
-    velo = AIR_CAST(double *, trc->nvelo->data);
-    pntNum = trc->nvert->axis[1].size;
+    stab = AIR_CAST(double *, trc->nstab->data);
+    if (smooth > 0) {
+      double *smst;
+      if (nrrdCopy(nsmst, trc->nstab)) {
+        biffMovef(PULL, NRRD, "%s: trouble w/ trace %u", me, trcIdx);
+        airMopError(mop); return 1;
+      }
+      smst = AIR_CAST(double *, nsmst->data);
+      for (pntIdx=0; pntIdx<pntNum; pntIdx++) {
+        int ii, jj;
+        double ss, ww, ws;
+        ss = ws = 0;
+        for (jj=-smooth; jj<=smooth; jj++) {
+          ii = pntIdx+jj;
+          ii = AIR_CLAMP(0, ii, pntNum-1);
+          ww = nrrdKernelBSpline3->eval1_d(AIR_AFFINE(-smooth-1, jj,
+                                                      smooth+1,-2,2), NULL);
+          ws += ww;
+          ss += ww*stab[0 + 2*ii]*stab[1 + 2*ii];
+        }
+        smst[pntIdx] = ss/ws;
+      }
+      /* now redirect stab */
+      stab = smst;
+    }
+    strn = AIR_CAST(double *, (strengthUse && trc->nstrn
+                               ? trc->nstrn->data : NULL));
+    /* would be nice to get some graphical indication of this */
+    fprintf(stderr, "!%s: trace %u in [%u,%u]: %u points; stops = %s(%s) | %s(%s)\n",
+            me, trcIdx, trcIdxMin, trcIdxMax, pntNum,
+            airEnumStr(pullTraceStop, trc->whyStop[0]),
+            (pullTraceStopConstrFail == trc->whyStop[0]
+             ? airEnumStr(pullConstraintFail, trc->whyStopCFail[0])
+             : ""),
+            airEnumStr(pullTraceStop, trc->whyStop[1]),
+            (pullTraceStopConstrFail == trc->whyStop[1]
+             ? airEnumStr(pullConstraintFail, trc->whyStopCFail[1])
+             : ""));
+    /* */
+
+    if (mask) {
+      maskInCount = 0;
+      ELL_4V_SET(maskInPos, 0, 0, 0, 0);
+    }
     for (pntIdx=0; pntIdx<pntNum; pntIdx++) {
       const double *pp;
+      double add, ww;
       unsigned int sidx, vidx;
       pp = vert + 4*pntIdx;
       if (!(AIR_IN_OP(ssRange[0], pp[3], ssRange[1]))) {
         continue;
       }
-      if (velo[pntIdx] <= 0.0) {
-        continue;
+      if (flatWght > 0) {
+        if (!pntIdx || pntIdx == pntNum-1) {
+          continue;
+        }
+      } else if (flatWght < 0) {
+        /* HACK: only show the seed point */
+        if (AIR_UINT(pntIdx) != trc->seedIdx) {
+          continue;
+        }
       }
       sidx = airIndex(ssRange[0], pp[3], ssRange[1], sizeS);
-      /* HEY weird that Clamp is needed, but it is, as this atan()
-         does sometime return a negative value (?) */
-      vidx = airIndexClamp(0.0, atan(velo[pntIdx]/velHalf), AIR_PI/2, sizeV);
-      plot[sidx + sizeS*vidx] += 1;
+      vidx = airIndexClamp(1, stab[0 + 2*pntIdx]*stab[1 + 2*pntIdx], 0, sizeT);
+      add = strn ? strn[pntIdx] : 1;
+      if (flatWght > 0) {
+        double dx = ( ((vert + 4*(pntIdx+1))[3] - (vert + 4*(pntIdx-1))[3])
+                      / (ssRange[1] - ssRange[0]) );
+        /*
+        double dx = ( ((vert + 4*(pntIdx+1))[3] - pp[3])
+                      / (ssRange[1] - ssRange[0]) );
+        */
+        double dy = (stab[0 + 2*(pntIdx+1)]*stab[1 + 2*(pntIdx+1)]
+                     - stab[0 + 2*(pntIdx-1)]*stab[1 + 2*(pntIdx-1)]);
+        ww = dx/sqrt(dx*dx + dy*dy);
+      } else {
+        ww = 1;
+      }
+      plot[sidx + sizeS*vidx] += AIR_MAX(0, ww*add);
+      if (mask && mask[sidx + sizeS*vidx] > 200) {
+        ELL_4V_ADD2(maskInPos, maskInPos, pp);
+        maskInCount ++;
+      }
+    }
+    if (mask && maskInCount) {
+      unsigned int mpi = airArrayLenIncr(mposArr, 1);
+      ELL_4V_SCALE(mpos + 4*mpi, 1.0/maskInCount, maskInPos);
     }
   }
+  if (mask && mposArr->len) {
+    if (nrrdMaybeAlloc_va(nmaskedpos, nrrdTypeDouble, 2,
+                          AIR_CAST(size_t, 4),
+                          AIR_CAST(size_t, mposArr->len))) {
+      biffAddf(PULL, "%s: couldn't allocate masked pos", me);
+      airMopError(mop); return 1;
+    }
+    memcpy(nmaskedpos->data, mposArr->data,
+           4*(mposArr->len)*sizeof(double));
+  }
+  airMopOkay(mop);
   return 0;
 }
 
@@ -574,7 +964,7 @@
     ret += sizeof(pullTrace);
     ret += nsizeof(mtrc->trace[ti]->nvert);
     ret += nsizeof(mtrc->trace[ti]->nstrn);
-    ret += nsizeof(mtrc->trace[ti]->nvelo);
+    ret += nsizeof(mtrc->trace[ti]->nstab);
   }
   ret += sizeof(pullTrace*)*(mtrc->traceArr->size);
   return ret;
@@ -598,11 +988,18 @@
 tracewrite(FILE *file, const pullTrace *trc, unsigned int ti) {
   static const char me[]="tracewrite";
 
+  /*
+  this was used to get ascii coordinates for a trace,
+  to help isolate (via emacs) one trace from a saved multi-trace
+  NrrdIoState *nio = nrrdIoStateNew();
+  nio->encoding = nrrdEncodingAscii;
+  */
+
   fprintf(file, "%s %u\n", DEMARK_STR, ti);
   ell_4v_print_d(file, trc->seedPos);
 #define WRITE(FF) \
   if (trc->FF && trc->FF->data) { \
-    if (nrrdWrite(file, trc->FF, NULL)) { \
+    if (nrrdWrite(file, trc->FF, NULL /* nio */ )) {        \
       biffMovef(PULL, NRRD, "%s: trouble with " #FF , me); \
       return 1; \
     } \
@@ -610,13 +1007,14 @@
     fprintf(file, "NULL"); \
   } \
   fprintf(file, "\n")
-  fprintf(file, "nrrds: vert strn velo = %d %d %d\n",
+
+  fprintf(file, "nrrds: vert strn stab = %d %d %d\n",
           trc->nvert && trc->nvert->data,
           trc->nstrn && trc->nstrn->data,
-          trc->nvelo && trc->nvelo->data);
+          trc->nstab && trc->nstab->data);
   WRITE(nvert);
   WRITE(nstrn);
-  WRITE(nvelo);
+  WRITE(nstab);
   fprintf(file, "%u\n", trc->seedIdx);
   fprintf(file, "%s %s %s\n",
           airEnumStr(pullTraceStop, trc->whyStop[0]),
@@ -652,7 +1050,7 @@
   static const char me[]="traceread";
   char line[AIR_STRLEN_MED], name[AIR_STRLEN_MED];
   unsigned int ti, lineLen;
-  int stops[3], hackhack, vertHN, strnHN, veloHN; /* HN == have nrrd */
+  int stops[3], hackhack, vertHN, strnHN, stabHN; /* HN == have nrrd */
 
   sprintf(name, "separator");
   lineLen = airOneLine(file, line, AIR_STRLEN_MED);
@@ -686,8 +1084,8 @@
     biffAddf(PULL, "%s: didn't get %s line", me, name);
     return 1;
   }
-  if (3 != sscanf(line, "nrrds: vert strn velo = %d %d %d",
-                  &vertHN, &strnHN, &veloHN)) {
+  if (3 != sscanf(line, "nrrds: vert strn stab = %d %d %d",
+                  &vertHN, &strnHN, &stabHN)) {
     biffAddf(PULL, "%s: couldn't parse %s line", me, name);
     return 1;
   }
@@ -705,7 +1103,7 @@
   nrrdStateVerboseIO = 0;
   READ(vert);
   READ(strn);
-  READ(velo);
+  READ(stab);
   nrrdStateVerboseIO = hackhack;
 
   sprintf(name, "seed idx");
diff --color -ruN teem-1.11.0-src.orig/src/pull/volumePull.c teem-1.11.0-src/src/pull/volumePull.c
--- teem-1.11.0-src.orig/src/pull/volumePull.c	2012-12-20 22:10:22.000000000 +0800
+++ teem-1.11.0-src/src/pull/volumePull.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -79,13 +79,15 @@
 ** used to set all the fields of pullVolume at once, including the
 ** gageContext inside the pullVolume
 **
+** OLD description ...
 ** used both for top-level volumes in the pullContext (pctx->vol[i])
 ** in which case pctx is non-NULL,
 ** and for the per-task volumes (task->vol[i]),
 ** in which case pctx is NULL
+** ...................
 */
 int
-_pullVolumeSet(pullContext *pctx, pullVolume *vol,
+_pullVolumeSet(const pullContext *pctx, int taskCopy, pullVolume *vol,
                const gageKind *kind,
                int verbose, const char *name,
                const Nrrd *ninSingle,
@@ -110,7 +112,7 @@
     biffAddf(PULL, "%s: needed non-NULL ninSingle", me);
     return 1;
   }
-  if (pctx) {
+  if (!taskCopy) {
     for (vi=0; vi<pctx->volNum; vi++) {
       if (pctx->vol[vi] == vol) {
         biffAddf(PULL, "%s: already got vol %p as vol[%u]", me,
@@ -147,6 +149,7 @@
   vol->scaleDerivNormBias = scaleDerivNormBias;
   gageParmSet(vol->gctx, gageParmStackNormalizeDerivBias,
               scaleDerivNormBias);
+  gageParmSet(vol->gctx, gageParmTwoDimZeroZ, pctx->flag.zeroZ);
   gageParmSet(vol->gctx, gageParmCheckIntegrals, AIR_TRUE);
   E = 0;
   if (!E) E |= gageKernelSet(vol->gctx, gageKernel00,
@@ -187,7 +190,7 @@
   vol->name = airStrdup(name);
   if (!vol->name) {
     biffAddf(PULL, "%s: couldn't strdup name (len %u)", me,
-             AIR_CAST(unsigned int, airStrlen(name)));
+             AIR_UINT(airStrlen(name)));
     return 1;
   }
   if (vol->verbose) {
@@ -238,7 +241,7 @@
   pullVolume *vol;
 
   vol = pullVolumeNew();
-  if (_pullVolumeSet(pctx, vol, kind,
+  if (_pullVolumeSet(pctx, AIR_FALSE /* taskCopy */, vol, kind,
                      pctx->verbose, name,
                      nin,
                      NULL, NULL, 0, AIR_FALSE, 0.0,
@@ -278,7 +281,8 @@
   pullVolume *vol;
 
   vol = pullVolumeNew();
-  if (_pullVolumeSet(pctx, vol, kind, pctx->verbose, name,
+  if (_pullVolumeSet(pctx, AIR_FALSE /* taskCopy */, vol, kind,
+                     pctx->verbose, name,
                      nin,
                      ninSS, scalePos, ninNum,
                      scaleDerivNorm, scaleDerivNormBias,
@@ -298,12 +302,12 @@
 ** DOES use biff
 */
 pullVolume *
-_pullVolumeCopy(const pullVolume *volOrig) {
+_pullVolumeCopy(const pullContext *pctx, const pullVolume *volOrig) {
   static const char me[]="pullVolumeCopy";
   pullVolume *volNew;
 
   volNew = pullVolumeNew();
-  if (_pullVolumeSet(NULL, volNew, volOrig->kind,
+  if (_pullVolumeSet(pctx, AIR_TRUE /* taskCopy */, volNew, volOrig->kind,
                      volOrig->verbose, volOrig->name,
                      volOrig->ninSingle,
                      volOrig->ninScale,
@@ -519,6 +523,12 @@
   return pctx->vol[vi];
 }
 
+/*
+******** pullConstraintScaleRange
+**
+** returns scale range from a scale-space volume,
+** either in terms of sigma, or (if pctx->flag.scaleIsTau), tau
+*/
 int
 pullConstraintScaleRange(pullContext *pctx, double ssrange[2]) {
   static const char me[]="pullConstraintScaleRange";
diff --color -ruN teem-1.11.0-src.orig/src/push/action.c teem-1.11.0-src/src/push/action.c
--- teem-1.11.0-src.orig/src/push/action.c	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/push/action.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -115,7 +115,7 @@
         TEN_T_COPY_TT(tenOut + 7*pointRun, float, point->ten);
       }
       if (enrOut) {
-        enrOut[pointRun] = AIR_CAST(float, point->enr);
+        enrOut[pointRun] = AIR_FLOAT(point->enr);
       }
       pointRun++;
     }
diff --color -ruN teem-1.11.0-src.orig/src/push/binning.c teem-1.11.0-src/src/push/binning.c
--- teem-1.11.0-src.orig/src/push/binning.c	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/push/binning.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -188,7 +188,7 @@
 
   if (!( bin = _pushBinLocate(pctx, point->pos) )) {
     biffAddf(PUSH, "%s: can't locate point %p %u",
-             me, AIR_CAST(void*, point), point->ttaagg);
+             me, AIR_VOIDP(point), point->ttaagg);
     return 1;
   }
   _pushBinPointAdd(pctx, bin, point);
@@ -215,7 +215,7 @@
         newBin = _pushBinLocate(pctx, point->pos);
         if (!newBin) {
           biffAddf(PUSH, "%s: can't locate point %p %u",
-                   me, AIR_CAST(void*, point), point->ttaagg);
+                   me, AIR_VOIDP(point), point->ttaagg);
           return 1;
         }
         if (oldBin != newBin) {
diff --color -ruN teem-1.11.0-src.orig/src/push/CMakeLists.txt teem-1.11.0-src/src/push/CMakeLists.txt
--- teem-1.11.0-src.orig/src/push/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/push/CMakeLists.txt	2021-02-18 15:42:33.000000000 +0800
@@ -0,0 +1,17 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(PUSH_SOURCES
+  action.c
+  binning.c
+  corePush.c
+  defaultsPush.c
+  forces.c
+  methodsPush.c
+  privatePush.h
+  push.h
+  setup.c
+  )
+
+target_sources(teem PRIVATE ${PUSH_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( push FILES ${PUSH_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/push/corePush.c teem-1.11.0-src/src/push/corePush.c
--- teem-1.11.0-src.orig/src/push/corePush.c	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/push/corePush.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/push/defaultsPush.c teem-1.11.0-src/src/push/defaultsPush.c
--- teem-1.11.0-src.orig/src/push/defaultsPush.c	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/push/defaultsPush.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/push/forces.c teem-1.11.0-src/src/push/forces.c
--- teem-1.11.0-src.orig/src/push/forces.c	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/push/forces.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -439,7 +439,7 @@
 }
 
 int
-_pushHestEnergyParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+_pushHestEnergyParse(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   pushEnergySpec **enspP;
   static const char me[]="_pushHestForceParse";
   char *perr;
diff --color -ruN teem-1.11.0-src.orig/src/push/GNUmakefile teem-1.11.0-src/src/push/GNUmakefile
--- teem-1.11.0-src.orig/src/push/GNUmakefile	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/push/GNUmakefile	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/push/methodsPush.c teem-1.11.0-src/src/push/methodsPush.c
--- teem-1.11.0-src.orig/src/push/methodsPush.c	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/push/methodsPush.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/push/privatePush.h teem-1.11.0-src/src/push/privatePush.h
--- teem-1.11.0-src.orig/src/push/privatePush.h	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/push/privatePush.h	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/push/push.h teem-1.11.0-src/src/push/push.h
--- teem-1.11.0-src.orig/src/push/push.h	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/push/push.h	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/push/setup.c teem-1.11.0-src/src/push/setup.c
--- teem-1.11.0-src.orig/src/push/setup.c	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/push/setup.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -84,7 +84,7 @@
     TEN_T_INV(inv, ten, det);
     if (!det || !AIR_EXISTS(det)) {
       fprintf(stderr, "!%s: tensor %u/%u has determinant %g\n", me,
-              AIR_CAST(unsigned int, ii), AIR_CAST(unsigned int, NN), det);
+              AIR_UINT(ii), AIR_UINT(NN), det);
     }
     TEN_T_COPY_TT(_inv, float, inv);
     _ten += 7;
@@ -276,7 +276,7 @@
   double col[3][4], volEdge[3];
 
   /* ------------------------ find maxEval, maxDet, and set up binning */
-  nn = nrrdElementNumber(pctx->nten)/7;
+  nn = AIR_UINT(nrrdElementNumber(pctx->nten)/7);
   pctx->maxEval = 0;
   pctx->maxDet = 0;
   pctx->meanEval = 0;
@@ -325,14 +325,11 @@
     volEdge[2] = ELL_3V_LEN(col[2])*pctx->gctx->shape->size[2];
     fprintf(stderr, "!%s: volEdge = %g %g %g\n", me,
             volEdge[0], volEdge[1], volEdge[2]);
-    pctx->binsEdge[0] = AIR_CAST(unsigned int,
-                                 floor(volEdge[0]/pctx->maxDist));
+    pctx->binsEdge[0] = AIR_UINT(floor(volEdge[0]/pctx->maxDist));
     pctx->binsEdge[0] = pctx->binsEdge[0] ? pctx->binsEdge[0] : 1;
-    pctx->binsEdge[1] = AIR_CAST(unsigned int,
-                                 floor(volEdge[1]/pctx->maxDist));
+    pctx->binsEdge[1] = AIR_UINT(floor(volEdge[1]/pctx->maxDist));
     pctx->binsEdge[1] = pctx->binsEdge[1] ? pctx->binsEdge[1] : 1;
-    pctx->binsEdge[2] = AIR_CAST(unsigned int,
-                                 floor(volEdge[2]/pctx->maxDist));
+    pctx->binsEdge[2] = AIR_UINT(floor(volEdge[2]/pctx->maxDist));
     pctx->binsEdge[2] = pctx->binsEdge[2] ? pctx->binsEdge[2] : 1;
     if (2 == pctx->dimIn) {
       pctx->binsEdge[pctx->sliceAxis] = 1;
@@ -377,7 +374,7 @@
   */
 
   pctx->pointNum = (pctx->npos
-                    ? pctx->npos->axis[1].size
+                    ? AIR_UINT(pctx->npos->axis[1].size)
                     : pctx->pointNum);
   lup = pctx->npos ? nrrdDLookup[pctx->npos->type] : NULL;
   fprintf(stderr, "!%s: initilizing/seeding ... \n", me);
diff --color -ruN teem-1.11.0-src.orig/src/push/sources.cmake teem-1.11.0-src/src/push/sources.cmake
--- teem-1.11.0-src.orig/src/push/sources.cmake	2012-12-20 22:08:37.000000000 +0800
+++ teem-1.11.0-src/src/push/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,15 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(PUSH_SOURCES
-  action.c
-  binning.c
-  corePush.c
-  defaultsPush.c
-  forces.c
-  methodsPush.c
-  privatePush.h
-  push.h
-  setup.c
-  )
-
-ADD_TEEM_LIBRARY(push ${PUSH_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/push/test/eparse.c teem-1.11.0-src/src/push/test/eparse.c
--- teem-1.11.0-src.orig/src/push/test/eparse.c	2012-12-20 22:08:29.000000000 +0800
+++ teem-1.11.0-src/src/push/test/eparse.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../push.h"
 
-char *info = ("Tests parsing of energy, and its methods.");
+const char *info = ("Tests parsing of energy, and its methods.");
 
 int
 main(int argc, const char *argv[]) {
diff --color -ruN teem-1.11.0-src.orig/src/push/test/pusher.c teem-1.11.0-src/src/push/test/pusher.c
--- teem-1.11.0-src.orig/src/push/test/pusher.c	2012-12-20 22:08:29.000000000 +0800
+++ teem-1.11.0-src/src/push/test/pusher.c	2021-02-18 15:42:33.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../push.h"
 
-char *info = ("Test program for push library.");
+const char *info = ("Test program for push library.");
 
 int
 main(int argc, const char *argv[]) {
@@ -89,6 +90,10 @@
   hestOptAdd(&hopt, "detr", NULL, airTypeBool, 0, 0,
              &(pctx->detReject), NULL,
              "do determinant-based rejection of initial sample locations");
+  hestOptAdd(&hopt, "mps", NULL, airTypeBool, 0, 0,
+             &(pctx->midPntSmp), NULL,
+             "sampling midpoint in tensor field, and invert it, instead of "
+             "approximating it by averaging the inverses at the endpoints");
   hestOptAdd(&hopt, "rng", "seed", airTypeUInt, 1, 1,
              &(pctx->seedRNG), "42",
              "seed value for RNG which determines initial point locations");
diff --color -ruN teem-1.11.0-src.orig/src/release.txt teem-1.11.0-src/src/release.txt
--- teem-1.11.0-src.orig/src/release.txt	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/release.txt	2021-02-18 15:42:34.000000000 +0800
@@ -1,4 +1,3 @@
-
 GLK's list of things to do for each release.  This started with an
 early version of Teem and has been only partially maintained since
 then; consider it a work-in-progress ...
@@ -8,27 +7,32 @@
 -4) Make sure the CMake and GNUMake agree on source files per-library
 
 -3.5) make sure that teem/src/meet/enumall.c:meetAirEnumAll()
- is up-to-date
+ is up-to-date, and run teem/src/meet/test/tenums
 
 -3) make sure that all the files have the right copyright
 pre-ambles
 
 -2.5) make sure that there are no DOS files
-find . -name \*.c -exec undos -n {}  \;
-find . -name \*.h -exec undos -n {}  \;
-find . -name \*.txt -exec undos -n {} \;
+find . -name \*.c -exec unu undos -n {}  \;
+find . -name \*.h -exec unu undos -n {}  \;
+find . -name \*.txt -exec unu undos -n {} \;
+
+-2.25) make sure there's no unwanted trailing whitespace
+grep -E '^.+[ ]+$' */*.h
+grep -E '^.+[ ]+$' */*.c
 
 -2) make sure there are no tabs:
 cat > tab.txt
 (tab) (return)
 ^D
 
-find . -name \*.c -exec grep -f tab.txt {} /dev/null \; | more
+find . -name \*.c -exec grep -f tab.txt {} /dev/null \; | more       for 1.13.0 PICK UP HERE                               
 find . -name \*.h -exec grep -f tab.txt {} /dev/null \; | more
 find . -name \*.txt -exec grep -f tab.txt {} /dev/null \; | more
 rm -f tab.txt
 
 -1) finalize TEEM_VERSION* in air/air.h and airTeemReleaseDate in air/misc.c
+and set airTeemReleaseDone to AIR_TRUE
 
 -0.5) regenerate teem/python/ctypes/teem.py
 
@@ -38,13 +42,15 @@
 make sure all the unrrdu pages agree with unu usage info
 cd ~/teem
 cp README.txt ~/teemdoc/html/tree/
-cp src/README.txt ~/teemdoc/html/tree/src/
-cp src/CHANGES.txt ~/teemdoc/html/tree/src/
 cp src/TODO.txt ~/teemdoc/html/tree/src/
-cp src/LICENSE.txt ~/teemdoc/html/tree/src/
 (cd ~/teemdoc; cvs commit -m "pre-release text file update")
-sftp kindlmann,teem@web.sourceforge.net
-is one way of putting files onto the web server
+
+from: http://sourceforge.net/p/forge/documentation/SFTP/
+  sftp kindlmann,teem@web.sourceforge.net
+  cd htdocs
+also worked (from teemdoc/html)
+scp index.html kindlmann,teem@web.sourceforge.net:/home/project-web/teem/htdocs
+(HEY: need to figure out using rsync to move things to sourceforge)
 
 1) Check namespace safety
   a) Make sure all library symbols are properly prefixed:
@@ -57,21 +63,20 @@
 
 2.5) svn "tag":
 setenv VERSION <<version>>
-svn copy https://teem.svn.sourceforge.net/svnroot/teem/teem/trunk \
-         https://teem.svn.sourceforge.net/svnroot/teem/teem/branches/Teem-${VERSION}
+svn copy https://svn.code.sf.net/p/teem/code/teem/trunk \
+         https://svn.code.sf.net/p/teem/code/teem/branches/Teem-${VERSION}
 
 3) Create source-only tgz:
-svn co http://teem.svn.sourceforge.net/svnroot/teem/teem/trunk teem
+svn co http://svn.code.sf.net/p/teem/code/teem/trunk teem
 cd teem
 find . -name .svn  -exec rm -rf {} \;
 cd ..; mv teem teem-${VERSION}-src
 tar czvf teem-${VERSION}-src.tar.gz teem-${VERSION}-src
 mv teem-${VERSION}-src.tar.gz ~/rel
 
-(HEY update this to use svn, not cvs!)
-cvs -d:ext:kindlmann@teem.cvs.sf.net:/cvsroot/teem co NrrdIO
+svn co http://svn.code.sf.net/p/teem/code/NrrdIO/trunk NrrdIO
 cd NrrdIO
-find . -name CVS  -exec rm -rf {} \;
+find . -name .svn  -exec rm -rf {} \;
 cd ..; mv NrrdIO NrrdIO-${VERSION}-src
 tar czvf NrrdIO-${VERSION}-src.tar.gz NrrdIO-${VERSION}-src
 mv NrrdIO-${VERSION}-src.tar.gz ~/rel
@@ -113,13 +118,13 @@
    for each TEEM_ARCH in:
    irix6.n32 linux.ia64 linux.amd64 linux.32 cygwin solaris darwin.32 darwin.64
 -  ssh to some ARCH machine, copy teem-VERSION-src.tar.gz there if needed
--  setenv TEEM_XXX for all the externals that it makes sense to 
+-  setenv TEEM_XXX for all the externals that it makes sense to
       compile into the distributed statically linked binaries
 setenv VERSION <<<version>>>
 tar xzvf ~/rel/teem-${VERSION}-src.tar.gz
 cd teem-${VERSION}-src; setenv TEEM_DEST `pwd`
 cd src; make; cd ..
-mv src/LICENSE.txt . 
+mv src/LICENSE.txt .
 yes | rm -rf README.txt aix cygwin darwin.32 darwin.64 irix6.64 \
       irix6.n32 linux.32 linux.amd64 linux.ia64 solaris win32 src \
       CMake CMakeLists.txt CTestConfig.cmake DartConfig.cmake
diff --color -ruN teem-1.11.0-src.orig/src/seek/CMakeLists.txt teem-1.11.0-src/src/seek/CMakeLists.txt
--- teem-1.11.0-src.orig/src/seek/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/seek/CMakeLists.txt	2021-02-18 15:42:34.000000000 +0800
@@ -0,0 +1,18 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(SEEK_SOURCES
+  descend.c
+  enumsSeek.c
+  extract.c
+  methodsSeek.c
+  privateSeek.h
+  seek.h
+  setSeek.c
+  tables.c
+  textract.c
+  updateSeek.c
+  )
+
+target_sources(teem PRIVATE ${SEEK_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( seek FILES ${SEEK_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/seek/descend.c teem-1.11.0-src/src/seek/descend.c
--- teem-1.11.0-src.orig/src/seek/descend.c	2012-12-20 22:09:15.000000000 +0800
+++ teem-1.11.0-src/src/seek/descend.c	2021-02-18 15:42:34.000000000 +0800
@@ -119,7 +119,7 @@
     double inv[3]; /* inverse of that matrix */
     double nom[2], dx[2]; /* more helpers to compute next step */
     /* variables needed for Armijo stepsize rule */
-    double beta=1, gamma=0.5, alpha=beta; /* parameters */
+    double beta=1, _gamma=0.5, alpha=beta; /* parameters */
     int accept=0, safetyct=0, maxct=30; /* counters */
     double dxsqr; /* squared length of stepsize */
     double hessleft[9], hessright[9]; /* used to compute Hessian derivative */
@@ -257,7 +257,7 @@
           newcoord[1]<0 || newcoord[1]>1) {
         if (safetyct==maxct)
           return 1; /* we left the cell */
-        alpha*=gamma;
+        alpha*=_gamma;
       }
 
       ELL_3M_LERP(hessbot,newcoord[0],botleft,botright);
@@ -312,7 +312,7 @@
         accept=1;
         discr = newdiscr;
       } else {
-        alpha*=gamma;
+        alpha*=_gamma;
       }
     }
 
@@ -367,7 +367,7 @@
     /* on the first run, initialize discr; later, employ the Armijo
      * stepsize rule to guarantee convergence */
     double beta=1.0;
-    double gamma=0.5;
+    double _gamma=0.5;
     double alpha=beta;
     int accept=0;
     double optgradsqr = ELL_3V_DOT(optgrad,optgrad);
@@ -403,7 +403,7 @@
                                           dir was the culprit */
           return 1; /* we left the cell */
         }
-        alpha*=gamma;
+        alpha*=_gamma;
         continue;
       }
 
@@ -466,7 +466,7 @@
         accept=1;
         discr = newdiscr;
       } else {
-        alpha*=gamma;
+        alpha*=_gamma;
       }
     }
 
@@ -660,7 +660,7 @@
     /* on the first run, initialize dist; later, employ the Armijo
      * stepsize rule to guarantee convergence */
     double beta=0.1;
-    double gamma=0.5;
+    double _gamma=0.5;
     double alpha=beta;
     int accept=0;
     double optgradsqr = ELL_3V_DOT(optgrad,optgrad);
@@ -685,7 +685,7 @@
           newcoord[2]<0 || newcoord[2]>1) {
         if (safetyct==maxct)
           return 1; /* we left the cell */
-        alpha*=gamma;
+        alpha*=_gamma;
       }
 
       ELL_3M_LERP(Hfrontleft, newcoord[2], Hbfl, Htfl);
@@ -724,7 +724,7 @@
         accept=1;
         dist = newdist;
       } else {
-        alpha*=gamma;
+        alpha*=_gamma;
       }
     }
 
diff --color -ruN teem-1.11.0-src.orig/src/seek/enumsSeek.c teem-1.11.0-src/src/seek/enumsSeek.c
--- teem-1.11.0-src.orig/src/seek/enumsSeek.c	2012-12-20 22:09:15.000000000 +0800
+++ teem-1.11.0-src/src/seek/enumsSeek.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/seek/extract.c teem-1.11.0-src/src/seek/extract.c
--- teem-1.11.0-src.orig/src/seek/extract.c	2012-12-20 22:09:15.000000000 +0800
+++ teem-1.11.0-src/src/seek/extract.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -34,7 +34,7 @@
   /* this is basically the mapping from the 12 edges on each voxel to
      the 5 unique edges for each sample on the slab, based on the lay-out
      defined in the beginning of tables.c */
-  sx = AIR_CAST(unsigned int, sctx->sx);
+  sx = AIR_UINT(sctx->sx);
   /*                     X      Y */
   bag->evti[ 0] = 0 + 5*(0 + sx*0);
   bag->evti[ 1] = 1 + 5*(0 + sx*0);
@@ -125,15 +125,15 @@
     unsigned int estVoxNum=0;
     /* estimate number of voxels, faces, and vertices involved */
     spanHist = AIR_CAST(unsigned int*, sctx->nspanHist->data);
-    valI = airIndex(sctx->range->min, sctx->isovalue, sctx->range->max,
-                    sctx->spanSize);
+    valI = AIR_UINT(airIndex(sctx->range->min, sctx->isovalue,
+                             sctx->range->max, AIR_UINT(sctx->spanSize)));
     for (minI=0; minI<=valI; minI++) {
       for (maxI=valI; maxI<sctx->spanSize; maxI++) {
         estVoxNum += spanHist[minI + sctx->spanSize*maxI];
       }
     }
-    estVertNum = AIR_CAST(unsigned int, estVoxNum*(sctx->vertsPerVoxel));
-    estFaceNum = AIR_CAST(unsigned int, estVoxNum*(sctx->facesPerVoxel));
+    estVertNum = AIR_UINT(estVoxNum*(sctx->vertsPerVoxel));
+    estFaceNum = AIR_UINT(estVoxNum*(sctx->facesPerVoxel));
     if (sctx->verbose) {
       fprintf(stderr, "%s: estimated vox --> vert, face: %u --> %u, %u\n", me,
               estVoxNum, estVertNum, estFaceNum);
@@ -200,7 +200,7 @@
 sclGet(seekContext *sctx, baggage *bag,
        unsigned int xi, unsigned int yi, unsigned int zi) {
 
-  zi = AIR_MIN(sctx->sz-1, zi);
+  zi = AIR_UINT(AIR_MIN(sctx->sz-1, zi));
   return bag->scllup(bag->scldata, xi + sctx->sx*(yi + sctx->sy*zi));
 }
 
@@ -235,9 +235,9 @@
   double u, du, dot, wantDot, minDu, mode;
   double current[3], next[3], posNext[3], posA[3], posB[3], evecA[3], evecB[3];
 
-  sx = AIR_CAST(unsigned int, sctx->sx);
-  sy = AIR_CAST(unsigned int, sctx->sy);
-  sz = AIR_CAST(unsigned int, sctx->sz);
+  sx = AIR_UINT(sctx->sx);
+  sy = AIR_UINT(sctx->sy);
+  sz = AIR_UINT(sctx->sz);
 
   if (!(xi + dx < sx
         && yi + dy < sy
@@ -341,8 +341,8 @@
   unsigned int xi, yi, sx, sy, si;
   signed char flipA, flipB, flipC;
 
-  sx = AIR_CAST(unsigned int, sctx->sx);
-  sy = AIR_CAST(unsigned int, sctx->sy);
+  sx = AIR_UINT(sctx->sx);
+  sy = AIR_UINT(sctx->sy);
 
   /* NOTE: these have to go all the way to sy-1 and sx-1, instead of
      sy-2 and sx-2 (like shuffleProbe() below) because of the need to
@@ -418,8 +418,8 @@
   static const char me[]="shuffleProbe";
   unsigned int xi, yi, sx, sy, si, spi;
 
-  sx = AIR_CAST(unsigned int, sctx->sx);
-  sy = AIR_CAST(unsigned int, sctx->sy);
+  sx = AIR_UINT(sctx->sx);
+  sy = AIR_UINT(sctx->sy);
 
   if (!sctx->strengthUse) { /* just request all edges */
     memset(sctx->treated, 0x01, sizeof(char)*sctx->sx*sctx->sy);
@@ -617,7 +617,7 @@
   unsigned int sx, si, spi, vi;
 
   AIR_UNUSED(bag);
-  sx = AIR_CAST(unsigned int, sctx->sx);
+  sx = AIR_UINT(sctx->sx);
   si = xi + sx*yi;
   spi = (xi+1) + (sx+2)*(yi+1);
 
@@ -663,7 +663,7 @@
   signed char flip[12]={0,0,0,0,0,0,0,0,0,0,0,0}, flipProd;
   unsigned int sx, si, vi, ei, vrti[8];
 
-  sx = AIR_CAST(unsigned int, sctx->sx);
+  sx = AIR_UINT(sctx->sx);
   si = xi + sx*yi;
   vrti[0] = 0 + 2*(xi + 0 + sx*(yi + 0));
   vrti[1] = 0 + 2*(xi + 1 + sx*(yi + 0));
@@ -768,8 +768,8 @@
   };
   /* ========================================================== */
 
-  sx = AIR_CAST(unsigned int, sctx->sx);
-  sy = AIR_CAST(unsigned int, sctx->sy);
+  sx = AIR_UINT(sctx->sx);
+  sy = AIR_UINT(sctx->sy);
 
   for (yi=0; yi<sy-1; yi++) {
     double vval[8], vgrad[8][3], vert[3], tvertA[4], tvertB[4], ww;
@@ -896,7 +896,7 @@
   baggage *bag;
 
   bag = baggageNew(sctx);
-  sz = AIR_CAST(unsigned int, sctx->sz);
+  sz = AIR_UINT(sctx->sz);
 
   /* this creates the airArrays in bag */
   if (outputInit(sctx, bag, lpld)) {
diff --color -ruN teem-1.11.0-src.orig/src/seek/GNUmakefile teem-1.11.0-src/src/seek/GNUmakefile
--- teem-1.11.0-src.orig/src/seek/GNUmakefile	2012-12-20 22:09:15.000000000 +0800
+++ teem-1.11.0-src/src/seek/GNUmakefile	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/seek/methodsSeek.c teem-1.11.0-src/src/seek/methodsSeek.c
--- teem-1.11.0-src.orig/src/seek/methodsSeek.c	2012-12-20 22:09:15.000000000 +0800
+++ teem-1.11.0-src/src/seek/methodsSeek.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -59,6 +59,11 @@
        which certainly does not apply to all cases */
     sctx->facesPerVoxel = 2.15;
     sctx->vertsPerVoxel = 1.15;
+
+    /* this should be larger so that we don't waste time from airArrayLenIncr
+       constantly re-allocating, when the isosurface is rough; better
+       solution is to use multiplicatively scaled dynamic array. But caller
+       can also change this value on a per-context basis. */
     sctx->pldArrIncr = 2048;
 
     sctx->nin = NULL;
diff --color -ruN teem-1.11.0-src.orig/src/seek/privateSeek.h teem-1.11.0-src/src/seek/privateSeek.h
--- teem-1.11.0-src.orig/src/seek/privateSeek.h	2012-12-20 22:09:15.000000000 +0800
+++ teem-1.11.0-src/src/seek/privateSeek.h	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/seek/seek.h teem-1.11.0-src/src/seek/seek.h
--- teem-1.11.0-src.orig/src/seek/seek.h	2012-12-20 22:09:15.000000000 +0800
+++ teem-1.11.0-src/src/seek/seek.h	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/seek/setSeek.c teem-1.11.0-src/src/seek/setSeek.c
--- teem-1.11.0-src.orig/src/seek/setSeek.c	2012-12-20 22:09:15.000000000 +0800
+++ teem-1.11.0-src/src/seek/setSeek.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -130,9 +130,9 @@
   numZero += 0 == samples[2];
   if (!( 0 == numZero || 3 == numZero )) {
     biffAddf(SEEK, "%s: samples (%u,%u,%u) must all be 0 or !=0 together", me,
-             AIR_CAST(unsigned int, samples[0]),
-             AIR_CAST(unsigned int, samples[1]),
-             AIR_CAST(unsigned int, samples[2]));
+             AIR_UINT(samples[0]),
+             AIR_UINT(samples[1]),
+             AIR_UINT(samples[2]));
     return 1;
   }
   if (sctx->samples[0] != samples[0]
diff --color -ruN teem-1.11.0-src.orig/src/seek/sources.cmake teem-1.11.0-src/src/seek/sources.cmake
--- teem-1.11.0-src.orig/src/seek/sources.cmake	2012-12-20 22:09:15.000000000 +0800
+++ teem-1.11.0-src/src/seek/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,16 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(SEEK_SOURCES
-  descend.c
-  enumsSeek.c
-  extract.c
-  methodsSeek.c
-  privateSeek.h
-  seek.h
-  setSeek.c
-  tables.c
-  textract.c
-  updateSeek.c
-  )
-
-ADD_TEEM_LIBRARY(seek ${SEEK_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/seek/test/tiso.c teem-1.11.0-src/src/seek/test/tiso.c
--- teem-1.11.0-src.orig/src/seek/test/tiso.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/seek/test/tiso.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/seek/test/trv.c teem-1.11.0-src/src/seek/test/trv.c
--- teem-1.11.0-src.orig/src/seek/test/trv.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/seek/test/trv.c	2021-02-18 15:42:34.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/seek/textract.c teem-1.11.0-src/src/seek/textract.c
--- teem-1.11.0-src.orig/src/seek/textract.c	2012-12-20 22:09:15.000000000 +0800
+++ teem-1.11.0-src/src/seek/textract.c	2021-02-18 15:42:34.000000000 +0800
@@ -80,7 +80,7 @@
   ELL_3M_TRANSPOSE(evecTrans,evecs);
   ell_3m_mul_d(tmp,hessder,evecTrans);
   ell_3m_mul_d(hessderE,evecs,tmp);
-  
+
   if (ridge) {
     double diff=evals[1]-evals[2];
     double l3;
@@ -92,7 +92,7 @@
     hessderE[6]=hessderE[2];
     hessderE[5]*=(1.0-l3)/(evals[1]-evals[2]);
     hessderE[7]=hessderE[5];
-    
+
     if (diff<evalDiffThresh)
       l3der = 2/evalDiffThresh*(1-diff/evalDiffThresh)*
         (hessderE[8]-hessderE[4]);
@@ -111,7 +111,7 @@
     hessderE[3]=hessderE[1];
     hessderE[2]*=(l1-1.0)/(evals[0]-evals[2]);
     hessderE[6]=hessderE[2];
-    
+
     if (diff<evalDiffThresh)
       l1der = 2/evalDiffThresh*(1-diff/evalDiffThresh)*
         (hessderE[4]-hessderE[0]);
@@ -120,9 +120,9 @@
     hessderE[0]=l1der;
     hessderE[4]=hessderE[5]=hessderE[7]=hessderE[8]=0.0;
   }
-  
+
   ell_3m_mul_d(tmp,hessderE,evecs);
-  ell_3m_mul_d(Tder,evecTrans,tmp);  
+  ell_3m_mul_d(Tder,evecTrans,tmp);
 }
 
 static int
@@ -139,7 +139,7 @@
                         + ELL_3V_DOT(Tleft+6, Tleft+6)),
     denom_r = sqrt(ELL_3V_DOT(Tright,Tright) + ELL_3V_DOT(Tright+3, Tright+3)
                    + ELL_3V_DOT(Tright+6, Tright+6));
-  
+
   if (Tdp/(denom_l*denom_r)<dotThresh &&
       idxright-idxleft>0.24) { /* do a recursive step */
     double idxcenter = 0.5*(idxleft+idxright);
@@ -148,12 +148,12 @@
     double evals[3],evecs[9];
     double Tnew[9], gradnew[3];
     int retval;
-    
+
     ELL_3M_LERP(hessnew,0.5,hessleft,hessright);
     ell_3m_eigensolve_d(evals, evecs, hessnew, AIR_TRUE);
-    
+
     _seekHess2T(Tnew, evals, evecs, evalDiffThresh, ridge);
-    
+
     ELL_3V_LERP(gradnew,0.5,gleft,gright);
     retval = findFeatureIntersection(results, Tleft, hessleft,
                                      gleft, Tnew, hessnew, gradnew,
@@ -163,14 +163,14 @@
                                       gradnew, Tright, hessright, gright,
                                       idxcenter, idxright,
                                       ridge, evalDiffThresh, dotThresh);
-    return retval;    
+    return retval;
   } else {
     double d1[3], d4[3];
     ell_3mv_mul_d(d1, Tleft, gleft);
     ELL_3V_SUB(d1,d1,gleft);
     ell_3mv_mul_d(d4, Tright, gright);
     ELL_3V_SUB(d4,d4,gright);
-    
+
     if (ELL_3V_DOT(d1,d4)<0) { /* mark edge as crossed */
       /* find assumed intersection point */
       double diff[3], dlen, alpha;
@@ -181,7 +181,7 @@
         alpha = ap/dlen;
       } else
         alpha = 0.5;
-      
+
       *results = (1-alpha)*idxleft+alpha*idxright;
       return 1;
     }
@@ -207,21 +207,21 @@
   ELL_3V_SUB(tmp,tmp,gder);
   ell_3mv_mul_d(derxv,Tder,g);
   ELL_3V_ADD2(derxv,derxv,tmp);
-  
+
   ELL_3M_SUB(Tder,Typ,Tym);
   ELL_3V_SUB(gder,gyp,gym);
   ell_3mv_mul_d(tmp,T,gder);
   ELL_3V_SUB(tmp,tmp,gder);
   ell_3mv_mul_d(deryv,Tder,g);
   ELL_3V_ADD2(deryv,deryv,tmp);
-  
+
   ELL_3M_SUB(Tder,Tzp,Tzm);
   ELL_3V_SUB(gder,gzp,gzm);
   ell_3mv_mul_d(tmp,T,gder);
   ELL_3V_SUB(tmp,tmp,gder);
   ell_3mv_mul_d(derzv,Tder,g);
   ELL_3V_ADD2(derzv,derzv,tmp);
-  
+
   /* accumulate a gradient */
   tmp1[0]=derxv[0]; tmp1[1]=deryv[0]; tmp1[2]=derzv[0];
   tmp2[0]=derxv[1]; tmp2[1]=deryv[1]; tmp2[2]=derzv[1];
@@ -242,10 +242,10 @@
 {
   double Txm[9], Txp[9], Tym[9], Typ[9], Tzm[9], Tzp[9], T[9],
     gxm[3], gxp[3], gym[3], gyp[3], gzm[3], gzp[3], g[3];
-  
-  unsigned int sx = AIR_CAST(unsigned int, sctx->sx);
-  unsigned int sy = AIR_CAST(unsigned int, sctx->sy);
-  unsigned int sz = AIR_CAST(unsigned int, sctx->sz);
+
+  unsigned int sx = AIR_UINT(sctx->sx);
+  unsigned int sy = AIR_UINT(sctx->sy);
+  unsigned int sz = AIR_UINT(sctx->sz);
   unsigned int si = xi + sx*yi;
   unsigned int six = xi + 1 + sx*yi, siX = xi - 1 + sx*yi;
   unsigned int siy = xi + sx*(yi+1), siY = xi + sx*(yi-1);
@@ -512,14 +512,14 @@
                     char faceid, double *coords) {
   double T[9], Txm[9], Txp[9], Tym[9], Typ[9], Tzm[9], Tzp[9],
     g[3], gxm[3], gxp[3], gym[3], gyp[3], gzm[3], gzp[3];
-  unsigned int sx = AIR_CAST(unsigned int, sctx->sx);
-  unsigned int sy = AIR_CAST(unsigned int, sctx->sy);
+  unsigned int sx = AIR_UINT(sctx->sx);
+  unsigned int sy = AIR_UINT(sctx->sy);
   unsigned int si = xi + sx*yi;
   unsigned int six = xi + 1 + sx*yi, siX = xi - 1 + sx*yi;
   unsigned int siy = xi + sx*(yi+1), siY = xi + sx*(yi-1);
   unsigned int sixy = xi + 1 + sx*(yi+1), sixY = xi + 1 + sx*(yi-1),
     siXy = xi - 1 + sx*(yi+1);
-  
+
   /* Again, lots of special cases to fill Txm, gxm, etc. */
   switch (faceid) {
   case 0:
@@ -539,17 +539,17 @@
     ELL_3M_LERP(Txp, coords[1], sctx->t + 9*(0+2*six), sctx->t + 9*(0+2*sixy));
     ELL_3V_LERP(gxp, coords[1], sctx->grad + 3*(0+2*six),
                 sctx->grad + 3*(0+2*sixy));
-    
+
     ELL_3M_LERP(Tym, coords[0], sctx->t + 9*(0+2*si), sctx->t + 9*(0+2*six));
     ELL_3V_LERP(gym, coords[0], sctx->grad + 3*(0+2*si),
                 sctx->grad + 3*(0+2*six));
     ELL_3M_LERP(Typ, coords[0], sctx->t + 9*(0+2*siy), sctx->t + 9*(0+2*sixy));
     ELL_3V_LERP(gyp, coords[0], sctx->grad + 3*(0+2*siy),
                 sctx->grad + 3*(0+2*sixy));
-    
+
     ELL_3M_LERP(T, coords[0], Txm, Txp);
     ELL_3V_LERP(g, coords[0], gxm, gxp);
-    
+
     computeGradientLin(sctx->facenorm+3*(faceid+4*si), T, g,
                        Txm, gxm, Txp, gxp,
                        Tym, gym, Typ, gyp,
@@ -585,17 +585,17 @@
     ELL_3M_LERP(Txp, coords[1], sctx->t + 9*(0+2*six), sctx->t + 9*(1+2*six));
     ELL_3V_LERP(gxp, coords[1], sctx->grad + 3*(0+2*six),
                 sctx->grad + 3*(1+2*six));
-    
+
     ELL_3M_LERP(Tzm, coords[0], sctx->t + 9*(0+2*si), sctx->t + 9*(0+2*six));
     ELL_3V_LERP(gzm, coords[0], sctx->grad + 3*(0+2*si),
                 sctx->grad + 3*(0+2*six));
     ELL_3M_LERP(Tzp, coords[0], sctx->t + 9*(1+2*si), sctx->t + 9*(1+2*six));
     ELL_3V_LERP(gzp, coords[0], sctx->grad + 3*(1+2*si),
                 sctx->grad + 3*(1+2*six));
-    
+
     ELL_3M_LERP(T, coords[0], Txm, Txp);
     ELL_3V_LERP(g, coords[0], gxm, gxp);
-    
+
     if (yi!=sy-1) {
       computeGradientLin(sctx->facenorm+3*(faceid+4*si), T, g,
                          Txm, gxm, Txp, gxp,
@@ -638,17 +638,17 @@
     ELL_3M_LERP(Typ, coords[1], sctx->t + 9*(0+2*siy), sctx->t + 9*(1+2*siy));
     ELL_3V_LERP(gyp, coords[1], sctx->grad + 3*(0+2*siy),
                 sctx->grad + 3*(1+2*siy));
-    
+
     ELL_3M_LERP(Tzm, coords[0], sctx->t + 9*(0+2*si), sctx->t + 9*(0+2*siy));
     ELL_3V_LERP(gzm, coords[0], sctx->grad + 3*(0+2*si),
                 sctx->grad + 3*(0+2*siy));
     ELL_3M_LERP(Tzp, coords[0], sctx->t + 9*(1+2*si), sctx->t + 9*(1+2*siy));
     ELL_3V_LERP(gzp, coords[0], sctx->grad + 3*(1+2*si),
                 sctx->grad + 3*(1+2*siy));
-    
+
     ELL_3M_LERP(T, coords[0], Tym, Typ);
     ELL_3V_LERP(g, coords[0], gym, gyp);
-    
+
     if (xi!=sx-1) {
       computeGradientLin(sctx->facenorm+3*(faceid+4*si), T, g,
                          T, g, Txp, gxp,
@@ -678,17 +678,17 @@
     ELL_3M_LERP(Txp, coords[1], sctx->t + 9*(1+2*six), sctx->t + 9*(1+2*sixy));
     ELL_3V_LERP(gxp, coords[1], sctx->grad + 3*(1+2*six),
                 sctx->grad + 3*(1+2*sixy));
-    
+
     ELL_3M_LERP(Tym, coords[0], sctx->t + 9*(1+2*si), sctx->t + 9*(1+2*six));
     ELL_3V_LERP(gym, coords[0], sctx->grad + 3*(1+2*si),
                 sctx->grad + 3*(1+2*six));
     ELL_3M_LERP(Typ, coords[0], sctx->t + 9*(1+2*siy), sctx->t + 9*(1+2*sixy));
     ELL_3V_LERP(gyp, coords[0], sctx->grad + 3*(1+2*siy),
                 sctx->grad + 3*(1+2*sixy));
-    
+
     ELL_3M_LERP(T, coords[0], Txm, Txp);
     ELL_3V_LERP(g, coords[0], gxm, gxp);
-    
+
     computeGradientLin(sctx->facenorm+3*(faceid+4*si), T, g,
                        Txm, gxm, Txp, gxp,
                        Tym, gym, Typ, gyp,
@@ -736,12 +736,12 @@
   ELL_3V_SUB(diff2, t1v3, t1v1);
   ELL_3V_CROSS(n1,diff1,diff2);
   d1=-ELL_3V_DOT(n1,t1v1);
-  
+
   /* compute scaled signed distances of t2 to plane of t1 */
   t2sd1 = ELL_3V_DOT(n1, t2v1)+d1;
   t2sd2 = ELL_3V_DOT(n1, t2v2)+d1;
   t2sd3 = ELL_3V_DOT(n1, t2v3)+d1;
-  
+
   if (t2sd1==0 && t2sd2==0 && t2sd3==0) {
     /* coplanar case: handle in 2D */
     double t1v12d[2], t1v22d[2], t1v32d[2], t2v12d[2], t2v22d[2], t2v32d[2];
@@ -800,7 +800,7 @@
       t2s12sd=t2sd3; t2s2sd=t2sd1;
     } else
       return 0; /* all on the same side; no intersection */
-    
+
     /* same game for triangle 2 */
     ELL_3V_SUB(diff1, t2v2, t2v1);
     ELL_3V_SUB(diff2, t2v3, t2v1);
@@ -820,7 +820,7 @@
       t1s12sd=t1sd3; t1s2sd=t1sd1;
     } else
       return 0; /* all on the same side; no intersection */
-    
+
     /* both planes intersect in a line; check if the intervals on that
      * line intersect */
     ELL_3V_CROSS(D,n1,n2);
@@ -900,7 +900,7 @@
 
 /* suggests a connectivity for a non-trivial combination of
  * intersection points in the plane.
- * pairs is output (permutation of idcs) 
+ * pairs is output (permutation of idcs)
  * bestval is input/output (best value so far, start with something big)
  * ct is the number of points (currently assumed even)
  * idcs is input (idcs that still need to be permuted)
@@ -959,6 +959,8 @@
 #define _SEEK_TREATED_EDGE4 0x20 /* unique edge 4 has been treated */
 #define _SEEK_TREATED_FACE3 0x40 /* unique face 3 has been treated */
 
+#define CHAR(x) AIR_CAST(char, x)
+
 /* find deg. points, normals, and connectivity on a given (unique) face
  * now refines the search if it couldn't find a degenerate point */
 static void
@@ -968,7 +970,7 @@
                     {0, 5, 8, 4},
                     {1, 6, 9, 4},
                     {8,10,11, 9}};
-  unsigned int sx = AIR_CAST(unsigned int, sctx->sx);
+  unsigned int sx = AIR_UINT(sctx->sx);
   unsigned int si = xi + sx*yi;
   unsigned int six = xi + 1 + sx*yi;
   unsigned int siy = xi + sx*(yi+1);
@@ -999,7 +1001,7 @@
                          0.25,0.5,  0.75,0.5,  0.6,0.75};
   int cand_idx[4]={0, 1, 5, 9};
   int interct;
-  
+
   /* apparently, some C compilers cannot make these initializations in-place */
   ELL_4V_SET(verti[0], 0+2*si, 0+2*six, 0+2*siy, 0+2*sixy);
   ELL_4V_SET(verti[1], 0+2*si, 0+2*six, 1+2*si, 1+2*six);
@@ -1017,7 +1019,7 @@
   ELL_4V_SET(verte[1], 0+2*six, 1+2*six, 1+2*six, 1+2*si);
   ELL_4V_SET(verte[2], 0+2*siy, 1+2*siy, 1+2*siy, 1+2*si);
   ELL_4V_SET(verte[3], 1+2*six, 1+2*sixy, 1+2*sixy, 1+2*siy);
-  
+
   /* find out which edges have not yet been treated */
   for (i=0; i<4; i++) {
     if (!(sctx->treated[voxel[faceid][i]]&mask[faceid][i])) {
@@ -1025,7 +1027,7 @@
       sctx->treated[voxel[faceid][i]] |= mask[faceid][i];
     }
   }
-  
+
   for (pass=0; pass<3; pass++) {
     /* first, find intersections for edges that need treatment */
     int j;
@@ -1076,20 +1078,20 @@
                    x, y, z);
         computeEdgeGradient(sctx, bag, sctx->edgenorm+
                             9*(bag->evti[edgeid[faceid][j]]+5*si)+3*i,
-                            xb, yb, idb, interpos[i]);
+                            xb, yb, CHAR(idb), interpos[i]);
       }
     }
-    
+
     interct=0; /* number of feature intersections */
     for (i=0; i<3; i++) {
       if (sctx->edgealpha[3*(bag->evti[edgeid[faceid][0]]+5*si)+i]>=0)
-        inter[interct++]=i; /* numbering is local w.r.t. face */
+        inter[interct++]=CHAR(i); /* numbering is local w.r.t. face */
       if (sctx->edgealpha[3*(bag->evti[edgeid[faceid][1]]+5*si)+i]>=0)
-        inter[interct++]=3+i;
+        inter[interct++]=CHAR(3+i);
       if (sctx->edgealpha[3*(bag->evti[edgeid[faceid][2]]+5*si)+i]>=0)
-        inter[interct++]=6+i;
+        inter[interct++]=CHAR(6+i);
       if (sctx->edgealpha[3*(bag->evti[edgeid[faceid][3]]+5*si)+i]>=0)
-        inter[interct++]=9+i;
+        inter[interct++]=CHAR(9+i);
     }
     if (interct%2==1) { /* we need to look for a degeneracy */
       int k;
@@ -1138,7 +1140,7 @@
       break;
     }
   }
-  
+
   if (interct<=1) { /* there is no connectivity on this face */
     ELL_4V_SET(sctx->pairs+12*(faceid+4*si),-1,-1,-1,-1);
   } else if (interct==2) { /* connectivity is straightforward */
@@ -1177,7 +1179,7 @@
           ELL_2V_SET(intern+2*i,
                      sctx->edgenorm[9*(bag->evti[resolved]+5*si)+3*offset+1],
                      sctx->edgenorm[9*(bag->evti[resolved]+5*si)+3*offset+2]);
-          break;   
+          break;
         }
       } else { /* face feature */
         switch (faceid) {
@@ -1198,13 +1200,13 @@
                      sctx->faceicoord[3*(faceid+4*si)+2]);
           ELL_2V_SET(intern+2*i, sctx->facenorm[3*(faceid+4*si)+1],
                      sctx->facenorm[3*(faceid+4*si)+2]);
-          break;   
+          break;
         }
       }
     }
     for (i=0; i<interct; i++) {
-      sctx->pairs[12*(faceid+4*si)+i]=i;
-      idcs[i]=i;
+      sctx->pairs[12*(faceid+4*si)+i]=CHAR(i);
+      idcs[i]=CHAR(i);
     }
     findConnectivity(sctx->pairs+12*(faceid+4*si), &bestscore, interct,
                      idcs, 0, interc, intern);
@@ -1219,10 +1221,10 @@
 intersectionShuffleProbe(seekContext *sctx, baggage *bag) {
   unsigned int xi, yi, sx, sy, si;
   int i;
-  
-  sx = AIR_CAST(unsigned int, sctx->sx);
-  sy = AIR_CAST(unsigned int, sctx->sy);
-  
+
+  sx = AIR_UINT(sctx->sx);
+  sy = AIR_UINT(sctx->sy);
+
   for (yi=0; yi<sy; yi++) {
     for (xi=0; xi<sx; xi++) {
       si = xi + sx*yi;
@@ -1234,9 +1236,9 @@
       }
       sctx->facevidx[1 + 4*si] = sctx->facevidx[2 + 4*si] =
         sctx->facevidx[3 + 4*si] = -1;
-      
+
       /* copy or reset data on the 5 unique edges */
-      
+
       if (sctx->treated[si]&_SEEK_TREATED_EDGE3) {
         /* has been treated, just copy results */
         ELL_3V_COPY(sctx->edgealpha+3*(0+5*si), sctx->edgealpha+3*(3+5*si));
@@ -1247,7 +1249,7 @@
         ELL_3V_SET(sctx->edgealpha+3*(0+5*si),-1,-1,-1);
         sctx->treated[si]&=0xFF^_SEEK_TREATED_EDGE0;
       }
-      
+
       if (sctx->treated[si]&_SEEK_TREATED_EDGE4) {
         /* has been treated, just copy results */
         ELL_3V_COPY(sctx->edgealpha+3*(1+5*si), sctx->edgealpha+3*(4+5*si));
@@ -1258,19 +1260,19 @@
         ELL_3V_SET(sctx->edgealpha+3*(1+5*si),-1,-1,-1);
         sctx->treated[si]&=0xFF^_SEEK_TREATED_EDGE1;
       }
-      
+
       /* edges within and at top of the slab are new */
       ELL_3V_SET(sctx->edgealpha+3*(2+5*si),-1,-1,-1);
       sctx->treated[si]&=0xFF^_SEEK_TREATED_EDGE2;
-      
+
       ELL_3V_SET(sctx->edgealpha+3*(3+5*si),-1,-1,-1);
       sctx->treated[si]&=0xFF^_SEEK_TREATED_EDGE3;
-      
+
       ELL_3V_SET(sctx->edgealpha+3*(4+5*si),-1,-1,-1);
       sctx->treated[si]&=0xFF^_SEEK_TREATED_EDGE4;
     }
   }
-  
+
   /* find missing deg. points, edge intersections, normals, and
    * connectivity on the four unique faces
    * this is done in a separate pass to make sure that all edge information
@@ -1296,7 +1298,7 @@
             (yi!=0 && sctx->treated[xi+sx*(yi-1)]&_SEEK_TREATED_REQUEST))
           connectFace(sctx, bag, xi, yi, 1);
         else ELL_4V_SET(sctx->pairs+12*(1+4*si),-1,-1,-1,-1);
-      }      
+      }
       if (yi!=sy-1) {
         if (sctx->treated[si]&_SEEK_TREATED_REQUEST ||
             (xi!=0 && sctx->treated[xi-1+sx*yi]&_SEEK_TREATED_REQUEST))
@@ -1320,7 +1322,7 @@
 int
 _seekTriangulateT(seekContext *sctx, baggage *bag, limnPolyData *lpld) {
   unsigned xi, yi, sx, sy, si, i;
-  
+
   /* map edge indices w.r.t. faces (as used in sctx->pairs) back to
    * edge indices w.r.t. voxel */
   char edges[6][5]={{0, 2, 3, 1,12},
@@ -1329,19 +1331,19 @@
                     {3, 7,11, 6,15},
                     {1, 6, 9, 4,16},
                     {8,10,11, 9,17}};
-  
-  sx = AIR_CAST(unsigned int, sctx->sx);
-  sy = AIR_CAST(unsigned int, sctx->sy);
-  
+
+  sx = AIR_UINT(sctx->sx);
+  sy = AIR_UINT(sctx->sy);
+
   for (yi=0; yi<sy-1; yi++) {
     for (xi=0; xi<sx-1; xi++) {
       int fvti[6]; /* indices into unique face array */
       char connections[84];/* (12 edges * 3 possible intersections+6 faces)*2 */
       char degeneracies[6];
       int degct=0;
-      
+
       unsigned int face;
-      
+
       if (sctx->strengthUse && sctx->stng[0+2*(xi+sx*yi)] < sctx->strength &&
           sctx->stng[1+2*(xi+sx*yi)] < sctx->strength &&
           sctx->stng[0+2*(xi+1+sx*yi)] < sctx->strength &&
@@ -1351,11 +1353,11 @@
           sctx->stng[0+2*(xi+1+sx*(yi+1))] < sctx->strength &&
           sctx->stng[1+2*(xi+1+sx*(yi+1))] < sctx->strength)
         continue;/* all vertices below strength limit, do not create geometry */
-      
+
       si = xi + sx*yi;
       ELL_3V_SET(fvti, 0 + 4*si, 1 + 4*si, 2 + 4*(xi+1 + sx*yi));
       ELL_3V_SET(fvti+3, 1 + 4*(xi + sx*(yi+1)), 2 + 4*si, 3 + 4*si);
-      
+
       /* collect all intersection + connectivity info for this voxel */
       memset(connections,-1,sizeof(connections));
       for (face=0; face<6; face++) {
@@ -1370,24 +1372,24 @@
           idxmap2=3*idx2+offset2;
           if (idx1>11) {
             idxmap1=idx1+24; /* +36-12 */
-            degeneracies[degct++] = idxmap1;
+            degeneracies[degct++] = CHAR(idxmap1);
           }
           if (idx2>11) {
             idxmap2=idx2+24;
-            degeneracies[degct++] = idxmap2;
+            degeneracies[degct++] = CHAR(idxmap2);
           }
-          
+
           if (connections[2*idxmap1]==-1)
-            connections[2*idxmap1]=idxmap2;
+            connections[2*idxmap1]=CHAR(idxmap2);
           else
-            connections[2*idxmap1+1]=idxmap2;
+            connections[2*idxmap1+1]=CHAR(idxmap2);
           if (connections[2*idxmap2]==-1)
-            connections[2*idxmap2]=idxmap1;
+            connections[2*idxmap2]=CHAR(idxmap1);
           else
-            connections[2*idxmap2+1]=idxmap1;
+            connections[2*idxmap2+1]=CHAR(idxmap1);
         }
       }
-      
+
       /* connect the degenerate points */
       if (degct==2) {
         connections[2*degeneracies[0]+1]=degeneracies[1];
@@ -1539,7 +1541,7 @@
         connections[2*degeneracies[pairings[bestchoice][5]]+1]=
           degeneracies[pairings[bestchoice][4]];
       }
-      
+
       /* sufficient to run to 36: each polygon will contain at least
        * one edge vertex */
       for (i=0; i<36; i++) {
@@ -1547,9 +1549,9 @@
           /* extract polygon from connections array */
           signed char polygon[42];
           unsigned char polyct=0;
-          char thiz=i;
+          char thiz=CHAR(i);
           char next=connections[2*i];
-          polygon[polyct++]=i;
+          polygon[polyct++]=CHAR(i);
           connections[2*i]=-1;
           while (next!=-1) {
             char helpnext;
@@ -1575,25 +1577,25 @@
                   int ovi;
                   ELL_3V_COPY(tvertA, sctx->edgeicoord+3*eidx);
                   tvertA[3]=1.0;
-                  
+
                   /* tvertB in input index space */
                   ELL_4MV_MUL(tvertB, sctx->txfIdx, tvertA);
                   /* tvertA in world space */
                   ELL_4MV_MUL(tvertA, sctx->shape->ItoW, tvertB);
                   ELL_4V_HOMOG(tvertA, tvertA);
-                  
-                  ovi = sctx->vidx[eidx] = 
+
+                  ovi = sctx->vidx[eidx] =
                     airArrayLenIncr(bag->xyzwArr, 1);
                   ELL_4V_SET_TT(lpld->xyzw + 4*ovi, float,
                                 tvertA[0], tvertA[1], tvertA[2], 1.0);
-                  
+
                   if (sctx->normalsFind) {
                     double len=ELL_3V_LEN(sctx->edgenorm+3*eidx);
                     airArrayLenIncr(bag->normArr, 1);
                     ELL_3V_SCALE_TT(lpld->norm + 3*ovi, float, 1.0/len,
                                     sctx->edgenorm+3*eidx);
                   }
-                  
+
                   sctx->vertNum++;
                 }
               } else { /* we may need to insert a face vertex */
@@ -1607,20 +1609,20 @@
                   /* tvertA in world space */
                   ELL_4MV_MUL(tvertA, sctx->shape->ItoW, tvertB);
                   ELL_4V_HOMOG(tvertA, tvertA);
-                  
-                  ovi = sctx->facevidx[fidx] = 
+
+                  ovi = sctx->facevidx[fidx] =
                     airArrayLenIncr(bag->xyzwArr, 1);
                   ELL_4V_SET_TT(lpld->xyzw + 4*ovi, float,
                                 tvertA[0], tvertA[1], tvertA[2], 1.0);
-                  
+
                   if (sctx->normalsFind) {
                     double len=ELL_3V_LEN(sctx->facenorm+3*fidx);
                     airArrayLenIncr(bag->normArr, 1);
                     ELL_3V_SCALE_TT(lpld->norm + 3*ovi, float, 1.0/len,
                                     sctx->facenorm+3*fidx);
                   }
-                  
-                  sctx->vertNum++;    
+
+                  sctx->vertNum++;
                 }
               }
             }
@@ -1629,7 +1631,7 @@
                 normsum[3]={0,0,0};
                 int ovi;
                 unsigned int vii[3];
-                
+
                 for (j=0; j<polyct; j++) {
                   if (polygon[j]<36) {
                     int eidx=3*(bag->evti[polygon[j]/3] + 5*si)+polygon[j]%3;
@@ -1656,7 +1658,7 @@
                 /* tvertA in world space */
                 ELL_4MV_MUL(tvertA, sctx->shape->ItoW, tvertB);
                 ELL_4V_HOMOG(tvertA, tvertA);
-                
+
                 ovi = airArrayLenIncr(bag->xyzwArr, 1);
                 ELL_4V_SET_TT(lpld->xyzw + 4*ovi, float,
                               tvertA[0], tvertA[1], tvertA[2], 1.0);
@@ -1666,7 +1668,7 @@
                   ELL_3V_SCALE_TT(lpld->norm + 3*ovi, float, 1.0/len, normsum);
                 }
                 sctx->vertNum++;
-                
+
                 vii[0]=ovi;
                 vii[1]=sctx->vidx[3*(bag->evti[polygon[0]/3]+5*si)+polygon[0]%3];
                 for (j=0; j<polyct; ++j) {
@@ -1684,7 +1686,7 @@
                                         polygon[j+1]%3];
                     else vii[1]=sctx->facevidx[fvti[polygon[j+1]-36]];
                   }
-                  
+
                   /* check for degenerate tris */
                   ELL_3V_SUB(edgeA, lpld->xyzw+4*vii[1], lpld->xyzw+4*vii[0]);
                   ELL_3V_SUB(edgeB, lpld->xyzw+4*vii[2], lpld->xyzw+4*vii[0]);
@@ -1719,7 +1721,7 @@
               ELL_3V_COPY(lpld->indx + iii, vii);
               lpld->icnt[0] += 3;
               sctx->faceNum++;
-              
+
               if (polyct==4) {
                 vii[1]=vii[2];
                 if (polygon[3]<36)
@@ -1740,13 +1742,15 @@
   return 0;
 }
 
+#undef CHAR
+
 static void
 shuffleT(seekContext *sctx, baggage *bag) {
   unsigned int xi, yi, sx, sy, si;
-  
-  sx = AIR_CAST(unsigned int, sctx->sx);
-  sy = AIR_CAST(unsigned int, sctx->sy);
-  
+
+  sx = AIR_UINT(sctx->sx);
+  sy = AIR_UINT(sctx->sy);
+
   if (sctx->strengthUse) { /* requests need to be cleared initially */
     for (yi=0; yi<sy; yi++) {
       for (xi=0; xi<sx; xi++) {
@@ -1754,11 +1758,11 @@
       }
     }
   } /* else, the request bits are always on */
-  
+
   for (yi=0; yi<sy; yi++) {
     for (xi=0; xi<sx; xi++) {
       si = xi + sx*yi;
-      
+
       /* vidx neither needs past nor future context */
       if (!bag->zi) {
         ELL_3V_SET(sctx->vidx+3*(0+5*si), -1, -1, -1);
@@ -1770,7 +1774,7 @@
       ELL_3V_SET(sctx->vidx+3*(2+5*si),-1,-1,-1);
       ELL_3V_SET(sctx->vidx+3*(3+5*si),-1,-1,-1);
       ELL_3V_SET(sctx->vidx+3*(4+5*si),-1,-1,-1);
-      
+
       /* strength only has future context */
       if (sctx->strengthUse) {
         sctx->stng[0 + 2*si] = sctx->stng[1 + 2*si];
@@ -1785,18 +1789,18 @@
             sctx->treated[xi-1+sx*(yi-1)] |= _SEEK_TREATED_REQUEST;
         }
       }
-      
+
       /* shuffle grad, hess and t in three steps: move to past context,
        * shuffle in slab itself, move from future context */
-      
+
       ELL_3V_COPY(sctx->gradcontext + 3*(0+2*si), sctx->grad + 3*(0+2*si));
       ELL_3V_COPY(sctx->grad + 3*(0+2*si), sctx->grad + 3*(1+2*si));
       ELL_3V_COPY(sctx->grad + 3*(1+2*si), sctx->gradcontext + 3*(1+2*si));
-      
+
       ELL_3M_COPY(sctx->hesscontext + 9*(0+2*si), sctx->hess + 9*(0+2*si));
       ELL_3M_COPY(sctx->hess + 9*(0+2*si), sctx->hess + 9*(1+2*si));
       ELL_3M_COPY(sctx->hess + 9*(1+2*si), sctx->hesscontext + 9*(1+2*si));
-      
+
       ELL_3M_COPY(sctx->tcontext + 9*(0+2*si), sctx->t + 9*(0+2*si));
       ELL_3M_COPY(sctx->t + 9*(0+2*si), sctx->t + 9*(1+2*si));
       ELL_3M_COPY(sctx->t + 9*(1+2*si), sctx->tcontext + 9*(1+2*si));
@@ -1807,14 +1811,14 @@
 static void
 probeT(seekContext *sctx, baggage *bag, double zi) {
   unsigned int xi, yi, sx, sy, si;
-  
-  sx = AIR_CAST(unsigned int, sctx->sx);
-  sy = AIR_CAST(unsigned int, sctx->sy);
-  
+
+  sx = AIR_UINT(sctx->sx);
+  sy = AIR_UINT(sctx->sy);
+
   for (yi=0; yi<sy; yi++) {
     for (xi=0; xi<sx; xi++) {
       si = xi + sx*yi;
-      
+
       if (sctx->gctx) { /* HEY: need this check, what's the right way? */
         _seekIdxProbe(sctx, bag, xi, yi, zi);
       }
@@ -1842,7 +1846,7 @@
   /* for high-quality normal estimation, we need two slices of data
    * context; to keep the code simple, separate shuffle and probe
    * operations - let's hope this doesn't destroy cache performance */
-  
+
   if (!bag->zi) {
     if (sctx->strengthUse)
       /* before the first round, initialize treated to zero */
@@ -1857,9 +1861,9 @@
   shuffleT(sctx, bag);
   if (bag->zi!=sctx->sz-2)
     probeT(sctx, bag, bag->zi+2);
-  
+
   intersectionShuffleProbe(sctx, bag);
-  
+
   return 0;
 }
 
@@ -1883,7 +1887,7 @@
   unsigned int i;
   double *data;
   int E=0;
-  
+
   if (!(nval && sctx && pld)) {
     biffAddf(SEEK, "%s: got NULL pointer", me);
     return 1;
@@ -1901,7 +1905,7 @@
     biffAddf(SEEK, "%s: could not allocate output", me);
     return 1;
   }
-  
+
   data = (double*) nval->data;
   for (i=0; i<pld->xyzwNum; i++) {
     float homog[4];
diff --color -ruN teem-1.11.0-src.orig/src/seek/updateSeek.c teem-1.11.0-src/src/seek/updateSeek.c
--- teem-1.11.0-src.orig/src/seek/updateSeek.c	2012-12-20 22:09:15.000000000 +0800
+++ teem-1.11.0-src/src/seek/updateSeek.c	2021-02-18 15:42:34.000000000 +0800
@@ -252,12 +252,12 @@
         biffAddf(SEEK,
                  "%s: can't specify # samples (%u,%u,%u) independent of "
                  "volume dimensions (%u,%u,%u) without a gage context", me,
-                 AIR_CAST(unsigned int, sctx->samples[0]),
-                 AIR_CAST(unsigned int, sctx->samples[1]),
-                 AIR_CAST(unsigned int, sctx->samples[2]),
-                 AIR_CAST(unsigned int, sizeIn[0]),
-                 AIR_CAST(unsigned int, sizeIn[1]),
-                 AIR_CAST(unsigned int, sizeIn[2]));
+                 AIR_UINT(sctx->samples[0]),
+                 AIR_UINT(sctx->samples[1]),
+                 AIR_UINT(sctx->samples[2]),
+                 AIR_UINT(sizeIn[0]),
+                 AIR_UINT(sizeIn[1]),
+                 AIR_UINT(sizeIn[2]));
         return 1;
       }
       ELL_3V_COPY(sizeOut, sctx->samples);
@@ -661,10 +661,10 @@
         return 1;
       }
       spanHist = AIR_CAST(unsigned int*, sctx->nspanHist->data);
-      sx = sctx->sx;
-      sy = sctx->sy;
-      sz = sctx->sz;
-      ss = sctx->spanSize;
+      sx = AIR_UINT(sctx->sx);
+      sy = AIR_UINT(sctx->sy);
+      sz = AIR_UINT(sctx->sz);
+      ss = AIR_UINT(sctx->spanSize);
       for (si=0; si<ss*ss; si++) {
         spanHist[si] = 0;
       }
diff --color -ruN teem-1.11.0-src.orig/src/ten/aniso.c teem-1.11.0-src/src/ten/aniso.c
--- teem-1.11.0-src.orig/src/ten/aniso.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/aniso.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -325,11 +325,10 @@
 float  _tenAnisoEval_RA_f(const float  eval[3]) {
   float mean, stdv;
   mean = (eval[0] + eval[1] + eval[2])/3;
-  stdv = AIR_CAST(float,
-                  sqrt((mean-eval[0])*(mean-eval[0])   /* not exactly stdv */
-                       + (mean-eval[1])*(mean-eval[1])
-                       + (mean-eval[2])*(mean-eval[2])));
-  return mean ? AIR_CAST(float, stdv/(mean*SQRT6)) : 0.0f;
+  stdv = AIR_FLOAT(sqrt((mean-eval[0])*(mean-eval[0])   /* not exactly stdv */
+                        + (mean-eval[1])*(mean-eval[1])
+                        + (mean-eval[2])*(mean-eval[2])));
+  return mean ? AIR_FLOAT(stdv/(mean*SQRT6)) : 0.0f;
 }
 double _tenAnisoEval_RA_d(const double eval[3]) {
   double mean, stdv;
@@ -343,8 +342,8 @@
   float mn, stdv, dev[7];
   mn = TEN_T_TRACE(tt)/3;
   TEN_T_SET(dev, tt[0], tt[1]-mn, tt[2], tt[3], tt[4]-mn, tt[5], tt[6]-mn);
-  stdv = AIR_CAST(float, sqrt(TEN_T_DOT(dev, dev)));
-  return mn ? AIR_CAST(float, stdv/(mn*SQRT6)) : 0.0f;
+  stdv = AIR_FLOAT(sqrt(TEN_T_DOT(dev, dev)));
+  return mn ? AIR_FLOAT(stdv/(mn*SQRT6)) : 0.0f;
 }
 double _tenAnisoTen_RA_d(const double tt[7]) {
   double mn, stdv, dev[7];
@@ -359,11 +358,10 @@
   float denom, mean, stdv;
   denom = 2.0f*(eval[0]*eval[0] + eval[1]*eval[1] + eval[2]*eval[2]);
   mean = (eval[0] + eval[1] + eval[2])/3;
-  stdv = AIR_CAST(float,
-                  (mean-eval[0])*(mean-eval[0]) /* not exactly stdv */
-                  + (mean-eval[1])*(mean-eval[1])
-                  + (mean-eval[2])*(mean-eval[2]));
-  return denom ? AIR_CAST(float, sqrt(3.0*stdv/denom)) : 0.0f;
+  stdv = AIR_FLOAT((mean-eval[0])*(mean-eval[0]) /* not exactly stdv */
+                   + (mean-eval[1])*(mean-eval[1])
+                   + (mean-eval[2])*(mean-eval[2]));
+  return denom ? AIR_FLOAT(sqrt(3.0*stdv/denom)) : 0.0f;
 }
 double _tenAnisoEval_FA_d(const double eval[3]) {
   double denom, mean, stdv;
@@ -376,11 +374,11 @@
 }
 float  _tenAnisoTen_FA_f(const float  tt[7]) {
   float denom, mn, stdv, dev[7];
-  denom = AIR_CAST(float, 2.0*TEN_T_DOT(tt, tt));
+  denom = AIR_FLOAT(2.0*TEN_T_DOT(tt, tt));
   mn = TEN_T_TRACE(tt)/3;
   TEN_T_SET(dev, tt[0], tt[1]-mn, tt[2], tt[3], tt[4]-mn, tt[5], tt[6]-mn);
   stdv = TEN_T_DOT(dev, dev);
-  return denom ? AIR_CAST(float, sqrt(3.0*stdv/denom)) : 0.0f;
+  return denom ? AIR_FLOAT(sqrt(3.0*stdv/denom)) : 0.0f;
 }
 double _tenAnisoTen_FA_d(const double tt[7]) {
   double denom, mn, stdv, dev[7];
@@ -388,7 +386,7 @@
   mn = TEN_T_TRACE(tt)/3;
   TEN_T_SET(dev, tt[0], tt[1]-mn, tt[2], tt[3], tt[4]-mn, tt[5], tt[6]-mn);
   stdv = TEN_T_DOT(dev, dev);
-  return denom ? AIR_CAST(float, sqrt(3.0*stdv/denom)) : 0.0;
+  return denom ? AIR_FLOAT(sqrt(3.0*stdv/denom)) : 0.0;
 }
 
 
@@ -514,9 +512,9 @@
   ELL_3V_SET(eval, _eval[0] - mn, _eval[1] - mn, _eval[2] - mn);
   Q = _tenAnisoEval_Q_f(eval);
   num = _tenAnisoEval_R_f(eval);
-  dnm = AIR_CAST(float, Q*sqrt(2*Q));
-  ret = dnm ? AIR_CAST(float, num/dnm) : 0.0f;
-  return AIR_CAST(float, AIR_CLAMP(-OOSQRT2, ret, OOSQRT2));
+  dnm = AIR_FLOAT(Q*sqrt(2*Q));
+  ret = dnm ? AIR_FLOAT(num/dnm) : 0.0f;
+  return AIR_FLOAT(AIR_CLAMP(-OOSQRT2, ret, OOSQRT2));
 }
 double _tenAnisoEval_Skew_d(const double _eval[3]) {
   double Q, num, dnm, ret, mn, eval[3];
@@ -534,9 +532,9 @@
   TEN_T_SET(ten, _t[0], _t[1]-mn, _t[2], _t[3], _t[4]-mn, _t[5], _t[6]-mn);
   Q = _tenAnisoTen_Q_f(ten);
   num = _tenAnisoTen_R_f(ten);
-  dnm = AIR_CAST(float, Q*sqrt(2*Q));
-  ret = dnm ? AIR_CAST(float, num/dnm) : 0.0f;
-  return AIR_CAST(float, AIR_CLAMP(-OOSQRT2, ret, OOSQRT2));
+  dnm = AIR_FLOAT(Q*sqrt(2*Q));
+  ret = dnm ? AIR_FLOAT(num/dnm) : 0.0f;
+  return AIR_FLOAT(AIR_CLAMP(-OOSQRT2, ret, OOSQRT2));
 }
 double _tenAnisoTen_Skew_d(const double _t[7]) {
   double Q, num, dnm, ret, mn, ten[7];
@@ -557,9 +555,9 @@
   n = (e[0] + e[1] - 2*e[2])*(2*e[0] - e[1] - e[2])*(e[0] - 2*e[1] + e[2]);
   d = (e[0]*e[0] + e[1]*e[1] + e[2]*e[2]
        - e[0]*e[1] - e[1]*e[2] - e[0]*e[2]);
-  d = AIR_CAST(float, sqrt(AIR_MAX(0, d)));
+  d = AIR_FLOAT(sqrt(AIR_MAX(0, d)));
   d = 2*d*d*d;
-  ret = d ? AIR_CAST(float, n/d) : 0.0f;
+  ret = d ? AIR_FLOAT(n/d) : 0.0f;
   return AIR_CLAMP(-1, ret, 1);
 }
 double _tenAnisoEval_Mode_d(const double _eval[3]) {
@@ -578,10 +576,10 @@
   float mn, dev[7], tmp, ret;
   mn = TEN_T_TRACE(tt)/3.0f;
   TEN_T_SET(dev, tt[0], tt[1]-mn, tt[2], tt[3], tt[4]-mn, tt[5], tt[6]-mn);
-  tmp = AIR_CAST(float, TEN_T_NORM(dev));
+  tmp = AIR_FLOAT(TEN_T_NORM(dev));
   tmp = tmp ? 1.0f/tmp : 0.0f;
   TEN_T_SCALE(dev, tmp, dev);
-  ret = AIR_CAST(float, 3*SQRT6*TEN_T_DET(dev));
+  ret = AIR_FLOAT(3*SQRT6*TEN_T_DET(dev));
   return AIR_CLAMP(-1, ret, 1);
 }
 double _tenAnisoTen_Mode_d(const double tt[7]) {
@@ -601,8 +599,8 @@
 #define SQRT2 1.41421356237309504880
 float  _tenAnisoEval_Th_f(const float  eval[3]) {
   float tmp;
-  tmp = AIR_CAST(float, SQRT2*_tenAnisoEval_Skew_f(eval));
-  return AIR_CAST(float, acos(AIR_CLAMP(-1, tmp, 1))/3);
+  tmp = AIR_FLOAT(SQRT2*_tenAnisoEval_Skew_f(eval));
+  return AIR_FLOAT(acos(AIR_CLAMP(-1, tmp, 1))/3);
 }
 double _tenAnisoEval_Th_d(const double eval[3]) {
   double tmp;
@@ -611,8 +609,8 @@
 }
 float  _tenAnisoTen_Th_f(const float  ten[7]) {
   float tmp;
-  tmp = AIR_CAST(float, SQRT2*_tenAnisoTen_Skew_f(ten));
-  return AIR_CAST(float, acos(AIR_CLAMP(-1, tmp, 1))/3);
+  tmp = AIR_FLOAT(SQRT2*_tenAnisoTen_Skew_f(ten));
+  return AIR_FLOAT(acos(AIR_CLAMP(-1, tmp, 1))/3);
 }
 double _tenAnisoTen_Th_d(const double ten[7]) {
   double tmp;
@@ -932,16 +930,15 @@
   c[tenAniso_Ct2] = ca ? cp/ca : 0.0f;
   /* non-westin anisos */
   mean = sum/3.0f;
-  stdv = AIR_CAST(float,
-                  sqrt((mean-e0)*(mean-e0) /* okay, not exactly standard dev */
-                       + (mean-e1)*(mean-e1)
-                       + (mean-e2)*(mean-e2)));
-  ra = mean ? AIR_CAST(float, stdv/(mean*SQRT6)) : 0.0f;
+  stdv = AIR_FLOAT(sqrt((mean-e0)*(mean-e0) /* okay, not exactly standard dev */
+                        + (mean-e1)*(mean-e1)
+                        + (mean-e2)*(mean-e2)));
+  ra = mean ? AIR_FLOAT(stdv/(mean*SQRT6)) : 0.0f;
   ra = AIR_CLAMP(0.0f, ra, 1.0f);
   c[tenAniso_RA] = ra;
   denom = 2.0f*(e0*e0 + e1*e1 + e2*e2);
   if (denom) {
-    fa = AIR_CAST(float, stdv*sqrt(3.0/denom));
+    fa = AIR_FLOAT(stdv*sqrt(3.0/denom));
     fa = AIR_CLAMP(0.0f, fa, 1.0f);
   } else {
     fa = 0.0f;
@@ -957,14 +954,14 @@
   Q = c[tenAniso_Q] = (A*A - 3*B)/9;
   R = c[tenAniso_R] = (-2*A*A*A + 9*A*B - 27*C)/54;
   c[tenAniso_S] = e0*e0 + e1*e1 + e2*e2;
-  c[tenAniso_Skew] = Q ? AIR_CAST(float, R/(Q*sqrt(2*Q))) : 0.0f;
+  c[tenAniso_Skew] = Q ? AIR_FLOAT(R/(Q*sqrt(2*Q))) : 0.0f;
   c[tenAniso_Skew] = AIR_CLAMP(-OOSQRT2, c[tenAniso_Skew], OOSQRT2);
   N = (e0 + e1 - 2*e2)*(2*e0 - e1 - e2)*(e0 - 2*e1 + e2);
-  D = AIR_CAST(float, sqrt(e0*e0+e1*e1+e2*e2 - e0*e1-e1*e2-e0*e2));
+  D = AIR_FLOAT(sqrt(e0*e0+e1*e1+e2*e2 - e0*e1-e1*e2-e0*e2));
   c[tenAniso_Mode] = D ? N/(2*D*D*D) : 0.0f;
   c[tenAniso_Mode] = AIR_CLAMP(-1, c[tenAniso_Mode], 1);
   c[tenAniso_Th] =
-    AIR_CAST(float, acos(AIR_CLAMP(-1, sqrt(2)*c[tenAniso_Skew], 1))/3);
+    AIR_FLOAT(acos(AIR_CLAMP(-1, sqrt(2)*c[tenAniso_Skew], 1))/3);
   c[tenAniso_Omega] = c[tenAniso_FA]*(1+c[tenAniso_Mode])/2;
   c[tenAniso_Det] = e0*e1*e2;
   c[tenAniso_Tr] = e0 + e1 + e2;
@@ -1017,8 +1014,8 @@
   for (y=0; y<res; y++) {
     for (x=0; x<=y; x++) {
       /* (c0,c1,c2) are the barycentric coordinates */
-      c0 = AIR_CAST(float, 1.0 - AIR_AFFINE(-0.5, y, res-0.5, 0.0, 1.0));
-      c2 = AIR_CAST(float, AIR_AFFINE(-0.5, x, res-0.5, 0.0, 1.0));
+      c0 = AIR_FLOAT(1.0 - AIR_AFFINE(-0.5, y, res-0.5, 0.0, 1.0));
+      c2 = AIR_FLOAT(AIR_AFFINE(-0.5, x, res-0.5, 0.0, 1.0));
       c1 = 1 - c0 - c2;
       e[0] = c0*m0[0] + c1*m1[0] + c2*m2[0];
       e[1] = c0*m0[1] + c1*m1[1] + c2*m2[1];
@@ -1091,10 +1088,10 @@
                out[I],
                tensor[0], tensor[1], tensor[2], tensor[3],
                tensor[4], tensor[5], tensor[6],
-               AIR_CAST(unsigned int, I),
-               AIR_CAST(unsigned int, coord[0]),
-               AIR_CAST(unsigned int, coord[1]),
-               AIR_CAST(unsigned int, coord[2]));
+               AIR_UINT(I),
+               AIR_UINT(coord[0]),
+               AIR_UINT(coord[1]),
+               AIR_UINT(coord[2]));
       return 1;
     }
   }
@@ -1151,7 +1148,7 @@
     return 1;
   }
   if (right) {
-    yres = AIR_CAST(unsigned int, AIR_CAST(double, res)/sqrt(3));
+    yres = AIR_UINT(AIR_CAST(double, res)/sqrt(3));
   } else {
     yres = res;
   }
@@ -1183,11 +1180,11 @@
     cp = tenAnisoEval_f(eval, cpIdx);
     cs = tenAnisoEval_f(eval, csIdx);
     if (right) {
-      xi = AIR_CAST(unsigned int, cs*0 + cl*(res-1) + cp*0);
-      yi = AIR_CAST(unsigned int, cs*0 + cl*(yres-1) + cp*(yres-1));
+      xi = AIR_UINT(cs*0 + cl*(res-1) + cp*0);
+      yi = AIR_UINT(cs*0 + cl*(yres-1) + cp*(yres-1));
     } else {
-      xi = AIR_CAST(unsigned int, cs*0 + cl*0 + cp*(res-1));
-      yi = AIR_CAST(unsigned int, cs*0 + cl*(res-1) + cp*(res-1));
+      xi = AIR_UINT(cs*0 + cl*0 + cp*(res-1));
+      yi = AIR_UINT(cs*0 + cl*(res-1) + cp*(res-1));
     }
     weight = wlup ? wlup(nwght->data, I) : 1.0f;
     if (xi < res && yi < yres-1) {
@@ -1260,7 +1257,7 @@
   X = AIR_ABS(comp);
   X = pow(X, 1.0/rgbp->gamma);
   X = AIR_LERP(rgbp->maxSat*aniso, rgbp->isoGray, X);
-  return AIR_CAST(float, conf > rgbp->confThresh ? X : rgbp->bgGray);
+  return AIR_FLOAT(conf > rgbp->confThresh ? X : rgbp->bgGray);
 }
 
 double
@@ -1281,7 +1278,7 @@
 
   if (RGB && eval && rgbp) {
     aniso = tenAnisoEval_f(eval, rgbp->aniso);
-    aniso = AIR_CAST(float, pow(aniso, 1.0/rgbp->anisoGamma));
+    aniso = AIR_FLOAT(pow(aniso, 1.0/rgbp->anisoGamma));
     ELL_3V_SET(RGB,
                _tenEvecRGBComp_f(conf, aniso, evec[0], rgbp),
                _tenEvecRGBComp_f(conf, aniso, evec[1], rgbp),
diff --color -ruN teem-1.11.0-src.orig/src/ten/bimod.c teem-1.11.0-src/src/ten/bimod.c
--- teem-1.11.0-src.orig/src/ten/bimod.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/bimod.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -61,7 +61,7 @@
 int
 _tenEMBimodalInit(tenEMBimodalParm *biparm, const Nrrd *_nhisto) {
   static const char me[]="_tenEMBimodalInit";
-  int i, median;
+  unsigned int i, median;
   Nrrd *nhisto;
   double medianD, sum;
   airArray *mop;
@@ -80,7 +80,7 @@
     biffMovef(TEN, NRRD, "%s: trouble converting histogram to double", me);
     airMopError(mop); return 1;
   }
-  biparm->N = nhisto->axis[0].size;
+  biparm->N = AIR_UINT(nhisto->axis[0].size);
   biparm->histo = (double*)(nhisto->data);
   biparm->vmin = (AIR_EXISTS(nhisto->axis[0].min)
                   ? nhisto->axis[0].min
@@ -105,7 +105,7 @@
               "%s: got empty histogram? (median calculation failed)", me);
     airMopError(mop); return 1;
   }
-  median = (int)medianD;
+  median = AIR_UINT(medianD);
 
   biparm->pp1 = (double*)calloc(biparm->N, sizeof(double));
   biparm->pp2 = (double*)calloc(biparm->N, sizeof(double));
@@ -174,7 +174,7 @@
 */
 void
 _tenEMBimodalPP(tenEMBimodalParm *biparm) {
-  int i;
+  unsigned int i;
   double g1, g2, pp1, pp2, f1, min;
 
   min = (1 == biparm->stage
@@ -210,7 +210,7 @@
 
 double
 _tenEMBimodalNewFraction1(tenEMBimodalParm *biparm) {
-  int i;
+  unsigned int i;
   double pp1, pp2, h, sum1, sum2;
 
   sum1 = sum2 = 0.0;
@@ -227,7 +227,7 @@
 void
 _tenEMBimodalNewMean(double *m1P, double *m2P,
                      tenEMBimodalParm *biparm) {
-  int i;
+  unsigned int i;
   double pp1, pp2, h, sum1, isum1, sum2, isum2;
 
   sum1 = isum1 = sum2 = isum2 = 0.0;
@@ -248,7 +248,7 @@
 _tenEMBimodalNewSigma(double *s1P, double *s2P,
                       double m1, double m2,
                       tenEMBimodalParm *biparm) {
-  int i;
+  unsigned int i;
   double pp1, pp2, h, sum1, isum1, sum2, isum2;
 
   sum1 = isum1 = sum2 = isum2 = 0.0;
@@ -272,7 +272,7 @@
   NrrdRange *range;
   const Nrrd *nhmhi[3];
   double *m, max;
-  int i;
+  unsigned int i;
 
   nh = nrrdNew();
   nm = nrrdNew();
diff --color -ruN teem-1.11.0-src.orig/src/ten/bvec.c teem-1.11.0-src/src/ten/bvec.c
--- teem-1.11.0-src.orig/src/ten/bvec.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/bvec.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -25,9 +25,10 @@
 #include "privateTen.h"
 
 double
-tenBVecNonLinearFit_error(double *bb, double *ss, double *ww, int len,
+tenBVecNonLinearFit_error(double *bb, double *ss, double *ww,
+                          unsigned int len,
                           double amp, double dec) {
-  int ii;
+  unsigned int ii;
   double err, tmp;
 
   err = 0;
@@ -40,9 +41,10 @@
 
 void
 tenBVecNonLinearFit_linear(double *amp, double *dec,
-                           double *bb, double *ss, double *ww, int len) {
+                           double *bb, double *ss, double *ww,
+                           unsigned int len) {
   double x, y, wi=0, xi=0, yi=0, xiyi=0, xisq=0, det;
-  int ii;
+  unsigned int ii;
 
   for (ii=0; ii<len; ii++) {
     x = bb[ii];
@@ -61,10 +63,11 @@
 
 void
 tenBVecNonLinearFit_GNstep(double *d_amp, double *d_dec,
-                           double *bb, double *ss, double *ww, int len,
+                           double *bb, double *ss, double *ww,
+                           unsigned int len,
                            double amp, double dec) {
   double tmp, ff, dfdx1, dfdx2, AA=0, BB=0, CC=0, JTf[2], det;
-  int ii;
+  unsigned int ii;
 
   JTf[0] = JTf[1] = 0;
   for (ii=0; ii<len; ii++) {
@@ -133,7 +136,7 @@
     return 1;
   }
   for (ii=1; ii<nin->dim; ii++) {
-    map[ii] = ii;
+    map[ii] = AIR_INT(ii);
   }
   map[0] = -1;
   if (nrrdAxisInfoCopy(nout, nin, map, NRRD_AXIS_INFO_NONE)) {
@@ -142,7 +145,8 @@
   }
 
   /* process all b vectors */
-  vecSize = nin->axis[0].size*nrrdTypeSize[nin->type];
+  /* HEY unsigned? */
+  vecSize = AIR_INT(nin->axis[0].size*nrrdTypeSize[nin->type]);
   vecNum = nrrdElementNumber(nin)/nin->axis[0].size;
   vecLup = nrrdDLookup[nin->type];
   vec = (char*)nin->data;
@@ -153,21 +157,27 @@
       ss[ii] = vecLup(vec, ii);
     }
     /* start with linear fit */
-    tenBVecNonLinearFit_linear(&amp, &dec, bb, ss, ww, nin->axis[0].size);
-    error = tenBVecNonLinearFit_error(bb, ss, ww, nin->axis[0].size, amp, dec);
+    tenBVecNonLinearFit_linear(&amp, &dec, bb, ss, ww,
+                               AIR_UINT(nin->axis[0].size));
+    error = tenBVecNonLinearFit_error(bb, ss, ww,
+                                      AIR_UINT(nin->axis[0].size),
+                                      amp, dec);
     /* possibly refine with gauss-newton */
     if (iterMax > 0) {
       iter = 0;
       do {
         iter++;
-        tenBVecNonLinearFit_GNstep(&d_amp, &d_dec,
-                                   bb, ss, ww, nin->axis[0].size, amp, dec);
+        tenBVecNonLinearFit_GNstep(&d_amp, &d_dec, bb, ss, ww,
+                                   AIR_UINT(nin->axis[0].size),
+                                   amp, dec);
         amp += 0.3*d_amp;
         dec += 0.3*d_dec;
         diff = d_amp*d_amp + d_dec*d_dec;
       } while (iter < iterMax && diff > eps);
     }
-    error = tenBVecNonLinearFit_error(bb, ss, ww, nin->axis[0].size, amp, dec);
+    error = tenBVecNonLinearFit_error(bb, ss, ww,
+                                      AIR_UINT(nin->axis[0].size),
+                                      amp, dec);
     out[0] = amp;
     out[1] = dec;
     out[2] = error;
diff --color -ruN teem-1.11.0-src.orig/src/ten/chan.c teem-1.11.0-src/src/ten/chan.c
--- teem-1.11.0-src.orig/src/ten/chan.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/chan.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -135,7 +135,7 @@
              airEnumStr(nrrdKind, nrrdKindList));
     return 1;
   }
-  dwiNum = ndwi->axis[dwiAxis].size;
+  dwiNum = AIR_UINT(ndwi->axis[dwiAxis].size);
 
   /* figure out if we're parsing gradients or b-matrices */
   sprintf(tmpKey, tenDWMRIGradKeyFmt, 0);
@@ -351,7 +351,7 @@
   static const char me[]="tenBMatrixCalc";
   Nrrd *ngrad;
   double *bmat, *G;
-  int DD, dd;
+  unsigned int DD, dd;
   airArray *mop;
 
   if (!(nbmat && _ngrad && !tenGradientCheck(_ngrad, nrrdTypeDefault, 1))) {
@@ -367,7 +367,7 @@
     airMopError(mop); return 1;
   }
 
-  DD = ngrad->axis[1].size;
+  DD = AIR_UINT(ngrad->axis[1].size);
   G = (double*)(ngrad->data);
   bmat = (double*)(nbmat->data);
   for (dd=0; dd<DD; dd++) {
@@ -568,7 +568,7 @@
                             thresh, soft, b);
   TEN_T_COPY_TT(_ten, float, ten);
   if (_B0P) {
-    *_B0P = AIR_CAST(float, B0);
+    *_B0P = AIR_FLOAT(B0);
   }
   return;
 }
@@ -771,10 +771,10 @@
       } */
     }
     tenEstimateLinearSingle_f(ten, &_B0, dwi1, emat,
-                              vbuf, DD, knownB0,
-                              AIR_CAST(float, thresh),
-                              AIR_CAST(float, soft),
-                              AIR_CAST(float, b));
+                              vbuf, AIR_UINT(DD), knownB0,
+                              AIR_FLOAT(thresh),
+                              AIR_FLOAT(soft),
+                              AIR_FLOAT(b));
     if (nB0P) {
       *B0 = _B0;
     }
@@ -785,7 +785,8 @@
     if (nterrP) {
       te = 0;
       if (knownB0) {
-        tenSimulateSingle_f(dwi2, _B0, ten, bmat, DD, AIR_CAST(float, b));
+        tenSimulateSingle_f(dwi2, _B0, ten, bmat,
+                            AIR_UINT(DD), AIR_FLOAT(b));
         for (d=1; d<DD; d++) {
           d1 = AIR_MAX(dwi1[d], 1);
           d2 = AIR_MAX(dwi2[d], 1);
@@ -793,7 +794,8 @@
         }
         te /= (DD-1);
       } else {
-        tenSimulateSingle_f(dwi2, _B0, ten, bmat, DD+1, AIR_CAST(float, b));
+        tenSimulateSingle_f(dwi2, _B0, ten, bmat,
+                            AIR_UINT(DD+1), AIR_FLOAT(b));
         for (d=0; d<DD; d++) {
           d1 = AIR_MAX(dwi1[d], 1);
           /* tenSimulateSingle_f always puts the B0 in the beginning of
@@ -804,7 +806,7 @@
         }
         te /= DD;
       }
-      *terr = AIR_CAST(float, sqrt(te));
+      *terr = AIR_FLOAT(sqrt(te));
       terr += 1;
     }
     ten += 7;
@@ -860,7 +862,7 @@
     for (jj=0; jj<6; jj++) {
       vv += matwght[jj]*bmat[jj + 6*ii]*ten[jj+1];
     }
-    dwi[ii+1] = AIR_CAST(float, AIR_MAX(B0, 1)*exp(-b*vv));
+    dwi[ii+1] = AIR_FLOAT(AIR_MAX(B0, 1)*exp(-b*vv));
     /* if (tenVerbose) {
       fprintf(stderr, "v[%d] = %g --> dwi = %g\n", ii, vv, dwi[ii+1]);
     } */
@@ -923,8 +925,8 @@
   lup = nrrdFLookup[nT2->type];
   for (II=0; II<(size_t)(sx*sy*sz); II++) {
     /* tenVerbose = (II == 42 + 190*(96 + 196*0)); */
-    tenSimulateSingle_f(dwi, lup(nT2->data, II), ten, bmat, DD,
-                        AIR_CAST(float, b));
+    tenSimulateSingle_f(dwi, lup(nT2->data, II), ten, bmat,
+                        AIR_UINT(DD), AIR_FLOAT(b));
     dwi += DD;
     ten += 7;
   }
@@ -972,19 +974,19 @@
   c[5] = AIR_MAX(chan[5], 1);
   c[6] = AIR_MAX(chan[6], 1);
   sum = c[1] + c[2] + c[3] + c[4] + c[5] + c[6];
-  tens[0] = AIR_CAST(float, (1 + airErf(slope*(sum - thresh)))/2.0);
+  tens[0] = AIR_FLOAT((1 + airErf(slope*(sum - thresh)))/2.0);
   d1 = (log(c[0]) - log(c[1]))/b;
   d2 = (log(c[0]) - log(c[2]))/b;
   d3 = (log(c[0]) - log(c[3]))/b;
   d4 = (log(c[0]) - log(c[4]))/b;
   d5 = (log(c[0]) - log(c[5]))/b;
   d6 = (log(c[0]) - log(c[6]))/b;
-  tens[1] = AIR_CAST(float,  d1 + d2 - d3 - d4 + d5 + d6);    /* Dxx */
-  tens[2] = AIR_CAST(float,  d5 - d6);                        /* Dxy */
-  tens[3] = AIR_CAST(float,  d1 - d2);                        /* Dxz */
-  tens[4] = AIR_CAST(float, -d1 - d2 + d3 + d4 + d5 + d6);    /* Dyy */
-  tens[5] = AIR_CAST(float,  d3 - d4);                        /* Dyz */
-  tens[6] = AIR_CAST(float,  d1 + d2 + d3 + d4 - d5 - d6);    /* Dzz */
+  tens[1] = AIR_FLOAT( d1 + d2 - d3 - d4 + d5 + d6);    /* Dxx */
+  tens[2] = AIR_FLOAT( d5 - d6);                        /* Dxy */
+  tens[3] = AIR_FLOAT( d1 - d2);                        /* Dxz */
+  tens[4] = AIR_FLOAT(-d1 - d2 + d3 + d4 + d5 + d6);    /* Dyy */
+  tens[5] = AIR_FLOAT( d3 - d4);                        /* Dyz */
+  tens[6] = AIR_FLOAT( d1 + d2 + d3 + d4 - d5 - d6);    /* Dzz */
   return;
 }
 
@@ -1006,19 +1008,19 @@
   c[5] = AIR_MAX(chan[5], 1);
   c[6] = AIR_MAX(chan[6], 1);
   sum = c[1] + c[2] + c[3] + c[4] + c[5] + c[6];
-  tens[0] = AIR_CAST(float, (1 + airErf(slope*(sum - thresh)))/2.0);
+  tens[0] = AIR_FLOAT((1 + airErf(slope*(sum - thresh)))/2.0);
   d1 = (log(c[0]) - log(c[1]))/b;
   d2 = (log(c[0]) - log(c[2]))/b;
   d3 = (log(c[0]) - log(c[3]))/b;
   d4 = (log(c[0]) - log(c[4]))/b;
   d5 = (log(c[0]) - log(c[5]))/b;
   d6 = (log(c[0]) - log(c[6]))/b;
-  tens[1] =  AIR_CAST(float, d1);                 /* Dxx */
-  tens[2] =  AIR_CAST(float, d6 - (d1 + d2)/2);   /* Dxy */
-  tens[3] =  AIR_CAST(float, d5 - (d1 + d3)/2);   /* Dxz */
-  tens[4] =  AIR_CAST(float, d2);                 /* Dyy */
-  tens[5] =  AIR_CAST(float, d4 - (d2 + d3)/2);   /* Dyz */
-  tens[6] =  AIR_CAST(float, d3);                 /* Dzz */
+  tens[1] =  AIR_FLOAT(d1);                 /* Dxx */
+  tens[2] =  AIR_FLOAT(d6 - (d1 + d2)/2);   /* Dxy */
+  tens[3] =  AIR_FLOAT(d5 - (d1 + d3)/2);   /* Dxz */
+  tens[4] =  AIR_FLOAT(d2);                 /* Dyy */
+  tens[5] =  AIR_FLOAT(d4 - (d2 + d3)/2);   /* Dyz */
+  tens[6] =  AIR_FLOAT(d3);                 /* Dzz */
   return;
 }
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/CMakeLists.txt teem-1.11.0-src/src/ten/CMakeLists.txt
--- teem-1.11.0-src.orig/src/ten/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/ten/CMakeLists.txt	2021-02-18 15:42:36.000000000 +0800
@@ -0,0 +1,87 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(TEN_SOURCES
+  aniso.c
+  bimod.c
+  bvec.c
+  chan.c
+  defaultsTen.c
+  enumsTen.c
+  epireg.c
+  estimate.c
+  fiber.c
+  fiberMethods.c
+  glyph.c
+  grads.c
+  miscTen.c
+  mod.c
+  path.c
+  privateTen.h
+  qglox.c
+  qseg.c
+  ten.h
+  tenDwiGage.c
+  tenGage.c
+  tenMacros.h
+  tendAbout.c
+  tendAnhist.c
+  tendAnplot.c
+  tendAnscale.c
+  tendAnvol.c
+  tendAvg.c
+  tendBfit.c
+  tendBmat.c
+  tendEllipse.c
+  tendEpireg.c
+  tendEstim.c
+  tendEval.c
+  tendEvaladd.c
+  tendEvalmult.c
+  tendEvalclamp.c
+  tendEvalpow.c
+  tendEvec.c
+  tendEvecrgb.c
+  tendEvq.c
+  tendExp.c
+  tendExpand.c
+  tendFiber.c
+  tendFlotsam.c
+  tendGlyph.c
+  tendGrads.c
+  tendHelix.c
+  tendLog.c
+  tendMake.c
+  tendNorm.c
+  tendPoint.c
+  tendSatin.c
+  tendShrink.c
+  tendSim.c
+  tendMsim.c
+  tendMfit.c
+  tendMconv.c
+  tendSlice.c
+  tendSten.c
+  tendTconv.c
+  tendTriple.c
+  tendUnmf.c
+  tensor.c
+  triple.c
+  experSpec.c
+  tenModel.c
+  modelZero.c
+  modelB0.c
+  modelBall.c
+  model1Stick.c
+  model1Vector2D.c
+  model1Unit2D.c
+  model2Unit2D.c
+  modelBall1StickEMD.c
+  modelBall1Stick.c
+  modelBall1Cylinder.c
+  model1Cylinder.c
+  model1Tensor2.c
+  )
+
+target_sources(teem PRIVATE ${TEN_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( ten FILES ${TEN_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/ten/defaultsTen.c teem-1.11.0-src/src/ten/defaultsTen.c
--- teem-1.11.0-src.orig/src/ten/defaultsTen.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/defaultsTen.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/enumsTen.c teem-1.11.0-src/src/ten/enumsTen.c
--- teem-1.11.0-src.orig/src/ten/enumsTen.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/enumsTen.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/epireg.c teem-1.11.0-src/src/ten/epireg.c
--- teem-1.11.0-src.orig/src/ten/epireg.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/epireg.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -299,7 +299,7 @@
     thr = (unsigned char *)(nthresh[ni]->data);
     for (I=0; I<sx*sy*sz; I++) {
       val = nrrdFLookup[nblur[ni]->type](nblur[ni]->data, I);
-      val -= AIR_CAST(float, DWthr);
+      val -= AIR_FLOAT(DWthr);
       thr[I] = (val >= 0 ? 1 : 0);
     }
   }
@@ -334,14 +334,15 @@
   static const char me[]="_tenEpiRegCC";
   Nrrd *nslc, *ncc, *nval, *nsize;
   airArray *mop;
-  int ni, z, sz, big;
+  int ni, big;
+  unsigned int z, sz;
 
   mop = airMopNew();
   airMopAdd(mop, nslc=nrrdNew(), (airMopper)nrrdNuke, airMopAlways);
   airMopAdd(mop, nval=nrrdNew(), (airMopper)nrrdNuke, airMopAlways);
   airMopAdd(mop, ncc=nrrdNew(), (airMopper)nrrdNuke, airMopAlways);
   airMopAdd(mop, nsize=nrrdNew(), (airMopper)nrrdNuke, airMopAlways);
-  sz = nthr[0]->axis[2].size;
+  sz = AIR_UINT(nthr[0]->axis[2].size);
   if (verb) {
     fprintf(stderr, "%s:\n            ", me); fflush(stderr);
   }
@@ -518,9 +519,10 @@
 _tenEpiRegPairXforms(Nrrd *npxfr, Nrrd **nmom, int ninLen) {
   static const char me[]="_tenEpiRegPairXforms";
   double *xfr, *A, *B, hh, ss, tt;
-  int ai, bi, zi, sz;
+  int ai, bi;
+  unsigned int zi, sz;
 
-  sz = nmom[0]->axis[1].size;
+  sz = AIR_UINT(nmom[0]->axis[1].size);
   if (nrrdMaybeAlloc_va(npxfr, nrrdTypeDouble, 4,
                         AIR_CAST(size_t, 5),
                         AIR_CAST(size_t, sz),
@@ -557,14 +559,15 @@
 _tenEpiRegEstimHST(Nrrd *nhst, Nrrd *npxfr, int ninLen, Nrrd *ngrad) {
   static const char me[]="_tenEpiRegEstimHST";
   double *hst, *grad, *mat, *vec, *ans, *pxfr, *gA, *gB;
-  int z, sz, A, B, npairs, ri;
+  int A, B, npairs, ri;
   Nrrd **nmat, *nvec, **ninv, *nans;
   airArray *mop;
   int order;
+  unsigned int z, sz;
 
   order = 1;
 
-  sz = npxfr->axis[1].size;
+  sz = AIR_UINT(npxfr->axis[1].size);
   npairs = ninLen*(ninLen-1);
 
   mop = airMopNew();
@@ -794,7 +797,7 @@
   mess = AIR_CAST(float*, ntA->data);
 
   /* allocate an array of 2 floats per slice */
-  sz = ntA->axis[0].size;
+  sz = AIR_UINT(ntA->axis[0].size);
   two = AIR_CAST(float*, calloc(2*sz, sizeof(float)));
   if (!two) {
     biffAddf(TEN, "%s: couldn't allocate tmp buffer", me);
@@ -806,7 +809,7 @@
     two[0 + 2*zi] = (AIR_EXISTS(mess[zi])
                      ? mess[zi]
                      : 666);  /* don't use empty slices */
-    two[1 + 2*zi] = AIR_CAST(float, zi);
+    two[1 + 2*zi] = AIR_FLOAT(zi);
   }
   /* sort into ascending messiness */
   qsort(two, zi, 2*sizeof(float), nrrdValCompare[nrrdTypeFloat]);
@@ -831,7 +834,7 @@
   /* perform fitting for each column in hst (regardless of
      whether we're using a 1st or 2nd order model */
   hst = (double*)(nhst->data);
-  sh = nhst->axis[0].size;
+  sh = AIR_UINT(nhst->axis[0].size);
   for (hi=0; hi<sh; hi++) {
     x = y = xy = xx = 0;
     cc = 0;
@@ -861,15 +864,15 @@
                  int reference, int ni, int zi,
                  Nrrd *npxfr, Nrrd *nhst, Nrrd *ngrad) {
   double *xfr, *hst, *_g, grad[9]; /* big enough for 2nd order */
-  int sz, ninLen;
+  unsigned int sz, ninLen;
 
   int order;
 
   order = 1;
 
   /* these could also have been passed to us, but we can also discover them */
-  sz = npxfr->axis[1].size;
-  ninLen = npxfr->axis[2].size;
+  sz = AIR_UINT(npxfr->axis[1].size);
+  ninLen = AIR_UINT(npxfr->axis[2].size);
 
   if (-1 == reference) {
     /* we use the estimated H,S,T vectors to determine distortion
@@ -927,7 +930,7 @@
 
   sy = nin->axis[0].size;
   sx = nin->axis[1].size;
-  supp = AIR_CAST(unsigned int, kern->support(kparm));
+  supp = AIR_UINT(kern->support(kparm));
   ins = nrrdDInsert[nout->type];
   clamp = nrrdDClamp[nout->type];
 
@@ -936,11 +939,12 @@
     idx = AIR_CAST(int*, nidx->data);
     wght = AIR_CAST(float*, nwght->data);
     for (yi=0; yi<sy; yi++) {
-      pp = AIR_CAST(float, hh*(xi - cx) + ss*(yi - cy) + tt + cy);
+      pp = AIR_FLOAT(hh*(xi - cx) + ss*(yi - cy) + tt + cy);
       pb = AIR_CAST(size_t, floor(pp));
       pf = pp - pb;
       for (pi=0; pi<2*supp; pi++) {
-        idx[pi] = AIR_MIN(pb + pi - (supp-1), sy-1);
+        /* HEY GLK confused about signed-ness of this */
+        idx[pi] = AIR_CAST(int, AIR_MIN(pb + pi - (supp-1), sy-1));
         wght[pi] = pi - (supp-1) - pf;
       }
       idx += 2*supp;
@@ -970,13 +974,13 @@
 */
 int
 _tenEpiRegWarp(Nrrd **ndone, Nrrd *npxfr, Nrrd *nhst, Nrrd *ngrad,
-               Nrrd **nin, int ninLen,
+               Nrrd **nin, unsigned int ninLen,
                int reference, const NrrdKernel *kern, double *kparm,
                int verb) {
   static const char me[]="_tenEpiRegWarp";
   Nrrd *ntmp, *nfin, *nslcA, *nslcB, *nwght, *nidx;
   airArray *mop;
-  int sx, sy, sz, ni, zi, supp;
+  unsigned int sx, sy, sz, ni, zi, supp;
   double hh, ss, tt, cx, cy;
 
   mop = airMopNew();
@@ -990,12 +994,13 @@
   if (verb) {
     fprintf(stderr, "%s:\n            ", me); fflush(stderr);
   }
-  sx = nin[0]->axis[0].size;
-  sy = nin[0]->axis[1].size;
-  sz = nin[0]->axis[2].size;
+  sx = AIR_UINT(nin[0]->axis[0].size);
+  sy = AIR_UINT(nin[0]->axis[1].size);
+  sz = AIR_UINT(nin[0]->axis[2].size);
   cx = sx/2.0;
   cy = sy/2.0;
-  supp = (int)kern->support(kparm);
+  /* HEY this is effectively a floor(); why not say that? */
+  supp = AIR_UINT(kern->support(kparm));
   if (nrrdMaybeAlloc_va(nwght, nrrdTypeFloat, 2,
                         AIR_CAST(size_t, 2*supp),
                         AIR_CAST(size_t, sy))
@@ -1215,7 +1220,7 @@
     return 1;
   }
 
-  ninLen = _nin->axis[dwiAx].size;
+  ninLen = AIR_UINT(_nin->axis[dwiAx].size);
   /* outdated
   if (!( AIR_IN_CL(6, ninLen, 120) )) {
     biffAddf(TEN, "%s: %u (size of axis %u, and # DWIs) is unreasonable",
@@ -1268,7 +1273,7 @@
       airMopAdd(mop, ndwi[dwiIdx], (airMopper)nrrdNuke, airMopAlways);
       airMopAdd(mop, ndwiOut[dwiIdx], (airMopper)nrrdNuke, airMopAlways);
       if (nrrdSlice(ndwi[dwiIdx], _nin, dwiAx,
-                    AIR_CAST(unsigned int, ninIdx))) {
+                    AIR_UINT(ninIdx))) {
         biffMovef(TEN, NRRD, "%s: trouble slicing at %d on axis %u",
                   me, ninIdx, dwiAx);
         airMopError(mop); return 1;
@@ -1285,8 +1290,10 @@
     airMopError(mop); return 1;
   }
   /* HEY: HACK! */
-  ndwigrad->axis[1].size = 1 + AIR_CAST(unsigned int, dwiIdx);
-  if (tenEpiRegister3D(ndwiOut, ndwi, ndwigrad->axis[1].size, ndwigrad,
+  ndwigrad->axis[1].size = 1 + AIR_UINT(dwiIdx);
+  if (tenEpiRegister3D(ndwiOut, ndwi,
+                       AIR_UINT(ndwigrad->axis[1].size),
+                       ndwigrad,
                        reference,
                        bwX, bwY, fitFrac, DWthr,
                        doCC,
diff --color -ruN teem-1.11.0-src.orig/src/ten/estimate.c teem-1.11.0-src/src/ten/estimate.c
--- teem-1.11.0-src.orig/src/ten/estimate.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/estimate.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -434,6 +434,69 @@
 }
 
 int
+tenEstimateThresholdFind(double *threshP, unsigned char *isB0, Nrrd *nin4d) {
+  static const char me[]="tenEstimateThresholdFind";
+  Nrrd **ndwi;
+  airArray *mop;
+  unsigned int slIdx, slNum, dwiAx, dwiNum,
+    rangeAxisNum, rangeAxisIdx[NRRD_DIM_MAX];
+  int dwiIdx;
+
+  mop = airMopNew();
+
+  if (!(threshP && isB0 && nin4d)) {
+    biffAddf(TEN, "%s: got NULL pointer", me);
+    airMopError(mop); return 1;
+  }
+
+  /* HEY: copied from tenEpiRegister4D() */
+  rangeAxisNum = nrrdRangeAxesGet(nin4d, rangeAxisIdx);
+  if (0 == rangeAxisNum) {
+    /* we fall back on old behavior */
+    dwiAx = 0;
+  } else if (1 == rangeAxisNum) {
+    /* thankfully there's exactly one range axis */
+    dwiAx = rangeAxisIdx[0];
+  } else {
+    biffAddf(TEN, "%s: have %u range axes instead of 1, don't know which "
+             "is DWI axis", me, rangeAxisNum);
+    airMopError(mop); return 1;
+  }
+
+  slNum = AIR_UINT(nin4d->axis[dwiAx].size);
+  dwiNum = 0;
+  for (slIdx=0; slIdx<slNum; slIdx++) {
+    dwiNum += !isB0[slIdx];
+  }
+  if (0 == dwiNum) {
+    biffAddf(TEN, "%s: somehow got zero DWIs", me);
+    airMopError(mop); return 1;
+  }
+  ndwi = AIR_CALLOC(dwiNum, Nrrd *);
+  airMopAdd(mop, ndwi, (airMopper)airFree, airMopAlways);
+  dwiIdx = -1;
+  for (slIdx=0; slIdx<slNum; slIdx++) {
+    if (!isB0[slIdx]) {
+      dwiIdx++;
+      ndwi[dwiIdx] = nrrdNew();
+      airMopAdd(mop, ndwi[dwiIdx], (airMopper)nrrdNuke, airMopAlways);
+      if (nrrdSlice(ndwi[dwiIdx], nin4d, dwiAx, slIdx)) {
+        biffMovef(TEN, NRRD,
+                  "%s: trouble slicing DWI at index %u", me, slIdx);
+        airMopError(mop); return 1;
+      }
+    }
+  }
+  if (_tenEpiRegThresholdFind(threshP, ndwi, dwiNum, AIR_FALSE, 1.5)) {
+    biffAddf(TEN, "%s: trouble finding thresh", me);
+    airMopError(mop); return 1;
+  }
+
+  airMopOkay(mop);
+  return 0;
+}
+
+int
 tenEstimateThresholdSet(tenEstimateContext *tec,
                         double thresh, double soft) {
   static const char me[]="tenEstimateThresholdSet";
@@ -511,10 +574,10 @@
   if (tec->flag[flagBInfo]
       || tec->flag[flagSkipSet]) {
     if (tec->_ngrad) {
-      newAllNum = AIR_CAST(unsigned int, tec->_ngrad->axis[1].size);
+      newAllNum = AIR_UINT(tec->_ngrad->axis[1].size);
       lup = nrrdDLookup[tec->_ngrad->type];
     } else {
-      newAllNum = AIR_CAST(unsigned int, tec->_nbmat->axis[1].size);
+      newAllNum = AIR_UINT(tec->_nbmat->axis[1].size);
       lup = nrrdDLookup[tec->_nbmat->type];
     }
     if (tec->allNum != newAllNum) {
@@ -543,7 +606,8 @@
                 me, skipListIdx, skipIdx, tec->allNum);
         return 1;
       }
-      tec->skipLut[skipIdx] = skipDo;
+      /* HEY Wed Nov 18 17:20:27 CST 2020 GLK is skeptical about this */
+      tec->skipLut[skipIdx] = AIR_UCHAR(skipDo);
     }
     skipNotNum = 0;
     for (skipIdx=0; skipIdx<tec->allNum; skipIdx++) {
@@ -743,8 +807,8 @@
       /* HEY: ignores weights! */
       if (ell_Nm_pseudo_inv(tec->nemat, tec->nbmat)) {
         biffMovef(TEN, ELL, "%s: trouble pseudo-inverting %ux%u B-matrix", me,
-                  AIR_CAST(unsigned int, tec->nbmat->axis[1].size),
-                  AIR_CAST(unsigned int, tec->nbmat->axis[0].size));
+                  AIR_UINT(tec->nbmat->axis[1].size),
+                  AIR_UINT(tec->nbmat->axis[0].size));
         return 1;
       }
     }
@@ -956,7 +1020,7 @@
   dwiIdx = 0;
   for (allIdx=0; allIdx<tec->allNum; allIdx++) {
     if (tec->estimateB0 || tec->bnorm[allIdx]) {
-      simval[allIdx] = AIR_CAST(float, tec->dwiTmp[dwiIdx++]);
+      simval[allIdx] = AIR_FLOAT(tec->dwiTmp[dwiIdx++]);
     } else {
       simval[allIdx] = B0;
     }
@@ -1079,12 +1143,12 @@
       dwi_d += tec->allNum;
     } else {
       for (tt=0; tt<7; tt++) {
-        ten_f[tt] = AIR_CAST(float, tlup(nten->data, tt + sizeTen*II));
+        ten_f[tt] = AIR_FLOAT(tlup(nten->data, tt + sizeTen*II));
       }
       E = tenEstimate1TensorSimulateSingle_f(tec, dwi_f,
-                                             AIR_CAST(float, sigma),
-                                             AIR_CAST(float, bValue),
-                                             AIR_CAST(float, B0),
+                                             AIR_FLOAT(sigma),
+                                             AIR_FLOAT(bValue),
+                                             AIR_FLOAT(B0),
                                              ten_f);
       dwi_f += tec->allNum;
     }
@@ -1230,8 +1294,8 @@
   if (ell_Nm_wght_pseudo_inv(tec->nemat, tec->nbmat, tec->nwght)) {
     biffMovef(TEN, ELL,
               "%s(1): trouble wght-pseudo-inverting %ux%u B-matrix", me,
-              AIR_CAST(unsigned int, tec->nbmat->axis[1].size),
-              AIR_CAST(unsigned int, tec->nbmat->axis[0].size));
+              AIR_UINT(tec->nbmat->axis[1].size),
+              AIR_UINT(tec->nbmat->axis[0].size));
     return 1;
   }
   /*
@@ -1270,8 +1334,8 @@
     }
     if (ell_Nm_wght_pseudo_inv(tec->nemat, tec->nbmat, tec->nwght)) {
       biffMovef(TEN, ELL, "%s(2): trouble w/ %ux%u B-matrix (iter %u)", me,
-                AIR_CAST(unsigned int, tec->nbmat->axis[1].size),
-                AIR_CAST(unsigned int, tec->nbmat->axis[0].size), iter);
+                AIR_UINT(tec->nbmat->axis[1].size),
+                AIR_UINT(tec->nbmat->axis[0].size), iter);
       return 1;
     }
     _tenEstimate1Tensor_LLS(tec);
@@ -1337,7 +1401,7 @@
                                             double B0,
                                             double ten[7])) {
   static const char me[]="_tenEstimate1TensorDescent";
-  double currB0, lastB0, currTen[7], lastTen[7], gradB0, gradTen[7],
+  double currB0, lastB0, currTen[7], lastTen[7], gradB0=AIR_NAN, gradTen[7],
     epsilon,
     stepSize, badInit, bad, badDelta, stepSizeMin = 0.00000000001, badLast;
   unsigned int iter, iterMax = 100000;
@@ -1979,7 +2043,7 @@
     tec->verbose = 10*(II == 42509);
     */
     if (tec->verbose) {
-      fprintf(stderr, "!%s: hello; II=%u\n", me, AIR_CAST(unsigned int, II));
+      fprintf(stderr, "!%s: hello; II=%u\n", me, AIR_UINT(II));
     }
     if (tenEstimate1TensorSingle_d(tec, ten, all)) {
       biffAddf(TEN, "%s: failed at sample %s", me,
diff --color -ruN teem-1.11.0-src.orig/src/ten/experSpec.c teem-1.11.0-src/src/ten/experSpec.c
--- teem-1.11.0-src.orig/src/ten/experSpec.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/experSpec.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -230,7 +230,7 @@
     airMopError(mop); return 1;
   }
 
-  imgNum = ngrad->axis[1].size;
+  imgNum = AIR_UINT(ngrad->axis[1].size);
   bval = AIR_CALLOC(imgNum, double);
   airMopAdd(mop, bval, airFree, airMopAlways);
   grad = AIR_CAST(double *, ngrad->data);
diff --color -ruN teem-1.11.0-src.orig/src/ten/fiber.c teem-1.11.0-src/src/ten/fiber.c
--- teem-1.11.0-src.orig/src/ten/fiber.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/fiber.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -1069,13 +1069,13 @@
   if (!(2 == _nseed->dim && 3 == _nseed->axis[0].size)) {
     biffAddf(TEN, "%s: seed list should be a 2-D (not %u-D) "
             "3-by-X (not %u-by-X) array", me, _nseed->dim,
-            AIR_CAST(unsigned int, _nseed->axis[0].size));
+            AIR_UINT(_nseed->axis[0].size));
     return 1;
   }
 
   mop = airMopNew();
 
-  seedNum = _nseed->axis[1].size;
+  seedNum = AIR_UINT(_nseed->axis[1].size);
   if (nrrdTypeDouble == _nseed->type) {
     seedData = AIR_CAST(const double *, _nseed->data);
   } else {
@@ -1238,7 +1238,7 @@
     if (!(tenFiberStopUnknown == tfs->whyNowhere)) {
       continue;
     }
-    vertNum = tfs->nvert->axis[1].size;
+    vertNum = AIR_UINT(tfs->nvert->axis[1].size);
     pans = (nval
             ? AIR_CAST(double*, tfs->nval->data)
             : NULL);
diff --color -ruN teem-1.11.0-src.orig/src/ten/fiberMethods.c teem-1.11.0-src/src/ten/fiberMethods.c
--- teem-1.11.0-src.orig/src/ten/fiberMethods.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/fiberMethods.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/glyph.c teem-1.11.0-src/src/ten/glyph.c
--- teem-1.11.0-src.orig/src/ten/glyph.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/glyph.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -623,9 +623,9 @@
       default:
         glyphIdx =
           limnObjectPolarSuperquadFancyAdd(glyphsLimn, lookIdx, axis,
-                                           AIR_CAST(float, qA),
-                                           AIR_CAST(float, qB),
-                                           AIR_CAST(float, qC), 0,
+                                           AIR_FLOAT(qA),
+                                           AIR_FLOAT(qB),
+                                           AIR_FLOAT(qC), 0,
                                            2*parm->facetRes,
                                            parm->facetRes);
         break;
diff --color -ruN teem-1.11.0-src.orig/src/ten/GNUmakefile teem-1.11.0-src/src/ten/GNUmakefile
--- teem-1.11.0-src.orig/src/ten/GNUmakefile	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/GNUmakefile	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/ten/grads.c teem-1.11.0-src/src/ten/grads.c
--- teem-1.11.0-src.orig/src/ten/grads.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/grads.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/miscTen.c teem-1.11.0-src/src/ten/miscTen.c
--- teem-1.11.0-src.orig/src/ten/miscTen.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/miscTen.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -38,7 +38,7 @@
 
   if (!(nout && nin)) {
     biffAddf(TEN, "%s: got NULL pointer (%p,%p)",
-             me, AIR_CAST(void *, nout), AIR_CVOIDP(nin));
+             me, AIR_VOIDP(nout), AIR_CVOIDP(nin));
     return 1;
   }
   if (tenEvecRGBParmCheck(rgbp)) {
@@ -76,17 +76,17 @@
     tenEvecRGBSingle_f(RGB, ten[0], eval, evec + 3*(rgbp->which), rgbp);
     switch (nout->type) {
     case nrrdTypeUChar:
-      odataUC[0 + size[0]*II] = airIndexClamp(0.0, RGB[0], 1.0, 256);
-      odataUC[1 + size[0]*II] = airIndexClamp(0.0, RGB[1], 1.0, 256);
-      odataUC[2 + size[0]*II] = airIndexClamp(0.0, RGB[2], 1.0, 256);
+      odataUC[0 + size[0]*II] = AIR_UCHAR(airIndexClamp(0, RGB[0], 1, 256));
+      odataUC[1 + size[0]*II] = AIR_UCHAR(airIndexClamp(0, RGB[1], 1, 256));
+      odataUC[2 + size[0]*II] = AIR_UCHAR(airIndexClamp(0, RGB[2], 1, 256));
       if (rgbp->genAlpha) {
         odataUC[3 + size[0]*II] = 255;
       }
       break;
     case nrrdTypeUShort:
-      odataUS[0 + size[0]*II] = airIndexClamp(0.0, RGB[0], 1.0, 65536);
-      odataUS[1 + size[0]*II] = airIndexClamp(0.0, RGB[1], 1.0, 65536);
-      odataUS[2 + size[0]*II] = airIndexClamp(0.0, RGB[2], 1.0, 65536);
+      odataUS[0 + size[0]*II] = AIR_USHORT(airIndexClamp(0,RGB[0],1,65536));
+      odataUS[1 + size[0]*II] = AIR_USHORT(airIndexClamp(0,RGB[1],1,65536));
+      odataUS[2 + size[0]*II] = AIR_USHORT(airIndexClamp(0,RGB[2],1,65536));
       if (rgbp->genAlpha) {
         odataUS[3 + size[0]*II] = 65535;
       }
@@ -128,7 +128,7 @@
   L1 = AIR_ABS(vec[0]) + AIR_ABS(vec[1]) + AIR_ABS(vec[2]);
   ELL_3V_SCALE(vec, 1/L1, vec);
   scl = AIR_CLAMP(0.0f, scl, 1.0f);
-  scl = AIR_CAST(float, pow(scl, 0.75));
+  scl = AIR_FLOAT(pow(scl, 0.75));
   mi = airIndex(0.0, scl, 1.0, 6);
   if (mi) {
     switch (mi) {
@@ -143,7 +143,7 @@
     }
     vi = airIndex(-1, vec[0]+vec[1], 1, bins);
     ui = airIndex(-1, vec[0]-vec[1], 1, bins);
-    ret = vi*bins + ui + base;
+    ret = AIR_CAST(short, vi*bins + ui + base);
   }
   else {
     ret = 0;
diff --color -ruN teem-1.11.0-src.orig/src/ten/mod.c teem-1.11.0-src/src/ten/mod.c
--- teem-1.11.0-src.orig/src/ten/mod.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/mod.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -209,7 +209,7 @@
     for (II=0; II<=NN-1; II++) {
       tenEigensolve_f(eval, evec, tin);
       for (ri=0; ri<3; ri++) {
-        eval[ri] = AIR_CAST(float, log(eval[ri]));
+        eval[ri] = AIR_FLOAT(log(eval[ri]));
         eval[ri] = AIR_EXISTS(eval[ri]) ? eval[ri] : -1000000;
       }
       tenMakeSingle_f(tout, tin[0], eval, evec);
@@ -221,7 +221,7 @@
     for (II=0; II<=NN-1; II++) {
       tenEigensolve_f(eval, evec, tin);
       for (ri=0; ri<3; ri++) {
-        eval[ri] = AIR_CAST(float, exp(eval[ri]));
+        eval[ri] = AIR_FLOAT(exp(eval[ri]));
         eval[ri] = AIR_EXISTS(eval[ri]) ? eval[ri] : 0;
       }
       tenMakeSingle_f(tout, tin[0], eval, evec);
diff --color -ruN teem-1.11.0-src.orig/src/ten/model1Cylinder.c teem-1.11.0-src/src/ten/model1Cylinder.c
--- teem-1.11.0-src.orig/src/ten/model1Cylinder.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/model1Cylinder.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/model1Stick.c teem-1.11.0-src/src/ten/model1Stick.c
--- teem-1.11.0-src.orig/src/ten/model1Stick.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/model1Stick.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/model1Tensor2.c teem-1.11.0-src/src/ten/model1Tensor2.c
--- teem-1.11.0-src.orig/src/ten/model1Tensor2.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/model1Tensor2.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/model1Unit2D.c teem-1.11.0-src/src/ten/model1Unit2D.c
--- teem-1.11.0-src.orig/src/ten/model1Unit2D.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/model1Unit2D.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/model1Vector2D.c teem-1.11.0-src/src/ten/model1Vector2D.c
--- teem-1.11.0-src.orig/src/ten/model1Vector2D.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/model1Vector2D.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/model2Unit2D.c teem-1.11.0-src/src/ten/model2Unit2D.c
--- teem-1.11.0-src.orig/src/ten/model2Unit2D.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/model2Unit2D.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/modelB0.c teem-1.11.0-src/src/ten/modelB0.c
--- teem-1.11.0-src.orig/src/ten/modelB0.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/modelB0.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/modelBall1Cylinder.c teem-1.11.0-src/src/ten/modelBall1Cylinder.c
--- teem-1.11.0-src.orig/src/ten/modelBall1Cylinder.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/modelBall1Cylinder.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/modelBall1Stick.c teem-1.11.0-src/src/ten/modelBall1Stick.c
--- teem-1.11.0-src.orig/src/ten/modelBall1Stick.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/modelBall1Stick.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/modelBall1StickEMD.c teem-1.11.0-src/src/ten/modelBall1StickEMD.c
--- teem-1.11.0-src.orig/src/ten/modelBall1StickEMD.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/modelBall1StickEMD.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/modelBall.c teem-1.11.0-src/src/ten/modelBall.c
--- teem-1.11.0-src.orig/src/ten/modelBall.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/modelBall.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/modelZero.c teem-1.11.0-src/src/ten/modelZero.c
--- teem-1.11.0-src.orig/src/ten/modelZero.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/modelZero.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/path.c teem-1.11.0-src/src/ten/path.c
--- teem-1.11.0-src.orig/src/ten/path.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/path.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -562,9 +562,9 @@
 
   tt = AIR_CAST(double *, ntt->data);
   if (doubleVerts) {
-    NN = AIR_CAST(unsigned int, (ntt->axis[1].size-1)/2);
+    NN = AIR_UINT((ntt->axis[1].size-1)/2);
   } else {
-    NN = AIR_CAST(unsigned int, ntt->axis[1].size-1);
+    NN = AIR_UINT(ntt->axis[1].size-1);
   }
   len = 0;
   for (ii=0; ii<NN; ii++) {
@@ -616,7 +616,7 @@
 
   in = AIR_CAST(double *, nin->data);
   out = AIR_CAST(double *, nout->data);
-  NN = (nin->axis[1].size-1)/2;
+  NN = AIR_UINT((nin->axis[1].size-1)/2);
   lenTotal = tenInterpPathLength(nin, AIR_TRUE, AIR_FALSE, AIR_FALSE);
   lenStep = lenTotal/NN;
   /*
diff --color -ruN teem-1.11.0-src.orig/src/ten/privateTen.h teem-1.11.0-src/src/ten/privateTen.h
--- teem-1.11.0-src.orig/src/ten/privateTen.h	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/privateTen.h	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -29,7 +29,7 @@
 #endif
 
 #define TEND_CMD(name, info) \
-unrrduCmd tend_##name##Cmd = { #name, info, tend_##name##Main }
+  unrrduCmd tend_##name##Cmd = { #name, info, tend_##name##Main, AIR_FALSE }
 
 /* USAGE, PARSE: both copied verbatim from unrrdu/privateUnrrdu.h, but
 ** then some hacking was added . . .
diff --color -ruN teem-1.11.0-src.orig/src/ten/qglox.c teem-1.11.0-src/src/ten/qglox.c
--- teem-1.11.0-src.orig/src/ten/qglox.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/qglox.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/qseg.c teem-1.11.0-src/src/ten/qseg.c
--- teem-1.11.0-src.orig/src/ten/qseg.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/qseg.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/sources.cmake teem-1.11.0-src/src/ten/sources.cmake
--- teem-1.11.0-src.orig/src/ten/sources.cmake	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,85 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(TEN_SOURCES
-  aniso.c
-  bimod.c
-  bvec.c
-  chan.c
-  defaultsTen.c
-  enumsTen.c
-  epireg.c
-  estimate.c
-  fiber.c
-  fiberMethods.c
-  glyph.c
-  grads.c
-  miscTen.c
-  mod.c
-  path.c
-  privateTen.h
-  qglox.c
-  qseg.c
-  ten.h
-  tenDwiGage.c
-  tenGage.c
-  tenMacros.h
-  tendAbout.c
-  tendAnhist.c
-  tendAnplot.c
-  tendAnscale.c
-  tendAnvol.c
-  tendAvg.c
-  tendBfit.c
-  tendBmat.c
-  tendEllipse.c
-  tendEpireg.c
-  tendEstim.c
-  tendEval.c
-  tendEvaladd.c
-  tendEvalmult.c
-  tendEvalclamp.c
-  tendEvalpow.c
-  tendEvec.c
-  tendEvecrgb.c
-  tendEvq.c
-  tendExp.c
-  tendExpand.c
-  tendFiber.c
-  tendFlotsam.c
-  tendGlyph.c
-  tendGrads.c
-  tendHelix.c
-  tendLog.c
-  tendMake.c
-  tendNorm.c
-  tendPoint.c
-  tendSatin.c
-  tendShrink.c
-  tendSim.c
-  tendMsim.c
-  tendMfit.c
-  tendMconv.c
-  tendSlice.c
-  tendSten.c
-  tendTconv.c
-  tendTriple.c
-  tendUnmf.c
-  tensor.c
-  triple.c
-  experSpec.c
-  tenModel.c
-  modelZero.c
-  modelB0.c
-  modelBall.c
-  model1Stick.c
-  model1Vector2D.c
-  model1Unit2D.c
-  model2Unit2D.c
-  modelBall1StickEMD.c
-  modelBall1Stick.c
-  modelBall1Cylinder.c
-  model1Cylinder.c
-  model1Tensor2.c
-  )
-
-ADD_TEEM_LIBRARY(ten ${TEN_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendAbout.c teem-1.11.0-src/src/ten/tendAbout.c
--- teem-1.11.0-src.orig/src/ten/tendAbout.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendAbout.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -29,14 +29,15 @@
 int
 tend_aboutMain(int argc, const char **argv, const char *me,
                hestParm *hparm) {
-  char buff[AIR_STRLEN_MED], fmt[AIR_STRLEN_MED];
+  char buff[AIR_STRLEN_LARGE], fmt[AIR_STRLEN_MED];
   char par1[] = "\t\t\t\t"
     "\"tend\" is a command-line interface to much of the functionality "
     "in \"ten\", a C library for diffusion image processing. Ten is one "
     "library in the \"Teem\" collection of libraries.  More information "
     "about Teem is at <http://teem.sf.net>. A checkout of Teem source "
     "is available via:\n "
-    "svn co http://teem.svn.sf.net/svnroot/teem/teem/trunk teem\n ";
+    "svn co http://svn.code.sf.net/p/teem/code/teem/trunk teem\n ";
+  /* "svn co http://teem.svn.sf.net/svnroot/teem/teem/trunk teem\n "; */
   char par2[] = "\t\t\t\t"
     "Long-term maintenance of this software depends on funding, and "
     "funding depends on being able to document who is using it for what.  "
@@ -73,8 +74,7 @@
   sprintf(fmt, "%%%ds\n",
           (int)((hparm->columns-strlen(buff))/2 + strlen(buff) - 1));
   fprintf(stdout, fmt, buff);
-  sprintf(buff, "(Teem version %s, %s)",
-          airTeemVersion, airTeemReleaseDate);
+  airTeemVersionSprint(buff);
   sprintf(fmt, "%%%ds\n",
           (int)((hparm->columns-strlen(buff))/2 + strlen(buff) - 1));
   fprintf(stdout, fmt, buff);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendAnhist.c teem-1.11.0-src/src/ten/tendAnhist.c
--- teem-1.11.0-src.orig/src/ten/tendAnhist.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendAnhist.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -85,5 +85,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(anhist, INFO); */
-unrrduCmd tend_anhistCmd = { "anhist", INFO, tend_anhistMain };
+TEND_CMD(anhist, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendAnplot.c teem-1.11.0-src/src/ten/tendAnplot.c
--- teem-1.11.0-src.orig/src/ten/tendAnplot.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendAnplot.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -90,6 +90,5 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(anplot, INFO); */
-unrrduCmd tend_anplotCmd = { "anplot", INFO, tend_anplotMain };
+TEND_CMD(anplot, INFO);
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendAnscale.c teem-1.11.0-src/src/ten/tendAnscale.c
--- teem-1.11.0-src.orig/src/ten/tendAnscale.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendAnscale.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendAnvol.c teem-1.11.0-src/src/ten/tendAnvol.c
--- teem-1.11.0-src.orig/src/ten/tendAnvol.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendAnvol.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -75,5 +75,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(anvol, INFO); */
-unrrduCmd tend_anvolCmd = { "anvol", INFO, tend_anvolMain };
+TEND_CMD(anvol, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendAvg.c teem-1.11.0-src/src/ten/tendAvg.c
--- teem-1.11.0-src.orig/src/ten/tendAvg.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendAvg.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -76,5 +76,4 @@
   airMopOkay(mop);
   return 0;
 }
-
-unrrduCmd tend_avgCmd = { "avg", INFO, tend_avgMain };
+TEND_CMD(avg, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendBfit.c teem-1.11.0-src/src/ten/tendBfit.c
--- teem-1.11.0-src.orig/src/ten/tendBfit.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendBfit.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -109,5 +109,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(bfit, INFO); */
-unrrduCmd tend_bfitCmd = { "bfit", INFO, tend_bfitMain };
+TEND_CMD(bfit, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendBmat.c teem-1.11.0-src/src/ten/tendBmat.c
--- teem-1.11.0-src.orig/src/ten/tendBmat.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendBmat.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -76,4 +76,4 @@
   airMopOkay(mop);
   return 0;
 }
-unrrduCmd tend_bmatCmd = { "bmat", INFO, tend_bmatMain };
+TEND_CMD(bmat, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendEllipse.c teem-1.11.0-src/src/ten/tendEllipse.c
--- teem-1.11.0-src.orig/src/ten/tendEllipse.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendEllipse.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -71,9 +71,9 @@
   minX *= 72; minY *= 72;
   maxX *= 72; maxY *= 72;
   if (npos) {
-    gscale *= AIR_CAST(float, (maxX - minX)/(max[0] - min[0]));
-    dotRad *= AIR_CAST(float, (maxX - minX)/(max[0] - min[0]));
-    lineWidth *= AIR_CAST(float, (maxX - minX)/(max[0] - min[0]));
+    gscale *= AIR_FLOAT((maxX - minX)/(max[0] - min[0]));
+    dotRad *= AIR_FLOAT((maxX - minX)/(max[0] - min[0]));
+    lineWidth *= AIR_FLOAT((maxX - minX)/(max[0] - min[0]));
   }
 
   fprintf(file, "%%!PS-Adobe-3.0 EPSF-3.0\n");
@@ -111,8 +111,8 @@
       py = AIR_AFFINE(min[1], pdata[1], max[1], maxY, minY);
       pdata += 2;
     } else {
-      x = ti % sx;
-      y = ti / sx;
+      x = AIR_CAST(int, ti % sx); /* HEY unsigned? */
+      y = AIR_CAST(int, ti / sx);
       px = NRRD_CELL_POS(minX, maxX, sx, x);
       py = NRRD_CELL_POS(minY, maxY, sy, sy-1-y);
     }
@@ -156,8 +156,8 @@
         py = AIR_AFFINE(min[1], pdata[1], max[1], maxY, minY);
         pdata += 2;
       } else {
-        x = ti % sx;
-        y = ti / sx;
+        x = AIR_CAST(int, ti % sx); /* HEY unsigned? */
+        y = AIR_CAST(int, ti / sx);
         px = NRRD_CELL_POS(minX, maxX, sx, x);
         py = NRRD_CELL_POS(minY, maxY, sy, sy-1-y);
       }
@@ -308,5 +308,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(glyph, INFO); */
-unrrduCmd tend_ellipseCmd = { "ellipse", INFO, tend_ellipseMain };
+TEND_CMD(ellipse, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendEpireg.c teem-1.11.0-src/src/ten/tendEpireg.c
--- teem-1.11.0-src.orig/src/ten/tendEpireg.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendEpireg.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -207,5 +207,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(epireg, INFO); */
-unrrduCmd tend_epiregCmd = { "epireg", INFO, tend_epiregMain };
+TEND_CMD(epireg, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendEstim.c teem-1.11.0-src/src/ten/tendEstim.c
--- teem-1.11.0-src.orig/src/ten/tendEstim.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendEstim.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -35,88 +35,6 @@
    "according to the threshold and softness parameters. ");
 
 int
-tend_estimThresholdFind(double *threshP, Nrrd *nbmat, Nrrd *nin4d) {
-  static const char me[]="tend_estimThresholdFind";
-  Nrrd **ndwi;
-  airArray *mop;
-  unsigned int slIdx, slNum, dwiAx, dwiNum,
-    rangeAxisNum, rangeAxisIdx[NRRD_DIM_MAX];
-  double *bmat, bten[7], bnorm;
-  int dwiIdx;
-
-  mop = airMopNew();
-
-  if (!(threshP && nbmat && nin4d)) {
-    biffAddf(TEN, "%s: got NULL pointer", me);
-    airMopError(mop); return 1;
-  }
-  if (tenBMatrixCheck(nbmat, nrrdTypeDouble, 6)) {
-    biffAddf(TEN, "%s: problem within given b-matrix", me);
-    airMopError(mop); return 1;
-  }
-
-  /* HEY: copied from tenEpiRegister4D() */
-  rangeAxisNum = nrrdRangeAxesGet(nin4d, rangeAxisIdx);
-  if (0 == rangeAxisNum) {
-    /* we fall back on old behavior */
-    dwiAx = 0;
-  } else if (1 == rangeAxisNum) {
-    /* thankfully there's exactly one range axis */
-    dwiAx = rangeAxisIdx[0];
-  } else {
-    biffAddf(TEN, "%s: have %u range axes instead of 1, don't know which "
-             "is DWI axis", me, rangeAxisNum);
-    airMopError(mop); return 1;
-  }
-
-  slNum = nin4d->axis[dwiAx].size;
-  bmat = AIR_CAST(double *, nbmat->data);
-  dwiNum = 0;
-  for (slIdx=0; slIdx<slNum; slIdx++) {
-    TEN_T_SET(bten, 1.0,
-              bmat[0], bmat[1], bmat[2],
-              bmat[3], bmat[4],
-              bmat[5]);
-    bnorm = TEN_T_NORM(bten);
-    dwiNum += bnorm > 0.0;
-    bmat += 6;
-  }
-  if (0 == dwiNum) {
-    biffAddf(TEN, "%s: somehow got zero DWIs", me);
-    airMopError(mop); return 1;
-  }
-  ndwi = AIR_CALLOC(dwiNum, Nrrd *);
-  airMopAdd(mop, ndwi, (airMopper)airFree, airMopAlways);
-  bmat = AIR_CAST(double *, nbmat->data);
-  dwiIdx = -1;
-  for (slIdx=0; slIdx<slNum; slIdx++) {
-    TEN_T_SET(bten, 1.0,
-              bmat[0], bmat[1], bmat[2],
-              bmat[3], bmat[4],
-              bmat[5]);
-    bnorm = TEN_T_NORM(bten);
-    if (bnorm > 0.0) {
-      dwiIdx++;
-      ndwi[dwiIdx] = nrrdNew();
-      airMopAdd(mop, ndwi[dwiIdx], (airMopper)nrrdNuke, airMopAlways);
-      if (nrrdSlice(ndwi[dwiIdx], nin4d, dwiAx, slIdx)) {
-        biffMovef(TEN, NRRD,
-                  "%s: trouble slicing DWI at index %u", me, slIdx);
-        airMopError(mop); return 1;
-      }
-    }
-    bmat += 6;
-  }
-  if (_tenEpiRegThresholdFind(threshP, ndwi, dwiNum, AIR_FALSE, 1.5)) {
-    biffAddf(TEN, "%s: trouble finding thresh", me);
-    airMopError(mop); return 1;
-  }
-
-  airMopOkay(mop);
-  return 0;
-}
-
-int
 tend_estimMain(int argc, const char **argv, const char *me,
                hestParm *hparm) {
   int pret;
@@ -315,7 +233,27 @@
       airMopError(mop); return 1;
     }
     if (!AIR_EXISTS(thresh)) {
-      if (tend_estimThresholdFind(&thresh, nbmat, nin4d)) {
+      unsigned char *isB0 = NULL;
+      double bten[7], bnorm, *bmat;
+      unsigned int sl;
+      /* from nbmat, create an array that indicates B0 images */
+      if (tenBMatrixCheck(nbmat, nrrdTypeDouble, 6)) {
+        biffAddf(TEN, "%s: problem within given b-matrix", me);
+        airMopError(mop); return 1;
+      }
+      isB0 = AIR_CAST(unsigned char *, malloc(nbmat->axis[1].size));
+      airMopAdd(mop, isB0, airFree, airMopAlways);
+      bmat = (double*) nbmat->data;
+      for (sl=0; sl<nbmat->axis[1].size; sl++) {
+        TEN_T_SET(bten, 1.0,
+                  bmat[0], bmat[1], bmat[2],
+                  bmat[3], bmat[4],
+                  bmat[5]);
+        bnorm = TEN_T_NORM(bten);
+        isB0[sl]=(bnorm==0.0);
+        bmat+=6;
+      }
+      if (tenEstimateThresholdFind(&thresh, isB0, nin4d)) {
         airMopAdd(mop, err=biffGetDone(TEN), airFree, airMopAlways);
         fprintf(stderr, "%s: trouble finding threshold:\n%s\n", me, err);
         airMopError(mop); return 1;
@@ -443,5 +381,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(estim, INFO); */
-unrrduCmd tend_estimCmd = { "estim", INFO, tend_estimMain };
+TEND_CMD(estim, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendEvaladd.c teem-1.11.0-src/src/ten/tendEvaladd.c
--- teem-1.11.0-src.orig/src/ten/tendEvaladd.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendEvaladd.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendEval.c teem-1.11.0-src/src/ten/tendEval.c
--- teem-1.11.0-src.orig/src/ten/tendEval.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendEval.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendEvalclamp.c teem-1.11.0-src/src/ten/tendEvalclamp.c
--- teem-1.11.0-src.orig/src/ten/tendEvalclamp.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendEvalclamp.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendEvalmult.c teem-1.11.0-src/src/ten/tendEvalmult.c
--- teem-1.11.0-src.orig/src/ten/tendEvalmult.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendEvalmult.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendEvalpow.c teem-1.11.0-src/src/ten/tendEvalpow.c
--- teem-1.11.0-src.orig/src/ten/tendEvalpow.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendEvalpow.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendEvec.c teem-1.11.0-src/src/ten/tendEvec.c
--- teem-1.11.0-src.orig/src/ten/tendEvec.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendEvec.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -94,7 +94,7 @@
   if (1 == compLen) {
     for (I=0; I<N; I++) {
       tenEigensolve_f(eval, evec, tdata);
-      scl = AIR_CAST(float, tdata[0] >= thresh);
+      scl = AIR_FLOAT(tdata[0] >= thresh);
       ELL_3V_SCALE(edata, scl, evec+3*comp[0]);
       edata += 3;
       tdata += 7;
@@ -102,7 +102,7 @@
   } else {
     for (I=0; I<N; I++) {
       tenEigensolve_f(eval, evec, tdata);
-      scl = AIR_CAST(float, tdata[0] >= thresh);
+      scl = AIR_FLOAT(tdata[0] >= thresh);
       for (cc=0; cc<compLen; cc++) {
         ELL_3V_SCALE(edata+3*cc, scl, evec+3*comp[cc]);
       }
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendEvecrgb.c teem-1.11.0-src/src/ten/tendEvecrgb.c
--- teem-1.11.0-src.orig/src/ten/tendEvecrgb.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendEvecrgb.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendEvq.c teem-1.11.0-src/src/ten/tendEvq.c
--- teem-1.11.0-src.orig/src/ten/tendEvq.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendEvq.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendExpand.c teem-1.11.0-src/src/ten/tendExpand.c
--- teem-1.11.0-src.orig/src/ten/tendExpand.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendExpand.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendExp.c teem-1.11.0-src/src/ten/tendExp.c
--- teem-1.11.0-src.orig/src/ten/tendExp.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendExp.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendFiber.c teem-1.11.0-src/src/ten/tendFiber.c
--- teem-1.11.0-src.orig/src/ten/tendFiber.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendFiber.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -132,8 +132,8 @@
           && 4 == _nmat->axis[1].size)) {
       fprintf(stderr, "%s: transform matrix must be 2-D 4-by-4 array "
               "not %u-D %u-by-?\n", me,
-              AIR_CAST(unsigned int, _nmat->dim),
-              AIR_CAST(unsigned int, _nmat->axis[0].size));
+              AIR_UINT(_nmat->dim),
+              AIR_UINT(_nmat->axis[0].size));
       airMopError(mop); return 1;
     }
     nmat = nrrdNew();
@@ -172,7 +172,7 @@
     case tenFiberStopNumSteps:
     case tenFiberStopMinNumSteps:
       if (!E) E |= tenFiberStopSet(tfx, istop,
-                                   AIR_CAST(unsigned int, stop[1]));
+                                   AIR_UINT(stop[1]));
       break;
     case tenFiberStopLength:
     case tenFiberStopConfidence:
@@ -312,5 +312,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(fiber, INFO); */
-unrrduCmd tend_fiberCmd = { "fiber", INFO, tend_fiberMain };
+TEND_CMD(fiber, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendFlotsam.c teem-1.11.0-src/src/ten/tendFlotsam.c
--- teem-1.11.0-src.orig/src/ten/tendFlotsam.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendFlotsam.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -49,7 +49,7 @@
 ** info[2]: 2nd parameter, used occasionally
 */
 int
-tendFiberStopParse(void *ptr, char *_str, char err[AIR_STRLEN_HUGE]) {
+tendFiberStopParse(void *ptr, const char *_str, char err[AIR_STRLEN_HUGE]) {
   char me[]="tenFiberStopParse", *str, *opt, *opt2;
   double *info;
   airArray *mop;
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendGlyph.c teem-1.11.0-src/src/ten/tendGlyph.c
--- teem-1.11.0-src.orig/src/ten/tendGlyph.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendGlyph.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -571,5 +571,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(glyph, INFO); */
-unrrduCmd tend_glyphCmd = { "glyph", INFO, tend_glyphMain };
+TEND_CMD(glyph, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendGrads.c teem-1.11.0-src/src/ten/tendGrads.c
--- teem-1.11.0-src.orig/src/ten/tendGrads.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendGrads.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -120,7 +120,7 @@
   airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
 
   /* see if it was an integral exponent */
-  tgparm->expo = AIR_CAST(unsigned int, tgparm->expo_d);
+  tgparm->expo = AIR_UINT(tgparm->expo_d);
   if (tgparm->expo == tgparm->expo_d) {
     /* ooo, it was */
     tgparm->expo_d = 0;
@@ -150,4 +150,4 @@
   airMopOkay(mop);
   return 0;
 }
-unrrduCmd tend_gradsCmd = { "grads", INFO, tend_gradsMain };
+TEND_CMD(grads, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendHelix.c teem-1.11.0-src/src/ten/tendHelix.c
--- teem-1.11.0-src.orig/src/ten/tendHelix.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendHelix.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -49,16 +49,16 @@
                double orig[3], double i2w[9], double mf[9],
                double r, double R, double S, double angle, int incrtwist,
                double ev[3], double bgEval, int verbose) {
-  int sx, sy, sz, xi, yi, zi;
+  unsigned int sx, sy, sz, xi, yi, zi;
   double th, t0, t1, t2, t3, v1, v2,
     wpos[3], vpos[3], mfT[9],
     W2H[9], H2W[9], H2C[9], C2H[9], fv[3], rv[3], uv[3], mA[9], mB[9], inside,
     tmp[3], len;
   float *out;
 
-  sx = nout->axis[1].size;
-  sy = nout->axis[2].size;
-  sz = nout->axis[3].size;
+  sx = AIR_UINT(nout->axis[1].size);
+  sy = AIR_UINT(nout->axis[2].size);
+  sz = AIR_UINT(nout->axis[3].size);
   out = (float*)nout->data;
   ELL_3M_TRANSPOSE(mfT, mf);
   for (zi=0; zi<sz; zi++) {
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendLog.c teem-1.11.0-src/src/ten/tendLog.c
--- teem-1.11.0-src.orig/src/ten/tendLog.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendLog.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendMake.c teem-1.11.0-src/src/ten/tendMake.c
--- teem-1.11.0-src.orig/src/ten/tendMake.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendMake.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -70,4 +70,4 @@
   airMopOkay(mop);
   return 0;
 }
-unrrduCmd tend_makeCmd = { "make", INFO, tend_makeMain };
+TEND_CMD(make, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendMconv.c teem-1.11.0-src/src/ten/tendMconv.c
--- teem-1.11.0-src.orig/src/ten/tendMconv.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendMconv.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -95,5 +95,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(mconv, INFO); */
-unrrduCmd tend_mconvCmd = { "mconv", INFO, tend_mconvMain };
+TEND_CMD(mconv, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendMfit.c teem-1.11.0-src/src/ten/tendMfit.c
--- teem-1.11.0-src.orig/src/ten/tendMfit.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendMfit.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -144,5 +144,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(mfit, INFO); */
-unrrduCmd tend_mfitCmd = { "mfit", INFO, tend_mfitMain };
+TEND_CMD(mfit, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendMsim.c teem-1.11.0-src/src/ten/tendMsim.c
--- teem-1.11.0-src.orig/src/ten/tendMsim.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendMsim.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -142,7 +142,7 @@
   if (!E) E |= tenExperSpecGradSingleBValSet(espec, insertB0, bval,
                                              AIR_CAST(const double *,
                                                       ngrad->data),
-                                             ngrad->axis[1].size);
+                                             AIR_UINT(ngrad->axis[1].size));
   if (!E) E |= tenModelSimulate(nout, outType, espec,
                                 model, nT2, nin, keyValueSet);
   if (E) {
@@ -159,5 +159,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(msim, INFO); */
-unrrduCmd tend_msimCmd = { "msim", INFO, tend_msimMain };
+TEND_CMD(msim, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendNorm.c teem-1.11.0-src/src/ten/tendNorm.c
--- teem-1.11.0-src.orig/src/ten/tendNorm.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendNorm.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendPoint.c teem-1.11.0-src/src/ten/tendPoint.c
--- teem-1.11.0-src.orig/src/ten/tendPoint.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendPoint.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -57,9 +57,9 @@
     fprintf(stderr, "%s: didn't get a valid DT volume:\n%s\n", me, err);
     airMopError(mop); return 1;
   }
-  sx = nin->axis[1].size;
-  sy = nin->axis[2].size;
-  sz = nin->axis[3].size;
+  sx = AIR_CAST(int, nin->axis[1].size); /* HEY: unsigned? */
+  sy = AIR_CAST(int, nin->axis[2].size);
+  sz = AIR_CAST(int, nin->axis[3].size);
   if (!( AIR_IN_CL(0, loc[0], sx-1) &&
          AIR_IN_CL(0, loc[1], sy-1) &&
          AIR_IN_CL(0, loc[2], sz-1) )) {
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendSatin.c teem-1.11.0-src/src/ten/tendSatin.c
--- teem-1.11.0-src.orig/src/ten/tendSatin.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendSatin.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -36,12 +36,12 @@
                       float thick, float bnd, float evsc) {
   float aniso, bound1, bound2, r, norm, tmp[3];
 
-  r = AIR_CAST(float, sqrt(x*x + y*y + z*z));
+  r = AIR_FLOAT(sqrt(x*x + y*y + z*z));
   /* 1 on inside, 0 on outside */
-  bound1 = AIR_CAST(float, 0.5 - 0.5*airErf((r-0.9)/(bnd + 0.0001)));
+  bound1 = AIR_FLOAT(0.5 - 0.5*airErf((r-0.9)/(bnd + 0.0001)));
   /* other way around */
-  bound2 = AIR_CAST(float, 0.5 - 0.5*airErf((0.9-thick-r)/(bnd + 0.0001)));
-  aniso = AIR_CAST(float, AIR_AFFINE(0.0, AIR_MIN(bound1, bound2), 1.0,
+  bound2 = AIR_FLOAT(0.5 - 0.5*airErf((0.9-thick-r)/(bnd + 0.0001)));
+  aniso = AIR_FLOAT(AIR_AFFINE(0.0, AIR_MIN(bound1, bound2), 1.0,
                                      mina, maxa));
 
   ELL_3V_SET_TT(eval, float,
@@ -76,11 +76,11 @@
   float bound, R, r, norm, out[3], up[3], aniso;
 
   thick *= 2;
-  R = AIR_CAST(float, sqrt(x*x + y*y));
-  r = AIR_CAST(float, sqrt((R-1)*(R-1) + z*z));
+  R = AIR_FLOAT(sqrt(x*x + y*y));
+  r = AIR_FLOAT(sqrt((R-1)*(R-1) + z*z));
   /* 1 on inside, 0 on outside */
-  bound = AIR_CAST(float, 0.5 - 0.5*airErf((r-thick)/(bnd + 0.0001)));
-  aniso = AIR_CAST(float, AIR_AFFINE(0, bound, 1, mina, maxa));
+  bound = AIR_FLOAT(0.5 - 0.5*airErf((r-thick)/(bnd + 0.0001)));
+  aniso = AIR_FLOAT(AIR_AFFINE(0, bound, 1, mina, maxa));
 
   ELL_3V_SET_TT(eval, float,
                 AIR_LERP(aniso, 1.0/3.0, AIR_AFFINE(0.0, parm, 2.0, 1.0, 0.0)),
@@ -113,7 +113,8 @@
 
 int
 tend_satinGen(Nrrd *nout, float parm, float mina, float maxa, int wsize,
-              float thick, float bnd, float bndRm, float evsc, int torus) {
+              float thick, float scaling,
+              float bnd, float bndRm, float evsc, int torus) {
   static const char me[]="tend_satinGen";
   char buff[AIR_STRLEN_SMALL];
   Nrrd *nconf, *neval, *nevec;
@@ -144,20 +145,23 @@
   eval = (float *)neval->data;
   evec = (float *)nevec->data;
   for (zi=0; zi<size[2]; zi++) {
-    z = AIR_CAST(float, AIR_AFFINE(0, zi, size[2]-1, min[2], max[2]));
+    z = AIR_FLOAT(AIR_AFFINE(0, zi, size[2]-1, min[2], max[2]));
+    z /= scaling;
     for (yi=0; yi<size[1]; yi++) {
-      y = AIR_CAST(float, AIR_AFFINE(0, yi, size[1]-1, min[1], max[1]));
+      y = AIR_FLOAT(AIR_AFFINE(0, yi, size[1]-1, min[1], max[1]));
+      y /= scaling;
       for (xi=0; xi<size[0]; xi++) {
-        x = AIR_CAST(float, AIR_AFFINE(0, xi, size[0]-1, min[0], max[0]));
+        x = AIR_FLOAT(AIR_AFFINE(0, xi, size[0]-1, min[0], max[0]));
+        x /= scaling;
         *conf = 1.0;
         if (torus) {
           float aff;
-          aff = AIR_CAST(float, AIR_AFFINE(0, yi, size[1]-1, 0, 1));
+          aff = AIR_FLOAT(AIR_AFFINE(0, yi, size[1]-1, 0, 1));
           tend_satinTorusEigen(eval, evec, x, y, z, parm,
                                mina, maxa, thick, bnd + bndRm*aff, evsc);
         } else {
           float aff;
-          aff = AIR_CAST(float, AIR_AFFINE(0,yi, size[1]-1, 0, 1));
+          aff = AIR_FLOAT(AIR_AFFINE(0,yi, size[1]-1, 0, 1));
           tend_satinSphereEigen(eval, evec, x, y, z, parm,
                                 mina, maxa, thick, bnd + bndRm*aff, evsc);
         }
@@ -191,7 +195,7 @@
   airArray *mop;
 
   int wsize, torus;
-  float parm, maxa, mina, thick, bnd, bndRm, evsc;
+  float parm, maxa, mina, thick, scaling, bnd, bndRm, evsc;
   Nrrd *nout;
   char *outS;
   gageShape *shape;
@@ -219,6 +223,9 @@
              "Use \"-b 0\" for no such ramping.");
   hestOptAdd(&hopt, "th", "thickness", airTypeFloat, 1, 1, &thick, "0.3",
              "parameter governing how thick region of high anisotropy is");
+  hestOptAdd(&hopt, "scl", "scaling", airTypeFloat, 1, 1, &scaling, "1.0",
+             "scaling on size of sphere or torus within volume; lowering "
+             "this below default 1.0 produces more background margin");
   hestOptAdd(&hopt, "evsc", "eval scale", airTypeFloat, 1, 1, &evsc, "1.0",
              "scaling of eigenvalues");
   hestOptAdd(&hopt, "s", "size", airTypeInt, 1, 1, &wsize, "32",
@@ -236,7 +243,7 @@
   nout = nrrdNew();
   airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
 
-  if (tend_satinGen(nout, parm, mina, maxa, wsize, thick,
+  if (tend_satinGen(nout, parm, mina, maxa, wsize, thick, scaling,
                     bnd, bndRm, evsc, torus)) {
     airMopAdd(mop, err=biffGetDone(TEN), airFree, airMopAlways);
     fprintf(stderr, "%s: trouble making volume:\n%s\n", me, err);
@@ -302,4 +309,4 @@
   return 0;
 }
 /* TEND_CMD(satin, INFO); */
-unrrduCmd tend_satinCmd = { "satin", INFO, tend_satinMain };
+unrrduCmd tend_satinCmd = { "satin", INFO, tend_satinMain, AIR_FALSE };
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendShrink.c teem-1.11.0-src/src/ten/tendShrink.c
--- teem-1.11.0-src.orig/src/ten/tendShrink.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendShrink.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendSim.c teem-1.11.0-src/src/ten/tendSim.c
--- teem-1.11.0-src.orig/src/ten/tendSim.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendSim.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -156,5 +156,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(sim, INFO); */
-unrrduCmd tend_simCmd = { "sim", INFO, tend_simMain };
+TEND_CMD(sim, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendSlice.c teem-1.11.0-src/src/ten/tendSlice.c
--- teem-1.11.0-src.orig/src/ten/tendSlice.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendSlice.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendSten.c teem-1.11.0-src/src/ten/tendSten.c
--- teem-1.11.0-src.orig/src/ten/tendSten.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendSten.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -82,7 +82,6 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(sten, INFO); */
-unrrduCmd tend_stenCmd = { "sten", INFO, tend_stenMain };
+TEND_CMD(sten, INFO);
 
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendTconv.c teem-1.11.0-src/src/ten/tendTconv.c
--- teem-1.11.0-src.orig/src/ten/tendTconv.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendTconv.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -72,5 +72,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(anvol, INFO); */
-unrrduCmd tend_tconvCmd = { "tconv", INFO, tend_tconvMain };
+TEND_CMD(tconv, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendTriple.c teem-1.11.0-src/src/ten/tendTriple.c
--- teem-1.11.0-src.orig/src/ten/tendTriple.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendTriple.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -71,5 +71,4 @@
   airMopOkay(mop);
   return 0;
 }
-/* TEND_CMD(anvol, INFO); */
-unrrduCmd tend_tripleCmd = { "triple", INFO, tend_tripleMain };
+TEND_CMD(triple, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tendUnmf.c teem-1.11.0-src/src/ten/tendUnmf.c
--- teem-1.11.0-src.orig/src/ten/tendUnmf.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tendUnmf.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tenDwiGage.c teem-1.11.0-src/src/ten/tenDwiGage.c
--- teem-1.11.0-src.orig/src/ten/tenDwiGage.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tenDwiGage.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -477,7 +477,7 @@
                    pvlData->wght + 1, pvlData->dists );
     } else {
       /* stupid; should really return right here since data is garbage */
-      for (valIdx=1; valIdx < AIR_CAST(unsigned int, gradcount+1); valIdx++) {
+      for (valIdx=1; valIdx < AIR_UINT(gradcount+1); valIdx++) {
         pvlData->wght[valIdx] = valIdx % 2;
       }
     }
@@ -842,14 +842,15 @@
 
   /* pvlData->levmarInfo[] is output; not initialized */
 
-  return AIR_CAST(void *, pvlData);
+  return AIR_VOIDP(pvlData);
 }
 
 void *
 _tenDwiGagePvlDataCopy(const gageKind *kind, const void *_pvlDataOld) {
-  tenDwiGagePvlData *pvlDataOld, *pvlDataNew;
+  const tenDwiGagePvlData *pvlDataOld;
+  tenDwiGagePvlData *pvlDataNew;
 
-  pvlDataOld = AIR_CAST(tenDwiGagePvlData *, _pvlDataOld);
+  pvlDataOld = AIR_CAST(const tenDwiGagePvlData *, _pvlDataOld);
   pvlDataNew = AIR_CAST(tenDwiGagePvlData *, _tenDwiGagePvlDataNew(kind));
 
   /* HEY: no error checking? */
@@ -878,7 +879,7 @@
 int
 _tenDwiGagePvlDataUpdate(const gageKind *kind,
                          const gageContext *ctx,
-                         const gagePerVolume *pvl, const void *_pvlData) {
+                         const gagePerVolume *pvl, void *_pvlData) {
   /* static const char me[]="_tenDwiGagePvlDataUpdate"; */
   tenDwiGagePvlData *pvlData;
 
@@ -1012,7 +1013,7 @@
     kind->table = AIR_CAST(gageItemEntry *,
                            malloc(sizeof(_tenDwiGageTable)));
     memcpy(kind->table, _tenDwiGageTable, sizeof(_tenDwiGageTable));
-    kind->data = AIR_CAST(void *, tenDwiGageKindDataNew());
+    kind->data = AIR_VOIDP(tenDwiGageKindDataNew());
   }
   return kind;
 }
@@ -1105,7 +1106,7 @@
     biffMovef(TEN, NRRD, "%s: trouble converting", me);
     return 1;
   }
-  dwiKind->valLen = kindData->ngrad->axis[1].size;
+  dwiKind->valLen = AIR_UINT(kindData->ngrad->axis[1].size);
 
   /* fixing up the item table ... */
   dwiKind->table[tenDwiGageAll].answerLength = dwiKind->valLen;
diff --color -ruN teem-1.11.0-src.orig/src/ten/tenGage.c teem-1.11.0-src/src/ten/tenGage.c
--- teem-1.11.0-src.orig/src/ten/tenGage.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tenGage.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -602,7 +602,7 @@
   }
   if (GAGE_QUERY_ITEM_TEST(pvl->query, tenGageDetGradMag)) {
     magTmp = pvl->directAnswer[tenGageDetGradMag][0] =
-      AIR_CAST(float, ELL_3V_LEN(vecTmp));
+      AIR_FLOAT(ELL_3V_LEN(vecTmp));
   }
   if (GAGE_QUERY_ITEM_TEST(pvl->query, tenGageDetNormal)) {
     ELL_3V_SCALE(pvl->directAnswer[tenGageDetNormal],
@@ -1386,7 +1386,7 @@
 
     cov = pvl->directAnswer[tenGageCovariance];
     /* HEY: casting because radius signed (shouldn't be) */
-    fd = AIR_CAST(unsigned int, 2*ctx->radius);
+    fd = AIR_UINT(2*ctx->radius);
     fddd = fd*fd*fd;
 
     /* reset answer */
@@ -1479,7 +1479,7 @@
 
     pvlData = AIR_CAST(_tenGagePvlData *, pvl->data);
     /* HEY: casting because radius is signed (shouldn't be) */
-    fd = AIR_CAST(unsigned int, 2*ctx->radius);
+    fd = AIR_UINT(2*ctx->radius);
     fddd = fd*fd*fd;
     for (vijk=0; vijk<fddd; vijk++) {
       double wxx, wyy, wzz;
@@ -1666,7 +1666,7 @@
         ell_3m_mul_d(tmp,R,tmp2);
       }
       if (rdiff2<1.0) {
-        double mean, submatrix[3], isoPhi, gamma, beta, A, C, R[9],RT[9];
+        double mean, submatrix[3], isoPhi, _gamma, beta, A, C, R[9],RT[9];
         int axis, midaxis, smallest;
 
         mean=(tmp[0]+tmp[4]+tmp[8])/3.0;
@@ -1707,10 +1707,10 @@
           if (midaxis!=0) sign=-1;
         }
         isoPhi=0.0f;
-        gamma=sign*(submatrix[0]-submatrix[2]);
+        _gamma=sign*(submatrix[0]-submatrix[2]);
         beta=-sign*2*submatrix[1];
-        A=sqrt(gamma*gamma+beta*beta);
-        C=atan2(gamma,beta);
+        A=sqrt(_gamma*_gamma+beta*beta);
+        C=atan2(_gamma,beta);
         isoPhi=0.5*(asin(2.0/A*(mean-0.5*(submatrix[0]+submatrix[2])))-C);
         /* make sure we use the minimal rotation */
         isoPhi=asin(2.0/A*(mean-0.5*(submatrix[0]+submatrix[2])));
@@ -2050,11 +2050,12 @@
 void *
 _tenGagePvlDataCopy(const struct gageKind_t *kind,
                     const void *_pvlDataOld) {
-  _tenGagePvlData *pvlDataNew, *pvlDataOld;
+  _tenGagePvlData *pvlDataNew;
+  const _tenGagePvlData *pvlDataOld;
   unsigned int num;
 
   AIR_UNUSED(kind);
-  pvlDataOld = AIR_CAST(_tenGagePvlData *, _pvlDataOld);
+  pvlDataOld = AIR_CAST(const _tenGagePvlData *, _pvlDataOld);
   num = pvlDataOld->tip->allocLen;
   pvlDataNew = AIR_CALLOC(1, _tenGagePvlData);
   if (pvlDataNew) {
@@ -2082,14 +2083,14 @@
 int
 _tenGagePvlDataUpdate(const struct gageKind_t *kind,
                       const gageContext *ctx, const gagePerVolume *pvl,
-                      const void *_pvlData) {
+                      void *_pvlData) {
   _tenGagePvlData *pvlData;
   unsigned int fd, num;
 
   AIR_UNUSED(kind);
   AIR_UNUSED(pvl);
   pvlData = AIR_CAST(_tenGagePvlData *, _pvlData);
-  fd = AIR_CAST(unsigned int, 2*ctx->radius);
+  fd = AIR_UINT(2*ctx->radius);
   num = fd*fd*fd;
   if (num != pvlData->tip->allocLen) {
     /* HEY: no error checking */
diff --color -ruN teem-1.11.0-src.orig/src/ten/ten.h teem-1.11.0-src/src/ten/ten.h
--- teem-1.11.0-src.orig/src/ten/ten.h	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/ten.h	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -932,7 +932,7 @@
                             any intermediate histogram calculations, all of
                             which are done entirely in index space */
     delta;               /* some measure of model change between iters */
-  int N,                 /* number of bins in histogram */
+  unsigned int N,        /* number of bins in histogram */
     stage;               /* current stage (1 or 2) */
   unsigned int iteration;  /* current iteration */
   /* ----- output ------- */
@@ -1472,6 +1472,8 @@
                                   unsigned int valIdx,
                                   int doSkip);
 TEN_EXPORT int tenEstimateSkipReset(tenEstimateContext *tec);
+TEN_EXPORT int tenEstimateThresholdFind(double *threshP, unsigned char *isB0,
+                                        Nrrd *nin4d);
 TEN_EXPORT int tenEstimateThresholdSet(tenEstimateContext *tec,
                                        double thresh, double soft);
 TEN_EXPORT int tenEstimateUpdate(tenEstimateContext *tec);
diff --color -ruN teem-1.11.0-src.orig/src/ten/tenMacros.h teem-1.11.0-src/src/ten/tenMacros.h
--- teem-1.11.0-src.orig/src/ten/tenMacros.h	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tenMacros.h	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/tenModel.c teem-1.11.0-src/src/ten/tenModel.c
--- teem-1.11.0-src.orig/src/ten/tenModel.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tenModel.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -193,7 +193,7 @@
     return 1;
   }
 
-  gpsze = _nparm->axis[0].size;
+  gpsze = AIR_UINT(_nparm->axis[0].size);
   if (model->parmNum - 1 == gpsze) {
     /* got one less than needed parm #, see if we got B0 */
     if (!_nB0) {
@@ -456,10 +456,10 @@
              airEnumStr(nrrdType, typeOut));
     return 1;
   }
-  dwiNum = ndwi->axis[0].size;
+  dwiNum = AIR_UINT(ndwi->axis[0].size);
   if (espec->imgNum != dwiNum) {
     biffAddf(TEN, "%s: espec expects %u images but dwi has %u on axis 0",
-             me, espec->imgNum, AIR_CAST(unsigned int, dwiNum));
+             me, espec->imgNum, AIR_UINT(dwiNum));
     return 1;
   }
 
@@ -669,10 +669,10 @@
       airMopError(mop); return 1;
     }
   }
-  lablen = (strlen(tenModelPrefixStr)
-            + (saveB0 ? strlen("B0+") : 0)
-            + strlen(model->name)
-            + 1);
+  lablen = AIR_UINT((strlen(tenModelPrefixStr)
+                     + (saveB0 ? strlen("B0+") : 0)
+                     + strlen(model->name)
+                     + 1));
   nparm->axis[0].label = AIR_CALLOC(lablen, char);
   sprintf(nparm->axis[0].label, "%s%s%s",
           tenModelPrefixStr,
@@ -737,7 +737,7 @@
       withB0 = AIR_FALSE;
     } else {
       biffAddf(TEN, "%s: axis[0].size %u is not \"%s\" parmnum %u or 1 less",
-               me, AIR_CAST(unsigned int, nparmSrc->axis[0].size),
+               me, AIR_UINT(nparmSrc->axis[0].size),
                modelSrc->name, modelSrc->parmNum);
       return 1;
     }
@@ -751,7 +751,7 @@
   lup = nrrdDLookup[nparmSrc->type];
   ins = nrrdDInsert[nparmSrc->type];
   parmNumDst = withB0 ? modelDst->parmNum : modelDst->parmNum-1;
-  parmNumSrc = nparmSrc->axis[0].size;
+  parmNumSrc = AIR_UINT(nparmSrc->axis[0].size);
   for (ii=0; ii<nparmSrc->dim; ii++) {
     szOut[ii] = (!ii
                  ? parmNumDst
@@ -807,10 +807,10 @@
     airMopError(mop); return 1;
   }
   /* HEY: COPY AND PASTE! from above. perhaps make helper functions? */
-  lablen = (strlen(tenModelPrefixStr)
-            + (withB0 ? strlen("B0+") : 0)
-            + strlen(modelDst->name)
-            + 1);
+  lablen = AIR_UINT((strlen(tenModelPrefixStr)
+                     + (withB0 ? strlen("B0+") : 0)
+                     + strlen(modelDst->name)
+                     + 1));
   nparmDst->axis[0].label = AIR_CALLOC(lablen, char);
   sprintf(nparmDst->axis[0].label, "%s%s%s",
           tenModelPrefixStr,
diff --color -ruN teem-1.11.0-src.orig/src/ten/tensor.c teem-1.11.0-src/src/ten/tensor.c
--- teem-1.11.0-src.orig/src/ten/tensor.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/tensor.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -223,7 +223,7 @@
     redund[1] = masked[2];
     redund[2] = masked[2];
     redund[3] = masked[3];
-    ELL_4V_SCALE(redund, AIR_CAST(float, scale), redund);
+    ELL_4V_SCALE(redund, AIR_FLOAT(scale), redund);
   }
   if (nrrdAxisInfoCopy(nout, nin, NULL,
                        NRRD_AXIS_INFO_SIZE_BIT)) {
@@ -277,7 +277,7 @@
       continue;
     }
     TEN_T2M(nine, seven);
-    ELL_3M_SCALE(nine, AIR_CAST(float, scale), nine);
+    ELL_3M_SCALE(nine, AIR_FLOAT(scale), nine);
   }
   if (nrrdAxisInfoCopy(nout, nin, NULL,
                        NRRD_AXIS_INFO_SIZE_BIT)) {
@@ -988,7 +988,7 @@
 
   tenEigensolve_f(eval, evec, ten);
   for (ii=0; ii<3; ii++) {
-    eval[ii] = AIR_CAST(float, log(eval[ii]));
+    eval[ii] = AIR_FLOAT(log(eval[ii]));
     if (!AIR_EXISTS(eval[ii])) {
       eval[ii] = -FLT_MAX/10; /* still making stuff up */
     }
@@ -1015,7 +1015,7 @@
 
   tenEigensolve_f(eval, evec, ten);
   for (ii=0; ii<3; ii++) {
-    eval[ii] = AIR_CAST(float, exp(eval[ii]));
+    eval[ii] = AIR_FLOAT(exp(eval[ii]));
   }
   tenMakeSingle_f(expten, ten[0], eval, evec);
 }
@@ -1039,7 +1039,7 @@
 
   tenEigensolve_f(eval, evec, ten);
   for (ii=0; ii<3; ii++) {
-    eval[ii] = AIR_CAST(float, eval[ii] > 0 ? sqrt(eval[ii]) : 0);
+    eval[ii] = AIR_FLOAT(eval[ii] > 0 ? sqrt(eval[ii]) : 0);
   }
   tenMakeSingle_f(sqrtten, ten[0], eval, evec);
 }
@@ -1063,7 +1063,7 @@
 
   tenEigensolve_f(eval, evec, ten);
   for (ii=0; ii<3; ii++) {
-    eval[ii] = AIR_CAST(float, pow(eval[ii], power));
+    eval[ii] = AIR_FLOAT(pow(eval[ii], power));
   }
   tenMakeSingle_f(powten, ten[0], eval, evec);
 }
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/cntr.c teem-1.11.0-src/src/ten/test/cntr.c
--- teem-1.11.0-src.orig/src/ten/test/cntr.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/cntr.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,8 +24,8 @@
 
 #include "../ten.h"
 
-char *info = ("does contraction between 2 2nd-order "
-              "and 1 4rth-order tensor.");
+const char *info = ("does contraction between 2 2nd-order "
+                    "and 1 4rth-order tensor.");
 
 int
 main(int argc, const char *argv[]) {
@@ -60,16 +61,16 @@
   }
   if (!(4 == _ncov->dim && 21 == _ncov->axis[0].size)) {
     fprintf(stderr, "%s: didn't get a 4-D 21-by-X volume (got %u-D %u-by-X)\n",
-            me, _ncov->dim, AIR_CAST(unsigned int, _ncov->axis[0].size));
+            me, _ncov->dim, AIR_UINT(_ncov->axis[0].size));
     airMopError(mop);
     return 1;
   }
   if (!(nrrdElementNumber(_ncov)/21 == nrrdElementNumber(_nten[0])/7
         && nrrdElementNumber(_nten[0])/7 == nrrdElementNumber(_nten[1])/7)) {
     fprintf(stderr, "%s: number voxels %u %u %u don't all match\n", me,
-            AIR_CAST(unsigned int, nrrdElementNumber(_ncov)/21),
-            AIR_CAST(unsigned int, nrrdElementNumber(_nten[0])/7),
-            AIR_CAST(unsigned int, nrrdElementNumber(_nten[1])/7));
+            AIR_UINT(nrrdElementNumber(_ncov)/21),
+            AIR_UINT(nrrdElementNumber(_nten[0])/7),
+            AIR_UINT(nrrdElementNumber(_nten[1])/7));
     airMopError(mop);
     return 1;
   }
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/csim.c teem-1.11.0-src/src/ten/test/csim.c
--- teem-1.11.0-src.orig/src/ten/test/csim.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/csim.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -145,7 +146,7 @@
   return 0;
 }
 
-char *info = ("does something");
+const char *info = ("does something");
 
 int
 main(int argc, const char *argv[]) {
@@ -282,7 +283,7 @@
 
     dwibuff = AIR_CAST(double *, calloc(ngrad->axis[1].size, sizeof(double)));
     airMopAdd(mop, dwibuff, airFree, airMopAlways);
-    nsamp = sizeX*sizeY*sizeZ;
+    nsamp = AIR_UINT(sizeX*sizeY*sizeZ);
     inTen = AIR_CAST(double *, ninTen->data);
     lup  = nrrdDLookup[nrrdTypeDouble];
     outTen = AIR_CAST(double *, noutTen->data);
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/didthis-slice.txt teem-1.11.0-src/src/ten/test/didthis-slice.txt
--- teem-1.11.0-src.orig/src/ten/test/didthis-slice.txt	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/didthis-slice.txt	2021-02-18 15:42:36.000000000 +0800
@@ -13,7 +13,7 @@
 echo "1   1 1 1   -1 -1 -3" \
  | emap -i - -fr $FR -up 0 0 1 -rh -amb 0 0 0 -o emap.nrrd
 
-alias CROP unu crop -min 0 0 0 -max 2 M M 
+alias CROP unu crop -min 0 0 0 -max 2 M M
 
 valgrind tend glyph -i test.nrrd -a ca1 -atr 0.5 \
    -emap emap.nrrd  -bg 1 1 0 \
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/geode.c teem-1.11.0-src/src/ten/test/geode.c
--- teem-1.11.0-src.orig/src/ten/test/geode.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/geode.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../ten.h"
 
-char *info = ("does geodesics");
+const char *info = ("does geodesics");
 
 int
 main(int argc, const char *argv[]) {
@@ -109,9 +110,9 @@
       airMopError(mop);
       return 1;
     }
-    sx = AIR_CAST(unsigned int, _nin->axis[1].size);
-    sy = AIR_CAST(unsigned int, _nin->axis[2].size);
-    sz = AIR_CAST(unsigned int, _nin->axis[3].size);
+    sx = AIR_UINT(_nin->axis[1].size);
+    sy = AIR_UINT(_nin->axis[2].size);
+    sz = AIR_UINT(_nin->axis[3].size);
     if (!( refIdx[0] < sx
            && refIdx[1] < sy
            && refIdx[2] < sz )) {
@@ -258,10 +259,10 @@
 
     if (1) {
       double *geod, eval0[3], eval[3], evec0[9], evec[9], rot[9], diff[7],
-        nrm, tmp, axis[3], angle;
-      unsigned int ii, NN;
+        nrm, axis[3], angle;
+      unsigned int ii;
 
-      NN = AIR_CAST(unsigned int, nout->axis[1].size);
+      NN = AIR_UINT(nout->axis[1].size);
       geod = AIR_CAST(double *, nout->data);
       geod += 7;
       for (ii=1; ii<NN; ii++) {
@@ -289,7 +290,7 @@
     }
 
     if (0) {
-      double eval[3], evec[9], rot[9], tt[7], qB[4];
+      double eval[3], evec[9], rot[9], tt[7];
       double unitq[8][4] = {{+1, 0, 0, 0},
                             {-1, 0, 0, 0},
                             {0, +1, 0, 0},
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/igrt.c teem-1.11.0-src/src/ten/test/igrt.c
--- teem-1.11.0-src.orig/src/ten/test/igrt.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/igrt.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../ten.h"
 
-char *info = ("tests invariant grads and rotation tangents.");
+const char *info = ("tests invariant grads and rotation tangents.");
 
 int
 main(int argc, const char *argv[]) {
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/odf-hist.c teem-1.11.0-src/src/ten/test/odf-hist.c
--- teem-1.11.0-src.orig/src/ten/test/odf-hist.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/odf-hist.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../ten.h"
 
-char *info = ("The histogram craziness continues.");
+const char *info = ("The histogram craziness continues.");
 
 int
 main(int argc, const char *argv[]) {
@@ -33,7 +34,7 @@
 
   char *errS, *outS, *covarS;
   Nrrd *_nodf, *nvec, *nhist, *ncovar;
-  int bins;
+  unsigned int bins;
   size_t size[NRRD_DIM_MAX];
   float min;
 
@@ -49,7 +50,7 @@
              "ODF values below this are ignored, and per-voxel ODF is "
              "normalized to have sum 1.0.  Use \"nan\" to subtract out "
              "the per-voxel min.");
-  hestOptAdd(&hopt, "b", "bins", airTypeInt, 1, 1, &bins, "128",
+  hestOptAdd(&hopt, "b", "bins", airTypeUInt, 1, 1, &bins, "128",
              "number of bins in histograms");
   hestOptAdd(&hopt, "o", "nout", airTypeString, 1, 1, &outS, "-",
              "output file");
@@ -97,13 +98,14 @@
 
   {
     /* we modify the lengths of the vectors here */
-    int NN, VV, ii, jj=0, kk, *anglut;
+    int *anglut;
+    unsigned int ii, jj=0, kk, NN, VV;
     float *odf, *hist, *covar, *vec, *vi, *vj, tmp, pvmin;
     double *mean;
     Nrrd *nodf, *nanglut;
 
-    VV = nvec->axis[1].size;
-    NN = nrrdElementNumber(_nodf)/VV;
+    VV = AIR_UINT(nvec->axis[1].size);
+    NN = AIR_UINT(nrrdElementNumber(_nodf)/VV);
 
     nanglut = nrrdNew();
     airMopAdd(mop, nanglut, (airMopper)nrrdNuke, airMopAlways);
@@ -130,7 +132,7 @@
     vec = (float*)nvec->data;
     for (ii=0; ii<=jj; ii++) {
       vi = vec + 3*ii;
-      ELL_3V_NORM(vi, vi, tmp);
+      ELL_3V_NORM_TT(vi, float, vi, tmp);
     }
 
     /* pre-compute pair-wise angles */
@@ -141,7 +143,7 @@
         vi = vec + 3*ii;
         tmp = ELL_3V_DOT(vi, vj);
         tmp = AIR_ABS(tmp);
-        tmp = acos(tmp)/(AIR_PI/2.0);
+        tmp = AIR_FLOAT(acos(tmp)/(AIR_PI/2.0));
         anglut[ii + VV*jj] = airIndex(0.0, tmp, 1.0, bins);
       }
     }
@@ -213,11 +215,12 @@
     for (kk=0; kk<NN; kk++) {
       for (jj=0; jj<bins; jj++) {
         for (ii=0; ii<jj; ii++) {
-          tmp = (hist[ii] - mean[ii])*(hist[jj] - mean[jj]);
+          tmp = AIR_FLOAT((hist[ii] - mean[ii])*(hist[jj] - mean[jj]));
           covar[ii + bins*jj] += tmp;
           covar[jj + bins*ii] += tmp;
         }
-        covar[jj + bins*jj] += (hist[jj] - mean[jj])*(hist[jj] - mean[jj]);
+        covar[jj + bins*jj] +=
+          AIR_FLOAT((hist[jj] - mean[jj])*(hist[jj] - mean[jj]));
       }
       hist += bins;
     }
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/rgbprobe.c teem-1.11.0-src/src/ten/test/rgbprobe.c
--- teem-1.11.0-src.orig/src/ten/test/rgbprobe.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/rgbprobe.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/roistat.c teem-1.11.0-src/src/ten/test/roistat.c
--- teem-1.11.0-src.orig/src/ten/test/roistat.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/roistat.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../ten.h"
 
-char *info = ("tensor ROI information.");
+const char *info = ("tensor ROI information.");
 
 int
 main(int argc, const char *argv[]) {
@@ -72,9 +73,9 @@
     return 1;
   }
 
-  sx = nten->axis[1].size;
-  sy = nten->axis[2].size;
-  sz = nten->axis[3].size;
+  sx = AIR_UINT(nten->axis[1].size);
+  sy = AIR_UINT(nten->axis[2].size);
+  sz = AIR_UINT(nten->axis[3].size);
   if (!(3 == nroi->dim
         && sx == nroi->axis[0].size
         && sy == nroi->axis[1].size
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/rotedge.c teem-1.11.0-src/src/ten/test/rotedge.c
--- teem-1.11.0-src.orig/src/ten/test/rotedge.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/rotedge.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../ten.h"
 
-char *info =
+const char *info =
 ("Oh, just fricken super! "
  "Another stupid one-off program to make a thesis-related figure. "
  "Reproducibility in visualization, yea, yea fricken great. ");
@@ -35,7 +36,8 @@
   hestOpt *hopt=NULL;
   airArray *mop;
 
-  int xi, yi, samp[2], fsd;
+  unsigned int xi, yi, samp[2];
+  int fsd;
   float *tdata, mrg, slp;
   double x, xx, y,
     mRot1[9], mRot2[9], mRot3[9],
@@ -121,7 +123,7 @@
       ell_3m_post_mul_d(mT, mR);
 
       tdata[0] = 1.0;
-      TEN_M2T(tdata, mT);
+      TEN_M2T_TT(tdata, float, mT);
       tdata += 7;
     }
   }
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/taniso.c teem-1.11.0-src/src/ten/test/taniso.c
--- teem-1.11.0-src.orig/src/ten/test/taniso.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/taniso.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../ten.h"
 
-char *info = ("tests anisotropy measures");
+const char *info = ("tests anisotropy measures");
 
 int
 main(int argc, char *argv[]) {
@@ -72,7 +73,7 @@
     ELL_3M_TRANSPOSE_IP(rot, tmp);
     ell_3m_mul_d(mat1, mat2, rot);
     TEN_M2T(tenD, mat1);
-    TEN_T_COPY(tenF, tenD);
+    TEN_T_COPY_TT(tenF, float, tenD);
     tenEigensolve_d(evalD, NULL, tenD);
     tenEigensolve_f(evalF, NULL, tenF);
     for (aa=tenAnisoUnknown+1; aa<tenAnisoLast; aa++) {
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/teigen.c teem-1.11.0-src/src/ten/test/teigen.c
--- teem-1.11.0-src.orig/src/ten/test/teigen.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/teigen.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2011, 2010, 2009, University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -24,7 +24,7 @@
 
 #include "../ten.h"
 
-char *info = ("tests tenEigensolve_d and new stand-alone function.");
+const char *info = ("tests tenEigensolve_d and new stand-alone function.");
 
 #define ROOT_TRIPLE 2           /* ell_cubic_root_triple */
 #define ROOT_SINGLE_DOUBLE 3    /* ell_cubic_root_single_double */
@@ -421,6 +421,16 @@
   roots = tenEigensolve_d(evalA, evecA, tt);
   printf("%s roots\n", airEnumStr(ell_cubic_root, roots));
   testeigen(tt, evalA, evecA);
+  if (1) {
+    double sntt[7], sneval[3], snevec[9];
+    int snroots;
+    printf("========== sneaky hack: 2-step tenEigensolve_d ==========\n");
+    TEN_T_COPY(sntt, tt);
+    snroots = tenEigensolve_d(sneval, NULL, sntt);
+    sntt[0] = (double)((1 << 16) + snroots);
+    tenEigensolve_d(sneval, snevec, sntt);
+    testeigen(tt, sneval, snevec);
+  }
 
   printf("================== new eigensolve ==================\n");
   roots = evals(evalB, tt[1], tt[2], tt[3], tt[4], tt[5], tt[6]);
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/teigen-evals-A.c teem-1.11.0-src/src/ten/test/teigen-evals-A.c
--- teem-1.11.0-src.orig/src/ten/test/teigen-evals-A.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/teigen-evals-A.c	2021-02-18 15:42:36.000000000 +0800
@@ -19,8 +19,8 @@
   M00 -= mean;
   M11 -= mean;
   M22 -= mean;
-  
-  /* 
+
+  /*
   ** divide out L2 norm of eigenvalues (will multiply back later);
   ** this too seems to help with stability
   */
@@ -39,7 +39,7 @@
      "Eigensystems for 3 x 3 Symmetric Matrices (Revisited)" */
   Q = (M01*M01 + M02*M02 + M12*M12 - M00*M11 - M00*M22 - M11*M22)/3.0;
   QQQ = Q*Q*Q;
-  R = (M00*M11*M22 + M02*(2*M01*M12 - M02*M11) 
+  R = (M00*M11*M22 + M02*(2*M01*M12 - M02*M11)
        - M00*M12*M12 - M01*M01*M22)/2.0;
   D = QQQ - R*R;
   if (D > epsilon) {
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/tem.c teem-1.11.0-src/src/ten/test/tem.c
--- teem-1.11.0-src.orig/src/ten/test/tem.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/tem.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../ten.h"
 
-char *info = ("Test EM bimodal histogram fitting.");
+const char *info = ("Test EM bimodal histogram fitting.");
 
 int
 main(int argc, const char *argv[]) {
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/tensorDotDat.c teem-1.11.0-src/src/ten/test/tensorDotDat.c
--- teem-1.11.0-src.orig/src/ten/test/tensorDotDat.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/tensorDotDat.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../ten.h"
 
-char *info = ("Compute the makings of a new tensor.dat file.");
+const char *info = ("Compute the makings of a new tensor.dat file.");
 
 int
 main(int argc, const char *argv[]) {
@@ -147,8 +148,8 @@
               "desired (%s 2-D 9x%u)\n", me,
               airEnumStr(nrrdType, nlog->type),
               nlog->dim,
-              AIR_CAST(unsigned int, nlog->axis[0].size),
-              AIR_CAST(unsigned int, nlog->axis[1].size),
+              AIR_UINT(nlog->axis[0].size),
+              AIR_UINT(nlog->axis[1].size),
               airEnumStr(nrrdType, nrrdTypeDouble),
               numRange[1]+1);
       airMopError(mop); return 1;
@@ -200,7 +201,7 @@
        seedRange[1] < seedRange[0] || seed <= seedRange[1];
        seed++) {
     for (ii=numRange[0]; ii<=numRange[1]; ii++) {
-      seedDone = AIR_CAST(unsigned int, log[1 + 9*ii]);
+      seedDone = AIR_UINT(log[1 + 9*ii]);
       /* if no seeds have been tried, seedDone will be zero */
       if (seedDone >= seed) {
         /* have already tried this seed, move on */
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/tg.c teem-1.11.0-src/src/ten/test/tg.c
--- teem-1.11.0-src.orig/src/ten/test/tg.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/tg.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../ten.h"
 
-char *info = ("Sample space of tensor shape.");
+const char *info = ("Sample space of tensor shape.");
 
 void
 _clp2xyz(double xyz[3], double clp[2]) {
@@ -128,7 +129,7 @@
         ell_3m_post_mul_d(mT, mRF);
 
         tdata[0] = 1.0;
-        TEN_M2T(tdata, mT);
+        TEN_M2T_TT(tdata, float, mT);
         tdata += 7;
       }
     }
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/to.c teem-1.11.0-src/src/ten/test/to.c
--- teem-1.11.0-src.orig/src/ten/test/to.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/to.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../ten.h"
 
-char *info = ("Sample space of tensor orientation.");
+const char *info = ("Sample space of tensor orientation.");
 
 void
 washQtoM3(double m[9], double q[4]) {
@@ -113,7 +114,7 @@
         ell_3m_post_mul_d(mT, mRF);
 
         tdata[0] = 1.0;
-        TEN_M2T(tdata, mT);
+        TEN_M2T_TT(tdata, float, mT);
         tdata += 7;
       }
     }
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/tqgl.c teem-1.11.0-src/src/ten/test/tqgl.c
--- teem-1.11.0-src.orig/src/ten/test/tqgl.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/tqgl.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -69,9 +70,9 @@
              -sin(rtp[2]));
 }
 
-char *info = ("quaternion geo-lox hacking.  Actually all this does is "
-              "help debug the analytic loxodrome part, not the quaternion "
-              "geodesic part.");
+const char *info = ("quaternion geo-lox hacking.  Actually all this does is "
+                    "help debug the analytic loxodrome part, not the "
+                    "quaternion geodesic part.");
 
 int
 main(int argc, const char *argv[]) {
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/tsoid.c teem-1.11.0-src/src/ten/test/tsoid.c
--- teem-1.11.0-src.orig/src/ten/test/tsoid.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/tsoid.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,11 +24,12 @@
 
 #include "../ten.h"
 
-char *info = ("Save a single ellipsoid or superquadric into an OFF file.");
+const char *info = ("Save a single ellipsoid or superquadric "
+                    "into an OFF file.");
 
 int
 soidDoit(limnObject *obj, int look,
-         int sphere, float gamma, int res,
+         int gtype, float gamma, int res,
          float AB[2], float ten[7]) {
   int partIdx, axis;
   float cl, cp, qA, qB, eval[3], evec[9], matA[16], matB[16];
@@ -43,20 +45,22 @@
     cp = 2*(eval[1] - eval[2])/(eval[0] + eval[1] + eval[2]);
     if (cl > cp) {
       axis = 0;
-      qA = pow(1-cp, gamma);
-      qB = pow(1-cl, gamma);
+      qA = powf(1-cp, gamma);
+      qB = powf(1-cl, gamma);
     } else {
       axis = 2;
-      qA = pow(1-cl, gamma);
-      qB = pow(1-cp, gamma);
+      qA = powf(1-cl, gamma);
+      qB = powf(1-cp, gamma);
     }
-
+    /*
     fprintf(stderr, "eval = %g %g %g -> cl=%g %s cp=%g -> axis = %d\n",
             eval[0], eval[1], eval[2], cl, cl > cp ? ">" : "<", cp, axis);
-
+    */
   }
 
-  if (sphere) {
+  if (tenGlyphTypeBox == gtype) {
+    partIdx = limnObjectCubeAdd(obj, look);
+  } else if (tenGlyphTypeSphere == gtype) {
     partIdx = limnObjectPolarSphereAdd(obj, look,
                                        0, 2*res, res);
   } else {
@@ -80,48 +84,72 @@
   return partIdx;
 }
 
+static void
+scalingMatrix(double mat[9], double vec[3], double scl) {
+  double dir[3], tmp[9], len;
+
+  ELL_3V_NORM(dir, vec, len);
+  ELL_3MV_OUTER(tmp, dir, dir);
+  ELL_3M_SCALE(tmp, scl-1, tmp);
+  ELL_3M_IDENTITY_SET(mat);
+  ELL_3M_ADD2(mat, mat, tmp);
+  return;
+}
+
 int
 main(int argc, const char *argv[]) {
   const char *me;
   char *err, *outS;
-  double scale[3], matA[9], matB[9], matC[9], sval[3], uu[9], vv[9];
+  double eval[3], matA[9], matB[9], sval[3], uu[9], vv[9], escl[5],
+    view[3];
   float matAf[9], matBf[16];
-  float p[3], q[4], mR[9], len, gamma;
-  float os, vs, rad, AB[2], ten[7], view[3];
+  float pp[3], qq[4], mR[9], len, gamma;
+  float os, vs, rad, AB[2], ten[7];
   hestOpt *hopt=NULL;
   airArray *mop;
   limnObject *obj;
   limnLook *look; int lookRod, lookSoid;
-  int partIdx=-1; /* sssh */
-  int res, sphere;
+  float kadsRod[3], kadsSoid[3];
+  int gtype, partIdx=-1; /* sssh */
+  int res;
   FILE *file;
 
   me = argv[0];
-  hestOptAdd(&hopt, "sc", "scalings", airTypeDouble, 3, 3, scale, "1 1 1",
-             "axis-aligned scaling to do on ellipsoid");
+  hestOptAdd(&hopt, "sc", "evals", airTypeDouble, 3, 3, eval, "1 1 1",
+             "original eigenvalues of tensor to be visualized");
   hestOptAdd(&hopt, "AB", "A, B exponents", airTypeFloat, 2, 2, AB, "nan nan",
              "Directly set the A, B parameters to the superquadric surface, "
              "over-riding the default behavior of determining them from the "
              "scalings \"-sc\" as superquadric tensor glyphs");
   hestOptAdd(&hopt, "os", "over-all scaling", airTypeFloat, 1, 1, &os, "1",
              "over-all scaling (multiplied by scalings)");
-  hestOptAdd(&hopt, "vs", "over-all scaling", airTypeFloat, 1, 1, &vs, "1",
+  hestOptAdd(&hopt, "vs", "view-dir scaling", airTypeFloat, 1, 1, &vs, "1",
              "scaling along view-direction (to show off bas-relief "
              "ambibuity of ellipsoids versus superquads)");
-  hestOptAdd(&hopt, "fr", "from (eye) point", airTypeFloat, 3, 3, &view,
+  hestOptAdd(&hopt, "es", "extra scaling", airTypeDouble, 5, 5, escl,
+             "2 1 0 0 1", "extra scaling specified with five values "
+             "0:tensor|1:geometry|2:none vx vy vz scaling");
+  hestOptAdd(&hopt, "fr", "from (eye) point", airTypeDouble, 3, 3, &view,
              "4 4 4", "eye point, needed for non-unity \"-vs\"");
   hestOptAdd(&hopt, "gamma", "superquad sharpness", airTypeFloat, 1, 1,
              &gamma, "0",
              "how much to sharpen edges as a "
              "function of differences between eigenvalues");
-  hestOptAdd(&hopt, "sphere", NULL, airTypeInt, 0, 0, &sphere, NULL,
-             "use a sphere instead of a superquadric");
-  hestOptAdd(&hopt, "p", "x y z", airTypeFloat, 3, 3, p, "0 0 0",
+  hestOptAdd(&hopt, "g", "glyph shape", airTypeEnum, 1, 1, &gtype, "sqd",
+             "glyph to use; not all are implemented here",
+             NULL, tenGlyphType);
+  hestOptAdd(&hopt, "pp", "x y z", airTypeFloat, 3, 3, pp, "0 0 0",
+             "transform: rotation identified by"
              "location in quaternion quotient space");
   hestOptAdd(&hopt, "r", "radius", airTypeFloat, 1, 1, &rad, "0.015",
              "black axis cylinder radius (or 0.0 to not drawn these)");
   hestOptAdd(&hopt, "res", "resolution", airTypeInt, 1, 1, &res, "25",
              "tesselation resolution for both glyph and axis cylinders");
+  hestOptAdd(&hopt, "pg", "ka kd ks", airTypeFloat, 3, 3, kadsSoid,
+             "0.2 0.8 0.0",
+             "phong coefficients for glyph");
+  hestOptAdd(&hopt, "pr", "ka kd ks", airTypeFloat, 3, 3, kadsRod, "1 0 0",
+             "phong coefficients for black rods (if being drawn)");
   hestOptAdd(&hopt, "o", "output OFF", airTypeString, 1, 1, &outS, "out.off",
              "output file to save OFF into");
   hestParseOrDie(hopt, argc-1, argv+1, NULL,
@@ -133,35 +161,58 @@
   obj = limnObjectNew(1000, AIR_TRUE);
   airMopAdd(mop, obj, (airMopper)limnObjectNix, airMopAlways);
 
-  /* create limnLooks for ellipsoid and for rods */
+  if (!( 0 == escl[0] || 1 == escl[0] || 2 == escl[0] )) {
+    fprintf(stderr, "%s: escl[0] %g not 0, 1 or 2\n", me, escl[0]);
+    airMopError(mop); return 1;
+  }
+  if (!(tenGlyphTypeBox == gtype ||
+        tenGlyphTypeSphere == gtype ||
+        tenGlyphTypeSuperquad == gtype)) {
+    fprintf(stderr, "%s: got %s %s, but here only do %s, %s, or %s\n", me,
+            tenGlyphType->name,
+            airEnumStr(tenGlyphType, gtype),
+            airEnumStr(tenGlyphType, tenGlyphTypeBox),
+            airEnumStr(tenGlyphType, tenGlyphTypeSphere),
+            airEnumStr(tenGlyphType, tenGlyphTypeSuperquad));
+    airMopError(mop); return 1;
+  }
+
+  /* create limnLooks for glyph and for rods */
   lookSoid = limnObjectLookAdd(obj);
   look = obj->look + lookSoid;
   ELL_4V_SET(look->rgba, 1, 1, 1, 1);
-  ELL_3V_SET(look->kads, 0.2, 0.8, 0);
+  ELL_3V_COPY(look->kads, kadsSoid);
+
   look->spow = 0;
   lookRod = limnObjectLookAdd(obj);
   look = obj->look + lookRod;
   ELL_4V_SET(look->rgba, 0, 0, 0, 1);
-  ELL_3V_SET(look->kads, 1, 0, 0);
+  ELL_3V_COPY(look->kads, kadsRod);
   look->spow = 0;
 
-  ELL_3M_IDENTITY_SET(matA);
-  ELL_3V_SCALE(scale, os, scale);
-  ELL_3M_SCALE_SET(matB, scale[0], scale[1], scale[2]);
-  ell_3m_post_mul_d(matA, matB);
+  ELL_3M_IDENTITY_SET(matA); /* A = I */
+  ELL_3V_SCALE(eval, os, eval);
+  ELL_3M_SCALE_SET(matB, eval[0], eval[1], eval[2]); /* B = diag(eval) */
+  ell_3m_post_mul_d(matA, matB); /* A = B*A = diag(eval) */
+
+  if (0 == escl[0]) {
+    scalingMatrix(matB, escl + 1, escl[4]);
+    ell_3m_post_mul_d(matA, matB);
+  }
+
   if (1 != vs) {
-    ELL_3V_NORM(view, view, len);
-    if (!len) {
-      /* HEY: perhaps do more diplomatic error message here */
-      fprintf(stderr, "%s: stupido!\n", me);
-      exit(1);
+    if (!ELL_3V_LEN(view)) {
+      fprintf(stderr, "%s: need non-zero view for vs %g != 1\n", me, vs);
+      airMopError(mop); return 1;
     }
-    ELL_3MV_OUTER(matB, view, view);
-    ELL_3M_SCALE(matB, vs-1, matB);
-    ELL_3M_IDENTITY_SET(matC);
-    ELL_3M_ADD2(matB, matC, matB);
-    ell_3m_post_mul_d(matA, matB);
+    scalingMatrix(matB, view, vs);
+    /* the scaling along the view direction is a symmetric matrix,
+       but applying that scaling to the symmetric input tensor
+       is not necessarily symmetric */
+    ell_3m_post_mul_d(matA, matB);  /* A = B*A */
   }
+  /* so we do an SVD to get rotation U and the scalings sval[] */
+  /* U * diag(sval) * V */
   ell_3m_svd_d(uu, sval, vv, matA, AIR_TRUE);
 
   /*
@@ -192,71 +243,79 @@
   fprintf(stderr, "%s: ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", me);
   */
 
+  /* now create symmetric matrix out of U and sval */
+  /* A = I */
   ELL_3M_IDENTITY_SET(matA);
-  ell_3m_pre_mul_d(matA, uu);
-  ELL_3M_SCALE_SET(matB, sval[0], sval[1], sval[2]);
-  ell_3m_pre_mul_d(matA, matB);
+  ell_3m_pre_mul_d(matA, uu);   /* A = A*U = I*U = U */
+  ELL_3M_SCALE_SET(matB, sval[0], sval[1], sval[2]); /* B = diag(sval) */
+  ell_3m_pre_mul_d(matA, matB); /* A = U*diag(sval) */
   ELL_3M_TRANSPOSE(matB, uu);
-  ell_3m_pre_mul_d(matA, matB);
-  TEN_M2T(ten, matA);
+  ell_3m_pre_mul_d(matA, matB); /* A = U*diag(sval)*U^T */
+  TEN_M2T_TT(ten, float, matA);
 
   partIdx = soidDoit(obj, lookSoid,
-                     sphere, gamma, res,
+                     gtype, gamma, res,
                      (AIR_EXISTS(AB[0]) && AIR_EXISTS(AB[1])) ? AB : NULL,
                      ten);
 
-  ELL_4V_SET(q, 1, p[0], p[1], p[2]);
-  ELL_4V_NORM(q, q, len);
-  ell_q_to_3m_f(mR, q);
+  if (1 == escl[0]) {
+    scalingMatrix(matB, escl + 1, escl[4]);
+    ELL_43M_INSET_TT(matBf, float, matB);
+    limnObjectPartTransform(obj, partIdx, matBf);
+  }
+  /* this is a rotate on the geomtry; nothing to do with the tensor */
+  ELL_4V_SET(qq, 1, pp[0], pp[1], pp[2]);
+  ELL_4V_NORM_TT(qq, float, qq, len);
+  ell_q_to_3m_f(mR, qq);
   ELL_43M_INSET(matBf, mR);
   limnObjectPartTransform(obj, partIdx, matBf);
 
   if (rad) {
     partIdx = limnObjectCylinderAdd(obj, lookRod, 0, res);
     ELL_4M_IDENTITY_SET(matAf);
-    ELL_4M_SCALE_SET(matBf, (1-scale[0])/2, rad, rad);
+    ELL_4M_SCALE_SET(matBf, AIR_FLOAT((1-eval[0])/2), rad, rad);
     ell_4m_post_mul_f(matAf, matBf);
-    ELL_4M_TRANSLATE_SET(matBf, (1+scale[0])/2, 0.0, 0.0);
+    ELL_4M_TRANSLATE_SET(matBf, AIR_FLOAT((1+eval[0])/2), 0.0, 0.0);
     ell_4m_post_mul_f(matAf, matBf);
     limnObjectPartTransform(obj, partIdx, matAf);
 
     partIdx = limnObjectCylinderAdd(obj, lookRod, 0, res);
     ELL_4M_IDENTITY_SET(matAf);
-    ELL_4M_SCALE_SET(matBf, (1-scale[0])/2, rad, rad);
+    ELL_4M_SCALE_SET(matBf, AIR_FLOAT((1-eval[0])/2), rad, rad);
     ell_4m_post_mul_f(matAf, matBf);
-    ELL_4M_TRANSLATE_SET(matBf, -(1+scale[0])/2, 0.0, 0.0);
+    ELL_4M_TRANSLATE_SET(matBf, AIR_FLOAT(-(1+eval[0])/2), 0.0, 0.0);
     ell_4m_post_mul_f(matAf, matBf);
     limnObjectPartTransform(obj, partIdx, matAf);
 
     partIdx = limnObjectCylinderAdd(obj, lookRod, 1, res);
     ELL_4M_IDENTITY_SET(matAf);
-    ELL_4M_SCALE_SET(matBf, rad, (1-scale[1])/2, rad);
+    ELL_4M_SCALE_SET(matBf, rad, AIR_FLOAT((1-eval[1])/2), rad);
     ell_4m_post_mul_f(matAf, matBf);
-    ELL_4M_TRANSLATE_SET(matBf, 0.0, (1+scale[1])/2, 0.0);
+    ELL_4M_TRANSLATE_SET(matBf, 0.0, AIR_FLOAT((1+eval[1])/2), 0.0);
     ell_4m_post_mul_f(matAf, matBf);
     limnObjectPartTransform(obj, partIdx, matAf);
 
     partIdx = limnObjectCylinderAdd(obj, lookRod, 1, res);
     ELL_4M_IDENTITY_SET(matAf);
-    ELL_4M_SCALE_SET(matBf, rad, (1-scale[1])/2, rad);
+    ELL_4M_SCALE_SET(matBf, rad, AIR_FLOAT((1-eval[1])/2), rad);
     ell_4m_post_mul_f(matAf, matBf);
-    ELL_4M_TRANSLATE_SET(matBf, 0.0, -(1+scale[1])/2, 0.0);
+    ELL_4M_TRANSLATE_SET(matBf, 0.0, AIR_FLOAT(-(1+eval[1])/2), 0.0);
     ell_4m_post_mul_f(matAf, matBf);
     limnObjectPartTransform(obj, partIdx, matAf);
 
     partIdx = limnObjectCylinderAdd(obj, lookRod, 2, res);
     ELL_4M_IDENTITY_SET(matAf);
-    ELL_4M_SCALE_SET(matBf, rad, rad, (1-scale[2])/2);
+    ELL_4M_SCALE_SET(matBf, rad, rad, AIR_FLOAT((1-eval[2])/2));
     ell_4m_post_mul_f(matAf, matBf);
-    ELL_4M_TRANSLATE_SET(matBf, 0.0, 0.0, (1+scale[2])/2);
+    ELL_4M_TRANSLATE_SET(matBf, 0.0, 0.0, AIR_FLOAT((1+eval[2])/2));
     ell_4m_post_mul_f(matAf, matBf);
     limnObjectPartTransform(obj, partIdx, matAf);
 
     partIdx = limnObjectCylinderAdd(obj, lookRod, 2, res);
     ELL_4M_IDENTITY_SET(matAf);
-    ELL_4M_SCALE_SET(matBf, rad, rad, (1-scale[2])/2);
+    ELL_4M_SCALE_SET(matBf, rad, rad, AIR_FLOAT((1-eval[2])/2));
     ell_4m_post_mul_f(matAf, matBf);
-    ELL_4M_TRANSLATE_SET(matBf, 0.0, 0.0, -(1+scale[2])/2);
+    ELL_4M_TRANSLATE_SET(matBf, 0.0, 0.0, AIR_FLOAT(-(1+eval[2])/2));
     ell_4m_post_mul_f(matAf, matBf);
     limnObjectPartTransform(obj, partIdx, matAf);
   }
@@ -273,4 +332,3 @@
   airMopOkay(mop);
   return 0;
 }
-
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/tt.c teem-1.11.0-src/src/ten/test/tt.c
--- teem-1.11.0-src.orig/src/ten/test/tt.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/tt.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,17 +24,17 @@
 
 #include "../ten.h"
 
-char *info = ("Sample space of tensor shape.");
+const char *info = ("Sample space of tensor shape.");
 
 void
 _ra2t(Nrrd *nten, double rad, double angle,
       double mRI[9], double mRF[9], double hack) {
   double x, y, xyz[3], XX[3], YY[3], CC[3], EE[3], VV[3], tmp, mD[9], mT[9];
   float *tdata;
-  int xi, yi, sx, sy;
+  unsigned int xi, yi, sx, sy;
 
-  sx = nten->axis[1].size;
-  sy = nten->axis[2].size;
+  sx = AIR_UINT(nten->axis[1].size);
+  sy = AIR_UINT(nten->axis[2].size);
   x = rad*sin(AIR_PI*angle/180);
   y = rad*cos(AIR_PI*angle/180);
   xi = airIndexClamp(0.0, x, sqrt(3.0)/2.0, sx);
@@ -55,7 +56,7 @@
   ell_3m_post_mul_d(mT, mRF);
   tdata = (float*)(nten->data) + 7*(xi + sx*(yi + 1*sy));
   tdata[0] = 1.0;
-  TEN_M2T(tdata, mT);
+  TEN_M2T_TT(tdata, float, mT);
 }
 
 void
@@ -301,7 +302,7 @@
         tdata = (float*)nten->data +
           7*(2*(samp-1-xi) - (samp-1-yi) + (2*samp-1)*((samp-1-yi) + samp));
         tdata[0] = 1.0;
-        TEN_M2T(tdata, mT);
+        TEN_M2T_TT(tdata, float, mT);
       }
     }
     nten->axis[1].spacing = 1;
diff --color -ruN teem-1.11.0-src.orig/src/ten/test/ttriple.c teem-1.11.0-src/src/ten/test/ttriple.c
--- teem-1.11.0-src.orig/src/ten/test/ttriple.c	2012-12-20 22:09:04.000000000 +0800
+++ teem-1.11.0-src/src/ten/test/ttriple.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,5 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -23,7 +24,7 @@
 
 #include "../ten.h"
 
-char *info = ("tests conversions between info triples");
+const char *info = ("tests conversions between info triples");
 
 int
 main(int argc, const char *argv[]) {
diff --color -ruN teem-1.11.0-src.orig/src/ten/triple.c teem-1.11.0-src/src/ten/triple.c
--- teem-1.11.0-src.orig/src/ten/triple.c	2012-12-20 22:09:11.000000000 +0800
+++ teem-1.11.0-src/src/ten/triple.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/tijk/3dTijk.c teem-1.11.0-src/src/tijk/3dTijk.c
--- teem-1.11.0-src.orig/src/tijk/3dTijk.c	2012-12-20 22:09:27.000000000 +0800
+++ teem-1.11.0-src/src/tijk/3dTijk.c	2021-02-18 15:42:37.000000000 +0800
@@ -2041,8 +2041,28 @@
 #define _tijk_8o3d_sym_convert_f NULL
 #define _tijk_8o3d_sym_convert_d NULL
 
-#define _tijk_8o3d_sym_approx_f NULL
-#define _tijk_8o3d_sym_approx_d NULL
+/* For convenience, do this via SH conversion */
+#define _TIJK_8O3D_SYM_APPROX(TYPE, SUF)                             \
+  int                                                                \
+  _tijk_8o3d_sym_approx_##SUF (TYPE *res, const tijk_type *res_type, \
+                               const TYPE *A) {                      \
+    if (res_type==tijk_2o3d_sym ||                                   \
+        res_type==tijk_4o3d_sym ||                                   \
+        res_type==tijk_6o3d_sym ||                                   \
+        res_type==tijk_8o3d_sym) {                                   \
+      TYPE esh[45];                                                  \
+      tijk_3d_sym_to_esh_##SUF (esh, A, tijk_8o3d_sym);              \
+      if (res_type==tijk_esh_to_3d_sym_##SUF (res, esh, res_type->order)) \
+        return 0;                                                       \
+    }                                                                \
+    if (NULL!=res_type->_approx_from_##SUF)                          \
+      return (*res_type->_approx_from_##SUF)(res,A,tijk_8o3d_sym);   \
+    else                                                             \
+      return 1;                                                      \
+  }
+
+_TIJK_8O3D_SYM_APPROX(double, d)
+_TIJK_8O3D_SYM_APPROX(float, f)
 
 double
 _tijk_8o3d_sym_s_form_d (const double *A, const double *v) {
diff --color -ruN teem-1.11.0-src.orig/src/tijk/approxTijk.c teem-1.11.0-src/src/tijk/approxTijk.c
--- teem-1.11.0-src.orig/src/tijk/approxTijk.c	2012-12-20 22:09:27.000000000 +0800
+++ teem-1.11.0-src/src/tijk/approxTijk.c	2021-02-18 15:42:38.000000000 +0800
@@ -153,7 +153,7 @@
 _TIJK_INIT_MAX(float, f, 3)
 
 static const tijk_refine_rank1_parm refine_rank1_parm_default = {
-  1e-10, 1e-4, 0.3, 0.9, 0.5, 50};
+  1e-10, 1e-6, 0.3, 0.9, 0.5, 50};
 
 tijk_refine_rank1_parm *tijk_refine_rank1_parm_new() {
   tijk_refine_rank1_parm *parm;
@@ -441,7 +441,9 @@
         if (largest/smallest>parm->ratios[currank-2])                   \
           accept=0;                                                     \
       }                                                                 \
-      if (accept && oldnorm-newnorm>parm->eps_impr*orignorm) {          \
+      if (currank>1 && oldnorm-newnorm<parm->eps_impr*orignorm)         \
+        accept=0;                                                       \
+      if (accept) {                                                     \
         /* copy over */                                                 \
         memcpy(vs, vstmp, sizeof(TYPE)*DIM*currank);                    \
         memcpy(ls, lstmp, sizeof(TYPE)*currank);                        \
diff --color -ruN teem-1.11.0-src.orig/src/tijk/CMakeLists.txt teem-1.11.0-src/src/tijk/CMakeLists.txt
--- teem-1.11.0-src.orig/src/tijk/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/tijk/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -0,0 +1,21 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(TIJK_SOURCES
+  2dTijk.c
+  3dTijk.c
+  approxTijk.c
+  enumsTijk.c
+  fsTijk.c
+  miscTijk.c
+  nrrdTijk.c
+  shTijk.c
+  privateTijk.h
+  convertQuietPush.h
+  convertQuietPop.h
+  shtables.h
+  tijk.h
+  )
+
+target_sources(teem PRIVATE ${TIJK_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( tijk FILES ${TIJK_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/tijk/convertQuietPop.h teem-1.11.0-src/src/tijk/convertQuietPop.h
--- teem-1.11.0-src.orig/src/tijk/convertQuietPop.h	2012-12-20 22:09:27.000000000 +0800
+++ teem-1.11.0-src/src/tijk/convertQuietPop.h	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/tijk/convertQuietPush.h teem-1.11.0-src/src/tijk/convertQuietPush.h
--- teem-1.11.0-src.orig/src/tijk/convertQuietPush.h	2012-12-20 22:09:27.000000000 +0800
+++ teem-1.11.0-src/src/tijk/convertQuietPush.h	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -21,6 +21,9 @@
   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
 
+/* NOTE: these warning suppressions are hopefully
+   only a short-term fix */
+
 /* when using an MS compiler, suppress all warnings about
  * truncation (4304) or conversion (4244) from double to float
  */
diff --color -ruN teem-1.11.0-src.orig/src/tijk/GNUmakefile teem-1.11.0-src/src/tijk/GNUmakefile
--- teem-1.11.0-src.orig/src/tijk/GNUmakefile	2012-12-20 22:09:27.000000000 +0800
+++ teem-1.11.0-src/src/tijk/GNUmakefile	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/tijk/nrrdTijk.c teem-1.11.0-src/src/tijk/nrrdTijk.c
--- teem-1.11.0-src.orig/src/tijk/nrrdTijk.c	2012-12-20 22:09:27.000000000 +0800
+++ teem-1.11.0-src/src/tijk/nrrdTijk.c	2021-02-18 15:42:38.000000000 +0800
@@ -46,8 +46,8 @@
   else if (axinfo->size!=type->num)
     return 4;
   axinfo->label = (char*) airFree(axinfo->label);
-  lablen = strlen("tijk__") + strlen(type->name) +
-    (masked?strlen("mask_"):0) + 1;
+  lablen = (unsigned int)(strlen("tijk__") + strlen(type->name) +
+                          (masked?strlen("mask_"):0) + 1);
   axinfo->label = AIR_CALLOC(lablen, char);
   sprintf(axinfo->label, "tijk_%s%s", masked?"mask_":"", type->name);
   return 0;
diff --color -ruN teem-1.11.0-src.orig/src/tijk/shTijk.c teem-1.11.0-src/src/tijk/shTijk.c
--- teem-1.11.0-src.orig/src/tijk/shTijk.c	2012-12-20 22:09:27.000000000 +0800
+++ teem-1.11.0-src/src/tijk/shTijk.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2011, 2010, 2009, 2008 Thomas Schultz
+  Copyright (C) 2013, 2012, 2011, 2010, 2009, 2008 Thomas Schultz
   Copyright (C) 2010, 2009, 2008 Gordon Kindlmann
 
   This library is free software; you can redistribute it and/or
@@ -39,6 +39,11 @@
 /* number of coefficients for order i/2 */
 const unsigned int tijk_esh_len[5]={1,6,15,28,45};
 
+/* We use the following convention:
+ * theta = polar angle from positive z
+ * phi   = azimuth from positive x
+ */
+
 #define TIJK_EVAL_ESH_BASIS(TYPE, SUF)                                  \
   unsigned int                                                          \
   tijk_eval_esh_basis_##SUF(TYPE *res, unsigned int order,              \
@@ -212,6 +217,49 @@
 TIJK_ESH_TO_3D_SYM(double, d)
 TIJK_ESH_TO_3D_SYM(float, f)
 
+/* Routines that return a pointer to the internal matrices used to map
+ * between Spherical Harmonics and Symmetric Tensors; useful if you
+ * want to concatenate (i.e. matrix multiply) this conversion with
+ * other linear operations; if you just want the conversion, simply use
+ *    tijk_esh_to_3d_sym_*   and   tijk_3d_sym_to_esh_*
+ */
+#define TIJK_3D_SYM_TO_ESH_MATRIX(TYPE, SUF)                    \
+  const TYPE*                                                   \
+  tijk_3d_sym_to_esh_matrix_##SUF(const tijk_type *type) {      \
+    if (type==tijk_2o3d_sym)                                    \
+      return _tijk_sym2esh_o2_##SUF;                            \
+    if (type==tijk_4o3d_sym)                                    \
+      return _tijk_sym2esh_o4_##SUF;                            \
+    if (type==tijk_6o3d_sym)                                    \
+      return _tijk_sym2esh_o6_##SUF;                            \
+    if (type==tijk_8o3d_sym)                                    \
+      return _tijk_sym2esh_o8_##SUF;                            \
+    return NULL;                                                \
+  }
+
+TIJK_3D_SYM_TO_ESH_MATRIX(double, d)
+TIJK_3D_SYM_TO_ESH_MATRIX(float, f)
+
+#define TIJK_ESH_TO_3D_SYM_MATRIX(TYPE, SUF)            \
+  const TYPE*                                           \
+  tijk_esh_to_3d_sym_matrix_##SUF(unsigned int order) { \
+    switch (order) {                                    \
+    case 2:                                             \
+      return _tijk_esh2sym_o2_##SUF;                    \
+    case 4:                                             \
+      return _tijk_esh2sym_o4_##SUF;                    \
+    case 6:                                             \
+      return _tijk_esh2sym_o6_##SUF;                    \
+    case 8:                                             \
+      return _tijk_esh2sym_o8_##SUF;                    \
+    default:                                            \
+      return NULL;                                      \
+    }                                                   \
+  }
+
+TIJK_ESH_TO_3D_SYM_MATRIX(double,d)
+TIJK_ESH_TO_3D_SYM_MATRIX(float,f)
+
 /* Convolve in with kernel and write to out (in==out is permitted) */
 #define TIJK_ESH_CONVOLVE(TYPE, SUF)                              \
   void tijk_esh_convolve_##SUF(TYPE *out, const TYPE *in,         \
@@ -330,5 +378,4 @@
 TIJK_ESH_MAKE_KERNEL_DELTA(double, d)
 TIJK_ESH_MAKE_KERNEL_DELTA(float, f)
 
-
 #include "convertQuietPop.h"
diff --color -ruN teem-1.11.0-src.orig/src/tijk/sources.cmake teem-1.11.0-src/src/tijk/sources.cmake
--- teem-1.11.0-src.orig/src/tijk/sources.cmake	2012-12-20 22:09:27.000000000 +0800
+++ teem-1.11.0-src/src/tijk/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,19 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(TIJK_SOURCES
-  2dTijk.c
-  3dTijk.c
-  approxTijk.c
-  enumsTijk.c
-  fsTijk.c
-  miscTijk.c
-  nrrdTijk.c
-  shTijk.c
-  privateTijk.h
-  convertQuietPush.h
-  convertQuietPop.h
-  shtables.h
-  tijk.h
-  )
-
-ADD_TEEM_LIBRARY(tijk ${TIJK_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/tijk/tijk.h teem-1.11.0-src/src/tijk/tijk.h
--- teem-1.11.0-src.orig/src/tijk/tijk.h	2012-12-20 22:09:27.000000000 +0800
+++ teem-1.11.0-src/src/tijk/tijk.h	2021-02-18 15:42:38.000000000 +0800
@@ -398,6 +398,12 @@
                                                   const float *sh,
                                                   unsigned int order);
 
+TIJK_EXPORT const double *tijk_3d_sym_to_esh_matrix_d(const tijk_type *type);
+TIJK_EXPORT const float *tijk_3d_sym_to_esh_matrix_f(const tijk_type *type);
+
+TIJK_EXPORT const double *tijk_esh_to_3d_sym_matrix_d(unsigned int order);
+TIJK_EXPORT const float *tijk_esh_to_3d_sym_matrix_f(unsigned int order);
+
 TIJK_EXPORT void tijk_esh_convolve_d(double *out, const double *in,
                                      const double *kernel,
                                      unsigned int order);
diff --color -ruN teem-1.11.0-src.orig/src/TODO.txt teem-1.11.0-src/src/TODO.txt
--- teem-1.11.0-src.orig/src/TODO.txt	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/TODO.txt	2021-02-18 15:42:32.000000000 +0800
@@ -1,10 +1,20 @@
+** Compared to what's in HELP.txt, these are more generally more
+** fine-grained and nit-picky; some of them are only sensibly done by
+** GLK.  The things listed for Teem 2.0 involve significant API
+** changes, or significantly thoughtful redesign of how functional
+** components of Teem are implemented.
+
+Figure out what is going on with parsing spaces in hest:
+this doesn't work:
+  unu basinfo -i tmp.nrrd -kv space:=RGB "novalue:=0.3 0 0" -o tmp2.nrrd
+and instead it sees:
+  !unu basinfo: kvpstring[0/2] = |space:=RGB|
+  !unu basinfo: kvpstring[1/2] = |"novalue:=0.3|
+where the hell is the " coming from?
 
 ========
 for Teem 2.0:
 
-teem/include/teemEndian.h should NOT be setting TEEM_ENDIAN; it should
-be set by the build system.
-
 decide on a uniform way of indicating if a given external is available
 (e.g. airThreadCapable vs nrrdFFTWEnabled vs #if TEEM_LEVMAR: not uniform).
 "meet" is the logical place for collecting this info, and would be
@@ -24,13 +34,35 @@
 pointers, but to all values as well.
 
 all:
-* scrutinize use of strncpy, consider using airStrcpy
+* for nrrd, ell, gage, and everything assuming some math accuracy,
+  investigate application of Herbie http://herbie.uwplse.org
+  http://herbie.uwplse.org/pldi15.html
+  (section 3 covers mundane quadratic formula)
 * remove '_'s from enum value names in non-elf non-tijk libraries
 * decide if <LIB>_EXPORT should just be TEEM_EXPORT
 * enforce consistent use of AIR_CALLOC/AIR_MALLOC
+* decide consistent API of Copy() functions, or if consistency is needed, eg:
+  nrrdCopy() vs gageContextCopy()
+* decide consistent API of Compare vs Equal() functions, or if consistency
+  is needed, eg:
+  nrrdCompare() vs nrrdKernelCompare() vs nrrdKernelSpecCompare()
+    vs gageShapeEqual() vs gageStackBlurParmEqual().
+  Should these all have "name" params, or none, and how should we modify
+  names passed to sub-compare functions?
+  What else would benefit from such a Compare() or Equal() function?
 
 air:
+* find and use a good sscanf/printf replacement. Current annoyances:
+  - not being able to ask, "will sprintf'ing this take up more than
+  this pre-allocated buffer", and "allocate this for as big as you need
+  to sprintf this".
+  - using airSingleScanf and airSinglePrintf for correctly handling
+  "inf", "-inf", "nan", and now "pi" on parsing.  And this will be a
+  place to handle setlocale weirness.  However, the "Single"
+  restriction is too cumbersome.
 * consider nixing AIR_ENDIAN, AIR_QNANHIBIT, and AIR_DIO
+* Hey, what does airSinglePrintf do with the common "%.17g" for a double?
+  It seems to not have the smarts to see that it is fact for a double.
 * airArray->len should probably be size_t, not unsigned int. Along with
 this is biffMsgErrNum and nrrdKeyValueSize.
 * consider changing airIndexULL and airIndexClampULL to work with
@@ -39,13 +71,11 @@
 * either change AIR_STRLEN_* to AIR_BUFFSIZE_* (or something similar,
 or take out the +1 from their definition and it into usage: the
 STRLEN is misleading as is.
-* important: change airArray implementation to re-allocate the array size
-multiplicatively (by some adjustable factor, default around 1.5 or 2.0),
-rather than the linear increments used now.  References:
-http://en.wikipedia.org/wiki/Dynamic_array
-http://hg.python.org/cpython/file/e3be2941c834/Objects/listobject.c
 * consider terminating airEnum->strEqv with NULL (just like argv)
 instead of with empty string ""
+* make airOneLine return number of bytes read; current return
+  of string length is entirely redundant with return of strlen()
+  and then enable the ftell() check after PNG magic read
 * reconcile names of "unsigned int airUIrandMT_r()" vs
   "unsigned int airRandInt()" and "unsigned int airRandInt_r()"
 * consider having something like a teemContext, which might be:
@@ -68,6 +98,23 @@
 things airType were created for the sake of hest. Instead of taking an
 airType enum value for hestOptAdd, hestOptAdd can take a string
 (e.g. "uchar", "float", "enum", "callback" for airTypeOther).
+* There's no such thing as a truly optional parameter: data is needed
+for all options, whether it comes from the default string or the
+command line, and its an error if no data is found.  Not having
+optional parameters is why things like "unu make" learn centerings via
+strings: the string can be given or not, and if its given, then the
+information is used.
+* There's no way to access the string that was parsed to get the
+information for an option (could be from default, or command-line,
+or response file)
+* (from tendGlyph.c): there needs to be an alternative API for hest
+that is not var-args based (as is hestOptAdd). You can't tell when
+you've based multiple strings for the detailed usage information by
+accident.  GLK had accidentally inserted a comma into my multi-line
+string for the "info" arg, relying on the automatic string
+concatenation, and ended up passing total garbage to hestOptAdd for
+the airEnum pointer, causing him to think that the tenGlyphType airEnum
+was malformed, when it was in fact fine ...
 
 biff:
 * biffMove(destKey, err, srcKey) --> biffMove(destKey, srcKey, err)
@@ -77,6 +124,11 @@
 * a few biff functions are never used in Teem, is that ok?
 
 nrrd:
+* allow the API for median filtering to be more flexible about boundaries
+  can be handled (right now with "pad", its only nrrdBoundaryBleed)
+* add a clamp flag argument to all the arithmetic stuff (in unu consider
+  making it true by default) that will clamp output values to representation
+  range of input (to work on large 16-bit data without copying to float)
 * ponder utility of having "const void *constdata" field in the Nrrd struct,
   to allow a nrrd to wrap around data it doesn't own.  Would this supersede
   the nrrdNuke vs nrrdNix distinction?
@@ -97,8 +149,15 @@
   just like nrrdDefaultWriteCharsPerLine and nrrdDefaultWriteValsPerLine)
   and argument to nrrdIoStateSet.
 * with NrrdKernel:
+ - debug apparent precision problems worked-around in nrrdKernelCheck
  - add fields for "what is my derivative" or "what is my integral", but
    how to do that at compile time?
+ - add field for "parm[0] controls the scaling that the old resampling code
+   (e.g. unu resample) has always assumed" vs "parm[0] isn't used".  The
+   assumption by the resampling code that all kernels use parm[0] was a big
+   longstanding bug; "bspln3" doesn't work that way
+ - consider nixing nrrdDefaultKernelParm0, nrrdEnvVarDefaultKernelParm0
+ - consider nixing nrrdDefaultSpacing and nrrdEnvVarDefaultSpacing
  - "when parsing from string, parm[0] is needed" vs "parm[0] defaults to 1.0"
    OR, maybe simplify things by saying that all parameters are always needed
  - add method for answering "do I interpolate?"
@@ -107,7 +166,6 @@
  - add: am I an odd or even function
  - rename numParm --> parmNum
  - fix the kernels that meetNrrdKernelAllCheck revealed to be broken
- - consider nixing nrrdDefaultKernelParm0, nrrdEnvVarDefaultKernelParm0
 * with NrrdFormat:
  - There is now an available() method, but this is incomplete - EPS is
    something that can be written for images, but not read in general.
@@ -117,8 +175,7 @@
    Is this something else that NrrdFormat should represent?
 * should re-evaluate the need for all the nrrdDefault and nrrdState
   global variables, especially nrrdStateGrayscaleImage3D,
-  nrrdEnvVarStateGrayscaleImage3D,
-  nrrdDefaultSpacing, nrrdEnvVarDefaultSpacing, which seem antiquated
+  nrrdEnvVarStateGrayscaleImage3D, which seem antiquated
 * the percentile-based bounds specification now supported in e.g
   "unu histo", "unu quantize", and "unu jhisto" should be migrated down
   to the nrrd library.  Consider doing this with a sorting of highest/lowest
@@ -143,27 +200,41 @@
 [nrrd] nrrdResampleKernelSet: haven't set input nrrd yet
 * for nrrdCropAuto: consider adding some minimum remaining size requirement,
   in addition to offset
-* all of the code in apply1D.c is ancient, and has not been brought into
-  the world of using unsigned int and size_t.  Also very confusing. Needs
-  to be walked through and tested thoroughly.
 * why is _nrrdCheck (different than nrrdCheck) public?  Should be renamed?
+* now that we the new NrrdBoundarySpec, it should be used, and used
+  consistently, throughout Teem; for example remove
+  nrrdResampleBoundarySet and nrrdResamplePadValueSet and instead use new
+  nrrdResampleBoundarySpecSet, and consider using NrrdBoundarySpec
+  inside of NrrdResampleContext
+* The guts of "unu make" have to be made into a function call.  Its crazy
+to have all those smarts not more generally available.
+* Totally insane that nrrdKeyValueGet can return a char* into the Nrrd*,
+depending on the value of nrrdStateKeyValueReturnInternalPointers. Really?
 
 unu:
 * the UNRRDU_QUIET_QUIT functionality should be enabled by default instead
-of having to set an environment variable to get it
+of having to set an environment variable to get it. Or maybe not: when this
+goes wrong it is REALLY mysterious, and hard to debug.  For example:
+"... | unu 2op x - 2 | ...".  If there is a directory named "2" in the
+current working directory, it will exist as a file, and hence be opened by
+unu as if it was a nrrd, but doing an fread on it will immediately hit EOF
+--> quiet quit, and very confusing.
 * unu dice -ff should change from using %d to %u
+* in unrrdu/make.c, reconsider the nrrdStateVerboseIO++ before, and the
+nrrdStateVerboseIO-- after, the calls to nrrdFormatNRRD->read.  You can
+set environment variable NRRD_STATE_VERBOSE_IO to 0 thinking this will turn
+things off, and yet its not off
 * unu resample:
--- should permit saying "resample this axis to whatever
-best preserves the aspect ratio relative to the one axis which is
-being resampled via the older "N" or "xF" means"
 -- consider supporting more sophisticated expressions e.g. "x2" --> "x2+1"
 -- reconsider whether normalization should be turned on by default
 (always a surprise when using purposely small kernels like cos4sup or
-small gauss)
+a small Gaussian)
 
 gage:
+* use new NrrdBoundarySpec whenever possible; for example remove
+gageStackBlurParmBoundarySet()
 * clean up gageVolumeCheck vs gageKindVolumeCheck mess
-* in a gageKinds, the airEnum for the items, and the assocaited table of
+* in a gageKinds, the airEnum for the items, and the associated table of
 pre-requisites, should really be compiled from some other description
 which is more reliably written and upated (updating a gageKind now is
 EXTREMELY error-prone).  More radically, perhaps the entire thing
@@ -186,16 +257,11 @@
 ** The items below have accumulated over time, but the importance of them
 ** for Teem 2.0 or any other release should be re-evaluated.
 
-large-scale fix: when using sizeof with memcpy or memset, should be using
-the variable name itself instead of type as argument to sizeof()
-
 for cmake:
  - build pv on windows
  - see if wild-card expansion works as expected on windows
  - make cmd-line utilities link with static libs
 
-unrrdu: standardize hest framework for doing unu/gkms/tend style programs
-
 [portable54-250:~/d/parepi/6] gk%
 tend estim -new -sigma 0.01 -est wls -i 6crop-dwi.nrrd \
    -B kvp -knownB0 false -t 250 -o tmp.nrrd
@@ -208,15 +274,7 @@
 
 gage: re-modularize to facilitate probing bricked data
 
-make system really botched: change the size of the tenFiberContext
-(added a field or two), do a make ten/install,
-then cd ../push; rm -f test/pusher
-
-air: make airOneLine return number of bytes read; current return
-  of string length is entirely redundant with return of strlen()
-  and then enable the ftell() check after PNG magic read
-
-bin/unu: valgrid parsing of encoding stuff
+bin/unu: valgrind parsing of encoding stuff
 
 gage changes into bane:
 - try gkms hvol with three explicit ranges
@@ -229,12 +287,8 @@
 
 leaf: do it
 
-hest: add commenting via # or something else
-
 bane: finish updating tutorial
 
-dye: see if dyeColorParse should allocate the thing and return it
-
 image registration tool for small translational errors
 
 limn: make it smarter- so that joining parts together is possible in a
@@ -243,6 +297,8 @@
 
 limn: either debug or remove limnQN16border1
 
+dye: see if dyeColorParse should allocate the thing and return it
+
 dye: colormaps
 
 dye: hest callbacks
@@ -262,7 +318,13 @@
 callahan TVCG May/June 05: Hardware-Assisted Visibility Sorting for Unstructured Volume Rendering
 jorik blaas vis05 fiber paper
 
-(less of an issue now that CMake is in use) make install; make; and
+Following are less of an issue now that CMake is in use ...
+
+make system really botched: change the size of the tenFiberContext
+(added a field or two), do a make ten/install,
+then cd ../push; rm -f test/pusher
+
+make install; make; and
 you'll STILL get memory errors due to seeing library/object files
 which use the older context size.  Do a top-level make clobber, and
 then things work.  This is crap.  I think the problem is that
diff --color -ruN teem-1.11.0-src.orig/src/unangle.pl teem-1.11.0-src/src/unangle.pl
--- teem-1.11.0-src.orig/src/unangle.pl	2012-12-20 22:10:31.000000000 +0800
+++ teem-1.11.0-src/src/unangle.pl	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #!/usr/bin/perl -w
 # Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/1op.c teem-1.11.0-src/src/unrrdu/1op.c
--- teem-1.11.0-src.orig/src/unrrdu/1op.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/1op.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -115,7 +115,7 @@
     }
   } else {
     /* got no request for specific seed */
-    airSrandMT(AIR_CAST(unsigned int, airTime()));
+    airSrandMT(AIR_UINT(airTime()));
   }
   if (nrrdArithUnaryOp(nout, op, ntmp)) {
     airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/2op.c teem-1.11.0-src/src/unrrdu/2op.c
--- teem-1.11.0-src.orig/src/unrrdu/2op.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/2op.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -48,6 +48,8 @@
              "Binary operator. Possibilities include:\n "
              "\b\bo \"+\", \"-\", \"x\", \"/\": "
              "add, subtract, multiply, divide\n "
+             "\b\bo \"+c\", \"-c\", \"xc\": add, subtract, multiply, with "
+             "clamping to range of output, in case its integral\n "
              "\b\bo \"^\": exponentiation (pow)\n "
              "\b\bo \"spow\": signed exponentiation: sgn(x)pow(abs(x),p)\n "
              "\b\bo \"fpow\": like spow but with curves flipped\n "
@@ -147,12 +149,12 @@
     }
   } else {
     /* got no request for specific seed */
-    airSrandMT(AIR_CAST(unsigned int, airTime()));
+    airSrandMT(AIR_UINT(airTime()));
   }
   if (-1 == which
       ? nrrdArithIterBinaryOp(nout, op, in1, in2)
       : nrrdArithIterBinaryOpSelect(nout, op, in1, in2,
-                                    AIR_CAST(unsigned int, which))) {
+                                    AIR_UINT(which))) {
     airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
     fprintf(stderr, "%s: error doing binary operation:\n%s", me, err);
     airMopError(mop);
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/3op.c teem-1.11.0-src/src/unrrdu/3op.c
--- teem-1.11.0-src.orig/src/unrrdu/3op.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/3op.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -51,7 +51,7 @@
              "min_sm(x, w, M) is like min(x,M) but for x > M-w (with w > 0) "
              "there is a smooth transition from x to asymptotic to M\n "
              "\b\bo \"max_sm\": smoothed maximum function; "
-             "max_sm(m, w, x) is like max(M,x) but for x < m+w (with w > m) "
+             "max_sm(M, w, x) is like max(M,x) but for x < m+w (with w > m) "
              "there is a smooth transition from x to asymptotic to m\n "
              "\b\bo \"lt_sm\": 1st less than 3rd, smoothed by 2nd\n "
              "\b\bo \"gt_sm\": 1st greater than 3rd, smoothed by 2nd\n "
@@ -140,7 +140,7 @@
   if (-1 == which
       ? nrrdArithIterTernaryOp(nout, op, in1, in2, in3)
       : nrrdArithIterTernaryOpSelect(nout, op, in1, in2, in3,
-                                     AIR_CAST(unsigned int, which))) {
+                                     AIR_UINT(which))) {
     airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
     fprintf(stderr, "%s: error doing ternary operation:\n%s", me, err);
     airMopError(mop);
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/aabplot.c teem-1.11.0-src/src/unrrdu/aabplot.c
--- teem-1.11.0-src.orig/src/unrrdu/aabplot.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/aabplot.c	2021-02-18 15:42:36.000000000 +0800
@@ -0,0 +1,211 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "unrrdu.h"
+#include "privateUnrrdu.h"
+
+#define INFO "Draws ASCII-art box plots"
+static const char *_unrrdu_aabplotInfoL =
+  (INFO
+   ".  Because why not.\n "
+   "* (uses nrrd, but no Nrrd function has this functionality)");
+
+int
+unrrdu_aabplotMain(int argc, const char **argv, const char *me,
+                   hestParm *hparm) {
+  /* these are stock for unrrdu */
+  hestOpt *opt = NULL;
+  airArray *mop;
+  int pret;
+  char *err;
+  /* these are specific to this command */
+  int medshow, rshow;
+  Nrrd *_nin, *nin, *_nsingle, *nsingle;
+  unsigned int plen;
+  double vrange[2], *single;
+
+  hestOptAdd(&opt, "l", "len", airTypeUInt, 1, 1, &plen, "78",
+             "number of characters in box plot");
+  hestOptAdd(&opt, "r", "min max", airTypeDouble, 2, 2, vrange, "0 100",
+             "values to use as absolute min and max (unfortunately "
+             "has to be same for all scanlines (rows).");
+  hestOptAdd(&opt, "rs", "show", airTypeBool, 1, 1, &rshow, "false",
+             "show range above plots");
+  hestOptAdd(&opt, "ms", "show", airTypeBool, 1, 1, &medshow, "false",
+             "print the median value");
+  OPT_ADD_NIN(_nin, "input nrrd");
+  hestOptAdd(&opt, "s", "single", airTypeOther, 1, 1, &_nsingle, "",
+             "if given a 1D nrrd here that matches the number of "
+             "rows in the \"-i\" input, interpret it as a list of values "
+             "that should be indicated with \"X\"s in the plots.",
+             NULL, NULL, nrrdHestNrrd);
+
+  mop = airMopNew();
+  airMopAdd(mop, opt, (airMopper)hestOptFree, airMopAlways);
+  USAGE(_unrrdu_aabplotInfoL);
+  PARSE();
+  airMopAdd(mop, opt, (airMopper)hestParseFree, airMopAlways);
+
+  if (!( 2 == _nin->dim || 1 == _nin->dim )) {
+    fprintf(stderr, "%s: need 1-D or 2-D array\n", me);
+    airMopError(mop);
+    return 1;
+  }
+  nin = nrrdNew();
+  airMopAdd(mop, nin, (airMopper)nrrdNuke, airMopAlways);
+  if (nrrdConvert(nin, _nin, nrrdTypeDouble)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error converting \"-s\" input:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+  if (1 == nin->dim) {
+    if (nrrdAxesInsert(nin, nin, 1)) {
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: error making 2-D from 1-D:\n%s", me, err);
+      airMopError(mop);
+      return 1;
+    }
+  }
+  if (_nsingle) {
+    if (nrrdElementNumber(_nsingle) != nin->axis[1].size) {
+      fprintf(stderr, "%s: \"-s\" input doesn't match size of \"-i\" input",
+              me);
+      airMopError(mop);
+      return 1;
+    }
+    nsingle = nrrdNew();
+    airMopAdd(mop, nsingle, (airMopper)nrrdNuke, airMopAlways);
+    if (nrrdConvert(nsingle, _nsingle, nrrdTypeDouble)) {
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: error converting \"-s\" input:\n%s", me, err);
+      airMopError(mop);
+      return 1;
+    }
+    single = (double*)nsingle->data;
+  } else {
+    nsingle = NULL;
+    single = NULL;
+  }
+
+  {
+#define PTNUM 5
+    double *in, *buff, ptile[PTNUM]={5,25,50,75,95};
+    unsigned int xi, yi, pi, ti, sx, sy, pti[PTNUM];
+    char *line, rbuff[128];
+    Nrrd *nbuff;
+
+    sx = AIR_UINT(nin->axis[0].size);
+    sy = AIR_UINT(nin->axis[1].size);
+    nbuff = nrrdNew();
+    airMopAdd(mop, nbuff, (airMopper)nrrdNuke, airMopAlways);
+    if (nrrdSlice(nbuff, nin, 1, 0)) {
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: error making buffer:\n%s", me, err);
+      airMopError(mop);
+      return 1;
+    }
+    line = calloc(plen+1, sizeof(char));
+    in = (double*)nin->data;
+    buff = (double*)nbuff->data;
+
+    if (rshow) {
+      for (pi=0; pi<plen; pi++) {
+        line[pi] = ' ';
+      }
+      sprintf(rbuff, "|<-- %g", vrange[0]);
+      memcpy(line, rbuff, strlen(rbuff));
+      sprintf(rbuff, "%g -->|", vrange[1]);
+      memcpy(line + plen - strlen(rbuff), rbuff, strlen(rbuff));
+      printf("%s", line);
+      if (medshow) {
+        printf(" median:");
+      }
+      printf("\n");
+    }
+    for (yi=0; yi<sy; yi++) {
+      for (xi=0; xi<sx; xi++) {
+        buff[xi] = in[xi + sx*yi];
+      }
+      qsort(buff, sx, sizeof(double), nrrdValCompare[nrrdTypeDouble]);
+      for (ti=0; ti<PTNUM; ti++) {
+        pti[ti] = airIndexClamp(vrange[0],
+                                buff[airIndexClamp(0, ptile[ti], 100, sx)],
+                                vrange[1], plen);
+        /*
+        fprintf(stderr, "ti %u (%g) -> buff[%u] = %g -> %u\n", ti,
+                ptile[ti], airIndexClamp(0, ptile[ti], 100, sx),
+                buff[airIndexClamp(0, ptile[ti], 100, sx)], pti[ti]);
+        */
+      }
+      for (pi=0; pi<plen; pi++) {
+        line[pi] = pi % 2 ? ' ' : '.';
+      }
+      for (pi=pti[0]; pi<=pti[4]; pi++) {
+        line[pi] = '-';
+      }
+      for (pi=pti[1]; pi<=pti[3]; pi++) {
+        line[pi] = '=';
+      }
+      line[pti[2]]='m';
+      if (pti[2] > 0) {
+        line[pti[2]-1]='<';
+      }
+      if (pti[2] < plen-1) {
+        line[pti[2]+1]='>';
+      }
+      if (single) {
+        line[airIndexClamp(vrange[0], single[yi], vrange[1], plen)]='X';
+      }
+      printf("%s", line);
+      if (medshow) {
+        printf(" %g", buff[airIndexClamp(0, 50, 100, sx)]);
+      }
+      printf("\n");
+#if 0
+      unsigned int ltt = (unsigned int)(-1);
+      /* printf("["); */
+      for (pi=0; pi<plen; pi++) {
+        for (tt=0; tt<PTNUM && pti[tt] < pi; tt++) {
+          /*
+          fprintf(stderr, "(pi %u < pti[%u]==%u)", pi, tt, pti[tt]);
+          */
+        }
+        /* fprintf(stderr, " --> tt=%u\n", tt); */
+        if (2 == ltt && 3 == tt) {
+          printf("M");
+        } else {
+          printf("%c", cc[tt]);
+        }
+        ltt = tt;
+      }
+      /* printf("]\n"); */
+      printf("\n");
+#endif
+    }
+  }
+  airMopOkay(mop);
+  return 0;
+}
+
+UNRRDU_CMD_HIDE(aabplot, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/about.c teem-1.11.0-src/src/unrrdu/about.c
--- teem-1.11.0-src.orig/src/unrrdu/about.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/about.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -36,7 +36,8 @@
     "library in the \"Teem\" collection of libraries.  More information "
     "about Teem is at <http://teem.sf.net>. A checkout of Teem source "
     "is available via:\n "
-    "svn co http://teem.svn.sf.net/svnroot/teem/teem/trunk teem\n ";
+    "svn co http://svn.code.sf.net/p/teem/code/teem/trunk teem\n ";
+  /* "svn co http://teem.svn.sf.net/svnroot/teem/teem/trunk teem\n "; */
   char par2[] = "\t\t\t\t"
     "Long-term maintenance of this software depends on funding, and "
     "funding depends on being able to document who is using it for what.  "
@@ -100,8 +101,7 @@
   sprintf(fmt, "%%%ds\n",
           (int)((hparm->columns-strlen(buff))/2 + strlen(buff) - 1));
   fprintf(stdout, fmt, buff);
-  sprintf(buff, "(Teem version %s, %s)",
-          airTeemVersion, airTeemReleaseDate);
+  airTeemVersionSprint(buff);
   sprintf(fmt, "%%%ds\n",
           (int)((hparm->columns-strlen(buff))/2 + strlen(buff) - 1));
   fprintf(stdout, fmt, buff);
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/acrop.c teem-1.11.0-src/src/unrrdu/acrop.c
--- teem-1.11.0-src.orig/src/unrrdu/acrop.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/acrop.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/affine.c teem-1.11.0-src/src/unrrdu/affine.c
--- teem-1.11.0-src.orig/src/unrrdu/affine.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/affine.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -115,7 +115,9 @@
     valOut = AIR_AFFINE(minIn->val, in->val, maxIn->val,
                         minOut->val, maxOut->val);
     if (clamp) {
-      valOut = AIR_CLAMP(minOut->val, valOut, maxOut->val);
+      double mmin = AIR_MIN(minOut->val, maxOut->val);
+      double mmax = AIR_MAX(minOut->val, maxOut->val);
+      valOut = AIR_CLAMP(mmin, valOut, mmax);
     }
     printf("%g\n", valOut);
   } else {
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/axdelete.c teem-1.11.0-src/src/unrrdu/axdelete.c
--- teem-1.11.0-src.orig/src/unrrdu/axdelete.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/axdelete.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/axinfo.c teem-1.11.0-src/src/unrrdu/axinfo.c
--- teem-1.11.0-src.orig/src/unrrdu/axinfo.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/axinfo.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -29,17 +29,18 @@
 (INFO
  ". The only attributes which are set are those for which command-line "
  "options are given.\n "
- "* Uses no particular function; just sets fields in NrrdAxisInfo");
+ "* Uses no particular function; just sets fields in the NrrdAxisInfo");
 
 int
 unrrdu_axinfoMain(int argc, const char **argv, const char *me,
                   hestParm *hparm) {
   hestOpt *opt = NULL;
-  char *out, *err, *label, *units, *centerStr, *kindStr;
+  char *out, *err, *label, *units, *centerStr, *kindStr,
+    *_dirStr, *dirStr, *mmStr[2];
   Nrrd *nin, *nout;
   int pret, center, kind;
-  unsigned int *axes, axesLen, axi;
-  double mm[2], spc;
+  unsigned int *axes, axesLen, axi, mmIdx, spIdx;
+  double mm[2], spc, sdir[NRRD_SPACE_DIM_MAX];
   airArray *mop;
 
   hestOptAdd(&opt, "a,axes", "ax0", airTypeUInt, 1, -1, &axes, NULL,
@@ -48,26 +49,30 @@
              "label to associate with axis");
   hestOptAdd(&opt, "u,units", "units", airTypeString, 1, 1, &units, "",
              "units of measurement");
-  hestOptAdd(&opt, "mm,minmax", "min max", airTypeDouble, 2, 2, mm, "nan nan",
+  mmIdx =
+  hestOptAdd(&opt, "mm,minmax", "min max", airTypeString, 2, 2, mmStr, "nan nan",
              "min and max values along axis");
+  spIdx =
   hestOptAdd(&opt, "sp,spacing", "spacing", airTypeDouble, 1, 1, &spc, "nan",
              "spacing between samples along axis");
-  /* HEY: this is currently a fundamental (but only rarely annoying)
-     problem in hest.  Because there is functionally no difference
-     between whether an option's information comes from the default
-     string or from the command-line, there is no real way to tell
-     hest, "hey, its just fine for this option to not be used, and
-     if its not used, DON'T DO ANYTHING".  The games of setting strings
-     to "" and floats/doubles to NaN are ways of compensating for
-     this.  However, there is no analogous trick for airEnums.
+  /* There used to be a complaint here about how hest doesn't allow
+     you to learn whether the option was parsed from the supplied
+     default versus from the command-line itself.  That issue has been
+     solved: opt[oi].source now takes on values from the hestSource*
+     enum; axinsert.c now provides an example of this. However,
+     parsing from a string here is still needed here, because here we
+     need to allow the string that represents "no centering"; this
+     is a current weakness of airEnumStr.
   hestOptAdd(&opt, "c,center", "center", airTypeEnum, 1, 1, &cent, "unknown",
              "centering of axis: \"cell\" or \"node\"",
              NULL, nrrdCenter);
   */
-  /* but this hack will do for now */
   hestOptAdd(&opt, "c,center", "center", airTypeString, 1, 1, &centerStr, "",
              "axis centering: \"cell\" or \"node\".  Not using this option "
              "leaves the centering as it is on input");
+  hestOptAdd(&opt, "dir,direction", "svec", airTypeString, 1, 1, &_dirStr, "",
+             "(NOTE: must quote vector) The \"space direction\": the vector "
+             "in space spanned by incrementing (by one) the axis index.");
   hestOptAdd(&opt, "k,kind", "kind", airTypeString, 1, 1, &kindStr, "",
              "axis kind. Not using this option "
              "leaves the kind as it is on input");
@@ -90,6 +95,15 @@
       return 1;
     }
   }
+  /* parse the strings given via -mm */
+  if (2 != airSingleSscanf(mmStr[0], "%lf", mm+0)
+      + airSingleSscanf(mmStr[1], "%lf", mm+1)) {
+    fprintf(stderr, "%s: couldn't parse both \"%s\" and \"%s\" "
+            "(from \"-mm\") as doubles\n", me, mmStr[0], mmStr[1]);
+    airMopError(mop);
+    return 1;
+  }
+
   nout = nrrdNew();
   airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
   if (nrrdCopy(nout, nin)) {
@@ -98,6 +112,29 @@
     airMopError(mop);
     return 1;
   }
+  if (airStrlen(_dirStr)) {
+    if (!nin->spaceDim) {
+      fprintf(stderr, "%s: wanted to add space direction, but input "
+              "doesn't have space dimension set", me);
+      airMopError(mop);
+      return 1;
+    }
+    /* mindlessly copying logic from unu make; unsure of the value */
+    if ('\"' == _dirStr[0] && '\"' == _dirStr[strlen(_dirStr)-1]) {
+      _dirStr[strlen(_dirStr)-1] = 0;
+      dirStr = _dirStr + 1;
+    } else {
+      dirStr = _dirStr;
+    }
+    if (nrrdSpaceVectorParse(sdir, dirStr, nin->spaceDim, AIR_TRUE)) {
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: couldn't parse space vector:\n%s", me, err);
+      airMopError(mop);
+      return 1;
+    }
+  } else {
+    dirStr = NULL;
+  }
 
   for (axi=0; axi<axesLen; axi++) {
     unsigned int axis;
@@ -110,14 +147,26 @@
       nout->axis[axis].units = (char *)airFree(nout->axis[axis].units);
       nout->axis[axis].units = airStrdup(units);
     }
-    if (AIR_EXISTS(mm[0])) {
+    if (hestSourceUser == opt[mmIdx].source) {
+      /* if it came from user, set the value, even if its nan. Actually,
+         especially if its nan: that is the purpose of this extra logic */
       nout->axis[axis].min = mm[0];
-    }
-    if (AIR_EXISTS(mm[1])) {
       nout->axis[axis].max = mm[1];
+    } else {
+      if (AIR_EXISTS(mm[0])) {
+        nout->axis[axis].min = mm[0];
+      }
+      if (AIR_EXISTS(mm[1])) {
+        nout->axis[axis].max = mm[1];
+      }
     }
-    if (AIR_EXISTS(spc)) {
+    if (hestSourceUser == opt[spIdx].source) {
+      /* same logic as with min,max above */
       nout->axis[axis].spacing = spc;
+    } else {
+      if (AIR_EXISTS(spc)) {
+        nout->axis[axis].spacing = spc;
+      }
     }
     /* see above
     if (nrrdCenterUnknown != cent) {
@@ -152,6 +201,9 @@
       }
       nout->axis[axis].kind = kind;
     }
+    if (dirStr) {
+      nrrdSpaceVecCopy(nout->axis[axis].spaceDirection, sdir);
+    }
   }
 
   SAVE(out, nout, NULL);
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/axinsert.c teem-1.11.0-src/src/unrrdu/axinsert.c
--- teem-1.11.0-src.orig/src/unrrdu/axinsert.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/axinsert.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -30,7 +30,7 @@
  ". The underlying linear ordering of the samples is "
  "unchanged, and the information about the other axes is "
  "shifted upwards as needed.\n "
- "* Uses nrrdAxesInsert");
+ "* Uses nrrdAxesInsert, and with \"-s\", nrrdPad_nva");
 
 int
 unrrdu_axinsertMain(int argc, const char **argv, const char *me,
@@ -38,13 +38,35 @@
   hestOpt *opt = NULL;
   char *out, *err, *label;
   Nrrd *nin, *nout;
-  int pret;
-  unsigned int axis;
+  int pret, kind, center;
+  unsigned int axis, size, opi, centOptIdx;
+  double mm[2];
   airArray *mop;
+  NrrdBoundarySpec *bspec;
 
+  hparm->elideSingleOtherDefault = AIR_FALSE;
   OPT_ADD_AXIS(axis, "dimension (axis index) at which to insert the new axis");
   hestOptAdd(&opt, "l,label", "label", airTypeString, 1, 1, &label, "",
              "label to associate with new axis");
+  opi = hestOptAdd(&opt, "k,kind", "kind", airTypeEnum, 1, 1, &kind, "stub",
+                   "axis kind to associate with new axis", NULL, nrrdKind);
+  hestOptAdd(&opt, "mm,minmax", "min max", airTypeDouble, 2, 2, mm, "nan nan",
+             "min and max values along new axis");
+  centOptIdx =
+    hestOptAdd(&opt, "c,center", "center", airTypeEnum, 1, 1, &center, "cell",
+               "centering of inserted axis: \"cell\" or \"node\"",
+               NULL, nrrdCenter);
+  hestOptAdd(&opt, "s,size", "size", airTypeUInt, 1, 1, &size, "1",
+             "after inserting stub axis, also pad out to some length, "
+             "according to the \"-b\" option");
+  hestOptAdd(&opt, "b,boundary", "behavior", airTypeOther, 1, 1, &bspec,
+             "bleed",
+             "How to handle samples beyond the input bounds:\n "
+             "\b\bo \"pad:<val>\": use specified value\n "
+             "\b\bo \"bleed\": extend border values outward\n "
+             "\b\bo \"mirror\": repeated reflections\n "
+             "\b\bo \"wrap\": wrap-around to other side",
+             NULL, NULL, nrrdHestBoundarySpec);
   OPT_ADD_NIN(nin, "input nrrd");
   OPT_ADD_NOUT(out, "output nrrd");
 
@@ -64,10 +86,49 @@
     airMopError(mop);
     return 1;
   }
+  if (hestSourceUser == opt[centOptIdx].source) {
+    nout->axis[axis].center = center;
+  }
+  if (1 < size) {
+    /* we also do padding here */
+    ptrdiff_t min[NRRD_DIM_MAX], max[NRRD_DIM_MAX];
+    unsigned int ai;
+    Nrrd *npad;
+    for (ai=0; ai<nout->dim; ai++) {
+      min[ai] = 0;
+      max[ai] = nout->axis[ai].size - 1;
+    }
+    max[axis] = size-1;
+    npad = nrrdNew();
+    airMopAdd(mop, npad, (airMopper)nrrdNuke, airMopAlways);
+    if (nrrdPad_nva(npad, nout, min, max,
+                    bspec->boundary, bspec->padValue)) {
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: error padding:\n%s", me, err);
+      airMopError(mop);
+      return 1;
+    }
+    /* sneaky, but ok; nothing changes in the mops */
+    nout = npad;
+    /* only set output kind if explicitly requested
+       (since the default is not appropriate) */
+    if (hestSourceUser == opt[opi].source) {
+      nout->axis[axis].kind = kind;
+    }
+  } else {
+    /* no request to pad; setting the default "stub" kind is sensible */
+    nout->axis[axis].kind = kind;
+  }
   if (strlen(label)) {
     nout->axis[axis].label = (char *)airFree(nout->axis[axis].label);
     nout->axis[axis].label = airStrdup(label);
   }
+  if (AIR_EXISTS(mm[0])) {
+    nout->axis[axis].min = mm[0];
+  }
+  if (AIR_EXISTS(mm[1])) {
+    nout->axis[axis].max = mm[1];
+  }
 
   SAVE(out, nout, NULL);
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/axmerge.c teem-1.11.0-src/src/unrrdu/axmerge.c
--- teem-1.11.0-src.orig/src/unrrdu/axmerge.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/axmerge.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/axsplit.c teem-1.11.0-src/src/unrrdu/axsplit.c
--- teem-1.11.0-src.orig/src/unrrdu/axsplit.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/axsplit.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/basinfo.c teem-1.11.0-src/src/unrrdu/basinfo.c
--- teem-1.11.0-src.orig/src/unrrdu/basinfo.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/basinfo.c	2021-02-18 15:42:37.000000000 +0800
@@ -0,0 +1,200 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2020  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "unrrdu.h"
+#include "privateUnrrdu.h"
+
+#define INFO "Modify whole-array attributes (not per-axis)"
+static const char *_unrrdu_basinfoInfoL =
+(INFO
+ ", which is called \"basic info\" in Nrrd terminology. "
+ "The only attributes which are set are those for which command-line "
+ "options are given.\n "
+ "* Uses no particular function; just sets fields in the Nrrd");
+
+int
+unrrdu_basinfoMain(int argc, const char **argv, const char *me,
+                   hestParm *hparm) {
+  /* these are stock for unrrdu */
+  hestOpt *opt = NULL;
+  airArray *mop;
+  int pret;
+  char *err;
+  /* these are stock for things using the usual -i and -o */
+  char *out;
+  Nrrd *nin, *nout;
+  /* these are specific to this command */
+  NrrdIoState *nio;
+  char *spcStr, *_origStr, *origStr, **kvp, **dkey, *content;
+  int space, nixkvp;
+  unsigned int spaceDim, kvpLen, dkeyLen, cIdx, ii;
+
+  hestOptAdd(&opt, "spc,space", "space", airTypeString, 1, 1, &spcStr, "",
+             "identify the space (e.g. \"RAS\", \"LPS\") in which the array "
+             "conceptually lives, from the nrrdSpace airEnum, which in turn "
+             "determines the dimension of the space.  Or, use an integer>0 to "
+             "give the dimension of a space that nrrdSpace doesn't know about. "
+             "By default (not using this option), the enclosing space is "
+             "set as unknown.");
+  hestOptAdd(&opt, "orig,origin", "origin", airTypeString, 1, 1, &_origStr, "",
+             "(NOTE: must quote vector) the origin in space of the array: "
+             "the location of the center "
+             "of the first sample, of the form \"(x,y,z)\" (or however "
+             "many coefficients are needed for the chosen space). Quoting the "
+             "vector is needed to stop interpretation from the shell");
+  /* HEY: copy and paste from unrrdu/make.c */
+  hestOptAdd(&opt, "kv,keyvalue", "key/val", airTypeString, 1, -1, &kvp, "",
+             "key/value string pairs to be stored in nrrd.  Each key/value "
+             "pair must be a single string (put it in \"\"s "
+             "if the key or the value contain spaces).  The format of each "
+             "pair is \"<key>:=<value>\", with no spaces before or after "
+             "\":=\".", &kvpLen);
+  hestOptAdd(&opt, "dk,delkey", "key", airTypeString, 1, -1, &dkey, "",
+             "keys to be deleted (erased) from key/value pairs", &dkeyLen);
+  hestOptAdd(&opt, "xkv,nixkeyvalue", NULL, airTypeBool, 0, 0,
+             &nixkvp, NULL,
+             "nix (clear) all key/value pairs");
+  cIdx =
+  hestOptAdd(&opt, "c,content", "content", airTypeString, 1, 1, &content, "",
+             "Specifies the content string of the nrrd, which is built upon "
+             "by many nrrd function to record a history of operations");
+  OPT_ADD_NIN(nin, "input nrrd");
+  OPT_ADD_NOUT(out, "output nrrd");
+
+  mop = airMopNew();
+  airMopAdd(mop, opt, (airMopper)hestOptFree, airMopAlways);
+  nio = nrrdIoStateNew();
+  airMopAdd(mop, nio, (airMopper)nrrdIoStateNix, airMopAlways);
+
+  USAGE(_unrrdu_basinfoInfoL);
+  PARSE();
+  airMopAdd(mop, opt, (airMopper)hestParseFree, airMopAlways);
+
+  nout = nrrdNew();
+  airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
+  if (nrrdCopy(nout, nin)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error copying input:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+
+  /* HEY: copy and paste from unrrdu/make.c */
+  if (airStrlen(spcStr)) {
+    space = airEnumVal(nrrdSpace, spcStr);
+    if (!space) {
+      /* couldn't parse it as space, perhaps its a uint */
+      if (1 != sscanf(spcStr, "%u", &spaceDim)) {
+        fprintf(stderr, "%s: couldn't parse \"%s\" as a nrrdSpace "
+                "or as a uint", me, spcStr);
+        airMopError(mop); return 1;
+      }
+      /* else we did parse it as a uint */
+      nout->space = nrrdSpaceUnknown;
+      nout->spaceDim = spaceDim;
+    } else {
+      /* we did parse a known space */
+      nrrdSpaceSet(nout, space);
+    }
+  }
+
+  /* HEY: copy and paste from unrrdu/make.c */
+  if (airStrlen(content)) { /* must have come from user */
+    if (nout->content) {
+      free(nout->content);
+    }
+    nout->content = airStrdup(content);
+  } else if (hestSourceUser == opt[cIdx].source) {
+    /* else user actually said: -c "" */
+    nout->content = (char *)airFree(nout->content);
+  } /* else option not used */
+
+  /* HEY: copy and paste from unrrdu/make.c */
+  if (airStrlen(_origStr)) {
+    /* why this is necessary is a bit confusing to me, both the check for
+       enclosing quotes, and the need to use to a separate variable (isn't
+       hest doing memory management of addresses, not variables?) */
+    if ('\"' == _origStr[0] && '\"' == _origStr[strlen(_origStr)-1]) {
+      _origStr[strlen(_origStr)-1] = 0;
+      origStr = _origStr + 1;
+    } else {
+      origStr = _origStr;
+    }
+    /* same hack about using NrrdIoState->line as basis for parsing */
+    nio->line = origStr;
+    nio->pos = 0;
+    if (nrrdFieldInfoParse[nrrdField_space_origin](NULL, nout,
+                                                   nio, AIR_TRUE)) {
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: trouble with origin \"%s\":\n%s",
+              me, origStr, err);
+      nio->line = NULL; airMopError(mop); return 1;
+    }
+    nio->line = NULL;
+  }
+
+  /* HEY: copy and paste from unrrdu/make.c */
+  if (kvpLen) {
+    for (ii=0; ii<kvpLen; ii++) {
+      /* a hack: have to use NrrdIoState->line as the channel to communicate
+         the key/value pair, since we have to emulate it having been
+         read from a NRRD header.  But because nio doesn't own the
+         memory, we must be careful to unset the pointer prior to
+         NrrdIoStateNix being called by the mop. */
+      nio->line = kvp[ii];
+      nio->pos = 0;
+      if (nrrdFieldInfoParse[nrrdField_keyvalue](NULL, nout,
+                                                 nio, AIR_TRUE)) {
+        airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+        fprintf(stderr, "%s: trouble with key/value %d \"%s\":\n%s",
+                me, ii, kvp[ii], err);
+        nio->line = NULL; airMopError(mop); return 1;
+      }
+      nio->line = NULL;
+    }
+  }
+
+  /* now delete ("erase") the keys that aren't wanted */
+  if (dkeyLen) {
+    for (ii=0; ii<dkeyLen; ii++) {
+      if (nrrdKeyValueErase(nout, dkey[ii])) {
+        airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+        fprintf(stderr, "%s: trouble erasing key/value %d \"%s\":\n%s",
+                me, ii, dkey[ii], err);
+        airMopError(mop); return 1;
+      }
+    }
+  }
+
+  /* now delete everything if requested */
+  if (nixkvp) {
+    nrrdKeyValueClear(nout);
+  }
+
+  SAVE(out, nout, NULL);
+
+  airMopOkay(mop);
+  return 0;
+}
+
+UNRRDU_CMD(basinfo, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/block.c teem-1.11.0-src/src/unrrdu/block.c
--- teem-1.11.0-src.orig/src/unrrdu/block.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/block.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/ccadj.c teem-1.11.0-src/src/unrrdu/ccadj.c
--- teem-1.11.0-src.orig/src/unrrdu/ccadj.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/ccadj.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/ccfind.c teem-1.11.0-src/src/unrrdu/ccfind.c
--- teem-1.11.0-src.orig/src/unrrdu/ccfind.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/ccfind.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/ccmerge.c teem-1.11.0-src/src/unrrdu/ccmerge.c
--- teem-1.11.0-src.orig/src/unrrdu/ccmerge.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/ccmerge.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/ccsettle.c teem-1.11.0-src/src/unrrdu/ccsettle.c
--- teem-1.11.0-src.orig/src/unrrdu/ccsettle.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/ccsettle.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/cksum.c teem-1.11.0-src/src/unrrdu/cksum.c
--- teem-1.11.0-src.orig/src/unrrdu/cksum.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/cksum.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/CMakeLists.txt teem-1.11.0-src/src/unrrdu/CMakeLists.txt
--- teem-1.11.0-src.orig/src/unrrdu/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/CMakeLists.txt	2021-02-18 15:42:37.000000000 +0800
@@ -0,0 +1,83 @@
+# This variable will help provide a master list of all the sources.
+# Add new source files here.
+set(UNRRDU_SOURCES
+  fft.c
+  i2w.c
+  w2i.c
+  1op.c
+  2op.c
+  3op.c
+  affine.c
+  about.c
+  axdelete.c
+  axinfo.c
+  basinfo.c
+  axinsert.c
+  axmerge.c
+  axsplit.c
+  block.c
+  ccadj.c
+  ccfind.c
+  ccmerge.c
+  ccsettle.c
+  cmedian.c
+  convert.c
+  crop.c
+  acrop.c
+  data.c
+  dering.c
+  dhisto.c
+  dice.c
+  dist.c
+  env.c
+  flip.c
+  flotsam.c
+  gamma.c
+  head.c
+  heq.c
+  histax.c
+  histo.c
+  imap.c
+  inset.c
+  jhisto.c
+  join.c
+  lut.c
+  lut2.c
+  make.c
+  minmax.c
+  cksum.c
+  diff.c
+  dnorm.c
+  vidicon.c
+  grid.c
+  hack.c
+  aabplot.c
+  undos.c
+  mlut.c
+  mrmap.c
+  pad.c
+  permute.c
+  privateUnrrdu.h
+  project.c
+  quantize.c
+  resample.c
+  reshape.c
+  rmap.c
+  save.c
+  shuffle.c
+  slice.c
+  sselect.c
+  splice.c
+  subst.c
+  swap.c
+  tile.c
+  unblock.c
+  unorient.c
+  unquantize.c
+  unrrdu.h
+  untile.c
+  )
+
+target_sources(teem PRIVATE ${UNRRDU_SOURCES})
+# This will group all the source files in the VS project by directory
+source_group( unrrdu FILES ${UNRRDU_SOURCES} )
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/cmedian.c teem-1.11.0-src/src/unrrdu/cmedian.c
--- teem-1.11.0-src.orig/src/unrrdu/cmedian.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/cmedian.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/convert.c teem-1.11.0-src/src/unrrdu/convert.c
--- teem-1.11.0-src.orig/src/unrrdu/convert.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/convert.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/crop.c teem-1.11.0-src/src/unrrdu/crop.c
--- teem-1.11.0-src.orig/src/unrrdu/crop.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/crop.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -106,7 +106,7 @@
     airULLong *bounds;
     unsigned int axi;
     if (!(2 == _nbounds->dim
-          && nin->dim == AIR_CAST(unsigned int, _nbounds->axis[0].size)
+          && nin->dim == AIR_UINT(_nbounds->axis[0].size)
           && 2 == _nbounds->axis[1].size)) {
       char stmp1[AIR_STRLEN_SMALL], stmp2[AIR_STRLEN_SMALL];
       if (_nbounds->dim >= 2) {
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/data.c teem-1.11.0-src/src/unrrdu/data.c
--- teem-1.11.0-src.orig/src/unrrdu/data.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/data.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -24,13 +24,13 @@
 #include "unrrdu.h"
 #include "privateUnrrdu.h"
 
-#define INFO "Print data segment of a nrrd file"
+#define INFO "Write data segment of a nrrd file"
 static const char *_unrrdu_dataInfoL =
 (INFO  ".  The value of this is to pass the data segment in isolation to a "
  "stand-alone decoder, in case this Teem build lacks an optional "
  "data encoding required for a given nrrd file.  Caveats: "
- "Will start copying "
- "characters from the datafile until EOF is hit, so this won't work "
+ "Will start copying characters from the datafile "
+ "to output file until EOF is hit, so this won't work "
  "correctly if the datafile has extraneous content at the end.  Will "
  "skip lines (as per \"line skip:\" header field) if needed, but can only "
  "skip bytes (as per \"byte skip:\") if the encoding is NOT a compression. "
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/dering.c teem-1.11.0-src/src/unrrdu/dering.c
--- teem-1.11.0-src.orig/src/unrrdu/dering.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/dering.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -104,8 +104,8 @@
           && nmask->axis[0].size == nin->axis[0].size
           && nmask->axis[1].size == nin->axis[1].size)) {
       fprintf(stderr, "%s: given mask not 2-D %u-by-%u array of scalar type",
-              me, AIR_CAST(unsigned int, nin->axis[0].size),
-              AIR_CAST(unsigned int, nin->axis[1].size));
+              me, AIR_UINT(nin->axis[0].size),
+              AIR_UINT(nin->axis[1].size));
       airMopError(mop);
       return 1;
     }
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/dhisto.c teem-1.11.0-src/src/unrrdu/dhisto.c
--- teem-1.11.0-src.orig/src/unrrdu/dhisto.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/dhisto.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/dice.c teem-1.11.0-src/src/unrrdu/dice.c
--- teem-1.11.0-src.orig/src/unrrdu/dice.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/dice.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -140,7 +140,9 @@
       }
     }
     sprintf(fnout, fffname, base, pos+start);
-    fprintf(stderr, "%s: %s ...\n", me, fnout);
+    if (nrrdStateVerboseIO > 0) {
+      fprintf(stderr, "%s: %s ...\n", me, fnout);
+    }
     if (nrrdSave(fnout, nout, NULL)) {
       airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
       fprintf(stderr, "%s: error writing nrrd to \"%s\":%s\n",
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/diff.c teem-1.11.0-src/src/unrrdu/diff.c
--- teem-1.11.0-src.orig/src/unrrdu/diff.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/diff.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -41,7 +41,7 @@
   int pret;
 
   Nrrd *ninA, *ninB;
-  int onlyData, differ;
+  int quiet, exitstat, onlyData, differ, ret;
   double epsilon;
   char explain[AIR_STRLEN_LARGE];
 
@@ -55,6 +55,12 @@
   hestOptAdd(&opt, "eps,epsilon", "eps", airTypeDouble, 1, 1, &epsilon, "0.0",
              "threshold for allowable difference in values in "
              "data values");
+  hestOptAdd(&opt, "q,quiet", NULL, airTypeInt, 0, 0, &quiet, NULL,
+             "be quiet (like regular diff), so that nothing is printed "
+             "if the nrrds are the same");
+  hestOptAdd(&opt, "x,exit", NULL, airTypeInt, 0, 0, &exitstat, NULL,
+             "use the exit status (like regular diff) to indicate if "
+             "there was a significant difference (as if it's an error)");
   hestOptAdd(&opt, "od,onlydata", NULL, airTypeInt, 0, 0, &onlyData, NULL,
              "Compare data values only, excluding array meta-data");
   airMopAdd(mop, opt, (airMopper)hestOptFree, airMopAlways);
@@ -72,17 +78,21 @@
   if (differ) {
     printf("%s: %s differ: %s\n", me, onlyData ? "data values" : "nrrds",
            explain);
+    ret=1;
   } else {
-    if (0 == epsilon) {
-      printf("%s: %s are the same\n", me, onlyData ? "data values" : "nrrds");
-    } else {
-      printf("%s: %s are same or within %g of each other\n", me,
-             onlyData ? "data values" : "nrrds", epsilon);
+    if (!quiet) {
+      if (0 == epsilon) {
+        printf("%s: %s are the same\n", me, onlyData ? "data values" : "nrrds");
+      } else {
+        printf("%s: %s are same or within %g of each other\n", me,
+               onlyData ? "data values" : "nrrds", epsilon);
+      }
     }
+    ret=0;
   }
 
   airMopOkay(mop);
-  return 0;
+  return exitstat ? ret : 0;
 }
 
 UNRRDU_CMD(diff, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/dist.c teem-1.11.0-src/src/unrrdu/dist.c
--- teem-1.11.0-src.orig/src/unrrdu/dist.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/dist.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/dnorm.c teem-1.11.0-src/src/unrrdu/dnorm.c
--- teem-1.11.0-src.orig/src/unrrdu/dnorm.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/dnorm.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -29,9 +29,11 @@
   (INFO
    ". Forces information about kind and orientation into "
    "a consistent form, and nixes various other fields. This was "
-   "created as a utility for the Diderot project "
-   "(http://diderot-language.cs.uchicago.edu), hence the name.\n "
-   "* (as yet there's no single nrrd function which does all this)");
+   "originally created as a utility for the Diderot project "
+   "(http://diderot-language.cs.uchicago.edu), hence the name, "
+   "but it has proven useful in other contexts (uses of gage) in which "
+   "it is nice to have standardized orientation information.\n "
+   "* Uses nrrdMetaDataNormalize");
 
 int
 unrrdu_dnormMain(int argc, const char **argv, const char *me,
@@ -41,9 +43,8 @@
 
   Nrrd *nin, *nout;
   NrrdIoState *nio;
-  int kindIn, kindOut, headerOnly, haveMM, trivialOrient, recenter, gotmf;
-  unsigned int kindAxis, axi, si, sj;
-  double sscl;
+  int version, lostmf, headerOnly, trivialOrient, recenter;
+  double newSpacing;
 
   hestOpt *opt = NULL;
   char *err;
@@ -51,21 +52,25 @@
 
   hestOptAdd(&opt, "h,header", NULL, airTypeInt, 0, 0, &headerOnly, NULL,
              "output header of nrrd file only, not the data itself");
+  hestOptAdd(&opt, "v,version", "version", airTypeEnum, 1,1,&version, "alpha",
+             "what version of canonical meta-data to convert to; "
+             "\"alpha\" is what has been used for Diderot until at least "
+             "2016", NULL, nrrdMetaDataCanonicalVersion);
   hestOptAdd(&opt, "to", NULL, airTypeInt, 0, 0, &trivialOrient, NULL,
              "(*t*rivial *o*rientation) "
              "even if the input nrrd comes with full orientation or "
              "per-axis min-max info, ignore it and instead assert the "
-             "most trivial mapping between index and world space");
-  hestOptAdd(&opt, "c,center", NULL, airTypeInt, 0, 0, &recenter, NULL,
+             "identity mapping between index and world space");
+  hestOptAdd(&opt, "rc,recenter", NULL, airTypeInt, 0, 0, &recenter, NULL,
              "re-locate output spaceOrigin so that field is centered "
              "around origin of space coordinates");
-  hestOptAdd(&opt, "s,scaling", "scl", airTypeDouble, 1, 1, &sscl, "1.0",
-             "when contriving orientation information, distance between "
-             "samples to use");
-  hestOptAdd(&opt, "i", "nin", airTypeOther, 1, 1, &nin, NULL,
-             "input image", NULL, NULL, nrrdHestNrrd);
-  hestOptAdd(&opt, "o", "nout", airTypeString, 1, 1, &outS, "-",
-             "output filename", NULL);
+  hestOptAdd(&opt, "sp,spacing", "scl", airTypeDouble, 1, 1, &newSpacing,
+             "1.0",
+             "when having to contrive orientation information and there's "
+             "no per-axis min/max or spacing, this is the sample spacing "
+             "to assert");
+  OPT_ADD_NIN(nin, "input image");
+  OPT_ADD_NOUT(outS, "output filename");
 
   mop = airMopNew();
   airMopAdd(mop, opt, (airMopper)hestOptFree, airMopAlways);
@@ -73,236 +78,46 @@
   PARSE();
   airMopAdd(mop, opt, (airMopper)hestParseFree, airMopAlways);
 
-  /* can't deal with block type */
-  if (nrrdTypeBlock == nin->type) {
-    fprintf(stderr, "%s: can only have scalar kinds (not %s)\n", me,
-            airEnumStr(nrrdType, nrrdTypeBlock));
-    airMopError(mop); exit(1);
-  }
-
-  /* make sure all kinds are set to something */
-  /* see if there's a range kind, verify that there's only one */
-  /* set haveMM */
-  haveMM = AIR_TRUE;
-  kindIn = nrrdKindUnknown;
-  kindAxis = 0;
-  for (axi=0; axi<nin->dim; axi++) {
-    if (nrrdKindUnknown == nin->axis[axi].kind
-        || nrrdKindIsDomain(nin->axis[axi].kind)) {
-      haveMM &= AIR_EXISTS(nin->axis[axi].min);
-      haveMM &= AIR_EXISTS(nin->axis[axi].max);
-    } else {
-      if (nrrdKindUnknown != kindIn) {
-        fprintf(stderr, "%s: got non-domain kind %s on axis %u, but already "
-                "have %s from axis %u\n", me,
-                airEnumStr(nrrdKind, nin->axis[axi].kind), axi,
-                airEnumStr(nrrdKind, kindIn), kindAxis);
-        airMopError(mop); exit(1);
-      }
-      kindIn = nin->axis[axi].kind;
-      kindAxis = axi;
-    }
-  }
-  /* see if the non-domain kind is something we can interpret as a tensor */
-  if (nrrdKindUnknown != kindIn) {
-    switch (kindIn) {
-      /* ======= THESE are the kinds that we can possibly output ======= */
-    case nrrdKind2Vector:
-    case nrrdKind3Vector:
-    case nrrdKind4Vector:
-    case nrrdKind2DSymMatrix:
-    case nrrdKind2DMatrix:
-    case nrrdKind3DSymMatrix:
-    case nrrdKind3DMatrix:
-      /* =============================================================== */
-      kindOut = kindIn;
-      break;
-      /* Some other kinds are mapped to those above */
-    case nrrdKind3Color:
-    case nrrdKindRGBColor:
-      kindOut = nrrdKind3Vector;
-      break;
-    case nrrdKind4Color:
-    case nrrdKindRGBAColor:
-      kindOut = nrrdKind4Vector;
-      break;
-    default:
-      fprintf(stderr, "%s: got non-conforming kind %s on axis %u\n", me,
-              airEnumStr(nrrdKind, kindIn), kindAxis);
-      airMopError(mop); exit(1);
-      break;
-    }
+  if (headerOnly) {
+    /* no reason to duplicate data */
+    nout = nin;
   } else {
-    kindOut = nrrdKindUnknown;
+    nout = nrrdNew();
+    airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
   }
 
-  /* initialize output by copying */
-  nout = nrrdNew();
-  airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
-  if (nrrdCopy(nout, nin)) {
+  if (nrrdMetaDataNormalize(nout, nin,
+                            version, trivialOrient,
+                            AIR_FALSE /* permuteComponentAxisFastest */,
+                            recenter,
+                            newSpacing,
+                            &lostmf)) {
     airMopAdd(mop, err = biffGet(NRRD), airFree, airMopAlways);
-    fprintf(stderr, "%s: trouble copying:\n%s", me, err);
-    airMopError(mop); exit(1);
+    fprintf(stderr, "%s: trouble:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+
+  if (lostmf) {
+    fprintf(stderr, "%s: WARNING: input array measurement frame "
+            "will be erased on output.\n", me);
   }
 
-  /* no comments, either advertising the format URL or anything else */
   nio = nrrdIoStateNew();
   airMopAdd(mop, nio, (airMopper)nrrdIoStateNix, airMopAlways);
+  /* disable printing comments about NRRD format URL */
   nio->skipFormatURL = AIR_TRUE;
   if (headerOnly) {
     nio->skipData = AIR_TRUE;
   }
-  nrrdCommentClear(nout);
-
-  /* no measurement frame */
-  gotmf = AIR_FALSE;
-  for (si=0; si<NRRD_SPACE_DIM_MAX; si++) {
-    for (sj=0; sj<NRRD_SPACE_DIM_MAX; sj++) {
-      gotmf |= AIR_EXISTS(nout->measurementFrame[si][sj]);
-    }
-  }
-  if (gotmf) {
-    fprintf(stderr, "%s: WARNING: incoming array measurement frame; "
-            "it will be erased on output.\n", me);
-    airMopError(mop); exit(1);
-  }
-  for (si=0; si<NRRD_SPACE_DIM_MAX; si++) {
-    for (sj=0; sj<NRRD_SPACE_DIM_MAX; sj++) {
-      nout->measurementFrame[si][sj] = AIR_NAN;
-    }
-  }
-
-  /* no key/value pairs */
-  nrrdKeyValueClear(nout);
-
-  /* no content field */
-  nout->content = airFree(nout->content);
-
-  /* normalize domain kinds to "space" */
-  /* turn off centers (perhaps Diderot should assume cell-centered) */
-  /* turn off thickness */
-  /* turn off labels and units */
-  for (axi=0; axi<nout->dim; axi++) {
-    if (nrrdKindUnknown == kindOut) {
-      nout->axis[axi].kind = nrrdKindSpace;
-    } else {
-      nout->axis[axi].kind = (kindAxis == axi
-                              ? kindOut
-                              : nrrdKindSpace);
-    }
-    nout->axis[axi].center = nrrdCenterUnknown;
-    nout->axis[axi].thickness = AIR_NAN;
-    nout->axis[axi].label = airFree(nout->axis[axi].label);
-    nout->axis[axi].units = airFree(nout->axis[axi].units);
-    nout->axis[axi].min = AIR_NAN;
-    nout->axis[axi].max = AIR_NAN;
-    nout->axis[axi].spacing = AIR_NAN;
-  }
-
-  /* logic of orientation definition:
-     if space dimension is known:
-        set origin to zero if not already set
-        set space direction to unit vector if not already set
-     else:
-        set origin to zero and all space directions to units
-     might be nice to use gage's logic for mapping from world to index,
-     but we have to accept a greater variety of kinds and dimensions
-     than gage ever has to process.
-  */
-  if (nout->spaceDim && !trivialOrient) {
-    int saxi = 0;
-    /* we use only the space dimension, not any named space */
-    nout->space = nrrdSpaceUnknown;
-    if (!nrrdSpaceVecExists(nout->spaceDim, nout->spaceOrigin)) {
-      nrrdSpaceVecSetZero(nout->spaceOrigin);
-    }
-    for (axi=0; axi<nout->dim; axi++) {
-      if (nrrdKindUnknown == kindOut || kindAxis != axi) {
-        if (!nrrdSpaceVecExists(nout->spaceDim,
-                                nout->axis[axi].spaceDirection)) {
-          nrrdSpaceVecSetZero(nout->axis[axi].spaceDirection);
-          nout->axis[axi].spaceDirection[saxi] = sscl;
-        }
-        saxi++;
-      } else {
-        nrrdSpaceVecSetNaN(nout->axis[axi].spaceDirection);
-      }
-    }
-  } else if (haveMM && !trivialOrient) {
-    int saxi = 0;
-    for (axi=0; axi<nout->dim; axi++) {
-      if (nrrdKindUnknown == kindOut || kindAxis != axi) {
-        nrrdSpaceVecSetZero(nout->axis[axi].spaceDirection);
-        nout->axis[axi].spaceDirection[saxi]
-          = (nin->axis[axi].max - nin->axis[axi].min)/(nin->axis[axi].size-1);
-        nout->spaceOrigin[saxi] = nin->axis[axi].min;
-        saxi++;
-      } else {
-        nrrdSpaceVecSetNaN(nout->axis[axi].spaceDirection);
-      }
-    }
-    nout->spaceDim = saxi;
-  } else {
-    /* either trivialOrient, or not spaceDim, or not not haveMM */
-    int saxi = 0;
-    nout->space = nrrdSpaceUnknown;
-    nrrdSpaceVecSetZero(nout->spaceOrigin);
-    for (axi=0; axi<nout->dim; axi++) {
-      if (nrrdKindUnknown == kindOut || kindAxis != axi) {
-        nrrdSpaceVecSetZero(nout->axis[axi].spaceDirection);
-        nout->axis[axi].spaceDirection[saxi]
-          = (AIR_EXISTS(nin->axis[axi].spacing)
-             ? nin->axis[axi].spacing
-             : sscl);
-        saxi++;
-      } else {
-        nrrdSpaceVecSetNaN(nout->axis[axi].spaceDirection);
-      }
-    }
-    nout->spaceDim = saxi;
-  }
-
-  /* space dimension has to match the number of domain axes */
-  if (nout->dim != nout->spaceDim + !!kindOut) {
-    fprintf(stderr, "%s: output dim %d != spaceDim %d + %d %s%s%s\n",
-            me, nout->dim, nout->spaceDim, !!kindOut,
-            kindOut ? "for non-scalar (" : "(scalar data)",
-            kindOut ? airEnumStr(nrrdKind, kindOut) : "",
-            kindOut ? ") data" : "");
-    airMopError(mop); exit(1);
-  }
-
-  if (recenter) {
-    /* sets field's origin so field is centered on the origin. capiche? */
-    /* this code was tacked on later than the stuff above, so its
-       logic could probably be moved up there, but it seems cleaner to
-       have it as a separate post-process */
-    double mean[NRRD_SPACE_DIM_MAX];
-    nrrdSpaceVecSetZero(mean);
-    for (axi=0; axi<nout->dim; axi++) {
-      if (nrrdKindUnknown == kindOut || kindAxis != axi) {
-        nrrdSpaceVecScaleAdd2(mean, 1.0, mean,
-                              0.5*(nout->axis[axi].size - 1),
-                              nout->axis[axi].spaceDirection);
-      }
-    }
-    nrrdSpaceVecScaleAdd2(mean, 1.0, mean,
-                          1.0, nout->spaceOrigin);
-    /* now mean is the center of the field */
-    nrrdSpaceVecScaleAdd2(nout->spaceOrigin,
-                          1.0, nout->spaceOrigin,
-                          -1.0, mean);
-  }
-
   if (nrrdSave(outS, nout, nio)) {
     airMopAdd(mop, err = biffGet(NRRD), airFree, airMopAlways);
     fprintf(stderr, "%s: trouble saving \"%s\":\n%s",
             me, outS, err);
-    airMopError(mop); exit(1);
+    airMopError(mop); return 1;
   }
 
   airMopOkay(mop);
   return 0;
 }
 
-UNRRDU_CMD_HIDE(dnorm, INFO);
+UNRRDU_CMD(dnorm, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/env.c teem-1.11.0-src/src/unrrdu/env.c
--- teem-1.11.0-src.orig/src/unrrdu/env.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/env.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -287,6 +287,13 @@
                   "When false, text files used for saving nrrds start with "
                   "comment (\"# ...\") lines containing nrrd fields.",
                   hparm->columns);
+  _unrrdu_envBool(out,
+                  nrrdEnvVarDefaultWriteMoreThanFloatInText,
+                  nrrdDefaultWriteMoreThanFloatInText,
+                  "nrrdDefaultWriteMoreThanFloatInText",
+                  "When true, text files used for saving nrrds can "
+                  "losslessly store values of more than just float type.",
+                  hparm->columns);
   _unrrdu_envEnum(out,
                   nrrdType, nrrdEnvVarStateMeasureType,
                   nrrdStateMeasureType,
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/fft.c teem-1.11.0-src/src/unrrdu/fft.c
--- teem-1.11.0-src.orig/src/unrrdu/fft.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/fft.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/flip.c teem-1.11.0-src/src/unrrdu/flip.c
--- teem-1.11.0-src.orig/src/unrrdu/flip.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/flip.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/flotsam.c teem-1.11.0-src/src/unrrdu/flotsam.c
--- teem-1.11.0-src.orig/src/unrrdu/flotsam.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/flotsam.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -48,7 +48,154 @@
 };
 
 /*
-******** unrrduUsageSpecial
+******** unrrduCmdMain
+**
+** A "main" function for unu-like programs, which is very similar to
+** teem/src/bin/unu.c:main(), and
+** teem/src/bin/tend.c:main(), and
+** teem/src/limn/test/lpu.c:main().
+** With more time (and a major Teem release), this function may change,
+** and those programs may use this.
+**
+** A sneaky but basic issue is the const-correctness of how the hestParm
+** is used; we'd like to take a const hestParm* to communicate parameters
+** the caller has set, but the show-stopper is that unrrduCmd->main()
+** takes a non-const hestParm, and it has to be that way, because some
+** unu commands alter the given hparm (which probably shouldn't happen).
+** Until that's fixed, we have a non-const hestParm* coming in here.
+*/
+int
+unrrduCmdMain(int argc, const char **argv,
+              const char *cmd, const char *title,
+              const unrrduCmd *const *cmdList,
+              hestParm *_hparm, FILE *fusage) {
+  int i, ret;
+  const char *me;
+  char *argv0 = NULL;
+  hestParm *hparm;
+  airArray *mop;
+
+  me = argv[0];
+
+  /* parse environment variables first, in case they break nrrdDefault*
+     or nrrdState* variables in a way that nrrdSanity() should see */
+  nrrdDefaultGetenv();
+  nrrdStateGetenv();
+
+  /* unu does some unu-specific environment-variable handling here */
+
+  nrrdSanityOrDie(me);
+
+  mop = airMopNew();
+  if (_hparm) {
+    hparm = _hparm;
+  } else {
+    hparm = hestParmNew();
+    airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);
+    hparm->elideSingleEnumType = AIR_TRUE;
+    hparm->elideSingleOtherType = AIR_TRUE;
+    hparm->elideSingleOtherDefault = AIR_FALSE;
+    hparm->elideSingleNonExistFloatDefault = AIR_TRUE;
+    hparm->elideMultipleNonExistFloatDefault = AIR_TRUE;
+    hparm->elideSingleEmptyStringDefault = AIR_TRUE;
+    hparm->elideMultipleEmptyStringDefault = AIR_TRUE;
+    hparm->cleverPluralizeOtherY = AIR_TRUE;
+    /* learning columns from current window; if ioctl is available
+    if (1) {
+      struct winsize ws;
+      ioctl(1, TIOCGWINSZ, &ws);
+      hparm->columns = ws.ws_col - 1;
+    }
+    */
+    hparm->columns = 78;
+  }
+
+  /* if there are no arguments, then we give general usage information */
+  if (1 >= argc) {
+    /* this is like unrrduUsageUnu() */
+    unsigned int ii, maxlen = 0;
+    char *buff, *fmt, tdash[] = "--- %s ---";
+    for (ii=0; cmdList[ii]; ii++) {
+      if (cmdList[ii]->hidden) {
+        continue;
+      }
+      maxlen = AIR_MAX(maxlen, AIR_UINT(strlen(cmdList[ii]->name)));
+    }
+    if (!maxlen) {
+      fprintf(fusage, "%s: problem: maxlen = %u\n", me, maxlen);
+      airMopError(mop); return 1;
+    }
+    buff = AIR_CALLOC(strlen(tdash) + strlen(title) + 1, char);
+    airMopAdd(mop, buff, airFree, airMopAlways);
+    sprintf(buff, tdash, title);
+    fmt = AIR_CALLOC(hparm->columns + strlen(buff) + 1, char); /* generous */
+    airMopAdd(mop, buff, airFree, airMopAlways);
+    sprintf(fmt, "%%%us\n",
+            AIR_UINT((hparm->columns-strlen(buff))/2 + strlen(buff) - 1));
+    fprintf(fusage, fmt, buff);
+
+    for (ii=0; cmdList[ii]; ii++) {
+      unsigned int cc, len;
+      if (cmdList[ii]->hidden) {
+        continue;
+      }
+      len = AIR_UINT(strlen(cmdList[ii]->name));
+      strcpy(buff, "");
+      for (cc=len; cc<maxlen; cc++)
+        strcat(buff, " ");
+      strcat(buff, cmd);
+      strcat(buff, " ");
+      strcat(buff, cmdList[ii]->name);
+      strcat(buff, " ... ");
+      len = AIR_UINT(strlen(buff));
+      fprintf(fusage, "%s", buff);
+      _hestPrintStr(fusage, len, len, hparm->columns,
+                    cmdList[ii]->info, AIR_FALSE);
+    }
+    airMopError(mop);
+    return 1;
+  }
+  /* else, we see if its --version */
+  if (!strcmp("--version", argv[1])) {
+    char vbuff[AIR_STRLEN_LARGE];
+    airTeemVersionSprint(vbuff);
+    printf("%s\n", vbuff);
+    exit(0);
+  }
+  /* else, we should see if they're asking for a command we know about */
+  for (i=0; cmdList[i]; i++) {
+    if (!strcmp(argv[1], cmdList[i]->name)) {
+      break;
+    }
+    /* if user typed "prog --help" we treat it as "prog about",
+       but only if there is an "about" command */
+    if (!strcmp("--help", argv[1])
+        && !strcmp("about", cmdList[i]->name)) {
+      break;
+    }
+  }
+  if (cmdList[i]) {
+    /* yes, we have that command */
+    /* initialize variables used by the various commands */
+    argv0 = AIR_CALLOC(strlen(cmd) + strlen(argv[1]) + 2, char);
+
+    airMopMem(mop, &argv0, airMopAlways);
+    sprintf(argv0, "%s %s", cmd, argv[1]);
+
+    /* run the individual command, saving its exit status */
+    ret = cmdList[i]->main(argc-2, argv+2, argv0, hparm);
+  } else {
+    fprintf(stderr, "%s: unrecognized command: \"%s\"; type \"%s\" for "
+            "complete list\n", cmd /* not me==argv[0] */, argv[1], me);
+    ret = 1;
+  }
+
+  airMopDone(mop, ret);
+  return ret;
+}
+
+/*
+******** unrrduUsageUnu
 **
 ** prints out a little banner, and a listing of all available commands
 ** with their one-line descriptions
@@ -179,7 +326,7 @@
 ** pos[0] == -1: pos[1] gives the position relative to a "minimum" position
 */
 int
-unrrduParsePos(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+unrrduParsePos(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   char me[]="unrrduParsePos";
   long int *pos;
 
@@ -259,7 +406,7 @@
 ** value as nrrdTypeDefault.
 */
 int
-unrrduParseMaybeType(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+unrrduParseMaybeType(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   char me[]="unrrduParseMaybeType";
   int *typeP;
 
@@ -301,7 +448,7 @@
 ** for parsing an int that can be 8, 16, or 32
 */
 int
-unrrduParseBits(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+unrrduParseBits(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   char me[]="unrrduParseBits";
   unsigned int *bitsP;
 
@@ -346,9 +493,10 @@
 ** +=<uint>  : unrrduScaleAdd
 ** -=<uint>  : unrrduScaleSubstract
 ** <uint>    : unrrduScaleExact
+** s<float>  : unrrduScaleSpacingTarget
 */
 int
-unrrduParseScale(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+unrrduParseScale(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   char me[]="unrrduParseScale";
   double *scale;
   unsigned int num;
@@ -372,19 +520,31 @@
               me, str);
       return 1;
     }
+    if (!( scale[1] > 0 )) {
+      sprintf(err, "%s: need positive float from \"%s\" (not %g)",
+              me, str, scale[1]);
+      return 1;
+    }
     scale[0] = AIR_CAST(double, ('x' == str[0]
                                  ? unrrduScaleMultiply
                                  : unrrduScaleDivide));
   } else if (strlen(str) > 1
-             && ('x' == str[0] || '/' == str[0])) {
+             && ('x' == str[0] || '/' == str[0] || 's' == str[0])) {
     if (1 != sscanf(str+1, "%lf", scale+1)) {
-      sprintf(err, "%s: can't parse \"%s\" as x<float> or /<float>",
-              me, str);
+      sprintf(err, "%s: can't parse \"%s\" as x<float>, /<float>, "
+              "or s<float>", me, str);
+      return 1;
+    }
+    if (!( scale[1] > 0 )) {
+      sprintf(err, "%s: need positive float from \"%s\" (not %g)",
+              me, str, scale[1]);
       return 1;
     }
     scale[0] = AIR_CAST(double, ('x' == str[0]
                                  ? unrrduScaleMultiply
-                                 : unrrduScaleDivide));
+                                 : ('/' == str[0]
+                                    ? unrrduScaleDivide
+                                    : unrrduScaleSpacingTarget)));
   } else if (strlen(str) > 2
              && ('+' == str[0] || '-' == str[0])
              && '=' == str[1]) {
@@ -438,7 +598,7 @@
 }
 
 int
-unrrduParseFile(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {
+unrrduParseFile(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
   char me[]="unrrduParseFile";
   FILE **fileP;
 
@@ -475,7 +635,7 @@
 ** enc[2]: for zlib: strategy, from nrrdZlibStrategy* enum
 */
 int
-unrrduParseEncoding(void *ptr, char *_str, char err[AIR_STRLEN_HUGE]) {
+unrrduParseEncoding(void *ptr, const char *_str, char err[AIR_STRLEN_HUGE]) {
   char me[]="unrrduParseEncoding", *str, *opt;
   int *enc;
   airArray *mop;
@@ -543,3 +703,52 @@
   NULL
 };
 
+/* --------------------------------------------------------- */
+/* --------------------------------------------------------- */
+/* --------------------------------------------------------- */
+
+/*
+******** unrrduHestFormatCB
+**
+** for parsing output format
+** enc[0]: which format, from nrrdFormatType* enum
+** enc[1]: for nrrdFormatText: bool for whether to enforce plain "bare" text
+**         as indicated by one of: btext, ptext, baretext, plaintext
+*/
+int
+unrrduParseFormat(void *ptr, const char *str, char err[AIR_STRLEN_HUGE]) {
+  char me[]="unrrduParseFormat";
+  int *enc;
+
+  if (!(ptr && str)) {
+    sprintf(err, "%s: got NULL pointer", me);
+    return 1;
+  }
+  enc = (int *)ptr;
+  /* these are the defaults, they may not get over-written */
+  enc[1] = 0;
+
+  enc[0] = airEnumVal(nrrdFormatType, str);
+  if (nrrdFormatTypeUnknown != enc[0]) {
+    /* we're done; given format was exactly a standard format */
+    return 0;
+  }
+  /* else given format was non-standard */
+  if (!strcmp("ptext", str) || !strcmp("plaintext", str)
+      || !strcmp("btext", str) || !strcmp("baretext", str)) {
+    enc[0] = nrrdFormatTypeText;
+    enc[1] = AIR_TRUE;
+  } else {
+    sprintf(err, "%s: format \"%s\" not a %s or recognized alternate",
+            me, str, nrrdFormatType->name);
+    return 1;
+  }
+  return 0;
+}
+
+hestCB unrrduHestFormatCB = {
+  2*sizeof(int),
+  "format",
+  unrrduParseFormat,
+  NULL
+};
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/gamma.c teem-1.11.0-src/src/unrrdu/gamma.c
--- teem-1.11.0-src.orig/src/unrrdu/gamma.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/gamma.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -29,8 +29,9 @@
 (INFO
  ". Just as in xv, the gamma value here is actually the "
  "reciprocal of the exponent actually used to transform "
- "the values.\n "
- "* Uses nrrdArithGamma");
+ "the values. Can also do the non-linear transforms used "
+ "in the sRGB standard (see https://en.wikipedia.org/wiki/SRGB)\n "
+ "* Uses nrrdArithGamma or nrrdArithGammaSRGB");
 
 int
 unrrdu_gammaMain(int argc, const char **argv, const char *me,
@@ -38,14 +39,17 @@
   hestOpt *opt = NULL;
   char *out, *err;
   Nrrd *nin, *nout;
-  double min, max, gamma;
+  char *GammaS;
+  double min, max, Gamma;
   airArray *mop;
-  int pret, blind8BitRange;
+  int pret, blind8BitRange, srgb, forward, E;
   NrrdRange *range;
 
-  hestOptAdd(&opt, "g,gamma", "gamma", airTypeDouble, 1, 1, &gamma, NULL,
+  hestOptAdd(&opt, "g,gamma", "gamma", airTypeString, 1, 1, &GammaS, NULL,
              "gamma > 1.0 brightens; gamma < 1.0 darkens. "
-             "Negative gammas invert values (like in xv). ");
+             "Negative gammas invert values (like in xv). "
+             "Or, can used \"srgb\" for ~2.2 gamma of sRGB encoding, or "
+             "\"1/srgb\" for ~0.455 gamma of inverse sRGB encoding");
   hestOptAdd(&opt, "min,minimum", "value", airTypeDouble, 1, 1, &min, "nan",
              "Value to implicitly map to 0.0 prior to calling pow(). "
              "Defaults to lowest value found in input nrrd.");
@@ -66,19 +70,39 @@
   PARSE();
   airMopAdd(mop, opt, (airMopper)hestParseFree, airMopAlways);
 
+  if (!strcmp(GammaS, "srgb")) {
+    srgb = AIR_TRUE;
+    forward = AIR_TRUE;
+  } else if (!strcmp(GammaS, "1/srgb")) {
+    srgb = AIR_TRUE;
+    forward = AIR_FALSE;
+  } else {
+    srgb = AIR_FALSE;
+    forward = AIR_FALSE;
+    if (1 != airSingleSscanf(GammaS, "%lf", &Gamma)) {
+      fprintf(stderr, "%s: couldn't parse gamma \"%s\" as double, and wasn't either "
+              "\"srgb\" or \"1/srgb\"\n", me, GammaS);
+      airMopError(mop);
+      return 1;
+    }
+  }
   nout = nrrdNew();
   airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
 
   range = nrrdRangeNew(min, max);
   airMopAdd(mop, range, (airMopper)nrrdRangeNix, airMopAlways);
   nrrdRangeSafeSet(range, nin, blind8BitRange);
-  if (nrrdArithGamma(nout, nin, range, gamma)) {
+  if (srgb) {
+    E =nrrdArithSRGBGamma(nout, nin, range, forward);
+  } else {
+    E =nrrdArithGamma(nout, nin, range, Gamma);
+  }
+  if (E) {
     airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
     fprintf(stderr, "%s: error doing gamma:\n%s", me, err);
     airMopError(mop);
     return 1;
   }
-
   SAVE(out, nout, NULL);
 
   airMopOkay(mop);
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/GNUmakefile teem-1.11.0-src/src/unrrdu/GNUmakefile
--- teem-1.11.0-src.orig/src/unrrdu/GNUmakefile	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/GNUmakefile	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images             .
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -62,7 +62,7 @@
 	inset.o axinsert.o axdelete.o axinfo.o ccfind.o ccadj.o ccmerge.o \
 	ccsettle.o about.o axsplit.o axmerge.o mlut.o mrmap.o tile.o untile.o \
 	unorient.o env.o dist.o affine.o i2w.o w2i.o fft.o acrop.o dering.o \
-	diff.o cksum.o dnorm.o vidicon.o
+	diff.o cksum.o dnorm.o vidicon.o undos.o basinfo.o grid.o hack.o aabplot.o
 ####
 ####
 ####
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/grid.c teem-1.11.0-src/src/unrrdu/grid.c
--- teem-1.11.0-src.orig/src/unrrdu/grid.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/grid.c	2021-02-18 15:42:36.000000000 +0800
@@ -0,0 +1,206 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "unrrdu.h"
+#include "privateUnrrdu.h"
+
+static int
+gridGen(Nrrd *nout, int typeOut, const Nrrd *nin, int psz, int psg) {
+  static const char me[]="gridGen";
+  size_t II, NN, size[NRRD_DIM_MAX], osz[NRRD_DIM_MAX], coord[NRRD_DIM_MAX];
+  double loc[NRRD_SPACE_DIM_MAX],
+    sdir[NRRD_DIM_MAX][NRRD_SPACE_DIM_MAX],
+    (*ins)(void *v, size_t I, double d);
+  unsigned int axi, dim, sdim, base, oxi=0;
+  void *out;
+
+  if (nrrdTypeBlock == typeOut) {
+    biffAddf(UNRRDU, "%s: can't use type %s", me,
+             airEnumStr(nrrdType, nrrdTypeBlock));
+    return 1;
+  }
+  if (!(nin->spaceDim)) {
+    biffAddf(UNRRDU, "%s: can currently only work on arrays "
+             "with space directions and space origin", me);
+    return 1;
+  }
+  dim = nin->dim;
+  sdim = nin->spaceDim;
+  if (!nrrdSpaceVecExists(sdim, nin->spaceOrigin)) {
+    biffAddf(UNRRDU, "%s: space origin didn't exist", me);
+    return 1;
+  }
+  if (!( sdim <= dim )) {
+    biffAddf(UNRRDU, "%s: sorry, can't currently handle space dimension %u "
+             "> dimension %u", me, sdim, dim);
+    return 1;
+  }
+  base = dim - sdim;
+  NN = 1;
+  nrrdAxisInfoGet_nva(nin, nrrdAxisInfoSize, size);
+  nrrdAxisInfoGet_nva(nin, nrrdAxisInfoSpaceDirection, sdir);
+  if (psg) {
+    osz[0] = 1+sdim;
+    osz[1] = 1+sdim;
+  } else {
+    osz[oxi++] = sdim;
+  }
+  for (axi=base; axi<dim; axi++) {
+    if (!nrrdSpaceVecExists(sdim, sdir[axi])) {
+      biffAddf(UNRRDU, "%s: axis %u space dir didn't exist", me, axi);
+      return 1;
+    }
+    NN *= size[axi];
+    if (!psg && psz) {
+      osz[oxi++] = size[axi];
+    }
+  }
+  if (!psg && !psz) {
+    osz[1] = NN;
+  }
+  ins = nrrdDInsert[typeOut];
+
+  if (nrrdMaybeAlloc_nva(nout, typeOut, psz ? oxi : 2, osz)) {
+    biffMovef(UNRRDU, NRRD, "%s: couldn't allocate output", me);
+    return 1;
+  }
+  out = AIR_VOIDP(nout->data);
+  if (psg) {
+    unsigned int jj;
+    ins(out, 0, sdim);
+    nrrdSpaceVecCopy(loc, nin->spaceOrigin);
+    for (jj=0; jj<sdim; jj++) {
+      ins(out, 1 + jj, loc[jj]);
+    }
+    for (axi=base; axi<dim; axi++) {
+      unsigned int oi = (1+sdim)*(1+axi-base);
+      ins(out, oi, size[axi]);
+      for (jj=0; jj<sdim; jj++) {
+        ins(out, oi+1+jj, sdir[axi][jj]);
+      }
+    }
+  } else {
+    for (axi=0; axi<dim; axi++) {
+      coord[axi] = 0;
+    }
+    for (II=0; II<NN; II++) {
+      nrrdSpaceVecCopy(loc, nin->spaceOrigin);
+      for (axi=base; axi<dim; axi++) {
+        nrrdSpaceVecScaleAdd2(loc, 1, loc, coord[axi], sdir[axi]);
+      }
+      /*
+      fprintf(stderr, "!%s: (%u) %u %u %u: %g %g\n", me,
+              AIR_UINT(II),
+              AIR_UINT(coord[0]),
+              AIR_UINT(coord[1]),
+              AIR_UINT(coord[2]),
+              loc[0], loc[1]);
+      */
+      for (axi=0; axi<sdim; axi++) {
+        ins(out, axi + sdim*II, loc[axi]);
+      }
+      NRRD_COORD_INCR(coord, size, dim, base);
+    }
+  }
+  return 0;
+}
+
+#define INFO "Describe image sample locations"
+static const char *_unrrdu_gridInfoL =
+(INFO ". For a N-D grid, the output is (by default) "
+ "a 2-D M-by-S array of grid sample "
+ "locations, where M is the space dimension of the oriented grid, and S "
+ "is the total number of real samples in the grid. "
+ "With the -ps option, the shape of input axes is better preserved. "
+ "With the -pg option, the output is a 2-D array that specifies the "
+ "sampling grid, in the format used by gprobe. Unfortunately the "
+ "implementation is currently incomplete, because of a number of "
+ "unresolved design questions (one limitation is that this can't "
+ "handle a 2D slice of a vector field: dimension == space dimension "
+ "but axis 0 is not spatial).\n "
+ "* (not based on any particular nrrd function)");
+
+int
+unrrdu_gridMain(int argc, const char **argv, const char *me,
+                   hestParm *hparm) {
+  hestOpt *opt = NULL;
+  char *outS, *err;
+  int pret;
+  airArray *mop;
+  char *inS;
+
+  Nrrd *nin, *nout;
+  int typeOut, psz, psg;
+  NrrdIoState *nio;
+
+  hestOptAdd(&opt, "i,input", "nin", airTypeString, 1, 1, &inS, NULL,
+             "input nrrd.  That this argument is required instead of "
+             "optional, as with most unu commands, is a quirk caused by the "
+             "need to have \"unu grid\" generate usage info, combined "
+             "with the fact that the other arguments have sensible "
+             "defaults");
+  hestOptAdd(&opt, "ps", NULL, airTypeInt, 0, 0, &psz, NULL,
+             "instead of the default behavior of flattening all but the "
+             "fastest axis, preserve the sizes of axes, so that the output "
+             "is more like that of the input");
+  hestOptAdd(&opt, "pg", NULL, airTypeInt, 0, 0, &psg, NULL,
+             "(overrides -ps) generate a 2D array that represents "
+             "the sampling grid in the way that \"gprobe -pg\" understands");
+  OPT_ADD_TYPE(typeOut, "type of output", "double");
+  OPT_ADD_NOUT(outS, "output nrrd");
+
+  mop = airMopNew();
+  airMopAdd(mop, opt, (airMopper)hestOptFree, airMopAlways);
+
+  USAGE(_unrrdu_gridInfoL);
+  PARSE();
+  airMopAdd(mop, opt, (airMopper)hestParseFree, airMopAlways);
+
+  nio = nrrdIoStateNew();
+  airMopAdd(mop, nio, (airMopper)nrrdIoStateNix, airMopAlways);
+  nin = nrrdNew();
+  airMopAdd(mop, nin, (airMopper)nrrdNuke /* but Nix enough */, airMopAlways);
+  nio->skipData = AIR_TRUE;
+  if (nrrdLoad(nin, inS, nio)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error reading input:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+  nout = nrrdNew();
+  airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
+
+  if (gridGen(nout, typeOut, nin, psz, psg)) {
+    airMopAdd(mop, err = biffGetDone(UNRRDU), airFree, airMopAlways);
+    fprintf(stderr, "%s: error generating output:\n%s", me, err);
+    airMopError(mop);
+    return 1;
+  }
+
+  SAVE(outS, nout, NULL);
+
+  airMopOkay(mop);
+  return 0;
+}
+
+UNRRDU_CMD(grid, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/hack.c teem-1.11.0-src/src/unrrdu/hack.c
--- teem-1.11.0-src.orig/src/unrrdu/hack.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/hack.c	2021-02-18 15:42:37.000000000 +0800
@@ -0,0 +1,94 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "unrrdu.h"
+#include "privateUnrrdu.h"
+
+#define INFO "a hack of some kind"
+static const char *_unrrdu_hackInfoL =
+(INFO ". This is used as a place to put whatever one-off code "
+ "you want to try, with the whatever benefits come with being a "
+ "unu command.\n "
+ "* (not based on any particular nrrd function)");
+
+int
+unrrdu_hackMain(int argc, const char **argv, const char *me,
+                hestParm *hparm) {
+  hestOpt *opt = NULL;
+  char *out, *err;
+  Nrrd *nin, *nout;
+  int pret;
+  airArray *mop;
+
+  char *what;
+
+  hestOptAdd(&opt, NULL, "what", airTypeString, 1, 1, &what, NULL,
+             "what hack to do");
+  OPT_ADD_NIN(nin, "input nrrd");
+  OPT_ADD_NOUT(out, "output nrrd");
+
+  mop = airMopNew();
+  airMopAdd(mop, opt, (airMopper)hestOptFree, airMopAlways);
+
+  USAGE(_unrrdu_hackInfoL);
+  PARSE();
+  airMopAdd(mop, opt, (airMopper)hestParseFree, airMopAlways);
+
+  nout = nrrdNew();
+  airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
+
+  if (!strcmp(what, "sdincr")) {
+    unsigned int sdim, axi;
+    sdim = nin->spaceDim;
+    if (!sdim) {
+      fprintf(stderr, "%s: need non-zero space dimension", me);
+      airMopError(mop);
+      return 1;
+    }
+    if (nrrdCopy(nout, nin)) {
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: error converting nrrd:\n%s", me, err);
+      airMopError(mop);
+      return 1;
+    }
+    nout->spaceDim = sdim + 1;
+    nout->space = nrrdSpaceUnknown;
+    nout->spaceOrigin[sdim] = 0.0;
+    for (axi=0; axi<nout->dim; axi++) {
+      if (nrrdSpaceVecExists(sdim, nout->axis[axi].spaceDirection)) {
+        nout->axis[axi].spaceDirection[sdim] = 0.0;
+      }
+    }
+  } else {
+    fprintf(stderr, "%s: no \"%s\" hack implemented", me, what);
+    airMopError(mop);
+    return 1;
+  }
+
+  SAVE(out, nout, NULL);
+
+  airMopOkay(mop);
+  return 0;
+}
+
+UNRRDU_CMD_HIDE(hack, INFO);
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/head.c teem-1.11.0-src/src/unrrdu/head.c
--- teem-1.11.0-src.orig/src/unrrdu/head.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/head.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/heq.c teem-1.11.0-src/src/unrrdu/heq.c
--- teem-1.11.0-src.orig/src/unrrdu/heq.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/heq.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/histax.c teem-1.11.0-src/src/unrrdu/histax.c
--- teem-1.11.0-src.orig/src/unrrdu/histax.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/histax.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/histo.c teem-1.11.0-src/src/unrrdu/histo.c
--- teem-1.11.0-src.orig/src/unrrdu/histo.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/histo.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/i2w.c teem-1.11.0-src/src/unrrdu/i2w.c
--- teem-1.11.0-src.orig/src/unrrdu/i2w.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/i2w.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/imap.c teem-1.11.0-src/src/unrrdu/imap.c
--- teem-1.11.0-src.orig/src/unrrdu/imap.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/imap.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/inset.c teem-1.11.0-src/src/unrrdu/inset.c
--- teem-1.11.0-src.orig/src/unrrdu/inset.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/inset.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/jhisto.c teem-1.11.0-src/src/unrrdu/jhisto.c
--- teem-1.11.0-src.orig/src/unrrdu/jhisto.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/jhisto.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -100,8 +100,8 @@
     if (asize != binLen) {
       fprintf(stderr,
               "%s: size (%u) of slice axis %u != # bins given (%u)\n", me,
-              AIR_CAST(unsigned int, asize), diceax,
-              AIR_CAST(unsigned int, binLen));
+              AIR_UINT(asize), diceax,
+              AIR_UINT(binLen));
       airMopError(mop);
       return 1;
     }
@@ -131,7 +131,7 @@
     if (ninLen != binLen) {
       fprintf(stderr,
               "%s: # input nrrds (%u) != # bin specifications (%u)\n", me,
-              AIR_CAST(unsigned int, ninLen), AIR_CAST(unsigned int, binLen));
+              AIR_UINT(ninLen), AIR_UINT(binLen));
       airMopError(mop);
       return 1;
     }
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/join.c teem-1.11.0-src/src/unrrdu/join.c
--- teem-1.11.0-src.orig/src/unrrdu/join.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/join.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -43,10 +43,10 @@
 unrrdu_joinMain(int argc, const char **argv, const char *me,
                 hestParm *hparm) {
   hestOpt *opt = NULL;
-  char *out, *err, *label;
+  char *out, *err, *label, *kindStr;
   Nrrd **nin;
   Nrrd *nout;
-  int incrDim, pret;
+  int incrDim, pret, kind;
   unsigned int ninLen, axis;
   double mm[2], spc;
   airArray *mop;
@@ -65,6 +65,9 @@
              "nrrds are joined side-by-side, along an existing axis.");
   hestOptAdd(&opt, "l,label", "label", airTypeString, 1, 1, &label, "",
              "label to associate with join axis");
+  hestOptAdd(&opt, "k,kind", "kind", airTypeString, 1, 1, &kindStr, "",
+             "kind to set on join axis. "
+             "Not using this option leaves the kind as is");
   hestOptAdd(&opt, "mm,minmax", "min max", airTypeDouble, 2, 2, mm, "nan nan",
              "min and max values along join axis");
   hestOptAdd(&opt, "sp,spacing", "spc", airTypeDouble, 1, 1, &spc, "nan",
@@ -92,6 +95,20 @@
     nout->axis[axis].label = (char *)airFree(nout->axis[axis].label);
     nout->axis[axis].label = airStrdup(label);
   }
+  if (airStrlen(kindStr)) {
+    if (!strcmp("none", kindStr)
+        || !strcmp("???", kindStr)) {
+      kind = nrrdKindUnknown;
+    } else {
+      if (!(kind = airEnumVal(nrrdKind, kindStr))) {
+        fprintf(stderr, "%s: couldn't parse \"%s\" as %s\n", me,
+                kindStr, nrrdKind->name);
+        airMopError(mop);
+        return 1;
+      }
+    }
+    nout->axis[axis].kind = kind;
+  }
   if (AIR_EXISTS(mm[0])) {
     nout->axis[axis].min = mm[0];
   }
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/lut2.c teem-1.11.0-src/src/unrrdu/lut2.c
--- teem-1.11.0-src.orig/src/unrrdu/lut2.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/lut2.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/lut.c teem-1.11.0-src/src/unrrdu/lut.c
--- teem-1.11.0-src.orig/src/unrrdu/lut.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/lut.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/make.c teem-1.11.0-src/src/unrrdu/make.c
--- teem-1.11.0-src.orig/src/unrrdu/make.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/make.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -74,13 +74,13 @@
   Nrrd *nrrd;
   size_t *size, bufLen;
   int headerOnly, pret, lineSkip, endian, type,
-    encodingType, gotSpacing, gotThickness, space,
+    encodingType, gotSpacing, gotThickness, gotMin, gotMax, space,
     spaceSet;
   long int byteSkip;
   unsigned int ii, kindsLen, thicknessLen, spacingLen, sizeLen, nameLen,
     centeringsLen, unitsLen, labelLen, kvpLen, spunitsLen, dataFileDim,
-    spaceDim;
-  double *spacing, *thickness;
+      spaceDim, minLen, maxLen, thicknessIdx, spacingIdx, minIdx, maxIdx;
+  double *spacing, *axmin, *axmax, *thickness;
   airArray *mop;
   NrrdIoState *nio;
   FILE *fileOut;
@@ -119,15 +119,33 @@
              "the dimension of the array data in each individual file. By "
              "default (not using this option), this dimension is assumed "
              "to be one less than the whole data dimension. ");
+  spacingIdx =
   hestOptAdd(&opt, "sp,spacing", "sp0 sp1", airTypeDouble, 1, -1,
              &spacing, "nan",
              "spacing between samples on each axis.  Use \"nan\" for "
              "any non-spatial axes (e.g. spacing between red, green, and blue "
              "along axis 0 of interleaved RGB image data)", &spacingLen);
+  /* NB: these are like unu jhisto's -min -max, not like unu crop's */
+  minIdx =
+  hestOptAdd(&opt, "min,axismin", "min0 min1", airTypeDouble, 1, -1,
+             &axmin, "nan",
+             "When each axis has a distinct meaning (as in a joint "
+             "histogram), the per-axis min is the smallest \"position\" "
+             "associated with the first sample on the axis. Use \"nan\" for "
+             "\"no value to set\" when other axes do have axis min",
+             &minLen);
+  maxIdx =
+  hestOptAdd(&opt, "max,axismax", "max0 max1", airTypeDouble, 1, -1,
+             &axmax, "nan",
+             "Goes with -min: the per-axis maximum \"position\". "
+             "-max and -min should probably be used together, and having "
+             "this information logically supersedes the -sp spacing on those "
+             "axes.", &maxLen);
+  thicknessIdx =
   hestOptAdd(&opt, "th,thickness", "th0 th1", airTypeDouble, 1, -1,
              &thickness, "nan",
              "thickness of region represented by one sample along each axis. "
-             "  As with spacing, use \"nan\" for "
+             "  As with -sp spacing, use \"nan\" for "
              "any non-spatial axes.", &thicknessLen);
   hestOptAdd(&opt, "k,kind", "k0 k1", airTypeString, 1, -1, &kinds, "",
              "what \"kind\" is each axis, from the nrrdKind airEnum "
@@ -186,7 +204,8 @@
              "identify the space (e.g. \"RAS\", \"LPS\") in which the array "
              "conceptually lives, from the nrrdSpace airEnum, which in turn "
              "determines the dimension of the space.  Or, use an integer>0 to"
-             "give the dimension of a space that nrrdSpace doesn't know about. "
+             "give the dimension of a space that nrrdSpace doesn't know "
+             "about. "
              "By default (not using this option), the enclosing space is "
              "set as unknown.");
   hestOptAdd(&opt, "orig,origin", "origin", airTypeString, 1, 1, &_origStr, "",
@@ -201,7 +220,9 @@
              "the vectors in space spanned by incrementing (by one) each "
              "axis index (the column vectors of the index-to-world "
              "matrix transform), OR, \"none\" for non-spatial axes. Give "
-             "one vector per axis. (Quoting around whole vector list, not "
+             "one vector per axis. Using a space direction logically "
+             "supersedes both per-axis -sp spacing and -min,-max. "
+             "(Quoting around whole vector list, not "
              "individually, is needed because of limitations in the parser)");
   hestOptAdd(&opt, "mf,measurementframe", "v0 v1 ...", airTypeString, 1, 1,
              &_mframeStr, "",
@@ -255,48 +276,62 @@
     airMopError(mop);
     return 1;
   }
-  gotSpacing = (spacingLen > 1 ||
-                (sizeLen == 1 && AIR_EXISTS(spacing[0])));
+  gotSpacing = (opt[spacingIdx].source == hestSourceUser);
   if (gotSpacing && spacingLen != sizeLen) {
     fprintf(stderr,
-            "%s: number of spacings (%d) not same as dimension (%d)\n",
+            "%s: number of spacings (%u) not same as dimension (%u)\n",
             me, spacingLen, sizeLen);
     airMopError(mop);
     return 1;
   }
-  gotThickness = (thicknessLen > 1 ||
-                  (sizeLen == 1 && AIR_EXISTS(thickness[0])));
+  gotThickness = (opt[thicknessIdx].source == hestSourceUser);
   if (gotThickness && thicknessLen != sizeLen) {
     fprintf(stderr,
-            "%s: number of thicknesses (%d) not same as dimension (%d)\n",
+            "%s: number of thicknesses (%u) not same as dimension (%u)\n",
             me, thicknessLen, sizeLen);
     airMopError(mop);
     return 1;
   }
+  gotMin = (opt[minIdx].source == hestSourceUser);
+  if (gotMin && minLen != sizeLen) {
+    fprintf(stderr,
+            "%s: number of mins (%u) not same as dimension (%u)\n",
+            me, minLen, sizeLen);
+    airMopError(mop);
+    return 1;
+  }
+  gotMax = (opt[maxIdx].source == hestSourceUser);
+  if (gotMax && maxLen != sizeLen) {
+    fprintf(stderr,
+            "%s: number of maxs (%u) not same as dimension (%u)\n",
+            me, maxLen, sizeLen);
+    airMopError(mop);
+    return 1;
+  }
   if (airStrlen(label[0]) && sizeLen != labelLen) {
     fprintf(stderr,
-            "%s: number of labels (%d) not same as dimension (%d)\n",
+            "%s: number of labels (%u) not same as dimension (%u)\n",
             me, labelLen, sizeLen);
     airMopError(mop);
     return 1;
   }
   if (airStrlen(units[0]) && sizeLen != unitsLen) {
     fprintf(stderr,
-            "%s: number of units (%d) not same as dimension (%d)\n",
+            "%s: number of units (%u) not same as dimension (%u)\n",
             me, unitsLen, sizeLen);
     airMopError(mop);
     return 1;
   }
   if (airStrlen(kinds[0]) && sizeLen != kindsLen) {
     fprintf(stderr,
-            "%s: number of kinds (%d) not same as dimension (%d)\n",
+            "%s: number of kinds (%u) not same as dimension (%u)\n",
             me, kindsLen, sizeLen);
     airMopError(mop);
     return 1;
   }
   if (airStrlen(centerings[0]) && sizeLen != centeringsLen) {
     fprintf(stderr,
-            "%s: number of centerings (%d) not same as dimension (%d)\n",
+            "%s: number of centerings (%u) not same as dimension (%u)\n",
             me, centeringsLen, sizeLen);
     airMopError(mop);
     return 1;
@@ -371,6 +406,12 @@
   if (gotThickness) {
     nrrdAxisInfoSet_nva(nrrd, nrrdAxisInfoThickness, thickness);
   }
+  if (gotMin) {
+    nrrdAxisInfoSet_nva(nrrd, nrrdAxisInfoMin, axmin);
+  }
+  if (gotMax) {
+    nrrdAxisInfoSet_nva(nrrd, nrrdAxisInfoMax, axmax);
+  }
   if (airStrlen(label[0])) {
     for (ii=0; ii<nrrd->dim; ii++) {
       if (!strcmp(NO_STRING, label[ii])) {
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/minmax.c teem-1.11.0-src/src/unrrdu/minmax.c
--- teem-1.11.0-src.orig/src/unrrdu/minmax.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/minmax.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -48,8 +48,12 @@
   airMopAdd(mop, range, (airMopper)nrrdRangeNix, airMopAlways);
   airSinglePrintf(fout, NULL, "min: %.17g\n", range->min);
   airSinglePrintf(fout, NULL, "max: %.17g\n", range->max);
-  if (0 == range->min && 0 == range->max) {
-    fprintf(fout, "# min == max == 0.0 exactly\n");
+  if (range->min == range->max) {
+    if (0 == range->min) {
+      fprintf(fout, "# min == max == 0.0 exactly\n");
+    } else {
+      fprintf(fout, "# min == max\n");
+    }
   }
   if (range->hasNonExist) {
     fprintf(fout, "# has non-existent values\n");
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/mlut.c teem-1.11.0-src/src/unrrdu/mlut.c
--- teem-1.11.0-src.orig/src/unrrdu/mlut.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/mlut.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/mrmap.c teem-1.11.0-src/src/unrrdu/mrmap.c
--- teem-1.11.0-src.orig/src/unrrdu/mrmap.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/mrmap.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/pad.c teem-1.11.0-src/src/unrrdu/pad.c
--- teem-1.11.0-src.orig/src/unrrdu/pad.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/pad.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/permute.c teem-1.11.0-src/src/unrrdu/permute.c
--- teem-1.11.0-src.orig/src/unrrdu/permute.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/permute.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/privateUnrrdu.h teem-1.11.0-src/src/unrrdu/privateUnrrdu.h
--- teem-1.11.0-src.orig/src/unrrdu/privateUnrrdu.h	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/privateUnrrdu.h	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/project.c teem-1.11.0-src/src/unrrdu/project.c
--- teem-1.11.0-src.orig/src/unrrdu/project.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/project.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -33,31 +33,40 @@
  "one less than input (except when the input is itself 1-D); "
  "the output type depends on "
  "the measure in a non-trivial way, or it can be set explicitly "
- "with the \"-t\" option.\n "
- "* Uses nrrdProject");
+ "with the \"-t\" option.  To save the overhead of multiple input data "
+ "reads if projections along different axes are needed, you can give "
+ "multiple axes to \"-a\" (and a matching number of output filenames "
+ "to \"-o\"), as well as multiple measures to \"-m\" (and possibly a "
+ "specific type to \"-t\" to permit their joining on fastest axis).\n "
+ "* Uses nrrdProject, and nrrdJoin if multiple measures");
 
 int
 unrrdu_projectMain(int argc, const char **argv, const char *me,
                    hestParm *hparm) {
   hestOpt *opt = NULL;
-  char *out, *err;
+  char **out, *err;
   Nrrd *nin, *nout;
-  unsigned int axis;
-  int measr, pret, type;
+  Nrrd **nslice;
+  unsigned int *axis, axisLen, outLen, measrLen, outIdx, measrIdx;
+  int *measr, pret, type;
   airArray *mop;
 
-  OPT_ADD_AXIS(axis, "axis to project along");
-  hestOptAdd(&opt, "m,measure", "measr", airTypeEnum, 1, 1, &measr, NULL,
+  hestOptAdd(&opt, "a,axis", "axis", airTypeUInt, 1, -1, &axis, NULL,
+             "axis or axes to project along", &axisLen);
+  hestOptAdd(&opt, "m,measure", "measr", airTypeEnum, 1, -1, &measr, NULL,
              "How to \"measure\" a scanline, by summarizing all its values "
-             "with a single scalar. " NRRD_MEASURE_DESC,
-             NULL, nrrdMeasure);
+             "with a single scalar. Multiple measures will be joined along "
+             "fastest axis if output, but you may need to set output type "
+             "explicitly via \"-t\" so that the join works. "
+             NRRD_MEASURE_DESC, &measrLen, nrrdMeasure);
   hestOptAdd(&opt, "t,type", "type", airTypeOther, 1, 1, &type, "default",
              "type to use for output. By default (not using this option), "
              "the output type is determined auto-magically",
              NULL, NULL, &unrrduHestMaybeTypeCB);
   OPT_ADD_NIN(nin, "input nrrd");
-  OPT_ADD_NOUT(out, "output nrrd");
-
+  hestOptAdd(&opt, "o,output", "nout", airTypeString, 1, -1, &out, "-",
+             "one or more output nrrd filenames. Number of names here "
+             "has to match number of axes specified.", &outLen);
   mop = airMopNew();
   airMopAdd(mop, opt, (airMopper)hestOptFree, airMopAlways);
 
@@ -65,17 +74,58 @@
   PARSE();
   airMopAdd(mop, opt, (airMopper)hestParseFree, airMopAlways);
 
-  nout = nrrdNew();
-  airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
-
-  if (nrrdProject(nout, nin, axis, measr, type)) {
-    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
-    fprintf(stderr, "%s: error projecting nrrd:\n%s", me, err);
+  if (axisLen != outLen) {
+    fprintf(stderr, "%s: got %u \"-a\" axes but %u \"-o\" outputs\n", me,
+            axisLen, outLen);
     airMopError(mop);
     return 1;
   }
 
-  SAVE(out, nout, NULL);
+  if (measrLen > 1) {
+    nslice = AIR_CALLOC(measrLen, Nrrd *);
+    airMopAdd(mop, nslice, airFree, airMopAlways);
+    for (measrIdx=0; measrIdx<measrLen; measrIdx++) {
+      nslice[measrIdx] = nrrdNew();
+      airMopAdd(mop, nslice[measrIdx], (airMopper)nrrdNuke, airMopAlways);
+    }
+  } else {
+    nslice = NULL;
+  }
+  nout = nrrdNew();
+  airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
+
+  for (outIdx=0; outIdx<outLen; outIdx++) {
+    if (measrLen > 1) {
+      /* first project into slices */
+      for (measrIdx=0; measrIdx<measrLen; measrIdx++) {
+        if (nrrdProject(nslice[measrIdx], nin, axis[outIdx],
+                        measr[measrIdx], type)) {
+          airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+          fprintf(stderr, "%s: error projecting nrrd %u/%u:\n%s",
+                  me, outIdx, measrIdx, err);
+          airMopError(mop);
+          return 1;
+        }
+      }
+      /* then join slices into output */
+      if (nrrdJoin(nout, (const Nrrd *const*)nslice, measrLen, 0, AIR_TRUE)) {
+        airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+        fprintf(stderr, "%s: error joining nrrd %u; will have to use \"-t\" "
+                "option to make sure all projections have same type:\n%s",
+                me, outIdx, err);
+        airMopError(mop);
+        return 1;
+      }
+    } else {
+      if (nrrdProject(nout, nin, axis[outIdx], measr[0], type)) {
+        airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+        fprintf(stderr, "%s: error projecting nrrd %u:\n%s", me, outIdx, err);
+        airMopError(mop);
+        return 1;
+      }
+    }
+    SAVE(out[outIdx], nout, NULL);
+  }
 
   airMopOkay(mop);
   return 0;
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/quantize.c teem-1.11.0-src/src/unrrdu/quantize.c
--- teem-1.11.0-src.orig/src/unrrdu/quantize.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/quantize.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -43,11 +43,13 @@
   hestOpt *opt = NULL;
   char *out, *err;
   Nrrd *nin, *nout;
-  char *minStr, *maxStr;
-  int pret, blind8BitRange;
-  unsigned int bits, hbins;
+  char *minStr, *maxStr, *gammaS;
+  int pret, blind8BitRange, srgb, E=0;
+  unsigned int bits, hbins, srgbIdx;
+  double gamma;
   NrrdRange *range;
   airArray *mop;
+  NrrdIoState *nio = NULL;
 
   hestOptAdd(&opt, "b,bits", "bits", airTypeOther, 1, 1, &bits, NULL,
              "Number of bits to quantize down to; determines the type "
@@ -80,6 +82,21 @@
              "\"0" NRRD_MINMAX_PERC_SUFF "\" means the highest input value is "
              "used, which is also the default "
              "behavior (same as not using this option).");
+  hestOptAdd(&opt, "g,gamma", "gamma", airTypeString, 1, 1, &gammaS, "1.0",
+             "gamma > 1.0 brightens; gamma < 1.0 darkens. "
+             "Negative gammas invert values. Or, can be the string "
+             "\"srgb\" to apply the roughly 2.2 gamma associated "
+             "with sRGB (see https://en.wikipedia.org/wiki/SRGB). ");
+  srgbIdx=  /* HEY copied from overrgb.c */
+  hestOptAdd(&opt, "srgb", "intent", airTypeEnum, 1, 1, &srgb, "none",
+             /* the default is "none" for backwards compatibility: until now
+                Teem's support of PNG hasn't handled the sRGB intent, so
+                we shouldn't start using it without being asked */
+             "If saving to PNG (when supported), how to set the rendering "
+             "intent in the sRGB chunk of the PNG file format. Can be "
+             "absolute, relative, perceptual, saturation, or none. This is "
+             "independent of using \"srgb\" as the -g gamma",
+             NULL, nrrdFormatPNGsRGBIntent);
   hestOptAdd(&opt, "hb,bins", "bins", airTypeUInt, 1, 1, &hbins, "5000",
              "number of bins in histogram of values, for determining min "
              "or max by percentiles.  This has to be large enough so that "
@@ -101,20 +118,49 @@
   PARSE();
   airMopAdd(mop, opt, (airMopper)hestParseFree, airMopAlways);
 
+  /* HEY copied from overrgb */
+  if (!( !strcmp(gammaS, "srgb") || 1 == sscanf(gammaS, "%lf", &gamma) )) {
+    fprintf(stderr, "%s: gamma \"%s\" neither \"srgb\" nor "
+            "parseable as double", me, gammaS);
+    airMopError(mop); return 1;
+  }
+
   range = nrrdRangeNew(AIR_NAN, AIR_NAN);
   airMopAdd(mop, range, (airMopper)nrrdRangeNix, airMopAlways);
   nout = nrrdNew();
   airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopAlways);
   if (nrrdRangePercentileFromStringSet(range, nin, minStr, maxStr,
-                                       hbins, blind8BitRange)
-      || nrrdQuantize(nout, nin, range, bits)) {
+                                       hbins, blind8BitRange)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error learning range:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+  if (!strcmp(gammaS, "srgb")) {
+    E = nrrdArithSRGBGamma(nin, nin, range, AIR_TRUE);
+  } else if (1 != gamma) {
+    E = nrrdArithGamma(nin, nin, range, gamma);
+  }
+  if (E) {
     airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
-    fprintf(stderr, "%s: error with range or quantizing:\n%s", me, err);
-    airMopError(mop);
-    return 1;
+    fprintf(stderr, "%s: error going gamma:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+  if (nrrdQuantize(nout, nin, range, bits)) {
+    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+    fprintf(stderr, "%s: error quantizing:\n%s", me, err);
+    airMopError(mop); return 1;
+  }
+
+  if (hestSourceUser == opt[srgbIdx].source) {
+    /* HEY copied from overrgb.c */
+    nio = nrrdIoStateNew();
+    airMopAdd(mop, nio, (airMopper)nrrdIoStateNix, airMopAlways);
+    nio->PNGsRGBIntentKnown = AIR_TRUE;
+    nio->PNGsRGBIntent = srgb; /* even if it is nrrdFormatPNGsRGBIntentNone;
+                                  that's handled by the writer */
   }
 
-  SAVE(out, nout, NULL);
+  SAVE(out, nout, nio);
 
   airMopOkay(mop);
   return 0;
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/resample.c teem-1.11.0-src/src/unrrdu/resample.c
--- teem-1.11.0-src.orig/src/unrrdu/resample.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/resample.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2020  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -51,8 +51,9 @@
   int type, bb, pret, norenorm, neb, older, E, defaultCenter,
     verbose, overrideCenter, minSet=AIR_FALSE, maxSet=AIR_FALSE,
     offSet=AIR_FALSE;
-  unsigned int scaleLen, ai, samplesOut, minLen, maxLen, offLen,
-    aspRatNum, nonAspRatNum, nonAspRatIdx;
+  unsigned int scaleLen, ai, minLen, maxLen, offLen,
+    aspRatNum, nonAspRatNum;
+  size_t samplesOut;
   airArray *mop;
   double *scale;
   double padVal, *min, *max, *off, aspRatScl=AIR_NAN;
@@ -78,6 +79,9 @@
              "\b\bo \"/<float>\": divide number of samples by <float>\n "
              "\b\bo \"+=<uint>\", \"-=<uint>\": add <uint> to or subtract "
              "<uint> from number input samples to get number output samples\n "
+             "\b\bo \"s<float>\": assuming that some spacing information is "
+             "known on this input axis, then set the number of sample so that "
+             "the given float is the output axis spacing\n "
              "\b\bo \"<uint>\": exact number of output samples\n "
              "\b\bo \"a\": resample this axis to whatever number of samples "
              "preserves the aspect ratio of other resampled axes. Currently "
@@ -277,13 +281,12 @@
     }
     aspRatNum = nonAspRatNum = 0;
     for (ai=0; ai<nin->dim; ai++) {
-      int dowhat = AIR_CAST(int, scale[0 + 2*ai]);
+      int dowhat = AIR_INT(scale[0 + 2*ai]);
       if (!(unrrduScaleNothing == dowhat)) {
         if (unrrduScaleAspectRatio == dowhat) {
           aspRatNum++;
         } else {
           nonAspRatNum++;
-          nonAspRatIdx = ai;
         }
       }
     }
@@ -305,7 +308,10 @@
     if (!E) E |= nrrdResampleDefaultCenterSet(rsmc, defaultCenter);
     if (!E) E |= nrrdResampleInputSet(rsmc, nin);
     for (ai=0; ai<nin->dim; ai++) {
-      int dowhat = AIR_CAST(int, scale[0 + 2*ai]);
+      double spin, spout, svec[NRRD_SPACE_DIM_MAX];
+      int spstat;
+      int dowhat = AIR_INT(scale[0 + 2*ai]);
+      size_t incr = AIR_CAST(size_t, scale[1 + 2*ai]);
       switch(dowhat) {
       case unrrduScaleNothing:
         /* no resampling */
@@ -321,22 +327,21 @@
         }
         if (!E) E |= nrrdResampleKernelSet(rsmc, ai, unuk->kernel, unuk->parm);
         switch(dowhat) {
-          unsigned int incr;
           char stmp[AIR_STRLEN_SMALL];
         case unrrduScaleMultiply:
-          samplesOut = AIR_ROUNDUP(nin->axis[ai].size*scale[1 + 2*ai]);
+          samplesOut = AIR_ROUNDUP_UI(nin->axis[ai].size*scale[1 + 2*ai]);
           break;
         case unrrduScaleDivide:
-          samplesOut = AIR_ROUNDUP(nin->axis[ai].size/scale[1 + 2*ai]);
+          samplesOut = AIR_ROUNDUP_UI(nin->axis[ai].size/scale[1 + 2*ai]);
           break;
         case unrrduScaleAdd:
-          samplesOut = nin->axis[ai].size + AIR_CAST(unsigned int, scale[1 + 2*ai]);
+          samplesOut = nin->axis[ai].size + incr;
           break;
         case unrrduScaleSubtract:
-          incr = AIR_CAST(unsigned int, scale[1 + 2*ai]);
           if (nin->axis[ai].size - 1 < incr) {
             fprintf(stderr, "%s: can't subtract %u from axis size %s\n",
-                    me, incr, airSprintSize_t(stmp, nin->axis[ai].size));
+                    me, (unsigned int)incr,
+                    airSprintSize_t(stmp, nin->axis[ai].size));
             airMopError(mop);
             return 1;
           }
@@ -346,6 +351,39 @@
         aspRatScl = AIR_CAST(double, samplesOut)/nin->axis[ai].size;
         if (!E) E |= nrrdResampleSamplesSet(rsmc, ai, samplesOut);
         break;
+      case unrrduScaleSpacingTarget:
+        /* wants the output spacing to be something particular */
+        spstat = nrrdSpacingCalculate(nin, ai, &spin, svec);
+        spout = scale[1 + 2*ai];
+        switch (spstat) {
+        case nrrdSpacingStatusUnknown:
+        case nrrdSpacingStatusNone:
+          fprintf(stderr, "%s: want to set output axis %u spacing (to %g), "
+                  "but can't find input axis spacing\n",
+                  me, ai, spout);
+          airMopError(mop);
+          return 1;
+          break;
+        case nrrdSpacingStatusScalarNoSpace:
+        case nrrdSpacingStatusScalarWithSpace:
+        case nrrdSpacingStatusDirection:
+          if (!AIR_EXISTS(spin)) {
+          fprintf(stderr, "%s: want to set output axis %u spacing (to %g), "
+                  "but can't input axis spacing was %g\n",
+                  me, ai, spout, spin);
+            airMopError(mop);
+            return 1;
+          }
+          samplesOut = AIR_ROUNDUP_UI(nin->axis[ai].size*spin/spout);
+          break;
+        }
+        aspRatScl = AIR_CAST(double, samplesOut)/nin->axis[ai].size;
+        if (defaultCenter && overrideCenter) {
+          if (!E) E |= nrrdResampleOverrideCenterSet(rsmc, ai, defaultCenter);
+        }
+        if (!E) E |= nrrdResampleKernelSet(rsmc, ai, unuk->kernel, unuk->parm);
+        if (!E) E |= nrrdResampleSamplesSet(rsmc, ai, samplesOut);
+        break;
       case unrrduScaleExact:
         /* explicit # of samples */
         if (defaultCenter && overrideCenter) {
@@ -392,9 +430,9 @@
         return 1;
       }
       for (ai=0; ai<nin->dim; ai++) {
-        int dowhat = AIR_CAST(int, scale[0 + 2*ai]);
+        int dowhat = AIR_INT(scale[0 + 2*ai]);
         if (unrrduScaleAspectRatio == dowhat) {
-          samplesOut = AIR_ROUNDUP(nin->axis[ai].size*aspRatScl);
+          samplesOut = AIR_ROUNDUP_UI(nin->axis[ai].size*aspRatScl);
           if (!E) E |= nrrdResampleSamplesSet(rsmc, ai, samplesOut);
         }
       }
@@ -413,7 +451,7 @@
     }
   } else {
     for (ai=0; ai<nin->dim; ai++) {
-      int dowhat = AIR_CAST(int, scale[0 + 2*ai]);
+      int dowhat = AIR_INT(scale[0 + 2*ai]);
       /* this may be over-written below */
       info->kernel[ai] = unuk->kernel;
       switch(dowhat) {
@@ -423,7 +461,7 @@
         break;
       case unrrduScaleMultiply:
         /* scaling of input # samples */
-        info->samples[ai] = AIR_ROUNDUP(scale[1 + 2*ai]*nin->axis[ai].size);
+        info->samples[ai] = AIR_ROUNDUP_UI(scale[1 + 2*ai]*nin->axis[ai].size);
         break;
       case unrrduScaleExact:
         /* explicit # of samples */
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/reshape.c teem-1.11.0-src/src/unrrdu/reshape.c
--- teem-1.11.0-src.orig/src/unrrdu/reshape.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/reshape.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/rmap.c teem-1.11.0-src/src/unrrdu/rmap.c
--- teem-1.11.0-src.orig/src/unrrdu/rmap.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/rmap.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/save.c teem-1.11.0-src/src/unrrdu/save.c
--- teem-1.11.0-src.orig/src/unrrdu/save.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/save.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -44,7 +44,7 @@
   Nrrd *nin, *nout;
   airArray *mop;
   NrrdIoState *nio;
-  int pret, enc[3], formatType;
+  int pret, enc[3], frmt[2];
 
   mop = airMopNew();
   nio = nrrdIoStateNew();
@@ -54,7 +54,10 @@
          "output file format. Possibilities include:\n "
          "\b\bo \"nrrd\": standard nrrd format\n "
          "\b\bo \"pnm\": PNM image; PPM for color, PGM for grayscale\n "
-         "\b\bo \"text\": plain ASCII text for 1-D and 2-D data\n "
+         "\b\bo \"text\": ASCII text for 1-D and 2-D data\n "
+         "\b\bo \"ptext\": like \"text\" but enforcing real plain text,\n "
+         "        i.e., no NRRD header fields on lines (prior to data) \n "
+         "        starting with \"#\"\n "
          "\b\bo \"vtk\": VTK \"STRUCTURED_POINTS\" dataset");
   if (nrrdFormatPNG->available()) {
     strcat(fmtInfo,
@@ -62,8 +65,8 @@
   }
   strcat(fmtInfo,
          "\n \b\bo \"eps\": EPS file");
-  hestOptAdd(&opt, "f,format", "form", airTypeEnum, 1, 1, &formatType, NULL,
-             fmtInfo, NULL, nrrdFormatType);
+  hestOptAdd(&opt, "f,format", "form", airTypeOther, 1, 1, frmt, NULL,
+             fmtInfo, NULL, NULL, &unrrduHestFormatCB);
   strcpy(encInfo,
          "encoding of data in file.  Not all encodings are supported in "
          "a given format. Possibilities include:"
@@ -115,8 +118,11 @@
 
   nrrdCopy(nout, nin);
 
+  nio->format = nrrdFormatArray[frmt[0]];
+  if (nrrdFormatTypeText == frmt[0] && frmt[1]) {
+    nio->bareText = AIR_TRUE;
+  }
   nio->encoding = nrrdEncodingArray[enc[0]];
-  nio->format = nrrdFormatArray[formatType];
   if (nrrdEncodingTypeGzip == enc[0]) {
     nio->zlibLevel = enc[1];
     nio->zlibStrategy = enc[2];
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/shuffle.c teem-1.11.0-src/src/unrrdu/shuffle.c
--- teem-1.11.0-src.orig/src/unrrdu/shuffle.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/shuffle.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/slice.c teem-1.11.0-src/src/unrrdu/slice.c
--- teem-1.11.0-src.orig/src/unrrdu/slice.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/slice.c	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -100,7 +100,7 @@
                 + _pos[1 + 2*axi]);
     /*
     printf("%s: [%d] axis = %u, pos = %u\n", me, axi, axis[axi],
-           AIR_CAST(unsigned int, pos[axi]));
+           AIR_UINT(pos[axi]));
     */
   }
   /* check on possibly adjust slice axes downward */
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/sources.cmake teem-1.11.0-src/src/unrrdu/sources.cmake
--- teem-1.11.0-src.orig/src/unrrdu/sources.cmake	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/sources.cmake	1970-01-01 08:00:00.000000000 +0800
@@ -1,76 +0,0 @@
-# This variable will help provide a master list of all the sources.
-# Add new source files here.
-SET(UNRRDU_SOURCES
-  fft.c
-  i2w.c
-  w2i.c
-  1op.c
-  2op.c
-  3op.c
-  affine.c
-  about.c
-  axdelete.c
-  axinfo.c
-  axinsert.c
-  axmerge.c
-  axsplit.c
-  block.c
-  ccadj.c
-  ccfind.c
-  ccmerge.c
-  ccsettle.c
-  cmedian.c
-  convert.c
-  crop.c
-  acrop.c
-  data.c
-  dering.c
-  dhisto.c
-  dice.c
-  dist.c
-  env.c
-  flip.c
-  flotsam.c
-  gamma.c
-  head.c
-  heq.c
-  histax.c
-  histo.c
-  imap.c
-  inset.c
-  jhisto.c
-  join.c
-  lut.c
-  lut2.c
-  make.c
-  minmax.c
-  cksum.c
-  diff.c
-  dnorm.c
-  vidicon.c
-  mlut.c
-  mrmap.c
-  pad.c
-  permute.c
-  privateUnrrdu.h
-  project.c
-  quantize.c
-  resample.c
-  reshape.c
-  rmap.c
-  save.c
-  shuffle.c
-  slice.c
-  sselect.c
-  splice.c
-  subst.c
-  swap.c
-  tile.c
-  unblock.c
-  unorient.c
-  unquantize.c
-  unrrdu.h
-  untile.c
-  )
-
-ADD_TEEM_LIBRARY(unrrdu ${UNRRDU_SOURCES})
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/splice.c teem-1.11.0-src/src/unrrdu/splice.c
--- teem-1.11.0-src.orig/src/unrrdu/splice.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/splice.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/sselect.c teem-1.11.0-src/src/unrrdu/sselect.c
--- teem-1.11.0-src.orig/src/unrrdu/sselect.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/sselect.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -85,7 +85,7 @@
   if (nrrdSliceSelect(noutAbove, noutBelow, nin, axis,
                       nline, thresh)) {
     airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
-    fprintf(stderr, "%s: error selecting slices nrrd:\n%s", me, err);
+    fprintf(stderr, "%s: error selecting slices:\n%s", me, err);
     airMopError(mop);
     return 1;
   }
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/subst.c teem-1.11.0-src/src/unrrdu/subst.c
--- teem-1.11.0-src.orig/src/unrrdu/subst.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/subst.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/swap.c teem-1.11.0-src/src/unrrdu/swap.c
--- teem-1.11.0-src.orig/src/unrrdu/swap.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/swap.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/tile.c teem-1.11.0-src/src/unrrdu/tile.c
--- teem-1.11.0-src.orig/src/unrrdu/tile.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/tile.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/TODO.txt teem-1.11.0-src/src/unrrdu/TODO.txt
--- teem-1.11.0-src.orig/src/unrrdu/TODO.txt	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/TODO.txt	2021-02-18 15:42:37.000000000 +0800
@@ -1,7 +1,5 @@
 examples of usage with the important unu commands
 
-make "unu make" into a nrrd function
-
 enable the unu 2op and 3op operations that output integers to save
 the output as, say, signed char, instead of float.  This is different
 than being able to change input type, for operations like "gt".
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/unblock.c teem-1.11.0-src/src/unrrdu/unblock.c
--- teem-1.11.0-src.orig/src/unrrdu/unblock.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/unblock.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/undos.c teem-1.11.0-src/src/unrrdu/undos.c
--- teem-1.11.0-src.orig/src/unrrdu/undos.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/undos.c	2021-02-18 15:42:36.000000000 +0800
@@ -0,0 +1,324 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "unrrdu.h"
+#include "privateUnrrdu.h"
+
+#define INFO "Converts DOS text files to normal, and more"
+static const char *_unrrdu_undosInfoL =
+  (INFO
+   ". The characters involved are:\n *\t\t\t\t\t\t\t"
+   "       carraige return = CR = '\\r' = 0x0d = decimal 13 = octal 015\n "
+   "* \"new line\" = line feed = LF = '\\n' = 0x0a = decimal 10 = octal 012\n "
+   "though see https://en.wikipedia.org/wiki/Newline for messy details. "
+   "This program converts CR-LF pairs (DOS/Windows line breaks) "
+   "to just LF (Unix line break). With the \"-r\" option, however, "
+   "this converts the other way, for whatever sick reason you'd want that. "
+   "With the \"-m\" option, this can convert legacy MAC text files "
+   "(which use only CR for line break, which may appear as \"^M\" in text "
+   "displays). Unlike simple sed/perl scripts for this purpose, this program "
+   "is careful to be idempotent in all modes of operation. Also, this makes an "
+   "effort to not meddle with binary files (on which this may be mistakenly "
+   "invoked), by not converting files with a high percentage of non-printing "
+   "characters, as controlled by the \"-pnp\" option. A message "
+   "is printed to stderr for all the files actually modified.\n "
+   "* (not actually based on Nrrd)");
+
+#define CR 0x0d
+#define LF 0x0a
+
+static void
+undosConvert(const char *me, char *name, int reverse, int mac,
+             int quiet, int noAction, float badPerc) {
+  airArray *mop;
+  FILE *fin, *fout;
+  char *data=NULL;
+  airArray *dataArr;
+  unsigned int ci, len;
+  int car, numBad, willConvert;
+  airPtrPtrUnion appu;
+
+  mop = airMopNew();
+  if (!airStrlen(name)) {
+    fprintf(stderr, "%s: empty filename\n", me);
+    airMopError(mop); return;
+  }
+
+  /* -------------------------------------------------------- */
+  /* open input file  */
+  fin = airFopen(name, stdin, "rb");
+  if (!fin) {
+    if (!quiet) {
+      fprintf(stderr, "%s: couldn't open \"%s\" for reading: \"%s\"\n",
+              me, name, strerror(errno));
+    }
+    airMopError(mop); return;
+  }
+  airMopAdd(mop, fin, (airMopper)airFclose, airMopOnError);
+
+  /* -------------------------------------------------------- */
+  /* create buffer */
+  appu.c = &data;
+  dataArr = airArrayNew(appu.v, NULL, sizeof(char), AIR_STRLEN_HUGE);
+  if (!dataArr) {
+    if (!quiet) {
+      fprintf(stderr, "%s: internal allocation error #1\n", me);
+    }
+    airMopError(mop); return;
+  }
+  airMopAdd(mop, dataArr, (airMopper)airArrayNuke, airMopAlways);
+
+  /* -------------------------------------------------------- */
+  /* read input file, testing for binary-ness along the way */
+  numBad = 0;
+  car = getc(fin);
+  if (EOF == car) {
+    if (!quiet) {
+      fprintf(stderr, "%s: \"%s\" is empty, skipping ...\n", me, name);
+    }
+    airMopError(mop); return;
+  }
+  do {
+    ci = airArrayLenIncr(dataArr, 1);
+    if (!dataArr->data) {
+      if (!quiet) {
+        fprintf(stderr, "%s: internal allocation error #2\n", me);
+      }
+      airMopError(mop); return;
+    }
+    data[ci] = AIR_CAST(char, car);
+    numBad += !isprint(car) && !isspace(car);
+    car = getc(fin);
+  } while (EOF != car && badPerc > 100.0*numBad/dataArr->len);
+  if (EOF != car) {
+    if (!quiet) {
+      fprintf(stderr, "%s: more than %g%% of \"%s\" is non-printing, "
+              "skipping ...\n", me, badPerc, name);
+    }
+    airMopError(mop); return;
+  }
+  fin = airFclose(fin);
+  len = dataArr->len; /* learn array length */
+
+  /* -------------------------------------------------------- */
+  /* see if we really need to do anything */
+  willConvert = AIR_FALSE;
+  if (!strcmp("-", name)) {
+    willConvert = AIR_TRUE;
+  } else if (reverse) { /* REVERSE operation, away from unix LF */
+    for (ci=0; ci<len; ci++) {
+      if (LF == data[ci] && (ci && CR != data[ci-1])) {
+        /* If converting to DOS, we're looking for LF not preceded by CR.
+           If converting to MAC, we could just look for LF, but the
+           principle here is that we are only converting from unix,
+           so a DOS CR-LF should also pass through unchanged */
+        willConvert = AIR_TRUE;
+        break;
+      }
+    }
+  } else { /* !reverse, normal operation */
+    for (ci=0; ci<len; ci++) {
+      if (mac) {
+        if (CR == data[ci] && (ci+1<len && LF != data[ci+1])) {
+          /* If converting from MAC, our job is NOT to convert DOS CR-LFs */
+          willConvert = AIR_TRUE;
+          break;
+        }
+      } else {
+        if (CR == data[ci] && (ci+1<len && LF == data[ci+1])) {
+          willConvert = AIR_TRUE;
+          break;
+        }
+      }
+    }
+  }
+  if (!willConvert) {
+    /* no, we don't need to do anything; quietly quit */
+    airMopOkay(mop);
+    return;
+  } else {
+    if (!quiet) {
+      fprintf(stderr, "%s: %s \"%s\" %s %s ... \n", me,
+              noAction ? "would convert" : "converting",
+              name,
+              reverse ? "to" : "from",
+              mac ? "MAC" : "DOS");
+    }
+  }
+  if (noAction) {
+    /* just joking, we won't actually write anything.
+       (yes, even if input was stdin) */
+    airMopOkay(mop);
+    return;
+  }
+
+  /* -------------------------------------------------------- */
+  /* open output file */
+  fout = airFopen(name, stdout, "wb");
+  if (!fout) {
+    if (!quiet) {
+      fprintf(stderr, "%s: couldn't open \"%s\" for writing: \"%s\"\n",
+              me, name, strerror(errno));
+    }
+    airMopError(mop); return;
+  }
+  airMopAdd(mop, fout, (airMopper)airFclose, airMopOnError);
+
+  /* -------------------------------------------------------- */
+  /* write output file */
+  car = 'a'; /* something not EOF */
+  if (reverse) { /* away from LF to either CR-LF (or mac CR) */
+    for (ci=0; EOF != car && ci<len; ci++) {
+      if (LF == data[ci]) {
+        if (ci && CR == data[ci-1]) {
+          /* if this LF was preceded by a CR, it is, if !mac, already
+             the intended DOS CR-LF, and we've already putc the CR, so
+             now we putc LF. Or, if mac, we're narrowly focusing on
+             converting only unix line breaks, so same thing: putc LF */
+          car = putc(LF, fout);
+        } else {
+          /* this LF was not preceded by a CR, so do either MAC or DOS
+             line break CR and LF */
+          car = putc(CR, fout);
+          if (!mac && EOF != car) car = putc(LF, fout);
+        }
+      } else {
+        car = putc(data[ci], fout);
+      }
+    }
+  } else { /* normal operation: from CR-LF (or mac CR but not CR-LF) to LF */
+    for (ci=0; EOF != car && ci<len; ci++) {
+      if (CR == data[ci]) {
+        if (mac) {
+          if (ci+1<len && LF == data[ci+1]) {
+            /* not our job to convert CR-LF, so this CR passes through */
+            car = putc(CR, fout);
+          } else {
+            /* just CR --> LF */
+            car = putc(LF, fout);
+          }
+        } else {
+          if (ci+1<len && LF == data[ci+1]) {
+            /* converting CR-LF to LF is our job */
+            car = putc(LF, fout);
+            ci++;
+          } else {
+            /* just a CR, not a CR-LF, but !mac, so this CR passes through */
+            car = putc(CR, fout);
+          }
+        }
+      } else {
+        /* saw something other than CR */
+        car = putc(data[ci], fout);
+      }
+    }
+  }
+  if (EOF == car) {
+    if (!quiet) {
+      fprintf(stderr, "%s: ERROR writing \"%s\" possible data loss !!! "
+              "(sorry)\n", me, name);
+    }
+  }
+  fout = airFclose(fout);
+
+  airMopOkay(mop);
+  return;
+}
+
+int
+unrrdu_undosMain(int argc, const char **argv, const char *me,
+                 hestParm *hparm) {
+  /* these are stock for unrrdu */
+  hestOpt *opt = NULL;
+  airArray *mop;
+  int pret;
+  char *err;
+  /* these are specific to this command */
+  char **name;
+  float badPerc;
+  int lenName, ni, reverse, quiet, noAction, mac;
+
+  hestOptAdd(&opt, "r", NULL, airTypeInt, 0, 0, &reverse, NULL,
+             "convert back to DOS, instead of converting from DOS to normal");
+  hestOptAdd(&opt, "q", NULL, airTypeInt, 0, 0, &quiet, NULL,
+             "never print anything to stderr, even for errors.");
+  hestOptAdd(&opt, "m", NULL, airTypeInt, 0, 0, &mac, NULL,
+             "deal with legacy MAC text files, and files generated by "
+             "weird software running on OSX that hasn't gotten the memo "
+             "about OSX uses unix-style line breaks.");
+  hestOptAdd(&opt, "n", NULL, airTypeInt, 0, 0, &noAction, NULL,
+             "don't actually write converted files, just pretend to. "
+             "This is useful to see which files WOULD be converted. ");
+  hestOptAdd(&opt, "pnp", "perc", airTypeFloat, 1, 1, &badPerc, "2",
+             "if the percentage of non-printing characters (characters "
+             "c for which isprint(c) and isspace(c) are both false) "
+             "exceeds this threshold, then don't do anything to the file; "
+             "it is probably not a text file at all. ");
+  hestOptAdd(&opt, NULL, "file", airTypeString, 1, -1, &name, NULL,
+             "all the files to convert.  Each file will be over-written "
+             "with its converted contents.  Use \"-\" to read from stdin "
+             "and write to stdout", &lenName);
+
+  mop = airMopNew();
+  airMopAdd(mop, opt, (airMopper)hestOptFree, airMopAlways);
+  USAGE(_unrrdu_undosInfoL);
+  PARSE();
+  airMopAdd(mop, opt, (airMopper)hestParseFree, airMopAlways);
+
+  for (ni=0; ni<lenName; ni++) {
+    undosConvert(me, name[ni], reverse, mac, quiet, noAction, badPerc);
+  }
+
+  airMopOkay(mop);
+  return 0;
+}
+
+UNRRDU_CMD_HIDE(undos, INFO);
+
+#if 0 /* this is the program used for testing */
+#include <stdio.h>
+#include <math.h>
+
+int
+main(int argc, char **argv) {
+
+#if 0
+#  define MM "M\r"   /* 4d 0d */
+#  define DD "D\r\n" /* 44 0d 0a */
+#  define UU "U\n"   /* 55 0a */
+#else
+#  define MM "M\r\r"
+#  define DD "D\r\n\r\n"
+#  define UU "U\n\n"
+#endif
+
+  if (2 == argc && 'M' == argv[1][0]) {
+    printf(DD UU MM);
+  } else if (2 == argc && 'D' == argv[1][0]) {
+    printf(UU MM DD);
+  } else {
+    printf(MM DD UU);
+  }
+  return 0;
+}
+#endif
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/unorient.c teem-1.11.0-src/src/unrrdu/unorient.c
--- teem-1.11.0-src.orig/src/unrrdu/unorient.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/unorient.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/unquantize.c teem-1.11.0-src/src/unrrdu/unquantize.c
--- teem-1.11.0-src.orig/src/unrrdu/unquantize.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/unquantize.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/unrrdu.h teem-1.11.0-src/src/unrrdu/unrrdu.h
--- teem-1.11.0-src.orig/src/unrrdu/unrrdu.h	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/unrrdu.h	2021-02-18 15:42:36.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -140,6 +140,7 @@
 F(shuffle) \
 F(flip) \
 F(unorient) \
+F(basinfo) \
 F(axinfo) \
 F(axinsert) \
 F(axsplit) \
@@ -170,6 +171,10 @@
 F(ccsettle) \
 F(dnorm) \
 F(vidicon) \
+F(grid) \
+F(hack) \
+F(aabplot) \
+F(undos) \
 F(save)
 /* these two have been removed since no one uses them
 F(block) \
@@ -203,14 +208,15 @@
 ** samples on an axis should be scaled (though now its more general
 ** than just scaling) */
 enum {
-  unrrduScaleUnknown,
-  unrrduScaleNothing,      /* "=" */
-  unrrduScaleMultiply,     /* e.g. "x2" */
-  unrrduScaleDivide,       /* e.g. "/2" */
-  unrrduScaleAdd,          /* e.g. "+2" */
-  unrrduScaleSubtract,     /* e.g. "-2" */
-  unrrduScaleAspectRatio,  /* "a" */
-  unrrduScaleExact,        /* e.g. "128" */
+  unrrduScaleUnknown,       /* 0: */
+  unrrduScaleNothing,       /* 1: "=" */
+  unrrduScaleMultiply,      /* 2: e.g. "x2" */
+  unrrduScaleDivide,        /* 3: e.g. "/2" */
+  unrrduScaleAdd,           /* 4: e.g. "+2" */
+  unrrduScaleSubtract,      /* 5: e.g. "-2" */
+  unrrduScaleAspectRatio,   /* 6: "a" */
+  unrrduScaleExact,         /* 7: e.g. "128" */
+  unrrduScaleSpacingTarget, /* 8: e.g. "s0.89" */
   unrrduScaleLast
 };
 
@@ -218,6 +224,10 @@
 UNRRDU_EXPORT const int unrrduPresent;
 UNRRDU_EXPORT const char *unrrduBiffKey;
 UNRRDU_EXPORT unsigned int unrrduDefNumColumns;
+UNRRDU_EXPORT int unrrduCmdMain(int argc, const char **argv,
+                                const char *cmd, const char *title,
+                                const unrrduCmd *const *cmdList,
+                                hestParm *hparm, FILE *fusage);
 /* addresses of all unrrdu_xxxCmd */
 UNRRDU_EXPORT unrrduCmd *unrrduCmdList[];
 UNRRDU_EXPORT void unrrduUsageUnu(const char *me, hestParm *hparm);
@@ -229,6 +239,7 @@
 UNRRDU_EXPORT hestCB unrrduHestBitsCB;
 UNRRDU_EXPORT hestCB unrrduHestFileCB;
 UNRRDU_EXPORT hestCB unrrduHestEncodingCB;
+UNRRDU_EXPORT hestCB unrrduHestFormatCB;
 
 
 #ifdef __cplusplus
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/untile.c teem-1.11.0-src/src/unrrdu/untile.c
--- teem-1.11.0-src.orig/src/unrrdu/untile.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/untile.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/vidicon.c teem-1.11.0-src/src/unrrdu/vidicon.c
--- teem-1.11.0-src.orig/src/unrrdu/vidicon.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/vidicon.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -108,8 +108,10 @@
       || nrrdResampleInputSet(rsmc, nin)
       || nrrdResampleKernelSet(rsmc, 0, rescaleKsp->kernel, rescaleKsp->parm)
       || nrrdResampleKernelSet(rsmc, 1, rescaleKsp->kernel, rescaleKsp->parm)
-      || nrrdResampleSamplesSet(rsmc, 0, rescale*nin->axis[0].size)
-      || nrrdResampleSamplesSet(rsmc, 1, rescale*nin->axis[1].size)
+      || nrrdResampleSamplesSet(rsmc, 0, AIR_CAST(size_t,
+                                                  rescale*nin->axis[0].size))
+      || nrrdResampleSamplesSet(rsmc, 1, AIR_CAST(size_t,
+                                                  rescale*nin->axis[1].size))
       || nrrdResampleRangeFullSet(rsmc, 0)
       || nrrdResampleRangeFullSet(rsmc, 1)
       || nrrdResampleTypeOutSet(rsmc, nrrdTypeFloat)
@@ -185,7 +187,8 @@
     nn = nrrdElementNumber(nrescale);
     rescaled = AIR_CAST(float *, nrescale->data);
     for (ii=0; ii<nn; ii++) {
-      rescaled[ii] = AIR_AFFINE(minval, rescaled[ii], maxval, 0.0, 255.0);
+      rescaled[ii] = AIR_FLOAT(AIR_AFFINE(minval, rescaled[ii],
+                                          maxval, 0.0, 255.0));
     }
     airMopOkay(submop);
     submop = NULL;
@@ -215,8 +218,8 @@
 
   /* rescaling down to "video" resolution */
   fprintf(stderr, "%s: downsampling to %u x %u\n", me,
-          AIR_CAST(unsigned int, vsize[0] + 2*vpadding[0]),
-          AIR_CAST(unsigned int, vsize[1] + 2*vpadding[1]));
+          AIR_UINT(vsize[0] + 2*vpadding[0]),
+          AIR_UINT(vsize[1] + 2*vpadding[1]));
   nvbase = nrrdNew();
   airMopAdd(mop, nvbase, (airMopper)nrrdNuke, airMopAlways);
   if (nrrdResampleDefaultCenterSet(rsmc, nrrdCenterCell)
diff --color -ruN teem-1.11.0-src.orig/src/unrrdu/w2i.c teem-1.11.0-src/src/unrrdu/w2i.c
--- teem-1.11.0-src.orig/src/unrrdu/w2i.c	2012-12-20 22:07:21.000000000 +0800
+++ teem-1.11.0-src/src/unrrdu/w2i.c	2021-02-18 15:42:37.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/TestBuild.cmake teem-1.11.0-src/TestBuild.cmake
--- teem-1.11.0-src.orig/TestBuild.cmake	2012-12-20 22:12:22.000000000 +0800
+++ teem-1.11.0-src/TestBuild.cmake	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
-# Teem: Tools to process and visualize scientific data and images              
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Teem: Tools to process and visualize scientific data and images
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -22,28 +22,28 @@
 #
 
 # Where the source code lives
-SET (CTEST_SOURCE_DIRECTORY "${CTEST_SCRIPT_DIRECTORY}")
-SET (CTEST_BINARY_DIRECTORY "${CTEST_SOURCE_DIRECTORY}/build-ctest")
+set (CTEST_SOURCE_DIRECTORY "${CTEST_SCRIPT_DIRECTORY}")
+set (CTEST_BINARY_DIRECTORY "${CTEST_SOURCE_DIRECTORY}/build-ctest")
 
 # Make sure we always reconfigure cmake stuff from scratch and don't
 # rely on previously built libraries
-SET (CTEST_START_WITH_EMPTY_BINARY_DIRECTORY TRUE)
+set (CTEST_START_WITH_EMPTY_BINARY_DIRECTORY TRUE)
 
-SET (CTEST_CMAKE_COMMAND "cmake")
+set (CTEST_CMAKE_COMMAND "cmake")
 # NOTE(bigler): On windows you should make sure something like cygwin is in
 # your path.  Then it will find cygwin's svn.  Otherwise, your nightlies
 # won't find svn and won't do the updates.  I put it in the bat script at
 # the end:
 #   set PATH=%PATH%;"C:\Program Files\CMake 2.4\bin";"c:/cygwin/bin"
-SET (CTEST_CVS_COMMAND "svn")
+set (CTEST_CVS_COMMAND "svn")
 
 # A smoke test only builds the code and doesn't run any tests, so we
 # exclude all tests here
-#SET (CTEST_COMMAND "ctest -D Nightly")
-SET (CTEST_COMMAND "ctest -VV -D Experimental -A \"${CTEST_BINARY_DIRECTORY}/CMakeCache.txt\"")
-SET (CTEST_CMAKE_COMMAND "cmake")
+#set (CTEST_COMMAND "ctest -D Nightly")
+set (CTEST_COMMAND "ctest -VV -D Experimental -A \"${CTEST_BINARY_DIRECTORY}/CMakeCache.txt\"")
+set (CTEST_CMAKE_COMMAND "cmake")
 
-SET(CTEST_INITIAL_CACHE "
+set(CTEST_INITIAL_CACHE "
   BUILD_EXPERIMENTAL_LIBS:BOOL=OFF
   BUILD_EXPERIMENTAL_APPS:BOOL=OFF
   BUILD_HEX:BOOL=OFF
diff --color -ruN teem-1.11.0-src.orig/Testing/air/amath.c teem-1.11.0-src/Testing/air/amath.c
--- teem-1.11.0-src.orig/Testing/air/amath.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/air/amath.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/Testing/air/CMakeLists.txt teem-1.11.0-src/Testing/air/CMakeLists.txt
--- teem-1.11.0-src.orig/Testing/air/CMakeLists.txt	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/air/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images             .
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -21,26 +21,26 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-ADD_EXECUTABLE(test_miscAir miscAir.c)
-TARGET_LINK_LIBRARIES(test_miscAir teem)
-ADD_TEST(misc ${EXECUTABLE_OUTPUT_PATH}/test_miscAir)
-
-ADD_EXECUTABLE(test_mtrand mtrand.c)
-TARGET_LINK_LIBRARIES(test_mtrand teem)
-ADD_TEST(mtrand ${EXECUTABLE_OUTPUT_PATH}/test_mtrand)
-
-ADD_EXECUTABLE(test_amath amath.c)
-TARGET_LINK_LIBRARIES(test_amath teem)
-ADD_TEST(amath ${EXECUTABLE_OUTPUT_PATH}/test_amath)
-
-ADD_EXECUTABLE(test_string string.c)
-TARGET_LINK_LIBRARIES(test_string teem)
-ADD_TEST(string ${EXECUTABLE_OUTPUT_PATH}/test_string)
-
-ADD_EXECUTABLE(test_strtok strtok.c)
-TARGET_LINK_LIBRARIES(test_strtok teem)
-ADD_TEST(strtok ${EXECUTABLE_OUTPUT_PATH}/test_strtok)
-
-ADD_EXECUTABLE(test_pptest pptest.c)
-TARGET_LINK_LIBRARIES(test_pptest teem)
-ADD_TEST(pptest ${EXECUTABLE_OUTPUT_PATH}/test_pptest)
+add_executable(test_miscAir miscAir.c)
+target_link_libraries(test_miscAir teem)
+add_test(NAME misc COMMAND $<TARGET_FILE:test_miscAir>)
+
+add_executable(test_mtrand mtrand.c)
+target_link_libraries(test_mtrand teem)
+add_test(NAME mtrand COMMAND $<TARGET_FILE:test_mtrand>)
+
+add_executable(test_amath amath.c)
+target_link_libraries(test_amath teem)
+add_test(NAME amath COMMAND $<TARGET_FILE:test_amath>)
+
+add_executable(test_string string.c)
+target_link_libraries(test_string teem)
+add_test(NAME string COMMAND $<TARGET_FILE:test_string>)
+
+add_executable(test_strtok strtok.c)
+target_link_libraries(test_strtok teem)
+add_test(NAME strtok COMMAND $<TARGET_FILE:test_strtok>)
+
+add_executable(test_pptest pptest.c)
+target_link_libraries(test_pptest teem)
+add_test(NAME pptest COMMAND $<TARGET_FILE:test_pptest>)
diff --color -ruN teem-1.11.0-src.orig/Testing/air/miscAir.c teem-1.11.0-src/Testing/air/miscAir.c
--- teem-1.11.0-src.orig/Testing/air/miscAir.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/air/miscAir.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -30,10 +30,6 @@
 AIR_EXPORT FILE *airFopen(const char *name, FILE *std, const char *mode);
 AIR_EXPORT FILE *airFclose(FILE *file);
 AIR_EXPORT int airSinglePrintf(FILE *file, char *str, const char *fmt, ...);
-AIR_EXPORT unsigned int airIndex(double min, double val, double max,
-                                 unsigned int N);
-AIR_EXPORT unsigned int airIndexClamp(double min, double val, double max,
-                                      unsigned int N);
 AIR_EXPORT airULLong airIndexULL(double min, double val, double max,
                                  airULLong N);
 AIR_EXPORT airULLong airIndexClampULL(double min, double val, double max,
@@ -77,7 +73,8 @@
 
   /* airSetNull */
   {
-    ptr = AIR_CAST(void *, airNull);
+    char tmp[10];
+    ptr = AIR_CAST(void *, tmp);
     if (NULL == ptr) {
       fprintf(stderr, "%s: couldn't set a non-NULL pointer", me);
       exit(1);
@@ -145,6 +142,38 @@
     }
   }
 
+  /* airIndex, airIndexClamp */
+  {
+    /* admittedly this not much of a test; mainly it serves to
+       demonstrate how the intervals are divided for N=4 */
+    unsigned int N=4;
+    double min=0.0, max=1.0;
+    double val[]={0.000, 0.001, 0.249,
+                  0.251, 0.400, 0.499,
+                  0.501, 0.700, 0.749,
+                  0.751, 0.999, 1.000};
+    unsigned int wantIdx[]={0, 0, 0,
+                            1, 1, 1,
+                            2, 2, 2,
+                            3, 3, 3};
+    unsigned int vn, vi, ii, ci;
+    vn = sizeof(wantIdx)/sizeof(unsigned int);
+    for (vi=0; vi<vn; vi++) {
+      ii = airIndex(min, val[vi], max, N);
+      ci = airIndexClamp(min, val[vi], max, N);
+      if (ii != wantIdx[vi]) {
+        fprintf(stderr, "%s: %u = airIndex(%.17g, %.17g, %.17g, %u) "
+                "!= correct %u\n", me, ii, min, val[vi], max, N, wantIdx[vi]);
+        exit(1);
+      }
+      if (ci != wantIdx[vi]) {
+        fprintf(stderr, "%s: %u = airIndexClamp(%.17g, %.17g, %.17g, %u) "
+                "!= correct %u\n", me, ci, min, val[vi], max, N, wantIdx[vi]);
+        exit(1);
+      }
+    }
+  }
+
   /* airSprintSize_t, airSprintPtrdiff_t in pptest.c */
 
   /* airPrettySprintSize_t */
@@ -173,7 +202,7 @@
                      16*1023*1024ul,         /* 20 */
                      16*1024*1024ul,         /* 21 = 2^64 */
                      0};
-    char *string[] = {
+    static const char * const string[] = {
       "0 bytes",    /* 0 */
       "800 bytes",  /* 1 */
       "1024 bytes", /* 2 */
diff --color -ruN teem-1.11.0-src.orig/Testing/air/mtrand.c teem-1.11.0-src/Testing/air/mtrand.c
--- teem-1.11.0-src.orig/Testing/air/mtrand.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/air/mtrand.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/Testing/air/pptest.c teem-1.11.0-src/Testing/air/pptest.c
--- teem-1.11.0-src.orig/Testing/air/pptest.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/air/pptest.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/Testing/air/string.c teem-1.11.0-src/Testing/air/string.c
--- teem-1.11.0-src.orig/Testing/air/string.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/air/string.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/Testing/air/strtok.c teem-1.11.0-src/Testing/air/strtok.c
--- teem-1.11.0-src.orig/Testing/air/strtok.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/air/strtok.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/Testing/biff/CMakeLists.txt teem-1.11.0-src/Testing/biff/CMakeLists.txt
--- teem-1.11.0-src.orig/Testing/biff/CMakeLists.txt	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/biff/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images             .
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -21,6 +21,6 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-ADD_EXECUTABLE(test_biff test.c)
-TARGET_LINK_LIBRARIES(test_biff teem)
-ADD_TEST(biff ${EXECUTABLE_OUTPUT_PATH}/test_biff)
+add_executable(test_biff test.c)
+target_link_libraries(test_biff teem)
+add_test(NAME biff COMMAND $<TARGET_FILE:test_biff>)
diff --color -ruN teem-1.11.0-src.orig/Testing/biff/test.c teem-1.11.0-src/Testing/biff/test.c
--- teem-1.11.0-src.orig/Testing/biff/test.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/biff/test.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -62,13 +62,14 @@
   biffAdd("bingo", "the third error bingo");
   biffAdd("axis", "the third error axis");
   {
-    char good[] = ("[bingo] the third error bingo\n"
-                   "[bingo] the second bll boo boo boo error bingo\n"
-                   "[bingo] the first error bingo\n"
-                   "[bingo] [chard] the third error chard\n"
-                   "[bingo] [chard] the second error chard\n"
-                   "[bingo] [chard] the first error chard\n"
-                   "[bingo] zero-eth bingo message\n");
+    char good[] =
+      "[bingo] the third error bingo\n"
+      "[bingo] the second bll boo boo boo error bingo\n"
+      "[bingo] the first error bingo\n"
+      "[bingo] [chard] the third error chard\n"
+      "[bingo] [chard] the second error chard\n"
+      "[bingo] [chard] the first error chard\n"
+      "[bingo] zero-eth bingo message\n";
     tmp = biffGet("bingo");
     airMopAdd(mop, tmp, airFree, airMopAlways);
 
@@ -91,9 +92,10 @@
   }
 
   {
-    char good[] = ("[axis] the third error axis\n"
-                   "[axis] the second error axis\n"
-                   "[axis] the first error axis\n");
+    char good[] =
+      "[axis] the third error axis\n"
+      "[axis] the second error axis\n"
+      "[axis] the first error axis\n";
     tmp = biffGet("axis");
     COMPARE(3);
   }
@@ -102,9 +104,10 @@
   biffAdd("harold", "the second error harold");
   biffAdd("harold", "the third error harold");
   {
-    char good[] = ("[harold] the third error harold\n"
-                   "[harold] the second error harold\n"
-                   "[harold] the first error harold\n");
+    char good[] =
+      "[harold] the third error harold\n"
+      "[harold] the second error harold\n"
+      "[harold] the first error harold\n";
     tmp = biffGetDone("harold");
     COMPARE(4);
   }
@@ -119,11 +122,12 @@
   biffAdd("axis", "the fourth error axis");
   biffAdd("axis", "the fifth error axis");
   {
-    char good[] = ("[axis] the fifth error axis\n"
-                   "[axis] the fourth error axis\n"
-                   "[axis] the third error axis\n"
-                   "[axis] the second error axis\n"
-                   "[axis] the first error axis\n");
+    char good[] =
+      "[axis] the fifth error axis\n"
+      "[axis] the fourth error axis\n"
+      "[axis] the third error axis\n"
+      "[axis] the second error axis\n"
+      "[axis] the first error axis\n";
     tmp = biffGetDone("axis");
     COMPARE(5);
   }
@@ -138,8 +142,9 @@
   biffAddf("test2", "%s: this is a test of biffAddf %d %g", "me", 1, 4.2);
   biffMovef("test3", "test2", "%s: testing biffMove %d.", "me", 1729);
   {
-    char good[] = ("[test3] me: testing biffMove 1729.\n"
-                   "[test3] [test2] me: this is a test of biffAddf 1 4.2\n");
+    char good[] =
+      "[test3] me: testing biffMove 1729.\n"
+      "[test3] [test2] me: this is a test of biffAddf 1 4.2\n";
     tmp = biffGet("test3");
     COMPARE(7);
   }
diff --color -ruN teem-1.11.0-src.orig/Testing/CMakeLists.txt teem-1.11.0-src/Testing/CMakeLists.txt
--- teem-1.11.0-src.orig/Testing/CMakeLists.txt	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images             .
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -21,16 +21,7 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-PROJECT(TEEMTesting)
-
-IF(Teem_BINARY_DIR)
-  # We are building inside the tree
-  IF(NOT EXECUTABLE_OUTPUT_PATH)
-    SET (EXECUTABLE_OUTPUT_PATH ${Teem_BINARY_DIR} CACHE PATH
-         "Single output directory for building all testing executables.")
-    SET(C_TEST_PATH ${Teem_BINARY_DIR})
-  ENDIF(NOT EXECUTABLE_OUTPUT_PATH)
-ENDIF(Teem_BINARY_DIR)
+project(TEEMTesting)
 
 # Create a header file with the path to the data in it.  Note that we don't
 # have to make these paths "windows friendly" as it turns out windows can read
@@ -47,30 +38,30 @@
 # This just runs nrrdSanity as test called "nrrd.Sanity"
 # We don't do the same for airSanity because that's an
 # "experimental app" . . .
-ADD_TEST(nrrd.Sanity ${EXECUTABLE_OUTPUT_PATH}/nrrdSanity)
+add_test(NAME nrrd.Sanity COMMAND $<TARGET_FILE:nrrdSanity>)
 
 # Hope to eventually have tests in all directories; until then
 # many of these are commented out. (TEEM_LIB_LIST)
-ADD_SUBDIRECTORY(air)
-# ADD_SUBDIRECTORY(hest)
-ADD_SUBDIRECTORY(biff)
-ADD_SUBDIRECTORY(nrrd)
-# ADD_SUBDIRECTORY(ell)
-ADD_SUBDIRECTORY(unrrdu)
-# ADD_SUBDIRECTORY(alan)
-# ADD_SUBDIRECTORY(moss)
-# ADD_SUBDIRECTORY(tijk)
-ADD_SUBDIRECTORY(gage)
-# ADD_SUBDIRECTORY(dye)
-# ADD_SUBDIRECTORY(bane)
-# ADD_SUBDIRECTORY(limn)
-# ADD_SUBDIRECTORY(echo)
-# ADD_SUBDIRECTORY(hoover)
-# ADD_SUBDIRECTORY(seek)
-ADD_SUBDIRECTORY(ten)
-# ADD_SUBDIRECTORY(elf)
-# ADD_SUBDIRECTORY(pull)
-# ADD_SUBDIRECTORY(coil)
-# ADD_SUBDIRECTORY(push)
-# ADD_SUBDIRECTORY(mite)
-ADD_SUBDIRECTORY(meet)
+add_subdirectory(air)
+# add_subdirectory(hest)
+add_subdirectory(biff)
+add_subdirectory(nrrd)
+# add_subdirectory(ell)
+add_subdirectory(unrrdu)
+# add_subdirectory(alan)
+# add_subdirectory(moss)
+# add_subdirectory(tijk)
+add_subdirectory(gage)
+# add_subdirectory(dye)
+# add_subdirectory(bane)
+# add_subdirectory(limn)
+# add_subdirectory(echo)
+# add_subdirectory(hoover)
+# add_subdirectory(seek)
+add_subdirectory(ten)
+# add_subdirectory(elf)
+# add_subdirectory(pull)
+# add_subdirectory(coil)
+# add_subdirectory(push)
+# add_subdirectory(mite)
+add_subdirectory(meet)
diff --color -ruN teem-1.11.0-src.orig/Testing/gage/CMakeLists.txt teem-1.11.0-src/Testing/gage/CMakeLists.txt
--- teem-1.11.0-src.orig/Testing/gage/CMakeLists.txt	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/gage/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images             .
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -21,14 +21,18 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-ADD_EXECUTABLE(test_probeScl probeScl.c)
-TARGET_LINK_LIBRARIES(test_probeScl teem)
-ADD_TEST(probeScl ${EXECUTABLE_OUTPUT_PATH}/test_probeScl)
+add_executable(test_sbp tsbp.c)
+target_link_libraries(test_sbp teem)
+add_test(NAME stackBlurParm COMMAND $<TARGET_FILE:test_sbp> -sbp 0-5-4.2)
 
-ADD_EXECUTABLE(test_probePolynomial probePolynomial.c)
-TARGET_LINK_LIBRARIES(test_probePolynomial teem)
-ADD_TEST(probePolynomial ${EXECUTABLE_OUTPUT_PATH}/test_probePolynomial)
+add_executable(test_probeScl probeScl.c)
+target_link_libraries(test_probeScl teem)
+add_test(NAME probeScl COMMAND $<TARGET_FILE:test_probeScl>)
 
-ADD_EXECUTABLE(test_probeMulti probeMulti.c)
-TARGET_LINK_LIBRARIES(test_probeMulti teem)
-ADD_TEST(probeMulti ${EXECUTABLE_OUTPUT_PATH}/test_probeMulti)
+add_executable(test_probePolynomial probePolynomial.c)
+target_link_libraries(test_probePolynomial teem)
+add_test(NAME probePolynomial COMMAND $<TARGET_FILE:test_probePolynomial>)
+
+add_executable(test_probeMulti probeMulti.c)
+target_link_libraries(test_probeMulti teem)
+add_test(NAME probeMulti COMMAND $<TARGET_FILE:test_probeMulti>)
diff --color -ruN teem-1.11.0-src.orig/Testing/gage/probeMulti.c teem-1.11.0-src/Testing/gage/probeMulti.c
--- teem-1.11.0-src.orig/Testing/gage/probeMulti.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/gage/probeMulti.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -46,7 +46,7 @@
 
 
 int
-main(int argc, const char **argv) {
+main() {
   airArray *mop, *submop;
   char *err;
 
diff --color -ruN teem-1.11.0-src.orig/Testing/gage/probePolynomial.c teem-1.11.0-src/Testing/gage/probePolynomial.c
--- teem-1.11.0-src.orig/Testing/gage/probePolynomial.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/gage/probePolynomial.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -202,7 +202,7 @@
 }
 
 int
-main(int argc, const char **argv) {
+main() {
   airArray *mop;
   char *err;
 
@@ -213,7 +213,6 @@
   const double *vmeas, *gmeas, *hmeas;
   gageContext *gctx;
 
-  AIR_UNUSED(argc);
   mop = airMopNew();
 
   rng = airRandMTStateNew(429);
diff --color -ruN teem-1.11.0-src.orig/Testing/gage/probeScl.c teem-1.11.0-src/Testing/gage/probeScl.c
--- teem-1.11.0-src.orig/Testing/gage/probeScl.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/gage/probeScl.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -40,39 +40,16 @@
   airArray *mop;
   char *fullname;
   gageContext *igctx[INTERP_KERN_NUM], *bgctx[BLUR_KERN_NUM];
-  const NrrdKernel *ikern[INTERP_KERN_NUM] = {
-    nrrdKernelBox,
-    nrrdKernelTent,
-    nrrdKernelBCCubic,
-    nrrdKernelCatmullRom,
-  };
+  const NrrdKernel *ikern[INTERP_KERN_NUM];
   double ikparm[INTERP_KERN_NUM][NRRD_KERNEL_PARMS_NUM] = {
     {1.0},
     {1.0},
     {1.0, 0.0, 0.5},
     {AIR_NAN},
   };
-  const NrrdKernel *bkern[BLUR_KERN_NUM] = {
-    nrrdKernelTent,
-    nrrdKernelBSpline3,
-    nrrdKernelBSpline5,
-    nrrdKernelBCCubic,
-    nrrdKernelGaussian,
-  };
-  const NrrdKernel *bkernD[BLUR_KERN_NUM] = {
-    nrrdKernelForwDiff,
-    nrrdKernelBSpline3D,
-    nrrdKernelBSpline5D,
-    nrrdKernelBCCubicD,
-    nrrdKernelGaussianD,
-  };
-  const NrrdKernel *bkernDD[BLUR_KERN_NUM] = {
-    nrrdKernelZero,
-    nrrdKernelBSpline3DD,
-    nrrdKernelBSpline5DD,
-    nrrdKernelBCCubicDD,
-    nrrdKernelGaussianDD,
-  };
+  const NrrdKernel *bkern[BLUR_KERN_NUM];
+  const NrrdKernel *bkernD[BLUR_KERN_NUM];
+  const NrrdKernel *bkernDD[BLUR_KERN_NUM];
   double bkparm[BLUR_KERN_NUM][NRRD_KERNEL_PARMS_NUM] = {
     {1.0},
     {AIR_NAN},
@@ -85,6 +62,27 @@
   int E;
   unsigned int sx, sy, sz, ki;
 
+  /* C89 doesn't allow setting these in array declaration */
+  ikern[0] = nrrdKernelBox;
+  ikern[1] = nrrdKernelTent;
+  ikern[2] = nrrdKernelBCCubic;
+  ikern[3] = nrrdKernelCatmullRom;
+  bkern[0] = nrrdKernelTent;
+  bkern[1] = nrrdKernelBSpline3;
+  bkern[2] = nrrdKernelBSpline5;
+  bkern[3] = nrrdKernelBCCubic;
+  bkern[4] = nrrdKernelGaussian;
+  bkernD[0] = nrrdKernelForwDiff;
+  bkernD[1] = nrrdKernelBSpline3D;
+  bkernD[2] = nrrdKernelBSpline5D;
+  bkernD[3] = nrrdKernelBCCubicD;
+  bkernD[4] = nrrdKernelGaussianD;
+  bkernDD[0] = nrrdKernelZero;
+  bkernDD[1] = nrrdKernelBSpline3DD;
+  bkernDD[2] = nrrdKernelBSpline5DD;
+  bkernDD[3] = nrrdKernelBCCubicDD;
+  bkernDD[4] = nrrdKernelGaussianDD;
+
   AIR_UNUSED(argc);
   me = argv[0];
   mop = airMopNew();
diff --color -ruN teem-1.11.0-src.orig/Testing/gage/tsbp.c teem-1.11.0-src/Testing/gage/tsbp.c
--- teem-1.11.0-src.orig/Testing/gage/tsbp.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/Testing/gage/tsbp.c	2021-02-18 15:42:38.000000000 +0800
@@ -0,0 +1,170 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "teem/gage.h"
+
+/*
+** Tests:
+** gageStackBlurParmParse
+** gageStackBlurParmSprint
+** gageHestStackBlurParm
+** gageStackBlurParmCompare
+*/
+
+/* experimenting with globals for the sake of simplifying tests */
+int extraFlag[256];
+char *extraParm;
+gageStackBlurParm *sbp, *sbq;
+airArray *mop;
+char *err;
+char buff[AIR_STRLEN_LARGE];
+
+void
+parseFailOrDie(const char *str) {
+  static const char me[]="parseFailOrDie";
+
+  fprintf(stderr, "%s(\"%s\"): ", me, str);
+  if (!gageStackBlurParmParse(sbp, extraFlag, &extraParm, str)) {
+    fprintf(stderr, "problem did NOT fail!\n");
+    airMopError(mop); exit(1);
+  }
+  /* else good, we got an error */
+  airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
+  fprintf(stderr, "did get error: %s", err);
+  return;
+}
+
+void
+parseOrDie(const char *str) {
+  static const char me[]="parseOrDie";
+  int differ;
+  char explain[AIR_STRLEN_LARGE]="!explain_not_set!";
+
+  if (gageStackBlurParmParse(sbp, extraFlag, &extraParm, str)
+      || gageStackBlurParmSprint(buff, sbp, extraFlag, extraParm)) {
+    airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
+    fprintf(stderr, "%s: failed to parse \"%s\" or then sprint: %s\n",
+            me, str, err);
+    airMopError(mop); exit(1);
+  }
+  if (gageStackBlurParmParse(sbq, extraFlag, &extraParm, str)) {
+    airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
+    fprintf(stderr, "%s: failed to parse \"%s\": %s\n", me, str, err);
+    airMopError(mop); exit(1);
+  }
+  /* can tweak sbq here to make sure compare is working */
+  /*
+  sbp->kspec = nrrdKernelSpecNew();
+  nrrdKernelSpecParse(sbp->kspec, "cubic:1,1,0");
+  sbq->kspec = nrrdKernelSpecNew();
+  nrrdKernelSpecParse(sbq->kspec, "gauss:1,5");
+  */
+  /*
+  sbp->bspec = nrrdBoundarySpecNew();
+  sbq->bspec = nrrdBoundarySpecNew();
+  nrrdBoundarySpecParse(sbp->bspec, "pad:3");
+  nrrdBoundarySpecParse(sbq->bspec, "pad:2");
+  */
+  if (gageStackBlurParmCompare(sbp, "first", sbq, "second",
+                               &differ, explain)) {
+    airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
+    fprintf(stderr, "%s: failed to compare: %s", me, err);
+    airMopError(mop); exit(1);
+  }
+  if (differ) {
+    fprintf(stderr, "%s: two sbps from same string differ: %s\n",
+            me, explain);
+    airMopError(mop); exit(1);
+  }
+  printf("%s: \"%s\" -> \"%s\"\n", me, str, buff);
+  gageStackBlurParmInit(sbp);
+  gageStackBlurParmInit(sbq);
+  return;
+}
+
+static const char *sbpInfo =
+  "for testing handling of stack blur parms";
+int
+main(int argc, const char **argv) {
+  /* stock variables */
+  const char *me;
+  hestOpt *hopt=NULL;
+  hestParm *hparm;
+  /* variables specific to this program */
+  gageStackBlurParm **sbpv;
+  unsigned int sbpNum, sbpIdx;
+
+  me = argv[0];
+  mop = airMopNew();
+  hparm = hestParmNew();
+  airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);
+  hestOptAdd(&hopt, "sbp", "sbp0", airTypeOther, 1, -1, &sbpv, NULL,
+             "stack blur parms", &sbpNum, NULL, gageHestStackBlurParm);
+  hestParseOrDie(hopt, argc-1, argv+1, hparm, me, sbpInfo,
+                 AIR_TRUE, AIR_TRUE, AIR_TRUE);
+  airMopAdd(mop, hopt, (airMopper)hestOptFree, airMopAlways);
+  airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);
+
+  printf("%s: command line options: ---------- \n", me);
+  for (sbpIdx=0; sbpIdx<sbpNum; sbpIdx++) {
+    if (gageStackBlurParmSprint(buff, sbpv[sbpIdx], NULL, NULL)) {
+      airMopAdd(mop, err = biffGetDone(GAGE), airFree, airMopAlways);
+      fprintf(stderr, "%s: problem with sbpv[%u]:%s", me, sbpIdx, err);
+      airMopError(mop); return 1;
+    }
+    printf("%s: sbp[%u] = \"%s\"\n", me, sbpIdx, buff);
+  }
+  printf("\n");
+
+  sbp = gageStackBlurParmNew();
+  airMopAdd(mop, sbp, (airMopper)gageStackBlurParmNix, airMopAlways);
+  sbq = gageStackBlurParmNew();
+  airMopAdd(mop, sbq, (airMopper)gageStackBlurParmNix, airMopAlways);
+
+  printf("%s: testing various broken strings ---------- \n", me);
+  parseFailOrDie("0-8");
+  parseFailOrDie("0-8-joe");
+  parseFailOrDie("0-n-8.3");
+  parseFailOrDie("0-n-8.3-r");
+  parseFailOrDie("0-4-8.3-uo");
+  parseFailOrDie("0-4-8.3-u+4");
+  parseFailOrDie("0-4-8.3-u/k=bingo");
+  parseFailOrDie("0-4-8.3-u/k=dg:1,5/b=bingo");
+  parseFailOrDie("0-4-8.3-u/k=dg:1,5/b=pad:joe");
+  parseFailOrDie("0-4-8.3-u/k=dg:1,5/b=pad:0/v=n");
+  parseFailOrDie("0-4-8.3-u/k=dg:1,5/b=pad:0/v=1/s=optiL2");
+  parseFailOrDie("0-4-8.3/k=dg:1,5/b=pad:0/v=1/s=optiL2/dggsm=bingo");
+  printf("\n");
+
+  printf("%s: testing various okay strings ---------- \n", me);
+  parseOrDie("0-4-8.3");
+  parseOrDie("0-4-8-o");
+  parseOrDie("0-4-8.3-u");
+  parseOrDie("0-4-8.3-u1rpn/k=dg:1,5");
+  parseOrDie("0-4-8.3-u1rpn/k=dg:1,5/b=pad:42/v=1/dggsm=8");
+  printf("\n");
+
+  airMopOkay(mop);
+  printf("%s: all okay!\n", me);
+  return 0;
+}
diff --color -ruN teem-1.11.0-src.orig/Testing/meet/buildinfo.c teem-1.11.0-src/Testing/meet/buildinfo.c
--- teem-1.11.0-src.orig/Testing/meet/buildinfo.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/meet/buildinfo.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/Testing/meet/CMakeLists.txt teem-1.11.0-src/Testing/meet/CMakeLists.txt
--- teem-1.11.0-src.orig/Testing/meet/CMakeLists.txt	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/meet/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images             .
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -21,25 +21,25 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-ADD_EXECUTABLE(test_enmall enmall.c)
-TARGET_LINK_LIBRARIES(test_enmall teem)
-ADD_TEST(enmall ${EXECUTABLE_OUTPUT_PATH}/test_enmall)
+add_executable(test_enmall enmall.c)
+target_link_libraries(test_enmall teem)
+add_test(NAME enmall COMMAND $<TARGET_FILE:test_enmall>)
 
-ADD_EXECUTABLE(test_kernall kernall.c)
-TARGET_LINK_LIBRARIES(test_kernall teem)
-ADD_TEST(kernall ${EXECUTABLE_OUTPUT_PATH}/test_kernall)
+add_executable(test_kernall kernall.c)
+target_link_libraries(test_kernall teem)
+add_test(NAME kernall COMMAND $<TARGET_FILE:test_kernall>)
 
-ADD_EXECUTABLE(test_buildinfo buildinfo.c)
-TARGET_LINK_LIBRARIES(test_buildinfo teem)
-ADD_TEST(buildinfo ${EXECUTABLE_OUTPUT_PATH}/test_buildinfo)
+add_executable(test_buildinfo buildinfo.c)
+target_link_libraries(test_buildinfo teem)
+add_test(NAME buildinfo COMMAND $<TARGET_FILE:test_buildinfo>)
 
-ADD_EXECUTABLE(test_probeSS probeSS.c)
-TARGET_LINK_LIBRARIES(test_probeSS teem)
-ADD_TEST(probeSS_box01 ${EXECUTABLE_OUTPUT_PATH}/test_probeSS -k box -supp 1.0 -pnum 1500)
-ADD_TEST(probeSS_cos01 ${EXECUTABLE_OUTPUT_PATH}/test_probeSS -k cos -supp 1.0 -pnum 1500)
-ADD_TEST(probeSS_cos02 ${EXECUTABLE_OUTPUT_PATH}/test_probeSS -k cos -supp 2.0 -pnum 1200)
-ADD_TEST(probeSS_cos04 ${EXECUTABLE_OUTPUT_PATH}/test_probeSS -k cos -supp 4.0 -pnum 1000)
-ADD_TEST(probeSS_cos10 ${EXECUTABLE_OUTPUT_PATH}/test_probeSS -k cos -supp 9.0 -pnum 800)
-ADD_TEST(probeSS_ctmr02 ${EXECUTABLE_OUTPUT_PATH}/test_probeSS -k ctmr -supp 2.0 -pnum 1300)
-ADD_TEST(probeSS_ctmr04 ${EXECUTABLE_OUTPUT_PATH}/test_probeSS -k ctmr -supp 4.0 -pnum 1300)
-ADD_TEST(probeSS_ctmr10 ${EXECUTABLE_OUTPUT_PATH}/test_probeSS -k ctmr -supp 9.0 -pnum 1300)
+add_executable(test_probeSS probeSS.c)
+target_link_libraries(test_probeSS teem)
+add_test(NAME probeSS_box01 COMMAND $<TARGET_FILE:test_probeSS> -k box -supp 1.0 -pnum 1500)
+add_test(NAME probeSS_cos01 COMMAND $<TARGET_FILE:test_probeSS> -k cos -supp 1.0 -pnum 1500)
+add_test(NAME probeSS_cos02 COMMAND $<TARGET_FILE:test_probeSS> -k cos -supp 2.0 -pnum 1200)
+add_test(NAME probeSS_cos04 COMMAND $<TARGET_FILE:test_probeSS> -k cos -supp 4.0 -pnum 1000)
+add_test(NAME probeSS_cos10 COMMAND $<TARGET_FILE:test_probeSS> -k cos -supp 9.0 -pnum 800)
+add_test(NAME probeSS_ctmr02 COMMAND $<TARGET_FILE:test_probeSS> -k ctmr -supp 2.0 -pnum 1300)
+add_test(NAME probeSS_ctmr04 COMMAND $<TARGET_FILE:test_probeSS> -k ctmr -supp 4.0 -pnum 1300)
+add_test(NAME probeSS_ctmr10 COMMAND $<TARGET_FILE:test_probeSS> -k ctmr -supp 9.0 -pnum 1300)
diff --color -ruN teem-1.11.0-src.orig/Testing/meet/enmall.c teem-1.11.0-src/Testing/meet/enmall.c
--- teem-1.11.0-src.orig/Testing/meet/enmall.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/meet/enmall.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/Testing/meet/kernall.c teem-1.11.0-src/Testing/meet/kernall.c
--- teem-1.11.0-src.orig/Testing/meet/kernall.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/meet/kernall.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/Testing/meet/probeSS.c teem-1.11.0-src/Testing/meet/probeSS.c
--- teem-1.11.0-src.orig/Testing/meet/probeSS.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/meet/probeSS.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -56,12 +56,14 @@
 #define KI_TEN 2
 #define KI_DWI 3
 
+/*
 static const char *kindStr[KIND_NUM] = {
   "scalar",
   "vector",
   "tensor",
   "  DWI "
 };
+*/
 
 #define HALTON_BASE 100
 
@@ -744,7 +746,7 @@
     tenDiff[7], tenAvg[7], tenErr, tenErrMax,
     vecDiff[3], vecAvg[3], vecErr, vecErrMax, vecErrNum,
     sclDiff, sclAvg, sclErr, sclErrMax, errNumFrac;
-  const double *dwiTenEstP, dwiTenEstNorm,
+  const double *dwiTenEstP,
     *tenTenP, *tenTenNormP, *tenTenNormGradP,
     *sclSclP, *sclGradP, *vecVecP;
 
@@ -891,9 +893,7 @@
   hestParm *hparm;
   airArray *mop;
 
-  const gageKind *kind[KIND_NUM] = {
-    /*    0            1           2         3          */
-    gageKindScl, gageKindVec, tenGageKind, NULL /* dwi */};
+  const gageKind *kind[KIND_NUM];
   char name[KIND_NUM][AIR_STRLEN_SMALL] = { "scl", "vec", "ten", "dwi" };
   char nameComp[KIND_NUM][AIR_STRLEN_SMALL] = { "sclComp", "vecComp", "tenComp", "dwiComp" };
   char *kernS;
@@ -912,6 +912,11 @@
                      a big reconstruction error */
   NrrdKernel *kpack[3];
 
+  kind[0] = gageKindScl;
+  kind[1] = gageKindVec;
+  kind[2] = tenGageKind;
+  kind[3] = NULL; /* dwi */
+
   me = argv[0];
   mop = airMopNew();
   hparm = hestParmNew();
diff --color -ruN teem-1.11.0-src.orig/Testing/nrrd/CMakeLists.txt teem-1.11.0-src/Testing/nrrd/CMakeLists.txt
--- teem-1.11.0-src.orig/Testing/nrrd/CMakeLists.txt	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/nrrd/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images             .
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -21,28 +21,32 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-ADD_EXECUTABLE(test_trand trand.c)
-TARGET_LINK_LIBRARIES(test_trand teem)
-ADD_TEST(trand ${EXECUTABLE_OUTPUT_PATH}/test_trand)
-
-ADD_EXECUTABLE(test_tload tload.c)
-TARGET_LINK_LIBRARIES(test_tload teem)
-ADD_TEST(tload ${EXECUTABLE_OUTPUT_PATH}/test_tload)
+add_executable(test_trand trand.c)
+target_link_libraries(test_trand teem)
+add_test(NAME trand COMMAND $<TARGET_FILE:test_trand>)
 
-ADD_EXECUTABLE(test_tskip tskip.c)
-TARGET_LINK_LIBRARIES(test_tskip teem)
+add_executable(test_tload tload.c)
+target_link_libraries(test_tload teem)
+add_test(NAME tload COMMAND $<TARGET_FILE:test_tload>)
+
+add_executable(test_tskip tskip.c)
+target_link_libraries(test_tskip teem)
 # Note the different file names; tests are run in parallel
-ADD_TEST(tskip11p ${EXECUTABLE_OUTPUT_PATH}/test_tskip -s 101 102 103 -p 66 81     -o tsA.raw tsA.nhdr)
-ADD_TEST(tskip11n ${EXECUTABLE_OUTPUT_PATH}/test_tskip -s 101 102 103 -p 66 81 -ns -o tsB.raw tsB.nhdr)
-ADD_TEST(tskip01p ${EXECUTABLE_OUTPUT_PATH}/test_tskip -s 101 102 103 -p 0 99      -o tsC.raw tsC.nhdr)
-ADD_TEST(tskip01n ${EXECUTABLE_OUTPUT_PATH}/test_tskip -s 101 102 103 -p 0 99 -ns  -o tsD.raw tsD.nhdr)
-ADD_TEST(tskip10p ${EXECUTABLE_OUTPUT_PATH}/test_tskip -s 101 102 103 -p 77 0      -o tsE.raw tsE.nhdr)
-ADD_TEST(tskip10n ${EXECUTABLE_OUTPUT_PATH}/test_tskip -s 101 102 103 -p 77 0 -ns  -o tsF.raw tsF.nhdr)
-
-ADD_EXECUTABLE(test_sanity sanity.c)
-TARGET_LINK_LIBRARIES(test_sanity teem)
-ADD_TEST(sanity ${EXECUTABLE_OUTPUT_PATH}/test_sanity)
-
-ADD_EXECUTABLE(test_macros macros.c)
-TARGET_LINK_LIBRARIES(test_macros teem)
-ADD_TEST(macros ${EXECUTABLE_OUTPUT_PATH}/test_macros)
+add_test(NAME tskip11p COMMAND $<TARGET_FILE:test_tskip> -s 101 102 103 -p 66 81     -o tsA.raw tsA.nhdr)
+add_test(NAME tskip11n COMMAND $<TARGET_FILE:test_tskip> -s 101 102 103 -p 66 81 -ns -o tsB.raw tsB.nhdr)
+add_test(NAME tskip01p COMMAND $<TARGET_FILE:test_tskip> -s 101 102 103 -p 0 99      -o tsC.raw tsC.nhdr)
+add_test(NAME tskip01n COMMAND $<TARGET_FILE:test_tskip> -s 101 102 103 -p 0 99 -ns  -o tsD.raw tsD.nhdr)
+add_test(NAME tskip10p COMMAND $<TARGET_FILE:test_tskip> -s 101 102 103 -p 77 0      -o tsE.raw tsE.nhdr)
+add_test(NAME tskip10n COMMAND $<TARGET_FILE:test_tskip> -s 101 102 103 -p 77 0 -ns  -o tsF.raw tsF.nhdr)
+
+add_executable(test_sanity sanity.c)
+target_link_libraries(test_sanity teem)
+add_test(NAME sanity COMMAND $<TARGET_FILE:test_sanity>)
+
+add_executable(test_macros macros.c)
+target_link_libraries(test_macros teem)
+add_test(NAME macros COMMAND $<TARGET_FILE:test_macros>)
+
+add_executable(test_bspec tbspec.c)
+target_link_libraries(test_bspec teem)
+add_test(NAME bspec COMMAND $<TARGET_FILE:test_bspec> -bs bleed wrap pad:42)
diff --color -ruN teem-1.11.0-src.orig/Testing/nrrd/macros.c teem-1.11.0-src/Testing/nrrd/macros.c
--- teem-1.11.0-src.orig/Testing/nrrd/macros.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/nrrd/macros.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -32,7 +32,7 @@
 */
 
 int
-main(int argc, char *argv[]) {
+main() {
   size_t II, *coord0, *ctmp0, *size0,
     coord1[1], ctmp1[1], size1[1],
     coord2[2], ctmp2[2], size2[2],
diff --color -ruN teem-1.11.0-src.orig/Testing/nrrd/sanity.c teem-1.11.0-src/Testing/nrrd/sanity.c
--- teem-1.11.0-src.orig/Testing/nrrd/sanity.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/nrrd/sanity.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/Testing/nrrd/tbspec.c teem-1.11.0-src/Testing/nrrd/tbspec.c
--- teem-1.11.0-src.orig/Testing/nrrd/tbspec.c	1970-01-01 08:00:00.000000000 +0800
+++ teem-1.11.0-src/Testing/nrrd/tbspec.c	2021-02-18 15:42:38.000000000 +0800
@@ -0,0 +1,167 @@
+/*
+  Teem: Tools to process and visualize scientific data and images             .
+  Copyright (C) 2009--2019  University of Chicago
+  Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
+  Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public License
+  (LGPL) as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+  The terms of redistributing and/or modifying this software also
+  include exceptions to the LGPL that facilitate static linking.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "teem/nrrd.h"
+
+/*
+** Tests:
+** nrrdBoundarySpecNew
+** nrrdBoundarySpecNix
+** nrrdBoundarySpecParse
+** nrrdBoundarySpecSprint
+** nrrdBoundarySpecCheck
+** nrrdHestBoundarySpec
+*/
+
+void
+checkFailOrDie(const NrrdBoundarySpec *bspec, airArray *mop) {
+  static const char me[]="checkFailOrDie";
+  char *err;
+
+  if (!nrrdBoundarySpecCheck(bspec)) {
+    /* what, no error? */
+    fprintf(stderr, "%s: did not get expected check failure!\n", me);
+    airMopError(mop);
+    exit(1);
+  }
+  /* good, there's an error */
+  err = biffGetDone(NRRD);
+  airMopAdd(mop, err, airFree, airMopAlways);
+  fprintf(stderr, "(expecting error): %s", err);
+  return;
+}
+
+void
+parseFailOrDie(NrrdBoundarySpec *bspec, const char *str, airArray *mop) {
+  static const char me[]="parseFailOrDie";
+  char *err;
+
+  if (!nrrdBoundarySpecParse(bspec, str)) {
+    /* what, no error? */
+    fprintf(stderr, "%s: did not get expected parse fail on \"%s\"\n", me, str);
+    airMopError(mop);
+    exit(1);
+  }
+  /* good, there's an error */
+  err = biffGetDone(NRRD);
+  airMopAdd(mop, err, airFree, airMopAlways);
+  fprintf(stderr, "(expecting error): %s", err);
+  return;
+}
+
+/*
+** yes, the equality check should really be on boundary specs,
+** not on the strings, but that isn't implemented yet
+*/
+void
+psLoopOrDie(NrrdBoundarySpec *bsp, const char *str,
+                     airArray *mop) {
+  static const char me[]="psLoopOrDie";
+  char *err;
+  char buff[AIR_STRLEN_LARGE];
+
+  if (nrrdBoundarySpecParse(bsp, str)
+      || nrrdBoundarySpecSprint(buff, bsp)) {
+    err = biffGetDone(NRRD);
+    airMopAdd(mop, err, airFree, airMopAlways);
+    fprintf(stderr, "%s: error: %s", me, err);
+    airMopError(mop);
+    exit(1);
+  }
+  if (strcmp(str, buff)) {
+    fprintf(stderr, "%s: parse->sprint->\"%s\" != given \"%s\"\n", me,
+            buff, str);
+    airMopError(mop);
+    exit(1);
+  }
+  fprintf(stderr, "(looped okay): %s\n", str);
+  return;
+}
+
+static const char *tbspecInfo =
+  "for testing handling of boundary specifications";
+
+int
+main(int argc, const char *argv[]) {
+  /* stock variables */
+  const char *me;
+  hestOpt *hopt=NULL;
+  hestParm *hparm;
+  airArray *mop;
+  /* variables specific to this program */
+  char *err;
+  NrrdBoundarySpec *bspec, **bsv;
+  unsigned int bsNum, bsIdx;
+  char buff[AIR_STRLEN_LARGE];
+
+  me = argv[0];
+  mop = airMopNew();
+  hparm = hestParmNew();
+  airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);
+  hestOptAdd(&hopt, "bs", "bspec0", airTypeOther, 1, -1, &bsv, NULL,
+             "bspecs", &bsNum, NULL, nrrdHestBoundarySpec);
+  hestParseOrDie(hopt, argc-1, argv+1, hparm, me, tbspecInfo,
+                 AIR_TRUE, AIR_TRUE, AIR_TRUE);
+  airMopAdd(mop, hopt, (airMopper)hestOptFree, airMopAlways);
+  airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);
+
+  printf("command line options:\n");
+  for (bsIdx=0; bsIdx<bsNum; bsIdx++) {
+    if (nrrdBoundarySpecSprint(buff, bsv[bsIdx])) {
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: problem with bsv[%u]:%s", me, bsIdx, err);
+      airMopError(mop); return 1;
+    }
+    printf("%s: bspec[%u] = %s\n", me, bsIdx, buff);
+  }
+
+  bspec = nrrdBoundarySpecNew();
+  airMopAdd(mop, bspec, (airMopper)nrrdBoundarySpecNix, airMopAlways);
+
+  fprintf(stderr, "%s: bogus value\n", me);
+  bspec->boundary = -10;
+  checkFailOrDie(bspec, mop);
+
+  fprintf(stderr, "%s: pad with bogus padValue\n", me);
+  bspec->boundary = nrrdBoundaryPad;
+  bspec->padValue = AIR_POS_INF;
+  checkFailOrDie(bspec, mop);
+
+  fprintf(stderr, "%s: checking parse failures\n", me);
+  parseFailOrDie(bspec, "bingo", mop);
+  parseFailOrDie(bspec, "wrap:10", mop);
+  parseFailOrDie(bspec, "pad", mop);
+  parseFailOrDie(bspec, "pad:nan", mop);
+  parseFailOrDie(bspec, "pad:bob", mop);
+
+  fprintf(stderr, "%s: checking string->bpsec->string\n", me);
+  psLoopOrDie(bspec, airEnumStr(nrrdBoundary, nrrdBoundaryBleed), mop);
+  psLoopOrDie(bspec, airEnumStr(nrrdBoundary, nrrdBoundaryWrap), mop);
+  psLoopOrDie(bspec, airEnumStr(nrrdBoundary, nrrdBoundaryWeight), mop);
+  psLoopOrDie(bspec, airEnumStr(nrrdBoundary, nrrdBoundaryMirror), mop);
+  psLoopOrDie(bspec, "pad:0", mop);
+  psLoopOrDie(bspec, "pad:3", mop);
+
+  airMopOkay(mop);
+  return 0;
+}
diff --color -ruN teem-1.11.0-src.orig/Testing/nrrd/tload.c teem-1.11.0-src/Testing/nrrd/tload.c
--- teem-1.11.0-src.orig/Testing/nrrd/tload.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/nrrd/tload.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/Testing/nrrd/trand.c teem-1.11.0-src/Testing/nrrd/trand.c
--- teem-1.11.0-src.orig/Testing/nrrd/trand.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/nrrd/trand.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -39,20 +39,28 @@
 #define BINS 1000
 #define HGHT 1000
 
-/* have to use PGM format for image because Teem might
-   not have been built with PNG */
-#define THISNAME "histo.pgm"
-#define CORRNAME "test/trandhisto.pgm"
-
 int
 main(int argc, const char *argv[]) {
   const char *me;
   size_t vi, ii, qvalLen;
-  Nrrd *nval, *nhist, *nimg, *nread, *ncorr;
+  Nrrd *nval, *nhist, *nimg, *nread, *ncorr, *ninmem[3];
   double aa, bb, *val;
   airArray *mop;
-  char *corrname, explain[AIR_STRLEN_LARGE];
-  int differ;
+  char *name, explain[AIR_STRLEN_LARGE];
+#define VALS 0
+#define HIST 1
+#define IMAG 2
+  /* PGM image since this Teem build might not support PNG */
+  static const char * const mine[3] = { "vals.nrrd",
+                    "histo.nrrd",
+                    "histo.pgm" };
+  static const char * const corr[3] = { "test/trandvals.nrrd",
+                    "test/trandhisto.nrrd",
+                    "test/trandhisto.pgm"};
+  static const char * const what[3] = { "value",
+                    "histogram",
+                    "histogram image" };
+  int differ, wi;
 
   AIR_UNUSED(argc);
   me = argv[0];
@@ -63,63 +71,91 @@
   airMopAdd(mop, nval, (airMopper)nrrdNuke, airMopAlways);
   val = AIR_CAST(double*, nval->data);
 
+  nhist=nrrdNew();
+  airMopAdd(mop, nhist, (airMopper)nrrdNuke, airMopAlways);
+  nimg=nrrdNew();
+  airMopAdd(mop, nimg, (airMopper)nrrdNuke, airMopAlways);
+  nread = nrrdNew();
+  airMopAdd(mop, nread, (airMopper)nrrdNuke, airMopAlways);
+  ncorr = nrrdNew();
+  airMopAdd(mop, ncorr, (airMopper)nrrdNuke, airMopAlways);
+
   airSrandMT(999);
   vi = 0;
+  /* without first casting to float, the platform-dependent
+     differences in the values from airNormalRand() would
+     lead to testing errors, e.g.:
+     correct (test/trandvals.nrrd) and generated values differ:
+     valA[0]=0.36654774192269141 < valB[0]=0.36654774192269146 by 5.55112e-17
+     Would be nice to figure out exactly what the origin of that is ... */
   for (ii=0; ii<qvalLen; ii++) {
     airNormalRand(&aa, NULL);
-    val[vi++] = aa;
+    val[vi++] = AIR_CAST(float, aa);
   }
   for (ii=0; ii<qvalLen; ii++) {
     airNormalRand(NULL, &bb);
-    val[vi++] = bb;
+    val[vi++] = AIR_CAST(float, bb);
   }
   for (ii=0; ii<qvalLen; ii++) {
     airNormalRand(&aa, &bb);
-    val[vi++] = aa;
-    val[vi++] = bb;
+    val[vi++] = AIR_CAST(float, aa);
+    val[vi++] = AIR_CAST(float, bb);
   }
 
-  nhist=nrrdNew();
-  airMopAdd(mop, nhist, (airMopper)nrrdNuke, airMopAlways);
-  nimg=nrrdNew();
-  airMopAdd(mop, nimg, (airMopper)nrrdNuke, airMopAlways);
-  if (nrrdHisto(nhist, nval, NULL, NULL, BINS, nrrdTypeInt)
+  if (nrrdSave(mine[VALS], nval, NULL)
+      || nrrdHisto(nhist, nval, NULL, NULL, BINS, nrrdTypeInt)
+      || nrrdSave(mine[HIST], nhist, NULL)
       || nrrdHistoDraw(nimg, nhist, HGHT, AIR_TRUE, 0.0)
-      || nrrdSave(THISNAME, nimg, NULL)) {
+      || nrrdSave(mine[IMAG], nimg, NULL)) {
     char *err;
     airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
-    fprintf(stderr, "%s: trouble producing histo:\n%s", me, err);
+    fprintf(stderr, "%s: trouble:\n%s", me, err);
     airMopError(mop); return 1;
   }
 
-  nread = nrrdNew();
-  airMopAdd(mop, nread, (airMopper)nrrdNuke, airMopAlways);
-  ncorr = nrrdNew();
-  airMopAdd(mop, ncorr, (airMopper)nrrdNuke, airMopAlways);
-
-  corrname = testDataPathPrefix(CORRNAME);
-  airMopAdd(mop, corrname, airFree, airMopAlways);
-  if (nrrdLoad(ncorr, corrname, NULL)
-      || nrrdLoad(nread, THISNAME, NULL)) {
-    char *err;
-    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
-    fprintf(stderr, "%s: trouble reading:\n%s", me, err);
-    airMopError(mop); return 1;
-  }
-
-  if (nrrdCompare(ncorr, nread, AIR_FALSE /* onlyData */,
-                  0.0 /* epsilon */, &differ, explain)) {
-    char *err;
-    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
-    fprintf(stderr, "%s: trouble comparing:\n%s", me, err);
-    airMopError(mop); return 1;
-  }
-  if (differ) {
-    fprintf(stderr, "%s: new and correct (%s) images differ: %s\n",
-            me, corrname, explain);
-    airMopError(mop); return 1;
-  } else {
-    printf("%s: all good\n", me);
+  ninmem[VALS] = nval;
+  ninmem[HIST] = nhist;
+  ninmem[IMAG] = nimg;
+  for (wi=0; wi<3; wi++) {
+    name = testDataPathPrefix(corr[wi]);
+    airMopAdd(mop, name, airFree, airMopAlways);
+    if (nrrdLoad(ncorr, name, NULL)
+        || nrrdLoad(nread, mine[wi], NULL)) {
+      char *err;
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: trouble reading %s:\n%s", me, err, what[wi]);
+      airMopError(mop); return 1;
+    }
+    if (nrrdCompare(ninmem[wi], nread, AIR_FALSE /* onlyData */,
+                    0.0 /* epsilon */, &differ, explain)) {
+      char *err;
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: trouble comparing in-mem and from-disk %s:\n%s",
+              me, what[wi], err);
+      airMopError(mop); return 1;
+    }
+    if (differ) {
+      fprintf(stderr, "%s: in-mem and from-disk (%s) %ss differ: %s\n",
+              me, mine[wi], what[wi], explain);
+      airMopError(mop); return 1;
+    } else {
+      printf("%s: good: in-mem and from-disk %ss same\n", me, what[wi]);
+    }
+    if (nrrdCompare(ncorr, nread, AIR_FALSE /* onlyData */,
+                    0.0 /* epsilon */, &differ, explain)) {
+      char *err;
+      airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
+      fprintf(stderr, "%s: trouble comparing correct and generated %s:\n%s",
+              me, what[wi], err);
+      airMopError(mop); return 1;
+    }
+    if (differ) {
+      fprintf(stderr, "%s: correct (%s) and generated %ss differ: %s\n",
+              me, corr[wi], what[wi], explain);
+      airMopError(mop); return 1;
+    } else {
+      printf("%s: good: correct and generated %ss same\n", me, what[wi]);
+    }
   }
 
   airMopOkay(mop);
diff --color -ruN teem-1.11.0-src.orig/Testing/nrrd/tskip.c teem-1.11.0-src/Testing/nrrd/tskip.c
--- teem-1.11.0-src.orig/Testing/nrrd/tskip.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/nrrd/tskip.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
@@ -151,21 +151,21 @@
   }
   fprintf(stderr, "\n");
   if (printbytes) {
-    size_t bi, rpb, nn;
-    char stmp[AIR_STRLEN_SMALL];
-    nn = nrrdElementSize(nref)*nrrdElementNumber(nref);
-    rpb = AIR_MIN(printbytes, nn);
+    size_t bi, rpb, local_nn;
+    char local_stmp[AIR_STRLEN_SMALL];
+    local_nn = nrrdElementSize(nref)*nrrdElementNumber(nref);
+    rpb = AIR_MIN(printbytes, local_nn);
     dataUC = AIR_CAST(unsigned char *, nref->data);
     fprintf(stderr, "CORRECT %s bytes at beginning:\n",
-            airSprintSize_t(stmp, rpb));
+            airSprintSize_t(local_stmp, rpb));
     for (bi=0; bi<rpb; bi++) {
       fprintf(stderr, "%x ", dataUC[bi]);
     }
     fprintf(stderr, "...\n");
     fprintf(stderr, "CORRECT %s bytes at end:\n",
-            airSprintSize_t(stmp, rpb));
+            airSprintSize_t(local_stmp, rpb));
     fprintf(stderr, "...");
-    for (bi=nn - rpb; bi<nn; bi++) {
+    for (bi=local_nn - rpb; bi<local_nn; bi++) {
       fprintf(stderr, " %x", dataUC[bi]);
     }
     fprintf(stderr, "\n");
@@ -212,21 +212,21 @@
     airMopError(mop); return 1;
   }
   if (printbytes) {
-    size_t bi, rpb, nn;
-    char stmp[AIR_STRLEN_SMALL];
-    nn = nrrdElementSize(nin)*nrrdElementNumber(nin);
-    rpb = AIR_MIN(printbytes, nn);
+    size_t bi, rpb, local_nn;
+    char local_stmp[AIR_STRLEN_SMALL];
+    local_nn = nrrdElementSize(nin)*nrrdElementNumber(nin);
+    rpb = AIR_MIN(printbytes, local_nn);
     dataUC = AIR_CAST(unsigned char *, nin->data);
     fprintf(stderr, "FOUND %s bytes at beginning:\n",
-            airSprintSize_t(stmp, rpb));
+            airSprintSize_t(local_stmp, rpb));
     for (bi=0; bi<rpb; bi++) {
       fprintf(stderr, "%x ", dataUC[bi]);
     }
     fprintf(stderr, "...\n");
     fprintf(stderr, "FOUND %s bytes at end:\n",
-            airSprintSize_t(stmp, rpb));
+            airSprintSize_t(local_stmp, rpb));
     fprintf(stderr, "...");
-    for (bi=nn - rpb; bi<nn; bi++) {
+    for (bi=local_nn - rpb; bi<local_nn; bi++) {
       fprintf(stderr, " %x", dataUC[bi]);
     }
     fprintf(stderr, "\n");
diff --color -ruN teem-1.11.0-src.orig/Testing/ten/CMakeLists.txt teem-1.11.0-src/Testing/ten/CMakeLists.txt
--- teem-1.11.0-src.orig/Testing/ten/CMakeLists.txt	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/ten/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images             .
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -21,10 +21,10 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-ADD_EXECUTABLE(test_tendlist tendlist.c)
-TARGET_LINK_LIBRARIES(test_tendlist teem)
-ADD_TEST(tendlist ${EXECUTABLE_OUTPUT_PATH}/test_tendlist)
+add_executable(test_tendlist tendlist.c)
+target_link_libraries(test_tendlist teem)
+add_test(NAME tendlist COMMAND $<TARGET_FILE:test_tendlist>)
 
-ADD_EXECUTABLE(test_glyphBqd glyphBqd.c)
-TARGET_LINK_LIBRARIES(test_glyphBqd teem)
-ADD_TEST(glyphBqd ${EXECUTABLE_OUTPUT_PATH}/test_glyphBqd)
+add_executable(test_glyphBqd glyphBqd.c)
+target_link_libraries(test_glyphBqd teem)
+add_test(NAME glyphBqd COMMAND $<TARGET_FILE:test_glyphBqd>)
diff --color -ruN teem-1.11.0-src.orig/Testing/ten/glyphBqd.c teem-1.11.0-src/Testing/ten/glyphBqd.c
--- teem-1.11.0-src.orig/Testing/ten/glyphBqd.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/ten/glyphBqd.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/Testing/ten/tendlist.c teem-1.11.0-src/Testing/ten/tendlist.c
--- teem-1.11.0-src.orig/Testing/ten/tendlist.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/ten/tendlist.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/Testing/testDataPath.h.in teem-1.11.0-src/Testing/testDataPath.h.in
--- teem-1.11.0-src.orig/Testing/testDataPath.h.in	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/Testing/testDataPath.h.in	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2011  James Bigler
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
diff --color -ruN teem-1.11.0-src.orig/Testing/unrrdu/CMakeLists.txt teem-1.11.0-src/Testing/unrrdu/CMakeLists.txt
--- teem-1.11.0-src.orig/Testing/unrrdu/CMakeLists.txt	2012-12-20 22:11:41.000000000 +0800
+++ teem-1.11.0-src/Testing/unrrdu/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 #
 # Teem: Tools to process and visualize scientific data and images             .
-# Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+# Copyright (C) 2009--2019  University of Chicago
 # Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
 # Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 #
@@ -21,6 +21,6 @@
 # 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 #
 
-ADD_EXECUTABLE(test_unulist unulist.c)
-TARGET_LINK_LIBRARIES(test_unulist teem)
-ADD_TEST(unulist ${EXECUTABLE_OUTPUT_PATH}/test_unulist)
+add_executable(test_unulist unulist.c)
+target_link_libraries(test_unulist teem)
+add_test(NAME unulist COMMAND $<TARGET_FILE:test_unulist>)
diff --color -ruN teem-1.11.0-src.orig/Testing/unrrdu/unulist.c teem-1.11.0-src/Testing/unrrdu/unulist.c
--- teem-1.11.0-src.orig/Testing/unrrdu/unulist.c	2012-12-20 22:11:41.000000000 +0800
+++ teem-1.11.0-src/Testing/unrrdu/unulist.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,6 +1,6 @@
 /*
   Teem: Tools to process and visualize scientific data and images             .
-  Copyright (C) 2012, 2011, 2010, 2009  University of Chicago
+  Copyright (C) 2009--2019  University of Chicago
   Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann
   Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah
 
diff --color -ruN teem-1.11.0-src.orig/UseTeemCMakeDemo/CMakeLists.txt teem-1.11.0-src/UseTeemCMakeDemo/CMakeLists.txt
--- teem-1.11.0-src.orig/UseTeemCMakeDemo/CMakeLists.txt	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/UseTeemCMakeDemo/CMakeLists.txt	2021-02-18 15:42:38.000000000 +0800
@@ -1,13 +1,14 @@
-project (TeemSampleProject)
+project (SampleTeemUsingProject)
 
-cmake_minimum_required(VERSION 2.4)
+cmake_minimum_required(VERSION 3.13...3.15)
 
-if(COMMAND cmake_policy)
-  cmake_policy(SET CMP0003 NEW)
-endif(COMMAND cmake_policy)
+if(${CMAKE_VERSION} VERSION_LESS 3.15)
+    cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})
+else()
+    cmake_policy(VERSION 3.15)
+endif()
 
 find_package(Teem REQUIRED)
-include(${Teem_USE_FILE})
-
-add_executable(sample sanity.c)
-target_link_libraries(sample teem)
+add_executable(sanity sanity.c)
+target_include_directories(sanity PRIVATE ${Teem_INCLUDE_DIRS})
+target_link_libraries(sanity teem)
diff --color -ruN teem-1.11.0-src.orig/UseTeemCMakeDemo/sanity.c teem-1.11.0-src/UseTeemCMakeDemo/sanity.c
--- teem-1.11.0-src.orig/UseTeemCMakeDemo/sanity.c	2012-12-20 22:11:42.000000000 +0800
+++ teem-1.11.0-src/UseTeemCMakeDemo/sanity.c	2021-02-18 15:42:38.000000000 +0800
@@ -1,23 +1,23 @@
 /*
   sanity.c: stand-alone demo of nrrdSanity() from Teem
   Copyright (C) 2008
- 
+
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any
   damages arising from the use of this software.
- 
+
   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:
- 
+
   1. The origin of this software must not be misrepresented; you must
      not claim that you wrote the original software. If you use this
      software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.
- 
+
   2. Altered source versions must be plainly marked as such, and must
      not be misrepresented as being the original software.
- 
+
   3. This notice may not be removed or altered from any source distribution.
 */
 
