From 1afe0ce75004e49e35e8781ea6b8c3134db5511f Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Thu, 21 Jul 2022 06:42:07 -0400
Subject: [PATCH] Backport of 16k page support on aarch64

---
 .../address_space_randomization.h             | 15 ++++++
 .../page_allocator_constants.h                | 50 ++++++++++++++++++-
 .../partition_address_space.cc                |  6 +++
 .../partition_alloc_constants.h               |  5 +-
 .../partition_allocator/partition_root.cc     |  2 +-
 5 files changed, 74 insertions(+), 4 deletions(-)

diff --git a/chromium/base/allocator/partition_allocator/address_space_randomization.h b/chromium/base/allocator/partition_allocator/address_space_randomization.h
index e77003eab25..31ac05b86f5 100644
--- a/chromium/base/allocator/partition_allocator/address_space_randomization.h
+++ b/chromium/base/allocator/partition_allocator/address_space_randomization.h
@@ -119,6 +119,21 @@ AslrMask(uintptr_t bits) {
         return AslrAddress(0x20000000ULL);
       }
 
+      #elif defined(OS_LINUX)
+
+      // Linux on arm64 can use 39, 42, 48, or 52-bit user space, depending on
+      // page size and number of levels of translation pages used. We use
+      // 39-bit as base as all setups should support this, lowered to 38-bit
+      // as ASLROffset() could cause a carry.
+      PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR ALWAYS_INLINE uintptr_t
+      ASLRMask() {
+        return AslrMask(38);
+      }
+      PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR ALWAYS_INLINE uintptr_t
+      ASLROffset() {
+        return AslrAddress(0x1000000000ULL);
+      }
+
       #else
 
       // ARM64 on Linux has 39-bit user space. Use 38 bits since ASLROffset()
diff --git a/chromium/base/allocator/partition_allocator/page_allocator_constants.h b/chromium/base/allocator/partition_allocator/page_allocator_constants.h
index f6f19e41611..200903d3342 100644
--- a/chromium/base/allocator/partition_allocator/page_allocator_constants.h
+++ b/chromium/base/allocator/partition_allocator/page_allocator_constants.h
@@ -24,6 +24,31 @@
 // elimination.
 #define PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR __attribute__((const))
 
+#elif defined(OS_LINUX) && defined(ARCH_CPU_ARM64)
+// This should work for all POSIX (if needed), but currently all other
+// supported OS/architecture combinations use either hard-coded values
+// (such as x86) or have means to determine these values without needing
+// atomics (such as macOS on arm64).
+
+// Page allocator constants are run-time constant
+#define PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR __attribute__((const))
+
+#include <unistd.h>
+#include <atomic>
+
+namespace base::internal {
+
+// Holds the current page size and shift, where size = 1 << shift
+// Use PageAllocationGranularity(), PageAllocationGranularityShift()
+// to initialize and retrieve these values safely.
+struct PageCharacteristics {
+  std::atomic<int> size;
+  std::atomic<int> shift;
+};
+extern PageCharacteristics page_characteristics;
+
+}  // namespace partition_alloc::internal
+
 #else
 
 // When defined, page size constants are fixed at compile time. When not
@@ -38,6 +63,10 @@
 
 namespace base {
 
+// Forward declaration, implementation below
+PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR ALWAYS_INLINE size_t
+PageAllocationGranularity();
+
 PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR ALWAYS_INLINE size_t
 PageAllocationGranularityShift() {
 #if defined(OS_WIN) || defined(ARCH_CPU_PPC64)
@@ -50,6 +79,15 @@ PageAllocationGranularityShift() {
   return 14;  // 16kB
 #elif defined(OS_APPLE) && defined(ARCH_CPU_64_BITS)
   return vm_page_shift;
+#elif defined(OS_LINUX) && defined(ARCH_CPU_ARM64)
+  // arm64 supports 4kb (shift = 12), 16kb (shift = 14), and 64kb (shift = 16)
+  // page sizes. Retrieve from or initialize cache.
+  int shift = internal::page_characteristics.shift.load(std::memory_order_relaxed);
+  if (UNLIKELY(shift == 0)) {
+    shift = __builtin_ctz((int)PageAllocationGranularity());
+    internal::page_characteristics.shift.store(shift, std::memory_order_relaxed);
+  }
+  return shift;
 #else
   return 12;  // 4kB
 #endif
@@ -61,6 +99,15 @@ PageAllocationGranularity() {
   // This is literally equivalent to |1 << PageAllocationGranularityShift()|
   // below, but was separated out for OS_APPLE to avoid << on a non-constexpr.
   return vm_page_size;
+#elif defined(OS_LINUX) && defined(ARCH_CPU_ARM64)
+  // arm64 supports 4kb, 16kb, and 64kb page sizes. Retrieve from or
+  // initialize cache.
+  int size = internal::page_characteristics.size.load(std::memory_order_relaxed);
+  if (UNLIKELY(size == 0)) {
+    size = getpagesize();
+    internal::page_characteristics.size.store(size, std::memory_order_relaxed);
+  }
+  return size;
 #else
   return 1ULL << PageAllocationGranularityShift();
 #endif
@@ -90,7 +137,8 @@ SystemPageShift() {
 
 PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR ALWAYS_INLINE size_t
 SystemPageSize() {
-#if defined(OS_APPLE) && defined(ARCH_CPU_64_BITS)
+#if (defined(OS_APPLE) && defined(ARCH_CPU_64_BITS)) || \
+    (defined(OS_LINUX) && defined(ARCH_CPU_ARM64))
   // This is literally equivalent to |1 << SystemPageShift()| below, but was
   // separated out for 64-bit OS_APPLE to avoid << on a non-constexpr.
   return PageAllocationGranularity();
diff --git a/chromium/base/allocator/partition_allocator/partition_address_space.cc b/chromium/base/allocator/partition_allocator/partition_address_space.cc
index ee6294d8f55..3c9e4f47d4c 100644
--- a/chromium/base/allocator/partition_allocator/partition_address_space.cc
+++ b/chromium/base/allocator/partition_allocator/partition_address_space.cc
@@ -97,6 +97,12 @@ void PartitionAddressSpace::UninitForTesting() {
   internal::AddressPoolManager::GetInstance()->ResetForTesting();
 }
 
+#if defined(OS_LINUX) && defined(ARCH_CPU_ARM64)
+
+PageCharacteristics page_characteristics;
+
+#endif  // defined(OS_LINUX) && defined(ARCH_CPU_ARM64)
+
 #endif  // defined(PA_HAS_64_BITS_POINTERS)
 
 }  // namespace internal
diff --git a/chromium/base/allocator/partition_allocator/partition_alloc_constants.h b/chromium/base/allocator/partition_allocator/partition_alloc_constants.h
index 1eeac4993a5..61bfc4f4b95 100644
--- a/chromium/base/allocator/partition_allocator/partition_alloc_constants.h
+++ b/chromium/base/allocator/partition_allocator/partition_alloc_constants.h
@@ -47,10 +47,11 @@ PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR ALWAYS_INLINE size_t
 PartitionPageShift() {
   return 18;  // 256 KiB
 }
-#elif defined(OS_APPLE) && defined(ARCH_CPU_64_BITS)
+#elif (defined(OS_APPLE) && defined(ARCH_CPU_64_BITS)) || \
+    (defined(OS_LINUX) && defined(ARCH_CPU_ARM64))
 PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR ALWAYS_INLINE size_t
 PartitionPageShift() {
-  return vm_page_shift + 2;
+  return PageAllocationGranularityShift() + 2;
 }
 #else
 PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR ALWAYS_INLINE size_t
diff --git a/chromium/base/allocator/partition_allocator/partition_root.cc b/chromium/base/allocator/partition_allocator/partition_root.cc
index 37a190f371d..a268c74f62d 100644
--- a/chromium/base/allocator/partition_allocator/partition_root.cc
+++ b/chromium/base/allocator/partition_allocator/partition_root.cc
@@ -182,7 +182,7 @@ static size_t PartitionPurgeSlotSpan(
   constexpr size_t kMaxSlotCount =
       (PartitionPageSize() * kMaxPartitionPagesPerRegularSlotSpan) /
       SystemPageSize();
-#elif defined(OS_APPLE)
+#elif defined(OS_APPLE) || (defined(OS_LINUX) && defined(ARCH_CPU_ARM64))
   // It's better for slot_usage to be stack-allocated and fixed-size, which
   // demands that its size be constexpr. On OS_APPLE, PartitionPageSize() is
   // always SystemPageSize() << 2, so regardless of what the run time page size
-- 
2.37.1

